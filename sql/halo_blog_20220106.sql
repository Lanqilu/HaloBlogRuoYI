/*
 Navicat Premium Data Transfer

 Source Server         : MySQL
 Source Server Type    : MySQL
 Source Server Version : 80022
 Source Host           : mysql:3306
 Source Schema         : halo_blog

 Target Server Type    : MySQL
 Target Server Version : 80022
 File Encoding         : 65001

 Date: 06/01/2022 22:10:32
*/

-- ----------------------------
-- Table structure for m_blog
-- ----------------------------
DROP TABLE IF EXISTS `m_blog`;
CREATE TABLE `m_blog`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `user_id` bigint NOT NULL,
  `blog_title` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `content` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL,
  `created` datetime NOT NULL ON UPDATE CURRENT_TIMESTAMP,
  `status` tinyint NULL DEFAULT 1 COMMENT '状态（1:正常,0:删除）',
  `blog_cover` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `blog_like` int NULL DEFAULT 0,
  `update_time` datetime NULL DEFAULT NULL,
  `tag_uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标签id',
  `collect_count` int NULL DEFAULT NULL COMMENT '收藏数',
  `blog_sort_uid` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '博客分类id',
  `is_publish` tinyint NULL DEFAULT 1 COMMENT '是否发布（0:否,1:是）',
  `is_open_comment` tinyint(1) NULL DEFAULT 1 COMMENT '是否开启评论（0:否,1:是）',
  `is_original` tinyint(1) NULL DEFAULT 0 COMMENT '是否原创(0:否,1:是)',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `deleted` tinyint(1) NULL DEFAULT 0,
  `content_html` longtext CHARACTER SET utf8 COLLATE utf8_general_ci NULL COMMENT '文章内容的HTML格式',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 32 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of m_blog
-- ----------------------------
INSERT INTO `m_blog` VALUES (7, 1, 'Docker', '初识 Docker', '## 初识 Docker\n\n### 什么是 Docker\n\n微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。\n\n- 分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。\n- 在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题\n\n#### 应用部署的环境问题\n\n大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：\n\n- 依赖关系复杂，容易出现兼容性问题\n\n- 开发、测试、生产环境有差异\n\n例如一个项目中，部署时需要依赖于 node.js、Redis、RabbitMQ、MySQL 等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。\n\n#### Docker 解决依赖兼容问题\n\n而 Docker 确巧妙的解决了这些问题，Docker 是如何实现的呢？\n\nDocker 为了解决依赖的兼容问题的，采用了两个手段：\n\n- 将应用的 Libs（函数库）、Deps（依赖）、配置与应用一起打包\n\n- 将每个应用放到一个隔离**容器**去运行，避免互相干扰\n\n这样打包好的应用包中，既包含应用本身，也保护应用所需要的 Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。\n\n虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？\n\n#### Docker 解决操作系统环境差异\n\n要解决不同操作系统环境差异问题，必须先了解操作系统结构。计算机系统结构如下：\n\n- 计算机硬件：例如 CPU、内存、磁盘等\n- 系统内核：所有 Linux 发行版的内核都是 Linux，例如 CentOS、Ubuntu、Fedora 等。内核可以与计算机硬件交互，对外提供内核指令，用于操作计算机硬件。\n- 系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。\n\n应用于计算机交互的流程如下：\n\n+ 应用调用操作系统应用（函数库），实现各种功能\n+ 系统函数库是对内核指令集的封装，会调用内核指令\n+ 内核指令操作计算机硬件\n\nUbuntu 和 CentOS 都是基于 Linux 内核，无非是系统应用不同，提供的函数库有差异。此时，如果将一个 Ubuntu 版本的 MySQL 应用安装到 CentOS 系统，MySQL 在调用 Ubuntu 函数库时，会发现找不到或者不匹配，就会报错了。\n\nDocker 如何解决不同系统环境的问题？\n\n- Docker 将用户程序与所需要调用的系统（比如 Ubuntu）函数库一起打包\n- Docker 运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的 Linux 内核来运行\n\n#### 什么是 Docker 小结\n\nDocker 如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？\n\n- Docker 允许开发中将应用、依赖、函数库、配置一起**打包**，形成可移植镜像\n- Docker 应用运行在容器中，使用沙箱机制，相互**隔离**\n\nDocker如何解决开发、测试、生产环境有差异的问题？\n\n- Docker 镜像中包含完整运行环境，包括系统函数库，仅依赖系统的 Linux 内核，因此可以在任意 Linux 操作系统上运行\n\nDocker 是一个快速交付应用、运行应用的技术，具备下列优势：\n\n- 可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意 Linux 操作系统\n- 运行时利用沙箱机制形成隔离容器，各个应用互不干扰\n- 启动、移除都可以通过一行命令完成，方便快捷\n\n### Docker 和虚拟机的区别\n\nDocker 可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。\n\n虚拟机（virtual machine）是在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的 Ubuntu 应用了。\n\nDocker 仅仅是封装函数库，并没有模拟完整的操作系统\n\n两者有什么差异呢？\n\n- Docker 是一个系统进程；虚拟机是在操作系统中的操作系统\n\n- Docker 体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般\n\n### Docker 基本知识\n\n#### 镜像和容器\n\nDocker 中有几个重要的概念：\n\n+ 镜像（Image）：Docker 将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。\n+ 容器（Container）：镜像中的应用程序运行后形成的进程就是**容器**，只是 Docker 会给容器进程做隔离，对外不可见。\n\n一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的**文件**。只有运行时，才会加载到内存，形成进程。\n\n+ 镜像，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。\n+ 容器，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。\n\n因此一个镜像可以启动多次，形成多个容器进程。\n\n#### DockerHub\n\n开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如 Redis、MySQL 镜像放到网络上，共享使用，就像 GitHub 的代码共享一样。\n\n- DockerHub ：DockerHub 是一个官方的 Docker 镜像的托管平台。这样的平台称为 Docker Registry。\n\n- 国内也有类似于 DockerHub 的公开服务，比如 [网易云镜像服务](https://c.163yun.com/hub)、[阿里云镜像库](https://cr.console.aliyun.com/) 等。\n\n#### Docker 架构\n\n我们要使用 Docker 来操作镜像、容器，就必须要安装 Docker。\n\nDocker 是一个 CS 架构的程序，由两部分组成：\n\n- 服务端（server）：Docker 守护进程，负责处理 Docker 指令，管理镜像、容器等\n\n- 客户端（client）：通过命令或 RestAPI 向 Docker 服务端发送指令。可以在本地或远程向服务端发送指令。\n\n![Docker架构](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Docker架构.4alzm4dto2g0.svg)\n\n## 配置 Docker\n\nDocker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。\n\nDocker CE 分为 `stable` `test` 和 `nightly` 三个更新频道。\n\n官方网站上有各种环境下的 [安装指南](https://docs.docker.com/install/)，这里主要介绍 Docker CE 在 CentOS上的安装。\n\n### CentOS 安装 Docker\n\nDocker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在 CentOS 7 安装 Docker。\n\n#### 卸载 Docker（可选）\n\n如果之前安装过旧版本的 Docker，可以使用下面命令卸载：\n\n```sh\nyum remove docker \\\n                  docker-client \\\n                  docker-client-latest \\\n                  docker-common \\\n                  docker-latest \\\n                  docker-latest-logrotate \\\n                  docker-logrotate \\\n                  docker-selinux \\\n                  docker-engine-selinux \\\n                  docker-engine \\\n                  docker-ce\n```\n\n#### 安装 Docker\n\n安装 yum 工具\n\n```sh\nyum install -y yum-utils \\\n           device-mapper-persistent-data \\\n           lvm2 --skip-broken\n```\n\n然后更新本地镜像源：\n\n```sh\n# 设置docker镜像源\nyum-config-manager \\\n    --add-repo \\\n    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo\n    \nsed -i \'s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g\' /etc/yum.repos.d/docker-ce.repo\n\nyum makecache fast\n```\n\n然后输入命令：\n\n```sh\nyum install -y docker-ce\n```\n\ndocker-ce 为社区免费版本。稍等片刻，docker 即可安装成功。\n\n### 启动 Docker\n\nDocker 应用需要用到各种端口，逐一去修改防火墙设置。学习时可以直接关闭防火墙。\n\n```sh\n# 关闭\nsystemctl stop firewalld\n# 禁止开机启动防火墙\nsystemctl disable firewalld\n```\n\n通过命令启动 Docker：\n\n```sh\nsystemctl start docker  # 启动docker服务\nsystemctl stop docker  # 停止docker服务\nsystemctl restart docker  # 重启docker服务\n```\n\n然后输入命令，可以查看 Docker 版本：\n\n```sh\ndocker -v\n```\n\n### 配置镜像加速\n\nDocker 官方镜像仓库网速较差，我们需要设置国内镜像服务：\n\n参考阿里云的镜像加速文档：https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors\n\n通过修改 daemon 配置文件 /etc/docker/daemon.json 来使用加速器\n\n```sh\nsudo mkdir -p /etc/docker\nsudo tee /etc/docker/daemon.json <<-\'EOF\'\n{\n  \"registry-mirrors\": [\"https://578xeysa.mirror.aliyuncs.com\"]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n```\n\n## Docker 的基本操作\n\n### 镜像操作\n\n#### 镜像名称\n\n首先来看下镜像的名称组成：\n\n- 镜名称一般分两部分组成：[repository]:[tag]。\n- 在没有指定 tag 时，默认是 latest，代表最新版本的镜像\n\n#### 镜像命令\n\n常见的镜像操作命令如图：\n\n![Docker镜像操作命令](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Docker镜像操作命令.71pfsgm3nn00.svg)\n\n#### 拉取、查看镜像\n\n需求：从 DockerHub 中拉取一个 Nginx 镜像并查看\n\n1. 首先去镜像仓库搜索 Nginx 镜像，比如 [DockerHub](https://hub.docker.com/):\n2. 根据查看到的镜像名称，拉取自己需要的镜像，通过命令：`docker pull nginx`\n3. 通过命令：`docker images` 查看拉取到的镜像\n\n#### 保存镜像\n\n需求：利用 docker save 将 Nginx 镜像导出磁盘，然后再通过 load 加载回来\n\n利用 `docker xx --help` 命令查看 `docker save` 和 `docker load` 的语法。例如，查看save命令用法，可以输入命令：\n\n```sh\ndocker save --help\n```\n\n命令格式：\n\n```sh\ndocker save -o [保存的目标文件名称] [镜像名称]\n```\n\n使用 `docker save` 导出镜像到磁盘，运行命令：\n\n```sh\ndocker save -o nginx.tar nginx:latest\n```\n\n#### 导入镜像\n\n先删除本地的 Nginx 镜像：\n\n```sh\ndocker rmi nginx:latest\n```\n\n然后运行命令，加载本地文件：\n\n```sh\ndocker load -i nginx.tar\n```\n\n### 容器操作\n\n#### 容器相关命令\n\n容器操作的命令如图：\n\n![Docker容器相关命令](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Docker容器相关命令.54kd7pt4p2w0.svg)\n\n容器保护三个状态：\n\n- 运行：进程正常运行\n- 暂停：进程暂停，CPU 不再运行，并不释放内存\n- 停止：进程终止，回收进程占用的内存、CPU 等资源\n\n其中：\n\n- `docker run`：创建并运行一个容器，处于运行状态\n- `docker pause`：让一个运行的容器暂停\n- `docker unpause`：让一个容器从暂停状态恢复运行\n- `docker stop`：停止一个运行的容器\n- `docker start`：让一个停止的容器再次运行\n- `docker rm`：删除一个容器\n- `docker logs` ：查看容器日志的命令，添加 `-f` 参数可以持续查看日志\n- `docker ps` ：查看容器状态，`-a` 查看所有容器，包括已经停止的\n\n#### 创建并运行一个容器\n\n创建并运行 Nginx 容器的命令：\n\n```sh\ndocker run --name haloNginx -p 81:80 -d nginx\n```\n\n命令解读：\n\n- `docker run` ：创建并运行一个容器\n- `--name` : 给容器起一个名字，比如叫做 haloNginx\n- `-p` ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口\n- `-d`：后台运行容器\n- `nginx`：镜像名称，例如 nginx\n\n这里的 `-p` 参数，是将容器端口映射到宿主机端口。\n\n默认情况下，容器是隔离环境，我们直接访问宿主机的 81 端口，肯定访问不到容器中的 Nginx。\n\n现在，将容器的 80 与宿主机的 81 关联起来，当我们访问宿主机的 81 端口时，就会被映射到容器的80，这样就能访问到 Nginx 了\n\n#### 进入容器并修改文件\n\n**需求**：进入 Nginx 容器，修改 HTML 文件内容，添加“Halo World!”\n\n> 提示：进入容器要用到 `docker exec` 命令。\n\n① 进入容器。进入我们刚刚创建的 Nginx 容器的命令为：\n\n```sh\ndocker exec -it haloNginx bash\n```\n\n命令解读：\n\n- `docker exec` ：进入容器内部，执行一个命令\n\n- `-it` : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互\n\n- `haloNginx`：要进入的容器的名称\n\n- `bash`：进入容器后执行的命令，bash 是一个 Linux 终端交互命令\n\n② 进入 Nginx 的 HTML 所在目录 /usr/share/nginx/html\n\n容器内部会模拟一个独立的 Linux 文件系统，看起来如同一个 Linux 服务器一样\n\nNginx 的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的 html 文件。\n\n查看 DockerHub 网站中的 Nginx 页面，可以知道 Nginx 的 html 目录位置在 `/usr/share/nginx/html`\n\n我们执行命令，进入该目录：\n\n```sh\ncd /usr/share/nginx/html\n```\n\n③ 修改 index.html 的内容\n\n容器内没有 vi 命令，无法直接修改，我们用下面的命令来修改：\n\n```sh\nsed -i -e \'s#Welcome to nginx#Halo World!#g\' -e \'s#<head>#<head><meta charset=\"utf-8\">#g\' index.html\n```\n\n### 数据卷（容器数据管理）\n\n在之前的 Nginx 案例中，修改 Nginx 的 html 页面时，需要进入 Nginx 内部。并且因为没有编辑器，修改文件也很麻烦。\n\n这就是因为容器与数据（容器内文件）耦合带来的后果。容器与数据耦合的问题：\n\n+ 不便于修改：当我们要修改 Nginx 的 html 内容时，需要进入容器内部修改，很不方便。\n+ 数据不可复用：在容器内的修改对外是不可见的。所有修改对新创建的容器是不可复用的。\n+ 升级维护困难：数据在容器内，如果要升级容器必然删除旧容器，所有数据都跟着删除了\n\n要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。\n\n#### 什么是数据卷\n\n数据卷（volume）是一个虚拟目录，指向宿主机文件系统中的某个目录。\n\n一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。\n\n这样，我们操作宿主机的 /var/lib/docker/volumes/html 目录，就等于操作容器内的 /usr/share/nginx/html 目录了\n\n#### 数据集操作命令\n\n数据卷操作的基本语法如下：\n\n```sh\ndocker volume [COMMAND]\n```\n\n`docker volume` 命令是数据卷操作，根据命令后跟随的 `command` 来确定下一步的操作：\n\n- `create` ：创建一个 volume\n- `inspect` ：显示一个或多个 volume 的信息\n- `ls` ：列出所有的 volume\n- `prune` ：删除未使用的 volume\n- `rm` ：删除一个或多个指定的 volume\n\n#### 创建和查看数据卷\n\n① 创建数据卷\n\n```sh\ndocker volume create nginx-html\n```\n\n② 查看所有数据\n\n```sh\ndocker volume ls\n```\n\n③ 查看数据卷详细信息卷\n\n```sh\ndocker volume inspect nginx-html\n```\n\n可以看到，我们创建的 nginx-html 这个数据卷关联的宿主机目录为 `/var/lib/docker/volumes/nginx-html/_data` 目录。\n\n#### 挂载数据卷\n\n我们在创建容器时，可以通过 `-v` 参数来挂载一个数据卷到某个容器内目录，命令格式如下：\n\n```sh\ndocker run \\\n  --name halo-nginx \\\n  -v nginx-html:/usr/share/nginx/html \\\n  -p 81:80\n  nginx \\\n```\n\n这里的 `-v` 就是挂载数据卷的命令。`-v nginx-html:/root/htm` ：把 nginx-html 数据卷挂载到容器内的 /root/html 这个目录中\n\n需求：创建一个 Nginx 容器，修改容器内的 html 目录内的 index.html 内容\n\n分析：上个案例中，我们进入 Nginx 容器内部，已经知道 Nginx 的 html 目录所在位置 /usr/share/nginx/html ，我们需要把这个目录挂载到 html 这个数据卷上，方便操作其中的内容。\n\n① 创建容器并挂载数据卷到容器内的 HTML 目录\n\n```sh\ndocker run --name halo-nginx -v nginx-html:/usr/share/nginx/html -p 81:80 -d nginx\n```\n\n② 进入 nginx-html 数据卷所在位置，并修改 HTML 内容\n\n```sh\n# 查看html数据卷的位置\ndocker volume inspect nginx-html\n# 进入该目录\ncd /var/lib/docker/volumes/nginx-html/_data\n# 修改文件\nvi index.html\n```\n\n> 数据卷不存在会自动创建\n\n#### 挂载本地目录\n\n容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：\n\n- 带数据卷模式：宿主机目录 → 数据卷 → 容器内目录\n- 直接挂载模式：宿主机目录 → 容器内目录\n\n目录挂载与数据卷挂载的语法是类似的：\n\n- `-v [宿主机目录]:[容器内目录]`\n- `-v [宿主机文件]:[容器内文件]`\n\n需求：创建并运行一个 MySQL 容器，将宿主机目录直接挂载到容器\n\n1. 拉取 MySQL 镜像\n\n2. 创建目录 /develop/docker-volumes/halo-mysql/data\n\n3. 创建目录 /develop/docker-volumes/halo-mysql/conf ，并在其中创建 halo.conf，内容如下\n\n   ```\n   [mysqld]\n   skip-name-resolve\n   character_set_server=utf8\n   datadir=/var/lib/mysql\n   server-id=1000\n   ```\n\n4. 进行挂载\n\n   ```\n   docker run \\\n     --name halo-mysql \\\n     -e MYSQL_ROOT_PASSWORD=halo \\\n     -p 3307:3306 \\\n     -v /develop/docker-volumes/halo-mysql/conf/halo.conf:/etc/mysql/conf.d/halo.conf \\\n     -v /develop/docker-volumes/halo-mysql/data:/var/lib/mysql \\\n     -d \\\n     mysql:latest\n   ```\n\n## Dockerfile 自定义镜像\n\n### 镜像结构\n\n镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。\n\n+ 基础镜像（Base Image）：应用依赖的系统函数库、环境、配置、文件等\n+ 层（ Layer ）：在 Base Image 基础上添加安装包、依赖、配置等，每次操作都形成新的一层。\n+ 入口（Entry Point）：镜像运行入口，一般是程序启动的脚本和参数\n\n简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。\n\n我们要构建镜像，其实就是实现上述打包的过程。\n\n### Dockerfile 语法\n\n构建自定义的镜像时，并不需要一个个文件去拷贝，打包。\n\n我们只需要告诉 Docker，我们的镜像的组成，需要哪些 Base Image、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来 Docker 会帮助我们构建镜像。\n\n而描述上述信息的文件就是 Dockerfile 文件。\n\nDockerfile 就是一个文本文件，其中包含一个个的指令（Instruction），用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层 Layer。\n\n| 指令       | 说明                                           | 示例                          |\n| ---------- | ---------------------------------------------- | ----------------------------- |\n| FROM       | 指定基础镜像                                   | `FROM centos:6`               |\n| ENV        | 设置环境变量，可在后面指令使用                 | `ENV key value`               |\n| COPY       | 拷贝本地文件到镜像的指定目录                   | `COPY ./mysql-5.7.rpm /tmp`   |\n| RUN        | 执行 Linux 的 shell 命令，一般是安装过程的命令 | `RUN yum install gcc`         |\n| EXPOSE     | 指定容器运行时监听的端口，是给镜像使用者看的   | `EXPOSE 8080`                 |\n| ENTRYPOINT | 镜像中应用的启动命令，容器运行时调用           | `ENTRYPOINT java -jar xx.jar` |\n\n更新详细语法说明，请参考官网文档： https://docs.docker.com/engine/reference/builder\n\n### 直接构建 Java 项目\n\n需求：基于 Ubuntu 镜像构建一个新镜像，运行一个 Java 项目\n\n1. Linux 下新建一个空文件夹 docker-demo\n\n2. 拷贝 docker-demo.jar 文件到 docker-demo 这个目录\n\n3. 拷贝 jdk8.tar.gz 文件到 docker-demo 这个目录\n\n4. 拷贝 Dockerfile 到 docker-demo 这个目录，其中的内容如下：\n\n   ```dockerfile\n   # 指定基础镜像\n   FROM ubuntu:16.04\n   # 配置环境变量，JDK的安装目录\n   ENV JAVA_DIR=/usr/local\n   \n   # 拷贝jdk和java项目的包\n   COPY ./jdk8.tar.gz $JAVA_DIR/\n   COPY ./docker-demo.jar /tmp/app.jar\n   \n   # 安装JDK\n   RUN cd $JAVA_DIR \\\n    && tar -xf ./jdk8.tar.gz \\\n    && mv ./jdk1.8.0_144 ./java8\n   \n   # 配置环境变量\n   ENV JAVA_HOME=$JAVA_DIR/java8\n   ENV PATH=$PATH:$JAVA_HOME/bin\n   \n   # 暴露端口\n   EXPOSE 8090\n   # 入口，java项目的启动命令\n   ENTRYPOINT java -jar /tmp/app.jar\n   ```\n\n5. 进入 docker-demo ，运行命令：\n\n   ```sh\n   docker build -t javaweb:1.0 .\n   ```\n\n6. 运行测试\n\n### 基于 java8-alpine  构建 Java 项目\n\n虽然我们可以基于 Ubuntu 基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。\n\n例如，构建 Java 项目的镜像，可以在已经准备了JDK 的基础镜像基础上构建。\n\n需求：基于 java:8-alpine 镜像，将一个 Java 项目构建为镜像\n\n实现思路如下：\n\n+  新建一个空的目录，然后在目录中新建一个文件，命名为 Dockerfile\n\n+ 拷贝 docker-demo.jar 到这个目录中\n\n+ 编写 Dockerfile 文件，内容如下：\n\n  ```dockerfile\n  FROM java:8-alpine\n  COPY ./app.jar /tmp/app.jar\n  EXPOSE 8090\n  ENTRYPOINT java -jar /tmp/app.jar\n  ```\n\n+ 进入 docker-demo ，运行命令：\n\n  ```\n  docker build -t javaweb:2.0 .\n  ```\n\n### Dockerfile 小结\n\n1. Dockerfile 的本质是一个文件，通过指令描述镜像的构建过程\n\n2. Dockerfile 的第一行必须是 FROM，从一个基础镜像来构建\n\n3. 基础镜像可以是基本操作系统，如 Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine\n\n## Docker Compose\n\nDocker Compose 可以基于 Compose 文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器。\n\n### 初识 Docker Compose\n\nCompose 文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：\n\n```json\nversion: \"3.8\"\n services:\n  mysql:\n    image: mysql:5.7.25\n    environment:\n     MYSQL_ROOT_PASSWORD: 123 \n    volumes:\n     - \"/tmp/mysql/data:/var/lib/mysql\"\n     - \"/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf\"\n  web:\n    build: .\n    ports:\n     - \"8090:8090\"\n```\n\n上面的 Compose 文件就描述一个项目，其中包含两个容器：\n\n- mysql：一个基于 `mysql:5.7.25` 镜像构建的容器，并且挂载了两个目录\n- web：一个基于 `docker build` 临时构建的镜像容器，映射端口时 8090\n\nDocker Compose 的详细语法参考官网：https://docs.docker.com/compose/compose-file/\n\n其实 Docker Compose 文件可以看做是将多个 docker run 命令写到一个文件，只是语法稍有差异。\n\n### 安装 Docker Compose\n\n1. 下载 docker-compose，Linux 下需要通过命令下载（速度较慢）：\n\n   ```sh\n   curl -L https://github.com/docker/compose/releases/download/1.23.1/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose\n   ```\n\n2. 修改文件权限\n\n   ```sh\n   chmod +x /usr/local/bin/docker-compose\n   ```\n\n配置 Base 自动补全命令\n\n```sh\ncurl -L https://raw.githubusercontent.com/docker/compose/1.29.1/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose\n```\n\n如果这里出现错误，需要修改自己的 hosts 文件：\n\n```sh\necho \"199.232.68.133 raw.githubusercontent.com\" >> /etc/hosts\n```\n\n### 部署微服务集群\n\n需求：将之前学习的 spring-cloud-demo 微服务集群利用 Docker Compose 部署\n\n实现思路：\n\n1. 编写 docker-compose 文件\n2. 修改自己的 cloud-demo 项目，将数据库、nacos 地址都命名为 docker-compose 中的服务名\n3. 使用 maven 打包工具，将项目中的每个微服务都打包为 app.jar\n4. 将打包好的 app.jar 拷贝到 cloud-demo 中的每一个对应的子目录中\n5. 到 cloud-demo 目录，利用 `docker-compose up -d` 来部署\n\n## Docker 镜像仓库 \n\n### 搭建私有镜像仓库\n\n搭建镜像仓库可以基于 Docker 官方提供的 Docker Registry 来实现。\n\n官网地址：https://hub.docker.com/_/registry\n\n#### 简化版镜像仓库\n\nDocker 官方的 Docker Registry 是一个基础版本的 Docker 镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。\n\n搭建方式比较简单，命令如下：\n\n```sh\ndocker run -d \\\n    --restart=always \\\n    --name registry	\\\n    -p 5000:5000 \\\n    -v registry-data:/var/lib/registry \\\n    registry\n```\n\n命令中挂载了一个数据卷 registry-data 到容器内的 /var/lib/registry 目录，这是私有镜像库存放数据的目录。\n\n访问 http://halo:5000/v2/_catalog 可以查看当前私有镜像服务中包含的镜像\n\n#### 带有图形化界面版本\n\n使用 Docker Compose 部署带有图象界面的 Docker Registry，命令如下：\n\n```yaml\nversion: \'3.0\'\nservices:\n  registry:\n    image: registry\n    volumes:\n      - ./registry-data:/var/lib/registry\n  ui:\n    image: joxit/docker-registry-ui:static\n    ports:\n      - 8181:80\n    environment:\n      - REGISTRY_TITLE=Halo-Docker-Registry\n      - REGISTRY_URL=http://registry:5000\n    depends_on:\n      - registry\n```\n\n配置 Docker 信任地址，私服采用的是 http 协议，默认不被 Docker 信任，所以需要做一个配置：\n\n```sh\n# 打开要修改的文件\nvi /etc/docker/daemon.json\n# 添加内容：\n\"insecure-registries\":[\"http://halo:8181\"]\n# 重加载\nsystemctl daemon-reload\n# 重启docker\nsystemctl restart docker\n```\n\n### 推送、拉取镜像\n\n推送镜像到私有镜像服务必须先 tag，步骤如下：\n\n① 重新 tag 本地镜像，名称前缀为私有仓库的地址：halo:8181/\n\n```sh\ndocker tag nginx:latest halo:8181/nginx:1.0 \n```\n\n② 推送镜像\n\n```sh\ndocker push halo:8181/nginx:1.0 \n```\n\n③ 拉取镜像\n\n```\ndocker pull halo:8181/nginx:1.0 \n```', '2021-10-21 14:32:30', 1, 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/macos.6z1mshl4twk0.svg', 8, '2021-10-14 11:15:54', NULL, NULL, '2', 1, 1, 0, NULL, 0, '<h2 id=\"初识-docker\">初识 Docker</h2>\n<h3 id=\"什么是-docker\">什么是 Docker</h3>\n<p>微服务虽然具备各种各样的优势，但服务的拆分通用给部署带来了很大的麻烦。</p>\n<ul>\n<li>分布式系统中，依赖的组件非常多，不同组件之间部署时往往会产生一些冲突。</li>\n<li>在数百上千台服务中重复部署，环境不一定一致，会遇到各种问题</li>\n</ul>\n<h4 id=\"应用部署的环境问题\">应用部署的环境问题</h4>\n<p>大型项目组件较多，运行环境也较为复杂，部署时会碰到一些问题：</p>\n<ul>\n<li><p>依赖关系复杂，容易出现兼容性问题</p>\n</li>\n<li><p>开发、测试、生产环境有差异</p>\n</li>\n</ul>\n<p>例如一个项目中，部署时需要依赖于 node.js、Redis、RabbitMQ、MySQL 等，这些服务部署时所需要的函数库、依赖项各不相同，甚至会有冲突。给部署带来了极大的困难。</p>\n<h4 id=\"docker-解决依赖兼容问题\">Docker 解决依赖兼容问题</h4>\n<p>而 Docker 确巧妙的解决了这些问题，Docker 是如何实现的呢？</p>\n<p>Docker 为了解决依赖的兼容问题的，采用了两个手段：</p>\n<ul>\n<li><p>将应用的 Libs（函数库）、Deps（依赖）、配置与应用一起打包</p>\n</li>\n<li><p>将每个应用放到一个隔离<strong>容器</strong>去运行，避免互相干扰</p>\n</li>\n</ul>\n<p>这样打包好的应用包中，既包含应用本身，也保护应用所需要的 Libs、Deps，无需再操作系统上安装这些，自然就不存在不同应用之间的兼容问题了。</p>\n<p>虽然解决了不同应用的兼容问题，但是开发、测试等环境会存在差异，操作系统版本也会有差异，怎么解决这些问题呢？</p>\n<h4 id=\"docker-解决操作系统环境差异\">Docker 解决操作系统环境差异</h4>\n<p>要解决不同操作系统环境差异问题，必须先了解操作系统结构。计算机系统结构如下：</p>\n<ul>\n<li>计算机硬件：例如 CPU、内存、磁盘等</li>\n<li>系统内核：所有 Linux 发行版的内核都是 Linux，例如 CentOS、Ubuntu、Fedora 等。内核可以与计算机硬件交互，对外提供内核指令，用于操作计算机硬件。</li>\n<li>系统应用：操作系统本身提供的应用、函数库。这些函数库是对内核指令的封装，使用更加方便。</li>\n</ul>\n<p>应用于计算机交互的流程如下：</p>\n<ul>\n<li>应用调用操作系统应用（函数库），实现各种功能</li>\n<li>系统函数库是对内核指令集的封装，会调用内核指令</li>\n<li>内核指令操作计算机硬件</li>\n</ul>\n<p>Ubuntu 和 CentOS 都是基于 Linux 内核，无非是系统应用不同，提供的函数库有差异。此时，如果将一个 Ubuntu 版本的 MySQL 应用安装到 CentOS 系统，MySQL 在调用 Ubuntu 函数库时，会发现找不到或者不匹配，就会报错了。</p>\n<p>Docker 如何解决不同系统环境的问题？</p>\n<ul>\n<li>Docker 将用户程序与所需要调用的系统（比如 Ubuntu）函数库一起打包</li>\n<li>Docker 运行到不同操作系统时，直接基于打包的函数库，借助于操作系统的 Linux 内核来运行</li>\n</ul>\n<h4 id=\"什么是-docker-小结\">什么是 Docker 小结</h4>\n<p>Docker 如何解决大型项目依赖关系复杂，不同组件依赖的兼容性问题？</p>\n<ul>\n<li>Docker 允许开发中将应用、依赖、函数库、配置一起<strong>打包</strong>，形成可移植镜像</li>\n<li>Docker 应用运行在容器中，使用沙箱机制，相互<strong>隔离</strong></li>\n</ul>\n<p>Docker如何解决开发、测试、生产环境有差异的问题？</p>\n<ul>\n<li>Docker 镜像中包含完整运行环境，包括系统函数库，仅依赖系统的 Linux 内核，因此可以在任意 Linux 操作系统上运行</li>\n</ul>\n<p>Docker 是一个快速交付应用、运行应用的技术，具备下列优势：</p>\n<ul>\n<li>可以将程序及其依赖、运行环境一起打包为一个镜像，可以迁移到任意 Linux 操作系统</li>\n<li>运行时利用沙箱机制形成隔离容器，各个应用互不干扰</li>\n<li>启动、移除都可以通过一行命令完成，方便快捷</li>\n</ul>\n<h3 id=\"docker-和虚拟机的区别\">Docker 和虚拟机的区别</h3>\n<p>Docker 可以让一个应用在任何操作系统中非常方便的运行。而以前我们接触的虚拟机，也能在一个操作系统中，运行另外一个操作系统，保护系统中的任何应用。</p>\n<p>虚拟机（virtual machine）是在操作系统中模拟硬件设备，然后运行另一个操作系统，比如在 Windows 系统里面运行 Ubuntu 系统，这样就可以运行任意的 Ubuntu 应用了。</p>\n<p>Docker 仅仅是封装函数库，并没有模拟完整的操作系统</p>\n<p>两者有什么差异呢？</p>\n<ul>\n<li><p>Docker 是一个系统进程；虚拟机是在操作系统中的操作系统</p>\n</li>\n<li><p>Docker 体积小、启动速度快、性能好；虚拟机体积大、启动速度慢、性能一般</p>\n</li>\n</ul>\n<h3 id=\"docker-基本知识\">Docker 基本知识</h3>\n<h4 id=\"镜像和容器\">镜像和容器</h4>\n<p>Docker 中有几个重要的概念：</p>\n<ul>\n<li>镜像（Image）：Docker 将应用程序及其所需的依赖、函数库、环境、配置等文件打包在一起，称为镜像。</li>\n<li>容器（Container）：镜像中的应用程序运行后形成的进程就是<strong>容器</strong>，只是 Docker 会给容器进程做隔离，对外不可见。</li>\n</ul>\n<p>一切应用最终都是代码组成，都是硬盘中的一个个的字节形成的<strong>文件</strong>。只有运行时，才会加载到内存，形成进程。</p>\n<ul>\n<li>镜像，就是把一个应用在硬盘上的文件、及其运行环境、部分系统函数库文件一起打包形成的文件包。这个文件包是只读的。</li>\n<li>容器，就是将这些文件中编写的程序、函数加载到内存中允许，形成进程，只不过要隔离起来。</li>\n</ul>\n<p>因此一个镜像可以启动多次，形成多个容器进程。</p>\n<h4 id=\"dockerhub\">DockerHub</h4>\n<p>开源应用程序非常多，打包这些应用往往是重复的劳动。为了避免这些重复劳动，人们就会将自己打包的应用镜像，例如 Redis、MySQL 镜像放到网络上，共享使用，就像 GitHub 的代码共享一样。</p>\n<ul>\n<li><p>DockerHub ：DockerHub 是一个官方的 Docker 镜像的托管平台。这样的平台称为 Docker Registry。</p>\n</li>\n<li><p>国内也有类似于 DockerHub 的公开服务，比如 <a href=\"https://c.163yun.com/hub\">网易云镜像服务</a>、<a href=\"https://cr.console.aliyun.com/\">阿里云镜像库</a> 等。</p>\n</li>\n</ul>\n<h4 id=\"docker-架构\">Docker 架构</h4>\n<p>我们要使用 Docker 来操作镜像、容器，就必须要安装 Docker。</p>\n<p>Docker 是一个 CS 架构的程序，由两部分组成：</p>\n<ul>\n<li><p>服务端（server）：Docker 守护进程，负责处理 Docker 指令，管理镜像、容器等</p>\n</li>\n<li><p>客户端（client）：通过命令或 RestAPI 向 Docker 服务端发送指令。可以在本地或远程向服务端发送指令。</p>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Docker%E6%9E%B6%E6%9E%84.4alzm4dto2g0.svg\" alt=\"Docker架构\"></p>\n<h2 id=\"配置-docker\">配置 Docker</h2>\n<p>Docker 分为 CE 和 EE 两大版本。CE 即社区版（免费，支持周期 7 个月），EE 即企业版，强调安全，付费使用，支持周期 24 个月。</p>\n<p>Docker CE 分为 <code>stable</code> <code>test</code> 和 <code>nightly</code> 三个更新频道。</p>\n<p>官方网站上有各种环境下的 <a href=\"https://docs.docker.com/install/\">安装指南</a>，这里主要介绍 Docker CE 在 CentOS上的安装。</p>\n<h3 id=\"centos-安装-docker\">CentOS 安装 Docker</h3>\n<p>Docker CE 支持 64 位版本 CentOS 7，并且要求内核版本不低于 3.10， CentOS 7 满足最低内核的要求，所以我们在 CentOS 7 安装 Docker。</p>\n<h4 id=\"卸载-docker（可选）\">卸载 Docker（可选）</h4>\n<p>如果之前安装过旧版本的 Docker，可以使用下面命令卸载：</p>\n<pre><code class=\"hljs language-sh\">yum remove docker <span class=\"hljs-string\">\\</span>\n                  docker-client <span class=\"hljs-string\">\\</span>\n                  docker-client-latest <span class=\"hljs-string\">\\</span>\n                  docker-common <span class=\"hljs-string\">\\</span>\n                  docker-latest <span class=\"hljs-string\">\\</span>\n                  docker-latest-logrotate <span class=\"hljs-string\">\\</span>\n                  docker-logrotate <span class=\"hljs-string\">\\</span>\n                  docker-selinux <span class=\"hljs-string\">\\</span>\n                  docker-engine-selinux <span class=\"hljs-string\">\\</span>\n                  docker-engine <span class=\"hljs-string\">\\</span>\n                  docker-ce\n</code></pre>\n<h4 id=\"安装-docker\">安装 Docker</h4>\n<p>安装 yum 工具</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-title\">yum</span> install -y yum-utils \\\n           device-mapper-persistent-<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> \\</span>\n           lvm2 <span class=\"hljs-comment\">--skip-broken</span>\n</code></pre>\n<p>然后更新本地镜像源：</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># 设置docker镜像源</span>\nyum-config-manager \\\n    --add-repo \\\n    https:<span class=\"hljs-regexp\">//mi</span>rrors.aliyun.com<span class=\"hljs-regexp\">/docker-ce/</span>linux<span class=\"hljs-regexp\">/centos/</span>docker-ce.repo\n    \nsed -i <span class=\"hljs-string\">&#x27;s/download.docker.com/mirrors.aliyun.com\\/docker-ce/g&#x27;</span> <span class=\"hljs-regexp\">/etc/yum</span>.repos.d/docker-ce.repo\n\nyum makecache fast\n</code></pre>\n<p>然后输入命令：</p>\n<pre><code class=\"hljs language-sh\">yum <span class=\"hljs-keyword\">install</span> -y docker-ce\n</code></pre>\n<p>docker-ce 为社区免费版本。稍等片刻，docker 即可安装成功。</p>\n<h3 id=\"启动-docker\">启动 Docker</h3>\n<p>Docker 应用需要用到各种端口，逐一去修改防火墙设置。学习时可以直接关闭防火墙。</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-meta\"># 关闭</span>\nsystemctl <span class=\"hljs-keyword\">stop</span> firewalld\n<span class=\"hljs-meta\"># 禁止开机启动防火墙</span>\nsystemctl <span class=\"hljs-keyword\">disable</span> firewalld\n</code></pre>\n<p>通过命令启动 Docker：</p>\n<pre><code class=\"hljs language-sh\">systemctl <span class=\"hljs-literal\">start</span> docker  <span class=\"hljs-comment\"># 启动docker服务</span>\nsystemctl <span class=\"hljs-literal\">stop</span> docker  <span class=\"hljs-comment\"># 停止docker服务</span>\nsystemctl restart docker  <span class=\"hljs-comment\"># 重启docker服务</span>\n</code></pre>\n<p>然后输入命令，可以查看 Docker 版本：</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-attribute\">docker -v</span>\n</code></pre>\n<h3 id=\"配置镜像加速\">配置镜像加速</h3>\n<p>Docker 官方镜像仓库网速较差，我们需要设置国内镜像服务：</p>\n<p>参考阿里云的镜像加速文档：<a href=\"https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors\">https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors</a></p>\n<p>通过修改 daemon 配置文件 /etc/docker/daemon.json 来使用加速器</p>\n<pre><code class=\"hljs language-sh\">sudo mkdir -p <span class=\"hljs-regexp\">/etc/</span>docker\nsudo tee <span class=\"hljs-regexp\">/etc/</span>docker/daemon.json &lt;&lt;-<span class=\"hljs-string\">&#x27;EOF&#x27;</span>\n{\n  <span class=\"hljs-string\">&quot;registry-mirrors&quot;</span>: [<span class=\"hljs-string\">&quot;https://578xeysa.mirror.aliyuncs.com&quot;</span>]\n}\nEOF\nsudo systemctl daemon-reload\nsudo systemctl restart docker\n</code></pre>\n<h2 id=\"docker-的基本操作\">Docker 的基本操作</h2>\n<h3 id=\"镜像操作\">镜像操作</h3>\n<h4 id=\"镜像名称\">镜像名称</h4>\n<p>首先来看下镜像的名称组成：</p>\n<ul>\n<li>镜名称一般分两部分组成：[repository]:[tag]。</li>\n<li>在没有指定 tag 时，默认是 latest，代表最新版本的镜像</li>\n</ul>\n<h4 id=\"镜像命令\">镜像命令</h4>\n<p>常见的镜像操作命令如图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Docker%E9%95%9C%E5%83%8F%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4.71pfsgm3nn00.svg\" alt=\"Docker镜像操作命令\"></p>\n<h4 id=\"拉取、查看镜像\">拉取、查看镜像</h4>\n<p>需求：从 DockerHub 中拉取一个 Nginx 镜像并查看</p>\n<ol>\n<li>首先去镜像仓库搜索 Nginx 镜像，比如 <a href=\"https://hub.docker.com/\">DockerHub</a>:</li>\n<li>根据查看到的镜像名称，拉取自己需要的镜像，通过命令：<code>docker pull nginx</code></li>\n<li>通过命令：<code>docker images</code> 查看拉取到的镜像</li>\n</ol>\n<h4 id=\"保存镜像\">保存镜像</h4>\n<p>需求：利用 docker save 将 Nginx 镜像导出磁盘，然后再通过 load 加载回来</p>\n<p>利用 <code>docker xx --help</code> 命令查看 <code>docker save</code> 和 <code>docker load</code> 的语法。例如，查看save命令用法，可以输入命令：</p>\n<pre><code class=\"hljs language-sh\">docker <span class=\"hljs-keyword\">save</span> --<span class=\"hljs-keyword\">help</span>\n</code></pre>\n<p>命令格式：</p>\n<pre><code class=\"hljs language-sh\">docker save -o <span class=\"hljs-selector-attr\">[保存的目标文件名称]</span> <span class=\"hljs-selector-attr\">[镜像名称]</span>\n</code></pre>\n<p>使用 <code>docker save</code> 导出镜像到磁盘，运行命令：</p>\n<pre><code class=\"hljs language-sh\">docker <span class=\"hljs-keyword\">save</span> -o nginx.tar nginx:latest\n</code></pre>\n<h4 id=\"导入镜像\">导入镜像</h4>\n<p>先删除本地的 Nginx 镜像：</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-attribute\">docker</span> rmi nginx:latest\n</code></pre>\n<p>然后运行命令，加载本地文件：</p>\n<pre><code class=\"hljs language-sh\">docker load -<span class=\"hljs-selector-tag\">i</span> nginx<span class=\"hljs-selector-class\">.tar</span>\n</code></pre>\n<h3 id=\"容器操作\">容器操作</h3>\n<h4 id=\"容器相关命令\">容器相关命令</h4>\n<p>容器操作的命令如图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Docker%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4.54kd7pt4p2w0.svg\" alt=\"Docker容器相关命令\"></p>\n<p>容器保护三个状态：</p>\n<ul>\n<li>运行：进程正常运行</li>\n<li>暂停：进程暂停，CPU 不再运行，并不释放内存</li>\n<li>停止：进程终止，回收进程占用的内存、CPU 等资源</li>\n</ul>\n<p>其中：</p>\n<ul>\n<li><code>docker run</code>：创建并运行一个容器，处于运行状态</li>\n<li><code>docker pause</code>：让一个运行的容器暂停</li>\n<li><code>docker unpause</code>：让一个容器从暂停状态恢复运行</li>\n<li><code>docker stop</code>：停止一个运行的容器</li>\n<li><code>docker start</code>：让一个停止的容器再次运行</li>\n<li><code>docker rm</code>：删除一个容器</li>\n<li><code>docker logs</code> ：查看容器日志的命令，添加 <code>-f</code> 参数可以持续查看日志</li>\n<li><code>docker ps</code> ：查看容器状态，<code>-a</code> 查看所有容器，包括已经停止的</li>\n</ul>\n<h4 id=\"创建并运行一个容器\">创建并运行一个容器</h4>\n<p>创建并运行 Nginx 容器的命令：</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-attribute\">docker</span> run --name haloNginx -p <span class=\"hljs-number\">81</span>:<span class=\"hljs-number\">80</span> -d nginx\n</code></pre>\n<p>命令解读：</p>\n<ul>\n<li><code>docker run</code> ：创建并运行一个容器</li>\n<li><code>--name</code> : 给容器起一个名字，比如叫做 haloNginx</li>\n<li><code>-p</code> ：将宿主机端口与容器端口映射，冒号左侧是宿主机端口，右侧是容器端口</li>\n<li><code>-d</code>：后台运行容器</li>\n<li><code>nginx</code>：镜像名称，例如 nginx</li>\n</ul>\n<p>这里的 <code>-p</code> 参数，是将容器端口映射到宿主机端口。</p>\n<p>默认情况下，容器是隔离环境，我们直接访问宿主机的 81 端口，肯定访问不到容器中的 Nginx。</p>\n<p>现在，将容器的 80 与宿主机的 81 关联起来，当我们访问宿主机的 81 端口时，就会被映射到容器的80，这样就能访问到 Nginx 了</p>\n<h4 id=\"进入容器并修改文件\">进入容器并修改文件</h4>\n<p><strong>需求</strong>：进入 Nginx 容器，修改 HTML 文件内容，添加“Halo World!”</p>\n<blockquote>\n<p>提示：进入容器要用到 <code>docker exec</code> 命令。</p>\n</blockquote>\n<p>① 进入容器。进入我们刚刚创建的 Nginx 容器的命令为：</p>\n<pre><code class=\"hljs language-sh\">docker exec -<span class=\"hljs-keyword\">it</span> haloNginx bash\n</code></pre>\n<p>命令解读：</p>\n<ul>\n<li><p><code>docker exec</code> ：进入容器内部，执行一个命令</p>\n</li>\n<li><p><code>-it</code> : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互</p>\n</li>\n<li><p><code>haloNginx</code>：要进入的容器的名称</p>\n</li>\n<li><p><code>bash</code>：进入容器后执行的命令，bash 是一个 Linux 终端交互命令</p>\n</li>\n</ul>\n<p>② 进入 Nginx 的 HTML 所在目录 /usr/share/nginx/html</p>\n<p>容器内部会模拟一个独立的 Linux 文件系统，看起来如同一个 Linux 服务器一样</p>\n<p>Nginx 的环境、配置、运行文件全部都在这个文件系统中，包括我们要修改的 html 文件。</p>\n<p>查看 DockerHub 网站中的 Nginx 页面，可以知道 Nginx 的 html 目录位置在 <code>/usr/share/nginx/html</code></p>\n<p>我们执行命令，进入该目录：</p>\n<pre><code class=\"hljs language-sh\">cd <span class=\"hljs-regexp\">/usr/</span>share<span class=\"hljs-regexp\">/nginx/</span>html\n</code></pre>\n<p>③ 修改 index.html 的内容</p>\n<p>容器内没有 vi 命令，无法直接修改，我们用下面的命令来修改：</p>\n<pre><code class=\"hljs language-sh\">sed -i -e &#x27;s<span class=\"hljs-symbol\">#Welcome</span> to nginx<span class=\"hljs-symbol\">#Halo</span> World!<span class=\"hljs-symbol\">#g</span>&#x27; -e &#x27;s#&lt;head&gt;#&lt;head&gt;&lt;meta charset=<span class=\"hljs-string\">&quot;utf-8&quot;</span>&gt;<span class=\"hljs-symbol\">#g</span>&#x27; index.html\n</code></pre>\n<h3 id=\"数据卷（容器数据管理）\">数据卷（容器数据管理）</h3>\n<p>在之前的 Nginx 案例中，修改 Nginx 的 html 页面时，需要进入 Nginx 内部。并且因为没有编辑器，修改文件也很麻烦。</p>\n<p>这就是因为容器与数据（容器内文件）耦合带来的后果。容器与数据耦合的问题：</p>\n<ul>\n<li>不便于修改：当我们要修改 Nginx 的 html 内容时，需要进入容器内部修改，很不方便。</li>\n<li>数据不可复用：在容器内的修改对外是不可见的。所有修改对新创建的容器是不可复用的。</li>\n<li>升级维护困难：数据在容器内，如果要升级容器必然删除旧容器，所有数据都跟着删除了</li>\n</ul>\n<p>要解决这个问题，必须将数据与容器解耦，这就要用到数据卷了。</p>\n<h4 id=\"什么是数据卷\">什么是数据卷</h4>\n<p>数据卷（volume）是一个虚拟目录，指向宿主机文件系统中的某个目录。</p>\n<p>一旦完成数据卷挂载，对容器的一切操作都会作用在数据卷对应的宿主机目录了。</p>\n<p>这样，我们操作宿主机的 /var/lib/docker/volumes/html 目录，就等于操作容器内的 /usr/share/nginx/html 目录了</p>\n<h4 id=\"数据集操作命令\">数据集操作命令</h4>\n<p>数据卷操作的基本语法如下：</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-attribute\">docker</span> volume<span class=\"hljs-meta\"> [COMMAND]</span>\n</code></pre>\n<p><code>docker volume</code> 命令是数据卷操作，根据命令后跟随的 <code>command</code> 来确定下一步的操作：</p>\n<ul>\n<li><code>create</code> ：创建一个 volume</li>\n<li><code>inspect</code> ：显示一个或多个 volume 的信息</li>\n<li><code>ls</code> ：列出所有的 volume</li>\n<li><code>prune</code> ：删除未使用的 volume</li>\n<li><code>rm</code> ：删除一个或多个指定的 volume</li>\n</ul>\n<h4 id=\"创建和查看数据卷\">创建和查看数据卷</h4>\n<p>① 创建数据卷</p>\n<pre><code class=\"hljs language-sh\">docker <span class=\"hljs-built_in\">volume</span> <span class=\"hljs-keyword\">create</span> nginx-html\n</code></pre>\n<p>② 查看所有数据</p>\n<pre><code class=\"hljs language-sh\">docker <span class=\"hljs-keyword\">volume</span><span class=\"language-bash\"> ls</span>\n</code></pre>\n<p>③ 查看数据卷详细信息卷</p>\n<pre><code class=\"hljs language-sh\">docker volume inspect nginx-<span class=\"hljs-selector-tag\">html</span>\n</code></pre>\n<p>可以看到，我们创建的 nginx-html 这个数据卷关联的宿主机目录为 <code>/var/lib/docker/volumes/nginx-html/_data</code> 目录。</p>\n<h4 id=\"挂载数据卷\">挂载数据卷</h4>\n<p>我们在创建容器时，可以通过 <code>-v</code> 参数来挂载一个数据卷到某个容器内目录，命令格式如下：</p>\n<pre><code class=\"hljs language-sh\">docker run \\\n  --name halo-nginx \\\n  -v nginx-html:<span class=\"hljs-regexp\">/usr/</span>share<span class=\"hljs-regexp\">/nginx/</span>html \\\n  -p <span class=\"hljs-number\">81</span>:<span class=\"hljs-number\">80</span>\n  nginx \\\n</code></pre>\n<p>这里的 <code>-v</code> 就是挂载数据卷的命令。<code>-v nginx-html:/root/htm</code> ：把 nginx-html 数据卷挂载到容器内的 /root/html 这个目录中</p>\n<p>需求：创建一个 Nginx 容器，修改容器内的 html 目录内的 index.html 内容</p>\n<p>分析：上个案例中，我们进入 Nginx 容器内部，已经知道 Nginx 的 html 目录所在位置 /usr/share/nginx/html ，我们需要把这个目录挂载到 html 这个数据卷上，方便操作其中的内容。</p>\n<p>① 创建容器并挂载数据卷到容器内的 HTML 目录</p>\n<pre><code class=\"hljs language-sh\">docker run --name halo-nginx -v nginx-html:<span class=\"hljs-regexp\">/usr/</span>share<span class=\"hljs-regexp\">/nginx/</span>html -p <span class=\"hljs-number\">81</span>:<span class=\"hljs-number\">80</span> -d nginx\n</code></pre>\n<p>② 进入 nginx-html 数据卷所在位置，并修改 HTML 内容</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># 查看html数据卷的位置</span>\ndocker volume inspect nginx-html\n<span class=\"hljs-comment\"># 进入该目录</span>\ncd <span class=\"hljs-regexp\">/var/</span>lib<span class=\"hljs-regexp\">/docker/</span>volumes<span class=\"hljs-regexp\">/nginx-html/</span>_data\n<span class=\"hljs-comment\"># 修改文件</span>\nvi index.html\n</code></pre>\n<blockquote>\n<p>数据卷不存在会自动创建</p>\n</blockquote>\n<h4 id=\"挂载本地目录\">挂载本地目录</h4>\n<p>容器不仅仅可以挂载数据卷，也可以直接挂载到宿主机目录上。关联关系如下：</p>\n<ul>\n<li>带数据卷模式：宿主机目录 → 数据卷 → 容器内目录</li>\n<li>直接挂载模式：宿主机目录 → 容器内目录</li>\n</ul>\n<p>目录挂载与数据卷挂载的语法是类似的：</p>\n<ul>\n<li><code>-v [宿主机目录]:[容器内目录]</code></li>\n<li><code>-v [宿主机文件]:[容器内文件]</code></li>\n</ul>\n<p>需求：创建并运行一个 MySQL 容器，将宿主机目录直接挂载到容器</p>\n<ol>\n<li><p>拉取 MySQL 镜像</p>\n</li>\n<li><p>创建目录 /develop/docker-volumes/halo-mysql/data</p>\n</li>\n<li><p>创建目录 /develop/docker-volumes/halo-mysql/conf ，并在其中创建 halo.conf，内容如下</p>\n<pre><code>[mysqld]\nskip-name-resolve\n<span class=\"hljs-attribute\">character_set_server</span>=utf8\n<span class=\"hljs-attribute\">datadir</span>=/var/lib/mysql\n<span class=\"hljs-attribute\">server-id</span>=1000\n</code></pre>\n</li>\n<li><p>进行挂载</p>\n<pre><code>docker run \\\n  --name halo-mysql \\\n  -e MYSQL_ROOT_PASSWORD=halo \\\n  -p <span class=\"hljs-number\">3307</span>:<span class=\"hljs-number\">3306</span> \\\n  -v <span class=\"hljs-regexp\">/develop/</span>docker-volumes<span class=\"hljs-regexp\">/halo-mysql/</span>conf<span class=\"hljs-regexp\">/halo.conf:/</span>etc<span class=\"hljs-regexp\">/mysql/</span>conf.d/halo.conf \\\n  -v <span class=\"hljs-regexp\">/develop/</span>docker-volumes<span class=\"hljs-regexp\">/halo-mysql/</span>data:<span class=\"hljs-regexp\">/var/</span>lib/mysql \\\n  -d \\\n  mysql:latest\n</code></pre>\n</li>\n</ol>\n<h2 id=\"dockerfile-自定义镜像\">Dockerfile 自定义镜像</h2>\n<h3 id=\"镜像结构\">镜像结构</h3>\n<p>镜像是将应用程序及其需要的系统函数库、环境、配置、依赖打包而成。</p>\n<ul>\n<li>基础镜像（Base Image）：应用依赖的系统函数库、环境、配置、文件等</li>\n<li>层（ Layer ）：在 Base Image 基础上添加安装包、依赖、配置等，每次操作都形成新的一层。</li>\n<li>入口（Entry Point）：镜像运行入口，一般是程序启动的脚本和参数</li>\n</ul>\n<p>简单来说，镜像就是在系统函数库、运行环境基础上，添加应用程序文件、配置文件、依赖文件等组合，然后编写好启动脚本打包在一起形成的文件。</p>\n<p>我们要构建镜像，其实就是实现上述打包的过程。</p>\n<h3 id=\"dockerfile-语法\">Dockerfile 语法</h3>\n<p>构建自定义的镜像时，并不需要一个个文件去拷贝，打包。</p>\n<p>我们只需要告诉 Docker，我们的镜像的组成，需要哪些 Base Image、需要拷贝什么文件、需要安装什么依赖、启动脚本是什么，将来 Docker 会帮助我们构建镜像。</p>\n<p>而描述上述信息的文件就是 Dockerfile 文件。</p>\n<p>Dockerfile 就是一个文本文件，其中包含一个个的指令（Instruction），用指令来说明要执行什么操作来构建镜像。每一个指令都会形成一层 Layer。</p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>FROM</td>\n<td>指定基础镜像</td>\n<td><code>FROM centos:6</code></td>\n</tr>\n<tr>\n<td>ENV</td>\n<td>设置环境变量，可在后面指令使用</td>\n<td><code>ENV key value</code></td>\n</tr>\n<tr>\n<td>COPY</td>\n<td>拷贝本地文件到镜像的指定目录</td>\n<td><code>COPY ./mysql-5.7.rpm /tmp</code></td>\n</tr>\n<tr>\n<td>RUN</td>\n<td>执行 Linux 的 shell 命令，一般是安装过程的命令</td>\n<td><code>RUN yum install gcc</code></td>\n</tr>\n<tr>\n<td>EXPOSE</td>\n<td>指定容器运行时监听的端口，是给镜像使用者看的</td>\n<td><code>EXPOSE 8080</code></td>\n</tr>\n<tr>\n<td>ENTRYPOINT</td>\n<td>镜像中应用的启动命令，容器运行时调用</td>\n<td><code>ENTRYPOINT java -jar xx.jar</code></td>\n</tr>\n</tbody></table>\n<p>更新详细语法说明，请参考官网文档： <a href=\"https://docs.docker.com/engine/reference/builder\">https://docs.docker.com/engine/reference/builder</a></p>\n<h3 id=\"直接构建-java-项目\">直接构建 Java 项目</h3>\n<p>需求：基于 Ubuntu 镜像构建一个新镜像，运行一个 Java 项目</p>\n<ol>\n<li><p>Linux 下新建一个空文件夹 docker-demo</p>\n</li>\n<li><p>拷贝 docker-demo.jar 文件到 docker-demo 这个目录</p>\n</li>\n<li><p>拷贝 jdk8.tar.gz 文件到 docker-demo 这个目录</p>\n</li>\n<li><p>拷贝 Dockerfile 到 docker-demo 这个目录，其中的内容如下：</p>\n<pre><code class=\"hljs language-dockerfile\"><span class=\"hljs-comment\"># 指定基础镜像</span>\nFROM ubuntu:<span class=\"hljs-number\">16.04</span>\n<span class=\"hljs-comment\"># 配置环境变量，JDK的安装目录</span>\nENV JAVA_DIR=<span class=\"hljs-regexp\">/usr/</span>local\n\n<span class=\"hljs-comment\"># 拷贝jdk和java项目的包</span>\nCOPY .<span class=\"hljs-regexp\">/jdk8.tar.gz $JAVA_DIR/</span>\nCOPY .<span class=\"hljs-regexp\">/docker-demo.jar /</span>tmp/app.jar\n\n<span class=\"hljs-comment\"># 安装JDK</span>\nRUN cd <span class=\"hljs-variable\">$JAVA_DIR</span> \\\n &amp;&amp; tar -xf ./jdk8.tar.gz \\\n &amp;&amp; mv .<span class=\"hljs-regexp\">/jdk1.8.0_144 ./</span>java8\n\n<span class=\"hljs-comment\"># 配置环境变量</span>\nENV JAVA_HOME=<span class=\"hljs-variable\">$JAVA_DIR</span>/java8\nENV PATH=<span class=\"hljs-variable\">$PATH</span>:<span class=\"hljs-variable\">$JAVA_HOME</span>/bin\n\n<span class=\"hljs-comment\"># 暴露端口</span>\nEXPOSE <span class=\"hljs-number\">8090</span>\n<span class=\"hljs-comment\"># 入口，java项目的启动命令</span>\nENTRYPOINT java -jar <span class=\"hljs-regexp\">/tmp/</span>app.jar\n</code></pre>\n</li>\n<li><p>进入 docker-demo ，运行命令：</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-attribute\">docker</span> build -t javaweb:<span class=\"hljs-number\">1</span>.<span class=\"hljs-number\">0</span> .\n</code></pre>\n</li>\n<li><p>运行测试</p>\n</li>\n</ol>\n<h3 id=\"基于-java8-alpine--构建-java-项目\">基于 java8-alpine  构建 Java 项目</h3>\n<p>虽然我们可以基于 Ubuntu 基础镜像，添加任意自己需要的安装包，构建镜像，但是却比较麻烦。所以大多数情况下，我们都可以在一些安装了部分软件的基础镜像上做改造。</p>\n<p>例如，构建 Java 项目的镜像，可以在已经准备了JDK 的基础镜像基础上构建。</p>\n<p>需求：基于 java:8-alpine 镜像，将一个 Java 项目构建为镜像</p>\n<p>实现思路如下：</p>\n<ul>\n<li><p> 新建一个空的目录，然后在目录中新建一个文件，命名为 Dockerfile</p>\n</li>\n<li><p>拷贝 docker-demo.jar 到这个目录中</p>\n</li>\n<li><p>编写 Dockerfile 文件，内容如下：</p>\n<pre><code class=\"hljs language-dockerfile\"><span class=\"hljs-keyword\">FROM</span> java:<span class=\"hljs-number\">8</span>-alpine\n<span class=\"hljs-keyword\">COPY</span> .<span class=\"hljs-regexp\">/app.jar /</span>tmp/app.jar\nEXPOSE <span class=\"hljs-number\">8090</span>\nENTRYPOINT java -jar <span class=\"hljs-regexp\">/tmp/</span>app.jar\n</code></pre>\n</li>\n<li><p>进入 docker-demo ，运行命令：</p>\n<pre><code><span class=\"hljs-attribute\">docker</span> build -t javaweb:<span class=\"hljs-number\">2</span>.<span class=\"hljs-number\">0</span> .\n</code></pre>\n</li>\n</ul>\n<h3 id=\"dockerfile-小结\">Dockerfile 小结</h3>\n<ol>\n<li><p>Dockerfile 的本质是一个文件，通过指令描述镜像的构建过程</p>\n</li>\n<li><p>Dockerfile 的第一行必须是 FROM，从一个基础镜像来构建</p>\n</li>\n<li><p>基础镜像可以是基本操作系统，如 Ubuntu。也可以是其他人制作好的镜像，例如：java:8-alpine</p>\n</li>\n</ol>\n<h2 id=\"docker-compose\">Docker Compose</h2>\n<p>Docker Compose 可以基于 Compose 文件帮我们快速的部署分布式应用，而无需手动一个个创建和运行容器。</p>\n<h3 id=\"初识-docker-compose\">初识 Docker Compose</h3>\n<p>Compose 文件是一个文本文件，通过指令定义集群中的每个容器如何运行。格式如下：</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-symbol\">version:</span> <span class=\"hljs-string\">&quot;3.8&quot;</span>\n<span class=\"hljs-symbol\"> services:</span>\n<span class=\"hljs-symbol\">  mysql:</span>\n<span class=\"hljs-symbol\">    image:</span> mysql:<span class=\"hljs-number\">5.7</span><span class=\"hljs-number\">.25</span>\n<span class=\"hljs-symbol\">    environment:</span>\n<span class=\"hljs-symbol\">     MYSQL_ROOT_PASSWORD:</span> <span class=\"hljs-number\">123</span> \n<span class=\"hljs-symbol\">    volumes:</span>\n     - <span class=\"hljs-string\">&quot;/tmp/mysql/data:/var/lib/mysql&quot;</span>\n     - <span class=\"hljs-string\">&quot;/tmp/mysql/conf/hmy.cnf:/etc/mysql/conf.d/hmy.cnf&quot;</span>\n<span class=\"hljs-symbol\">  web:</span>\n<span class=\"hljs-symbol\">    build:</span> .\n<span class=\"hljs-symbol\">    ports:</span>\n     - <span class=\"hljs-string\">&quot;8090:8090&quot;</span>\n</code></pre>\n<p>上面的 Compose 文件就描述一个项目，其中包含两个容器：</p>\n<ul>\n<li>mysql：一个基于 <code>mysql:5.7.25</code> 镜像构建的容器，并且挂载了两个目录</li>\n<li>web：一个基于 <code>docker build</code> 临时构建的镜像容器，映射端口时 8090</li>\n</ul>\n<p>Docker Compose 的详细语法参考官网：<a href=\"https://docs.docker.com/compose/compose-file/\">https://docs.docker.com/compose/compose-file/</a></p>\n<p>其实 Docker Compose 文件可以看做是将多个 docker run 命令写到一个文件，只是语法稍有差异。</p>\n<h3 id=\"安装-docker-compose\">安装 Docker Compose</h3>\n<ol>\n<li><p>下载 docker-compose，Linux 下需要通过命令下载（速度较慢）：</p>\n<pre><code class=\"hljs language-sh\">curl -L https:<span class=\"hljs-regexp\">//gi</span>thub.com<span class=\"hljs-regexp\">/docker/</span>compose<span class=\"hljs-regexp\">/releases/</span>download<span class=\"hljs-regexp\">/1.23.1/</span>docker-compose-`uname -s`-`uname -m` &gt; <span class=\"hljs-regexp\">/usr/</span>local<span class=\"hljs-regexp\">/bin/</span>docker-compose\n</code></pre>\n</li>\n<li><p>修改文件权限</p>\n<pre><code class=\"hljs language-sh\">chmod +x <span class=\"hljs-regexp\">/usr/</span>local<span class=\"hljs-regexp\">/bin/</span>docker-compose\n</code></pre>\n</li>\n</ol>\n<p>配置 Base 自动补全命令</p>\n<pre><code class=\"hljs language-sh\">curl -L https:<span class=\"hljs-regexp\">//</span>raw.githubusercontent.com<span class=\"hljs-regexp\">/docker/</span>compose<span class=\"hljs-regexp\">/1.29.1/</span>contrib<span class=\"hljs-regexp\">/completion/</span>bash<span class=\"hljs-regexp\">/docker-compose &gt; /</span>etc<span class=\"hljs-regexp\">/bash_completion.d/</span>docker-compose\n</code></pre>\n<p>如果这里出现错误，需要修改自己的 hosts 文件：</p>\n<pre><code class=\"hljs language-sh\">echo <span class=\"hljs-string\">&quot;199.232.68.133 raw.githubusercontent.com&quot;</span> &gt;&gt; <span class=\"hljs-regexp\">/etc/</span>hosts\n</code></pre>\n<h3 id=\"部署微服务集群\">部署微服务集群</h3>\n<p>需求：将之前学习的 spring-cloud-demo 微服务集群利用 Docker Compose 部署</p>\n<p>实现思路：</p>\n<ol>\n<li>编写 docker-compose 文件</li>\n<li>修改自己的 cloud-demo 项目，将数据库、nacos 地址都命名为 docker-compose 中的服务名</li>\n<li>使用 maven 打包工具，将项目中的每个微服务都打包为 app.jar</li>\n<li>将打包好的 app.jar 拷贝到 cloud-demo 中的每一个对应的子目录中</li>\n<li>到 cloud-demo 目录，利用 <code>docker-compose up -d</code> 来部署</li>\n</ol>\n<h2 id=\"docker-镜像仓库\">Docker 镜像仓库</h2>\n<h3 id=\"搭建私有镜像仓库\">搭建私有镜像仓库</h3>\n<p>搭建镜像仓库可以基于 Docker 官方提供的 Docker Registry 来实现。</p>\n<p>官网地址：<a href=\"https://hub.docker.com/_/registry\">https://hub.docker.com/_/registry</a></p>\n<h4 id=\"简化版镜像仓库\">简化版镜像仓库</h4>\n<p>Docker 官方的 Docker Registry 是一个基础版本的 Docker 镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。</p>\n<p>搭建方式比较简单，命令如下：</p>\n<pre><code class=\"hljs language-sh\">docker run -d <span class=\"hljs-string\">\\</span>\n    --restart=always <span class=\"hljs-string\">\\</span>\n    --name registry    <span class=\"hljs-string\">\\</span>\n    -p <span class=\"hljs-number\">5000</span>:<span class=\"hljs-number\">5000</span> <span class=\"hljs-string\">\\</span>\n    -v registry-data:/<span class=\"hljs-keyword\">var</span>/lib/registry <span class=\"hljs-string\">\\</span>\n    registry\n</code></pre>\n<p>命令中挂载了一个数据卷 registry-data 到容器内的 /var/lib/registry 目录，这是私有镜像库存放数据的目录。</p>\n<p>访问 <a href=\"http://halo:5000/v2/_catalog\">http://halo:5000/v2/_catalog</a> 可以查看当前私有镜像服务中包含的镜像</p>\n<h4 id=\"带有图形化界面版本\">带有图形化界面版本</h4>\n<p>使用 Docker Compose 部署带有图象界面的 Docker Registry，命令如下：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attribute\">version</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&#x27;3.0&#x27;</span>\n<span class=\"hljs-attribute\">services</span><span class=\"hljs-punctuation\">:</span>\n  <span class=\"hljs-attribute\">registry</span><span class=\"hljs-punctuation\">:</span>\n    <span class=\"hljs-attribute\">image</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">registry</span>\n    <span class=\"hljs-attribute\">volumes</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">./registry-data:/var/lib/registry</span>\n  <span class=\"hljs-attribute\">ui</span><span class=\"hljs-punctuation\">:</span>\n    <span class=\"hljs-attribute\">image</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">joxit/docker-registry-ui:static</span>\n    <span class=\"hljs-attribute\">ports</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">8181:80</span>\n    <span class=\"hljs-attribute\">environment</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">REGISTRY_TITLE=Halo-Docker-Registry</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">REGISTRY_URL=http://registry:5000</span>\n    <span class=\"hljs-attribute\">depends_on</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">registry</span>\n</code></pre>\n<p>配置 Docker 信任地址，私服采用的是 http 协议，默认不被 Docker 信任，所以需要做一个配置：</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># 打开要修改的文件</span>\nvi <span class=\"hljs-regexp\">/etc/</span>docker/daemon.json\n<span class=\"hljs-comment\"># 添加内容：</span>\n<span class=\"hljs-string\">&quot;insecure-registries&quot;</span>:[<span class=\"hljs-string\">&quot;http://halo:8181&quot;</span>]\n<span class=\"hljs-comment\"># 重加载</span>\nsystemctl daemon-reload\n<span class=\"hljs-comment\"># 重启docker</span>\nsystemctl restart docker\n</code></pre>\n<h3 id=\"推送、拉取镜像\">推送、拉取镜像</h3>\n<p>推送镜像到私有镜像服务必须先 tag，步骤如下：</p>\n<p>① 重新 tag 本地镜像，名称前缀为私有仓库的地址：halo:8181/</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-attribute\">docker</span> tag nginx:latest halo:<span class=\"hljs-number\">8181</span>/nginx:<span class=\"hljs-number\">1</span>.<span class=\"hljs-number\">0</span> \n</code></pre>\n<p>② 推送镜像</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-attribute\">docker</span> push halo:<span class=\"hljs-number\">8181</span>/nginx:<span class=\"hljs-number\">1</span>.<span class=\"hljs-number\">0</span> \n</code></pre>\n<p>③ 拉取镜像</p>\n<pre><code><span class=\"hljs-attribute\">docker</span> pull halo:<span class=\"hljs-number\">8181</span>/nginx:<span class=\"hljs-number\">1</span>.<span class=\"hljs-number\">0</span> \n</code></pre>\n');
INSERT INTO `m_blog` VALUES (8, 1, 'RabbitMQ 入门', 'RabbitMQ 入门', '## 初识 RabbitMQ\n\n### 同步和异步通讯\n\n微服务间通讯有同步和异步两种方式：\n\n+ 同步通讯：就像打电话，需要实时响应。\n+ 异步通讯：就像发邮件，不需要马上回复。\n\n#### 同步通讯\n\n我们之前学习的 Feign 调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：\n\n+ 耦合度高：每次加入新的需求，都要修改原来的代码\n+ 性能下降：调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用的时间之和。\n+ 资源浪费：调用链中的每个服务在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源\n+ 级联失败：如果服务提供者出现问题，所有调用方都会跟着出问题，如同多米诺骨牌一样，迅速导致整个微服务群故障\n\n#### 异步通讯\n\n异步调用则可以避免上述问题：\n\n我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。\n\n+ 在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单 id。\n+ 订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。\n+ 为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到 Broker，不关心谁来订阅事件。订阅者从 Broker 订阅事件，不关心谁发来的消息。\n\nBroker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。\n\n异步通讯的优点：\n\n- 吞吐量提升：无需等待订阅者处理完成，响应更快速\n\n- 故障隔离：服务没有直接调用，不存在级联失败问题\n- 调用间没有阻塞，不会造成无效的资源占用\n- 耦合度极低，每个服务都可以灵活插拔，可替换\n- 流量削峰：不管发布事件的流量波动多大，都由 Broker 接收，订阅者可以按照自己的速度去处理事件\n\n异步通讯的缺点：\n\n- 架构复杂了，业务没有明显的流程线，不好管理\n- 需要依赖于 Broker 的可靠、安全、性能\n\n### 技术对比\n\nMQ，中文是消息队列（Message Queue），字面来看就是存放消息的队列。也就是事件驱动架构中的 Broker。\n\n比较常见的MQ实现：\n\n- ActiveMQ\n- RabbitMQ\n- RocketMQ\n- Kafka\n\n几种常见 MQ 的对比：\n\n|            | RabbitMQ                | ActiveMQ                          | RocketMQ   | Kafka        |\n| ---------- | ----------------------- | --------------------------------- | ---------- | ------------ |\n| 公司/社区  | Rabbit                  | Apache                            | 阿里       | Apache       |\n| 开发语言   | Erlang                  | Java                              | Java       | Scala & Java |\n| 协议支持   | AMQP，XMPP，SMTP，STOMP | OpenWire，STOMP，REST，XMPP，AMQP | 自定义协议 | 自定义协议   |\n| 可用性     | 高                      | 一般                              | 高         | 高           |\n| 单机吞吐量 | 一般                    | 差                                | 高         | 非常高       |\n| 消息延迟   | 微秒级                  | 毫秒级                            | 毫秒级     | 毫秒以内     |\n| 消息可靠性 | 高                      | 一般                              | 高         | 一般         |\n\n追求可用性：Kafka、 RocketMQ 、RabbitMQ\n\n追求可靠性：RabbitMQ、RocketMQ\n\n追求吞吐能力：RocketMQ、Kafka\n\n追求消息低延迟：RabbitMQ、Kafka\n\n## RabbitMQ 快速入门\n\nRabbitMQ 是基于 Erlang 语言开发的开源消息通信中间件，官网地址：https://www.rabbitmq.com/\n\n### 安装 RabbitMQ\n\n在 Centos 7 虚拟机中使用 Docker 来安装\n\n```sh\ndocker pull rabbitmq:3-management\n```\n\n执行下面的命令来运行 MQ 容器：\n\n```\ndocker run \\\n -e RABBITMQ_DEFAULT_USER=halo \\\n -e RABBITMQ_DEFAULT_PASS=halo \\\n --name halo-rabbitmq-1 \\\n --hostname halo-rabbitmq-1 \\\n -p 15672:15672 \\\n -p 5672:5672 \\\n -d \\\n rabbitmq:3-management\n```\n\n### RabbitMQ 的基本结构\n\nRabbitMQ 的基本结构：\n\n![RabbitMQ的结构和概念](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/RabbitMQ的结构和概念.5365ey5rjww0.svg)\n\nRabbitMQ 中的一些角色：\n\n- publisher：生产者\n- consumer：消费者\n- exchange：交换机，负责消息路由\n- queue：队列，存储消息\n- virtualHost：虚拟主机，隔离不同租户的 exchange、queue、消息的隔离\n\n### RabbitMQ 消息模型\n\n[RabbitMQ 官方](https://www.rabbitmq.com/getstarted.html) 提供了 5 个不同的 Demo 示例，对应了不同的消息模型：\n\n+ 基本消息队列（Basic Queue）\n+ 工作消息队列（Work Queue）\n+ 发布订阅（Publish、Subscribe），又根据交换机类型不同分为三种：\n  + Fanout Exchange：广播\n  + Direct Exchange：路由\n  + Topic Exchange：主题\n\n![RabbitMQ消息模型](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/RabbitMQ消息模型.1fiomitimbsw.png)\n\n### Hello World 案例\n\n官方的 HelloWorld 是基于最基础的消息队列模型来实现的，只包括三个角色：\n\n•publisher：消息发布者，将消息发送到队列 queue\n\n•queue：消息队列，负责接受并缓存消息\n\n•consumer：订阅队列，处理队列中的消息\n\n![HelloWorld案例](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/HelloWorld案例.zb6pinalxzk.svg)\n\npublisher 实现思路：\n\n- 建立连接\n- 创建 Channel\n- 声明队列\n- 发送消息\n- 关闭连接和 Channel\n\n代码实现：\n\n```java\npackage cn.itcast.mq.helloworld;\n\nimport com.rabbitmq.client.Channel;\nimport com.rabbitmq.client.Connection;\nimport com.rabbitmq.client.ConnectionFactory;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\npublic class PublisherTest {\n    @Test\n    public void testSendMessage() throws IOException, TimeoutException {\n        // 1.建立连接\n        ConnectionFactory factory = new ConnectionFactory();\n        // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码\n        factory.setHost(\"halo\");\n        factory.setPort(5672);\n        factory.setVirtualHost(\"/\");\n        factory.setUsername(\"halo\");\n        factory.setPassword(\"halo\");\n        // 1.2.建立连接\n        Connection connection = factory.newConnection();\n\n        // 2.创建通道Channel\n        Channel channel = connection.createChannel();\n\n        // 3.创建队列\n        String queueName = \"simple.queue\";\n        channel.queueDeclare(queueName, false, false, false, null);\n\n        // 4.发送消息\n        String message = \"hello, rabbitmq!\";\n        channel.basicPublish(\"\", queueName, null, message.getBytes());\n        System.out.println(\"发送消息成功：【\" + message + \"】\");\n\n        // 5.关闭通道和连接\n        channel.close();\n        connection.close();\n\n    }\n}\n```\n\nconsumer 实现思路：\n\n- 建立连接\n- 创建 Channel\n- 声明队列\n- 订阅消息\n\n代码实现：\n\n```java\npackage cn.itcast.mq.helloworld;\n\nimport com.rabbitmq.client.*;\n\nimport java.io.IOException;\nimport java.util.concurrent.TimeoutException;\n\npublic class ConsumerTest {\n\n    public static void main(String[] args) throws IOException, TimeoutException {\n        // 1.建立连接\n        ConnectionFactory factory = new ConnectionFactory();\n        // 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码\n        factory.setHost(\"halo\");\n        factory.setPort(5672);\n        factory.setVirtualHost(\"/\");\n        factory.setUsername(\"halo\");\n        factory.setPassword(\"halo\");\n        // 1.2.建立连接\n        Connection connection = factory.newConnection();\n\n        // 2.创建通道Channel\n        Channel channel = connection.createChannel();\n\n        // 3.创建队列\n        String queueName = \"simple.queue\";\n        channel.queueDeclare(queueName, false, false, false, null);\n\n        // 4.订阅消息\n        channel.basicConsume(queueName, true, new DefaultConsumer(channel) {\n            @Override\n            public void handleDelivery(String consumerTag, Envelope envelope,\n                                       AMQP.BasicProperties properties, byte[] body) throws IOException {\n                // 5.处理消息\n                String message = new String(body);\n                System.out.println(\"接收到消息：【\" + message + \"】\");\n            }\n        });\n        System.out.println(\"等待接收消息。。。。\");\n    }\n}\n```\n\n基本消息队列的消息发送流程：\n\n1. 建立 connection\n\n2. 创建 channel\n\n3. 利用 channel 声明队列\n\n4. 利用 channel 向队列发送消息\n\n基本消息队列的消息接收流程：\n\n1. 建立 connection\n\n2. 创建 channel\n\n3. 利用 channel 声明队列\n\n4. 定义 consumer 的消费行为 `handleDelivery()`\n\n5. 利用 channel 将消费者与队列绑定\n\n## Spring AMQP\n\nSpring AMQP 是基于 RabbitMQ 封装的一套模板，并且还利用 Spring Boot 对其实现了自动装配，使用起来非常方便。\n\nSpring AMQP 的官方地址：https://spring.io/projects/spring-amqp\n\nAMQP ：Advanced Message Queuing Protocol，是用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求。\n\nSpring AMQP ：Spring AMQP 是基于 AMQP 协议定义的一套 API 规范，提供了模板来发送和接收消息。包含两部分，其中 spring-amqp 是基础抽象，spring-rabbit 是底层的默认实现。\n\nSpring AMQP 提供了三个功能：\n\n- 自动声明队列、交换机及其绑定关系\n- 基于注解的监听器模式，异步接收消息\n- 封装了 RabbitTemplate 工具，用于发送消息 \n\n### Basic Queue 基本消息队列\n\n![HelloWorld案例](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/HelloWorld案例.zb6pinalxzk.svg)\n\n流程如下：\n\n+ 在父工程中引入 spring-amqp 的依赖\n+ 在 publisher 服务中利用 RabbitTemplate 发送消息到 simple.queue 这个队列\n+ 在 consumer 服务中编写消费逻辑，绑定 simple.queue 这个队列\n\n#### 引入依赖\n\n在父工程 mq-demo 中引入依赖\n\n```xml\n<!--AMQP依赖，包含RabbitMQ-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n\n#### 消息发送\n\n首先配置 RabbitMQ 地址，在 publisher 服务的 application.yml 中添加配置：\n\n```yaml\nspring:\n  rabbitmq:\n    host: halo # 主机名\n    port: 5672 # 端口\n    virtual-host: / # 虚拟主机\n    username: halo # 用户名\n    password: halo # 密码\n```\n\n然后在 publisher 服务中编写测试类 `SpringAmqpTest`，并利用 RabbitTemplate 实现消息发送：\n\n```java\npackage cn.itcast.mq.spring;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.amqp.rabbit.core.RabbitTemplate;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringAmqpTest {\n\n    @Autowired\n    private RabbitTemplate rabbitTemplate;\n\n    @Test\n    public void testSimpleQueue() {\n        // 队列名称\n        String queueName = \"simple.queue\";\n        // 消息\n        String message = \"hello, spring amqp!\";\n        // 发送消息\n        rabbitTemplate.convertAndSend(queueName, message);\n    }\n}\n```\n\n#### 消息接收\n\n首先配置 RabbitMQ 地址，在 consumer 服务的 application.yml 中添加配置：\n\n```yaml\nspring:\n  rabbitmq:\n    host: halo # 主机名\n    port: 5672 # 端口\n    virtual-host: / # 虚拟主机\n    username: halo # 用户名\n    password: halo # 密码\n```\n\n然后在 consumer 服务的 `cn.itcast.mq.listener` 包中新建一个类 `SpringRabbitListener`，代码如下：\n\n```java\npackage cn.itcast.mq.listener;\n\nimport org.springframework.amqp.rabbit.annotation.RabbitListener;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class SpringRabbitListener {\n\n    @RabbitListener(queues = \"simple.queue\")\n    public void listenSimpleQueueMessage(String msg) throws InterruptedException {\n        System.out.println(\"spring 消费者接收到消息：【\" + msg + \"】\");\n    }\n}\n```\n\n注意：消息一旦消费就会从队列删除，RabbitMQ 没有消息回溯功能\n\n### Work Queue 工作队列\n\n![WorkQueue工作队列](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/WorkQueue工作队列.3xixqzsmydc0.svg)\n\nWork Queue，也被称为（Task queues），任务模型。简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。\n\n当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。\n\n此时就可以使用 work 模型，多个消费者共同处理消息处理，速度就能大大提高了。\n\n基本思路如下：\n\n1. 在 publisher 服务中定义测试方法，每秒产生 50 条消息，发送到 simple.queue\n2. 在 consumer 服务中定义两个消息监听者，都监听 simple.queue 队列\n3. 消费者 1 每秒处理 50 条消息，消费者 2 每秒处理 10 条消息\n\n#### 消息发送\n\n这次我们循环发送，模拟大量消息堆积现象。\n\n在 publisher 服务中的 SpringAmqpTest 类中添加一个测试方法：\n\n```java\n@Test\npublic void testWorkQueue() throws InterruptedException {\n    // 队列名称\n    String queueName = \"simple.queue\";\n    // 消息\n    String message = \"hello, message_\";\n    for (int i = 0; i < 50; i++) {\n        // 发送消息\n        rabbitTemplate.convertAndSend(queueName, message + i);\n        Thread.sleep(20);\n    }\n}\n```\n\n#### 消息接收\n\n要模拟多个消费者绑定同一个队列，我们在 consumer 服务的 `SpringRabbitListener` 中添加 2 个新的方法：\n\n```java\n@RabbitListener(queues = \"simple.queue\")\npublic void listenWorkQueue1(String msg) throws InterruptedException {\n    System.out.println(\"消费者-[1]-接收到消息：【\" + msg + \"】\" + LocalTime.now());\n    Thread.sleep(20);\n}\n\n@RabbitListener(queues = \"simple.queue\")\npublic void listenWorkQueue2(String msg) throws InterruptedException {\n    System.err.println(\"消费者-[2]-接收到消息：【\" + msg + \"】\" + LocalTime.now());\n    Thread.sleep(200);\n}\n```\n\n#### 测试分析\n\n启动 `ConsumerApplication` 后，在执行 publisher 服务中刚刚编写的发送测试方法 `testWorkQueue`。\n\n可以看到消费者 1 很快完成了自己的 25 条消息。消费者 2 却在缓慢的处理自己的 25 条消息。\n\n也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。\n\n#### 能者多劳\n\n在 spring 中有一个简单的配置，可以解决这个问题。我们修改 consumer 服务的 application.yml 文件，添加配置：\n\n```yaml\nspring:\n  rabbitmq:\n    listener:\n      simple:\n        prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息\n```\n\n设置 `preFetch` 这个值，可以控制预取消息的上限：\n\n### 发布与订阅\n\n发布订阅的模型如图：\n\n![发布订阅模式](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/发布订阅模式.g64vagn8am0.svg)\n\n可以看到，在订阅模型中，多了一个 exchange 角色，而且过程略有变化：\n\n- Publisher（生产者）：也就是要发送消息的程序，但是不再发送到队列中，而是发给 exchange \n- Exchange（交换机）：一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于 Exchange 的类型。Exchange 有以下 3 种类型：\n  - Fanout：广播，将消息交给所有绑定到交换机的队列\n  - Direct：定向，把消息交给符合指定 routing key 的队列\n  - Topic：通配符，把消息交给符合 routing pattern（路由模式） 的队列\n- Consumer：消费者，与以前一样，订阅队列，没有变化\n- Queue：消息队列也与以前一样，接收消息、缓存消息。\n\nExchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与 Exchange 绑定，或者没有符合路由规则的队列，那么消息会丢失！\n\n### Fanout Exchange\n\nFanout，英文翻译是扇出，在 MQ 中叫广播更合适。\n\n![Fanout](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Fanout.5ru00gaykjs0.svg)\n\n在广播模式下，消息发送流程是这样的：\n\n- 可以有多个队列\n- 每个队列都要绑定到 Exchange\n- 生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定\n- 交换机把消息发送给绑定过的所有队列\n- 订阅队列的消费者都能拿到消息\n\n利用 Spring AMQP 演示 Fanout Exchange 的使用，实现思路如下：\n\n1. 在 consumer 服务中，利用代码声明队列、交换机（halo.fanout），并将两者绑定\n2. 在 consumer 服务中，编写两个消费者方法，分别监听 fanout.queue1 和 fanout.queue2\n3. 在 publisher 中编写测试方法，向 halo.fanout 发送消息\n\n#### 声明队列和交换机\n\nSpring 提供了一个接口 Exchange，来表示所有不同类型的交换机：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.1jmh85mmwahs.png)\n\n在 consumer 中创建一个类，声明 Exchange、Queue、Binding：\n\n```java\npackage cn.itcast.mq.config;\n\nimport org.springframework.amqp.core.Binding;\nimport org.springframework.amqp.core.BindingBuilder;\nimport org.springframework.amqp.core.FanoutExchange;\nimport org.springframework.amqp.core.Queue;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class FanoutConfig {\n    /**\n     * 声明交换机\n     *\n     * @return Fanout类型交换机\n     */\n    @Bean\n    public FanoutExchange fanoutExchange() {\n        return new FanoutExchange(\"halo.fanout\");\n    }\n\n    /**\n     * 第1个队列\n     */\n    @Bean\n    public Queue fanoutQueue1() {\n        return new Queue(\"fanout.queue1\");\n    }\n\n    /**\n     * 绑定队列和交换机\n     */\n    @Bean\n    public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange) {\n        return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);\n    }\n\n    /**\n     * 第2个队列\n     */\n    @Bean\n    public Queue fanoutQueue2() {\n        return new Queue(\"fanout.queue2\");\n    }\n\n    /**\n     * 绑定队列和交换机\n     */\n    @Bean\n    public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange) {\n        return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);\n    }\n}\n```\n\n#### 消息发送\n\n在 publisher 服务的 SpringAmqpTest 类中添加测试方法：\n\n```java\n@Test\npublic void testFanoutExchange() {\n    // 队列名称\n    String exchangeName = \"halo.fanout\";\n    // 消息\n    String message = \"hello, everyone!\";\n    // 发送\n    rabbitTemplate.convertAndSend(exchangeName, \"\", message);\n}\n```\n\n#### 消息接收\n\n在 consumer 服务的 `SpringRabbitListener` 中添加两个方法，作为消费者：\n\n```java\n@RabbitListener(queues = \"fanout.queue1\")\npublic void listenFanoutQueue1(String msg) {\n    System.out.println(\"消费者-[1]-接收到Fanout消息：【\" + msg + \"】\");\n}\n\n@RabbitListener(queues = \"fanout.queue2\")\npublic void listenFanoutQueue2(String msg) {\n    System.err.println(\"消费者-[2]-接收到Fanout消息：【\" + msg + \"】\");\n}\n```\n\n#### Fanout Exchange 小结\n\n交换机的作用是什么？\n\n- 接收 publisher 发送的消息\n- 将消息按照规则路由到与之绑定的队列\n- 不能缓存消息，路由失败，消息丢失\n- Fanout Exchange 的会将消息路由到每个绑定的队列\n\n声明队列、交换机、绑定关系的 Bean 是什么？\n\n- Queue\n- Fanout Exchange\n- Binding\n\n### Direct Exchange\n\n在 Fanout 模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到 Direct 类型的 Exchange。\n\n![DirectExchange](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/DirectExchange.1xsf8z6diw00.svg)\n\nDirect Exchange 会将接收到的消息根据规则路由到指定的 Queue，因此称为路由模式（routes）。\n\n+ 每一个 Queue 都与 Exchange 设置一个 BindingKey\n+ 发布者发送消息时，指定消息的 RoutingKey\n+ Exchange 将消息路由到 BindingKey 与消息 RoutingKey 一致的队列\n\n案例需求如下：\n\n+ 利用 `@RabbitListener` 声明 Exchange、Queue、RoutingKey\n+ 在 consumer 服务中，编写两个消费者方法，分别监听 direct.queue1 和 direct.queue2\n+ 在 publisher 中编写测试方法，向 halo.direct发送消息\n\n#### 消息发送\n\n在 publisher 服务的 SpringAmqpTest 类中添加测试方法：\n\n```java\n@Test\npublic void testSendDirectExchange() {\n    // 交换机名称\n    String exchangeName = \"halo.direct\";\n    // 发送消息\n    rabbitTemplate.convertAndSend(exchangeName, \"red\", \"halo-direct-red\");\n    rabbitTemplate.convertAndSend(exchangeName, \"yellow\", \"halo-direct-yellow\");\n    rabbitTemplate.convertAndSend(exchangeName, \"blue\", \"halo-direct-blue\");\n}\n```\n\n#### 基于注解声明队列和交换机\n\n基于 `@Bean` 的方式声明队列和交换机比较麻烦，Spring 还提供了基于注解方式来声明。\n\n在 consumer 的 SpringRabbitListener 中添加两个消费者，同时基于注解来声明队列和交换机：\n\n```java\n@RabbitListener(bindings = @QueueBinding(\n    value = @Queue(name = \"direct.queue1\"),\n    exchange = @Exchange(name = \"halo.direct\", type = ExchangeTypes.DIRECT),\n    key = {\"red\", \"blue\"}\n))\npublic void listenDirectQueue1(String msg) {\n    System.out.println(\"消费者接收到direct.queue1的消息：【\" + msg + \"】\");\n}\n\n@RabbitListener(bindings = @QueueBinding(\n    value = @Queue(name = \"direct.queue2\"),\n    exchange = @Exchange(name = \"halo.direct\", type = ExchangeTypes.DIRECT),\n    key = {\"red\", \"yellow\"}\n))\npublic void listenDirectQueue2(String msg) {\n    System.out.println(\"消费者接收到direct.queue2的消息：【\" + msg + \"】\");\n}\n```\n\n#### Direct Exchange 小结\n\n描述下 Direct 交换机与 Fanout 交换机的差异？\n\n- Fanout 交换机将消息路由给每一个与之绑定的队列\n- Direct 交换机根据 Routing Key 判断路由给哪个队列\n- 如果多个队列具有相同的 Routing Key，则与 Fanout 功能类似\n\n基于 `@RabbitListener` 注解声明队列和交换机有哪些常见注解？\n\n- `@Queue`\n- `@Exchange`\n\n### Topic Exchange \n\nTopic 类型的 Exchange 与 Direct 相比，都是可以根据 Routing Key 把消息路由到不同的队列。\n\n只不过 Topic 类型 Exchange 可以让队列在绑定 Routing key 的时候使用通配符！\n\nRouting Key 一般都是有一个或多个单词组成，多个单词之间以 `.` 分割，例如：item.insert\n\n 通配符规则：\n\n`#`：匹配一个或多个词\n\n`*`：匹配不多不少恰好 1 个词\n\n举例：\n\n`item.#`：能够匹配 `item.spu.insert` 或者 `item.spu`\n\n`item.*`：只能匹配 `item.spu`\n\n![Topic](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Topic.60w0j0blgsw0.svg)\n\n- Queue1：绑定的是 `china.#` ，因此凡是以 `china.` 开头的 Routing Key 都会被匹配到。包括`china.news` 和 `china.weather`\n- Queue2：绑定的是 `#.news` ，因此凡是以 `.news` 结尾的 Routing Key 都会被匹配。包括 `china.news` 和 `japan.news`\n- 其他队列同理\n\n实现思路如下：\n\n1. 利用 `@RabbitListener` 声明 Exchange、Queue、RoutingKey\n\n2. 在 consumer 服务中，编写两个消费者方法，分别监听 topic.queue1 和 topic.queue2\n\n3. 在 publisher 中编写测试方法，向 halo. topic发送消息\n\n#### 消息发送\n\n在 publisher 服务的 SpringAmqpTest 类中添加测试方法：\n\n```java\n@Test\npublic void testSendTopicExchange() {\n    // 交换机名称\n    String exchangeName = \"itcast.topic\";\n    // 消息\n    String message = \"喜报！孙悟空大战哥斯拉，胜!\";\n    // 发送消息\n    rabbitTemplate.convertAndSend(exchangeName, \"china.news\", message);\n}\n```\n\n#### 消息接收\n\n在 consumer 服务的 SpringRabbitListener 中添加方法：\n\n```java\n@RabbitListener(bindings = @QueueBinding(\n    value = @Queue(name = \"topic.queue1\"),\n    exchange = @Exchange(name = \"halo.topic\", type = ExchangeTypes.TOPIC),\n    key = \"china.#\"\n))\npublic void listenTopicQueue1(String msg){\n    System.out.println(\"消费者接收到topic.queue1的消息：【\" + msg + \"】\");\n}\n\n@RabbitListener(bindings = @QueueBinding(\n    value = @Queue(name = \"topic.queue2\"),\n    exchange = @Exchange(name = \"halo.topic\", type = ExchangeTypes.TOPIC),\n    key = \"#.news\"\n))\npublic void listenTopicQueue2(String msg){\n    System.out.println(\"消费者接收到topic.queue2的消息：【\" + msg + \"】\");\n}\n```\n\n### 消息转换器\n\n之前说过，Spring 会把你发送的消息序列化为字节发送给 MQ，接收消息的时候，还会把字节反序列化为 Java 对象。\n\n只不过，默认情况下 Spring 采用的序列化方式是 JDK 序列化。众所周知，JDK 序列化存在下列问题：\n\n- 数据体积过大\n- 有安全漏洞\n- 可读性差\n\n#### 测试默认转换器\n\n我们修改消息发送的代码，发送一个 Map 对象：\n\n```java\n@Test\npublic void testSendMap() {\n    // 队列名称\n    String queueName = \"object.queue\";\n    // 准备消息\n    Map<String, Object> msg = new HashMap<>();\n    msg.put(\"name\", \"Jack\");\n    msg.put(\"age\", 21);\n    // 发送消息\n    rabbitTemplate.convertAndSend(queueName, msg);\n}\n```\n\n发送消息后查看控制台：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2jjb6wxbs120.png)\n\nSpring 的对消息对象的处理是由 `org.springframework.amqp.support.converter.MessageConverter` 来处理的。而默认实现是 `SimpleMessageConverter`，基于 JDK 的 `ObjectOutputStream` 完成序列化。\n\n#### 配置 JSON 转换器\n\n显然，JDK 序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用 JSON 方式来做序列化和反序列化。如果要修改只需要定义一个 `MessageConverter` 类型的Bean即可，步骤如下：\n\n在 publisher 和 consumer 两个服务中都引入依赖：\n\n```xml\n<dependency>\n    <groupId>com.fasterxml.jackson.core</groupId>\n    <artifactId>jackson-databind</artifactId>\n</dependency>\n```\n\n配置消息转换器。\n\n在启动类中添加一个 Bean 即可：\n\n```java\n@Bean\npublic MessageConverter jsonMessageConverter(){\n    return new Jackson2JsonMessageConverter();\n}\n```\n\n\n\n\n\n\n\n', '2021-09-23 19:11:31', 1, 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/macos.6z1mshl4twk0.svg', 19, '2021-10-14 11:17:39', NULL, NULL, NULL, 1, 1, 0, NULL, 0, '<h2 id=\"初识-rabbitmq\">初识 RabbitMQ</h2>\n<h3 id=\"同步和异步通讯\">同步和异步通讯</h3>\n<p>微服务间通讯有同步和异步两种方式：</p>\n<ul>\n<li>同步通讯：就像打电话，需要实时响应。</li>\n<li>异步通讯：就像发邮件，不需要马上回复。</li>\n</ul>\n<h4 id=\"同步通讯\">同步通讯</h4>\n<p>我们之前学习的 Feign 调用就属于同步方式，虽然调用可以实时得到结果，但存在下面的问题：</p>\n<ul>\n<li>耦合度高：每次加入新的需求，都要修改原来的代码</li>\n<li>性能下降：调用者需要等待服务提供者响应，如果调用链过长则响应时间等于每次调用的时间之和。</li>\n<li>资源浪费：调用链中的每个服务在等待响应过程中，不能释放请求占用的资源，高并发场景下会极度浪费系统资源</li>\n<li>级联失败：如果服务提供者出现问题，所有调用方都会跟着出问题，如同多米诺骨牌一样，迅速导致整个微服务群故障</li>\n</ul>\n<h4 id=\"异步通讯\">异步通讯</h4>\n<p>异步调用则可以避免上述问题：</p>\n<p>我们以购买商品为例，用户支付后需要调用订单服务完成订单状态修改，调用物流服务，从仓库分配响应的库存并准备发货。</p>\n<ul>\n<li>在事件模式中，支付服务是事件发布者（publisher），在支付完成后只需要发布一个支付成功的事件（event），事件中带上订单 id。</li>\n<li>订单服务和物流服务是事件订阅者（Consumer），订阅支付成功的事件，监听到事件后完成自己业务即可。</li>\n<li>为了解除事件发布者与订阅者之间的耦合，两者并不是直接通信，而是有一个中间人（Broker）。发布者发布事件到 Broker，不关心谁来订阅事件。订阅者从 Broker 订阅事件，不关心谁发来的消息。</li>\n</ul>\n<p>Broker 是一个像数据总线一样的东西，所有的服务要接收数据和发送数据都发到这个总线上，这个总线就像协议一样，让服务间的通讯变得标准和可控。</p>\n<p>异步通讯的优点：</p>\n<ul>\n<li><p>吞吐量提升：无需等待订阅者处理完成，响应更快速</p>\n</li>\n<li><p>故障隔离：服务没有直接调用，不存在级联失败问题</p>\n</li>\n<li><p>调用间没有阻塞，不会造成无效的资源占用</p>\n</li>\n<li><p>耦合度极低，每个服务都可以灵活插拔，可替换</p>\n</li>\n<li><p>流量削峰：不管发布事件的流量波动多大，都由 Broker 接收，订阅者可以按照自己的速度去处理事件</p>\n</li>\n</ul>\n<p>异步通讯的缺点：</p>\n<ul>\n<li>架构复杂了，业务没有明显的流程线，不好管理</li>\n<li>需要依赖于 Broker 的可靠、安全、性能</li>\n</ul>\n<h3 id=\"技术对比\">技术对比</h3>\n<p>MQ，中文是消息队列（Message Queue），字面来看就是存放消息的队列。也就是事件驱动架构中的 Broker。</p>\n<p>比较常见的MQ实现：</p>\n<ul>\n<li>ActiveMQ</li>\n<li>RabbitMQ</li>\n<li>RocketMQ</li>\n<li>Kafka</li>\n</ul>\n<p>几种常见 MQ 的对比：</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>RabbitMQ</th>\n<th>ActiveMQ</th>\n<th>RocketMQ</th>\n<th>Kafka</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>公司/社区</td>\n<td>Rabbit</td>\n<td>Apache</td>\n<td>阿里</td>\n<td>Apache</td>\n</tr>\n<tr>\n<td>开发语言</td>\n<td>Erlang</td>\n<td>Java</td>\n<td>Java</td>\n<td>Scala &amp; Java</td>\n</tr>\n<tr>\n<td>协议支持</td>\n<td>AMQP，XMPP，SMTP，STOMP</td>\n<td>OpenWire，STOMP，REST，XMPP，AMQP</td>\n<td>自定义协议</td>\n<td>自定义协议</td>\n</tr>\n<tr>\n<td>可用性</td>\n<td>高</td>\n<td>一般</td>\n<td>高</td>\n<td>高</td>\n</tr>\n<tr>\n<td>单机吞吐量</td>\n<td>一般</td>\n<td>差</td>\n<td>高</td>\n<td>非常高</td>\n</tr>\n<tr>\n<td>消息延迟</td>\n<td>微秒级</td>\n<td>毫秒级</td>\n<td>毫秒级</td>\n<td>毫秒以内</td>\n</tr>\n<tr>\n<td>消息可靠性</td>\n<td>高</td>\n<td>一般</td>\n<td>高</td>\n<td>一般</td>\n</tr>\n</tbody></table>\n<p>追求可用性：Kafka、 RocketMQ 、RabbitMQ</p>\n<p>追求可靠性：RabbitMQ、RocketMQ</p>\n<p>追求吞吐能力：RocketMQ、Kafka</p>\n<p>追求消息低延迟：RabbitMQ、Kafka</p>\n<h2 id=\"rabbitmq-快速入门\">RabbitMQ 快速入门</h2>\n<p>RabbitMQ 是基于 Erlang 语言开发的开源消息通信中间件，官网地址：<a href=\"https://www.rabbitmq.com/\">https://www.rabbitmq.com/</a></p>\n<h3 id=\"安装-rabbitmq\">安装 RabbitMQ</h3>\n<p>在 Centos 7 虚拟机中使用 Docker 来安装</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-attribute\">docker</span> pull rabbitmq:<span class=\"hljs-number\">3</span>-management\n</code></pre>\n<p>执行下面的命令来运行 MQ 容器：</p>\n<pre><code>docker run <span class=\"hljs-string\">\\</span>\n -e RABBITMQ_DEFAULT_USER=halo <span class=\"hljs-string\">\\</span>\n -e RABBITMQ_DEFAULT_PASS=halo <span class=\"hljs-string\">\\</span>\n --name halo-rabbitmq-<span class=\"hljs-number\">1</span> <span class=\"hljs-string\">\\</span>\n --hostname halo-rabbitmq-<span class=\"hljs-number\">1</span> <span class=\"hljs-string\">\\</span>\n -p <span class=\"hljs-number\">15672</span>:<span class=\"hljs-number\">15672</span> <span class=\"hljs-string\">\\</span>\n -p <span class=\"hljs-number\">5672</span>:<span class=\"hljs-number\">5672</span> <span class=\"hljs-string\">\\</span>\n -d <span class=\"hljs-string\">\\</span>\n rabbitmq:<span class=\"hljs-number\">3</span>-management\n</code></pre>\n<h3 id=\"rabbitmq-的基本结构\">RabbitMQ 的基本结构</h3>\n<p>RabbitMQ 的基本结构：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/RabbitMQ%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E6%A6%82%E5%BF%B5.5365ey5rjww0.svg\" alt=\"RabbitMQ的结构和概念\"></p>\n<p>RabbitMQ 中的一些角色：</p>\n<ul>\n<li>publisher：生产者</li>\n<li>consumer：消费者</li>\n<li>exchange：交换机，负责消息路由</li>\n<li>queue：队列，存储消息</li>\n<li>virtualHost：虚拟主机，隔离不同租户的 exchange、queue、消息的隔离</li>\n</ul>\n<h3 id=\"rabbitmq-消息模型\">RabbitMQ 消息模型</h3>\n<p><a href=\"https://www.rabbitmq.com/getstarted.html\">RabbitMQ 官方</a> 提供了 5 个不同的 Demo 示例，对应了不同的消息模型：</p>\n<ul>\n<li>基本消息队列（Basic Queue）</li>\n<li>工作消息队列（Work Queue）</li>\n<li>发布订阅（Publish、Subscribe），又根据交换机类型不同分为三种：<ul>\n<li>Fanout Exchange：广播</li>\n<li>Direct Exchange：路由</li>\n<li>Topic Exchange：主题</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/RabbitMQ%E6%B6%88%E6%81%AF%E6%A8%A1%E5%9E%8B.1fiomitimbsw.png\" alt=\"RabbitMQ消息模型\"></p>\n<h3 id=\"hello-world-案例\">Hello World 案例</h3>\n<p>官方的 HelloWorld 是基于最基础的消息队列模型来实现的，只包括三个角色：</p>\n<p>•publisher：消息发布者，将消息发送到队列 queue</p>\n<p>•queue：消息队列，负责接受并缓存消息</p>\n<p>•consumer：订阅队列，处理队列中的消息</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/HelloWorld%E6%A1%88%E4%BE%8B.zb6pinalxzk.svg\" alt=\"HelloWorld案例\"></p>\n<p>publisher 实现思路：</p>\n<ul>\n<li>建立连接</li>\n<li>创建 Channel</li>\n<li>声明队列</li>\n<li>发送消息</li>\n<li>关闭连接和 Channel</li>\n</ul>\n<p>代码实现：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">package</span> cn.itcast.mq.helloworld;\n\n<span class=\"hljs-keyword\">import</span> com.rabbitmq.client.Channel;\n<span class=\"hljs-keyword\">import</span> com.rabbitmq.client.Connection;\n<span class=\"hljs-keyword\">import</span> com.rabbitmq.client.ConnectionFactory;\n<span class=\"hljs-keyword\">import</span> org.junit.Test;\n\n<span class=\"hljs-keyword\">import</span> java.io.IOException;\n<span class=\"hljs-keyword\">import</span> java.util.concurrent.TimeoutException;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PublisherTest</span> {\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testSendMessage</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException, TimeoutException {\n        <span class=\"hljs-comment\">// 1.建立连接</span>\n        <span class=\"hljs-type\">ConnectionFactory</span> <span class=\"hljs-variable\">factory</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConnectionFactory</span>();\n        <span class=\"hljs-comment\">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span>\n        factory.setHost(<span class=\"hljs-string\">&quot;halo&quot;</span>);\n        factory.setPort(<span class=\"hljs-number\">5672</span>);\n        factory.setVirtualHost(<span class=\"hljs-string\">&quot;/&quot;</span>);\n        factory.setUsername(<span class=\"hljs-string\">&quot;halo&quot;</span>);\n        factory.setPassword(<span class=\"hljs-string\">&quot;halo&quot;</span>);\n        <span class=\"hljs-comment\">// 1.2.建立连接</span>\n        <span class=\"hljs-type\">Connection</span> <span class=\"hljs-variable\">connection</span> <span class=\"hljs-operator\">=</span> factory.newConnection();\n\n        <span class=\"hljs-comment\">// 2.创建通道Channel</span>\n        <span class=\"hljs-type\">Channel</span> <span class=\"hljs-variable\">channel</span> <span class=\"hljs-operator\">=</span> connection.createChannel();\n\n        <span class=\"hljs-comment\">// 3.创建队列</span>\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">queueName</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;simple.queue&quot;</span>;\n        channel.queueDeclare(queueName, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">null</span>);\n\n        <span class=\"hljs-comment\">// 4.发送消息</span>\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">message</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;hello, rabbitmq!&quot;</span>;\n        channel.basicPublish(<span class=\"hljs-string\">&quot;&quot;</span>, queueName, <span class=\"hljs-literal\">null</span>, message.getBytes());\n        System.out.println(<span class=\"hljs-string\">&quot;发送消息成功：【&quot;</span> + message + <span class=\"hljs-string\">&quot;】&quot;</span>);\n\n        <span class=\"hljs-comment\">// 5.关闭通道和连接</span>\n        channel.close();\n        connection.close();\n\n    }\n}\n</code></pre>\n<p>consumer 实现思路：</p>\n<ul>\n<li>建立连接</li>\n<li>创建 Channel</li>\n<li>声明队列</li>\n<li>订阅消息</li>\n</ul>\n<p>代码实现：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">package</span> cn.itcast.mq.helloworld;\n\n<span class=\"hljs-keyword\">import</span> com.rabbitmq.client.*;\n\n<span class=\"hljs-keyword\">import</span> java.io.IOException;\n<span class=\"hljs-keyword\">import</span> java.util.concurrent.TimeoutException;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ConsumerTest</span> {\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> <span class=\"hljs-keyword\">throws</span> IOException, TimeoutException {\n        <span class=\"hljs-comment\">// 1.建立连接</span>\n        <span class=\"hljs-type\">ConnectionFactory</span> <span class=\"hljs-variable\">factory</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ConnectionFactory</span>();\n        <span class=\"hljs-comment\">// 1.1.设置连接参数，分别是：主机名、端口号、vhost、用户名、密码</span>\n        factory.setHost(<span class=\"hljs-string\">&quot;halo&quot;</span>);\n        factory.setPort(<span class=\"hljs-number\">5672</span>);\n        factory.setVirtualHost(<span class=\"hljs-string\">&quot;/&quot;</span>);\n        factory.setUsername(<span class=\"hljs-string\">&quot;halo&quot;</span>);\n        factory.setPassword(<span class=\"hljs-string\">&quot;halo&quot;</span>);\n        <span class=\"hljs-comment\">// 1.2.建立连接</span>\n        <span class=\"hljs-type\">Connection</span> <span class=\"hljs-variable\">connection</span> <span class=\"hljs-operator\">=</span> factory.newConnection();\n\n        <span class=\"hljs-comment\">// 2.创建通道Channel</span>\n        <span class=\"hljs-type\">Channel</span> <span class=\"hljs-variable\">channel</span> <span class=\"hljs-operator\">=</span> connection.createChannel();\n\n        <span class=\"hljs-comment\">// 3.创建队列</span>\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">queueName</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;simple.queue&quot;</span>;\n        channel.queueDeclare(queueName, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">false</span>, <span class=\"hljs-literal\">null</span>);\n\n        <span class=\"hljs-comment\">// 4.订阅消息</span>\n        channel.basicConsume(queueName, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DefaultConsumer</span>(channel) {\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">handleDelivery</span><span class=\"hljs-params\">(String consumerTag, Envelope envelope,\n                                       AMQP.BasicProperties properties, <span class=\"hljs-type\">byte</span>[] body)</span> <span class=\"hljs-keyword\">throws</span> IOException {\n                <span class=\"hljs-comment\">// 5.处理消息</span>\n                <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">message</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>(body);\n                System.out.println(<span class=\"hljs-string\">&quot;接收到消息：【&quot;</span> + message + <span class=\"hljs-string\">&quot;】&quot;</span>);\n            }\n        });\n        System.out.println(<span class=\"hljs-string\">&quot;等待接收消息。。。。&quot;</span>);\n    }\n}\n</code></pre>\n<p>基本消息队列的消息发送流程：</p>\n<ol>\n<li><p>建立 connection</p>\n</li>\n<li><p>创建 channel</p>\n</li>\n<li><p>利用 channel 声明队列</p>\n</li>\n<li><p>利用 channel 向队列发送消息</p>\n</li>\n</ol>\n<p>基本消息队列的消息接收流程：</p>\n<ol>\n<li><p>建立 connection</p>\n</li>\n<li><p>创建 channel</p>\n</li>\n<li><p>利用 channel 声明队列</p>\n</li>\n<li><p>定义 consumer 的消费行为 <code>handleDelivery()</code></p>\n</li>\n<li><p>利用 channel 将消费者与队列绑定</p>\n</li>\n</ol>\n<h2 id=\"spring-amqp\">Spring AMQP</h2>\n<p>Spring AMQP 是基于 RabbitMQ 封装的一套模板，并且还利用 Spring Boot 对其实现了自动装配，使用起来非常方便。</p>\n<p>Spring AMQP 的官方地址：<a href=\"https://spring.io/projects/spring-amqp\">https://spring.io/projects/spring-amqp</a></p>\n<p>AMQP ：Advanced Message Queuing Protocol，是用于在应用程序之间传递业务消息的开放标准。该协议与语言和平台无关，更符合微服务中独立性的要求。</p>\n<p>Spring AMQP ：Spring AMQP 是基于 AMQP 协议定义的一套 API 规范，提供了模板来发送和接收消息。包含两部分，其中 spring-amqp 是基础抽象，spring-rabbit 是底层的默认实现。</p>\n<p>Spring AMQP 提供了三个功能：</p>\n<ul>\n<li>自动声明队列、交换机及其绑定关系</li>\n<li>基于注解的监听器模式，异步接收消息</li>\n<li>封装了 RabbitTemplate 工具，用于发送消息 </li>\n</ul>\n<h3 id=\"basic-queue-基本消息队列\">Basic Queue 基本消息队列</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/HelloWorld%E6%A1%88%E4%BE%8B.zb6pinalxzk.svg\" alt=\"HelloWorld案例\"></p>\n<p>流程如下：</p>\n<ul>\n<li>在父工程中引入 spring-amqp 的依赖</li>\n<li>在 publisher 服务中利用 RabbitTemplate 发送消息到 simple.queue 这个队列</li>\n<li>在 consumer 服务中编写消费逻辑，绑定 simple.queue 这个队列</li>\n</ul>\n<h4 id=\"引入依赖\">引入依赖</h4>\n<p>在父工程 mq-demo 中引入依赖</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-comment\">&lt;!--AMQP依赖，包含RabbitMQ--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<h4 id=\"消息发送\">消息发送</h4>\n<p>首先配置 RabbitMQ 地址，在 publisher 服务的 application.yml 中添加配置：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">rabbitmq:</span>\n    <span class=\"hljs-attr\">host:</span> <span class=\"hljs-string\">halo</span> <span class=\"hljs-comment\"># 主机名</span>\n    <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">5672</span> <span class=\"hljs-comment\"># 端口</span>\n    <span class=\"hljs-attr\">virtual-host:</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-comment\"># 虚拟主机</span>\n    <span class=\"hljs-attr\">username:</span> <span class=\"hljs-string\">halo</span> <span class=\"hljs-comment\"># 用户名</span>\n    <span class=\"hljs-attr\">password:</span> <span class=\"hljs-string\">halo</span> <span class=\"hljs-comment\"># 密码</span>\n</code></pre>\n<p>然后在 publisher 服务中编写测试类 <code>SpringAmqpTest</code>，并利用 RabbitTemplate 实现消息发送：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">package</span> cn.itcast.mq.spring;\n\n<span class=\"hljs-keyword\">import</span> org.junit.Test;\n<span class=\"hljs-keyword\">import</span> org.junit.runner.RunWith;\n<span class=\"hljs-keyword\">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;\n<span class=\"hljs-keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.test.context.SpringBootTest;\n<span class=\"hljs-keyword\">import</span> org.springframework.test.context.junit4.SpringRunner;\n\n<span class=\"hljs-meta\">@RunWith(SpringRunner.class)</span>\n<span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SpringAmqpTest</span> {\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> RabbitTemplate rabbitTemplate;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testSimpleQueue</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-comment\">// 队列名称</span>\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">queueName</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;simple.queue&quot;</span>;\n        <span class=\"hljs-comment\">// 消息</span>\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">message</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;hello, spring amqp!&quot;</span>;\n        <span class=\"hljs-comment\">// 发送消息</span>\n        rabbitTemplate.convertAndSend(queueName, message);\n    }\n}\n</code></pre>\n<h4 id=\"消息接收\">消息接收</h4>\n<p>首先配置 RabbitMQ 地址，在 consumer 服务的 application.yml 中添加配置：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">rabbitmq:</span>\n    <span class=\"hljs-attr\">host:</span> <span class=\"hljs-string\">halo</span> <span class=\"hljs-comment\"># 主机名</span>\n    <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">5672</span> <span class=\"hljs-comment\"># 端口</span>\n    <span class=\"hljs-attr\">virtual-host:</span> <span class=\"hljs-string\">/</span> <span class=\"hljs-comment\"># 虚拟主机</span>\n    <span class=\"hljs-attr\">username:</span> <span class=\"hljs-string\">halo</span> <span class=\"hljs-comment\"># 用户名</span>\n    <span class=\"hljs-attr\">password:</span> <span class=\"hljs-string\">halo</span> <span class=\"hljs-comment\"># 密码</span>\n</code></pre>\n<p>然后在 consumer 服务的 <code>cn.itcast.mq.listener</code> 包中新建一个类 <code>SpringRabbitListener</code>，代码如下：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">package</span> cn.itcast.mq.listener;\n\n<span class=\"hljs-keyword\">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Component;\n\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SpringRabbitListener</span> </span>{\n\n    <span class=\"hljs-meta\">@RabbitListener</span>(queues = <span class=\"hljs-string\">&quot;simple.queue&quot;</span>)\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">listenSimpleQueueMessage</span><span class=\"hljs-params\">(String msg)</span> <span class=\"hljs-keyword\">throws</span> InterruptedException </span>{\n        System.out.println(<span class=\"hljs-string\">&quot;spring 消费者接收到消息：【&quot;</span> + msg + <span class=\"hljs-string\">&quot;】&quot;</span>);\n    }\n}\n</code></pre>\n<p>注意：消息一旦消费就会从队列删除，RabbitMQ 没有消息回溯功能</p>\n<h3 id=\"work-queue-工作队列\">Work Queue 工作队列</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/WorkQueue%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97.3xixqzsmydc0.svg\" alt=\"WorkQueue工作队列\"></p>\n<p>Work Queue，也被称为（Task queues），任务模型。简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。</p>\n<p>当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。</p>\n<p>此时就可以使用 work 模型，多个消费者共同处理消息处理，速度就能大大提高了。</p>\n<p>基本思路如下：</p>\n<ol>\n<li>在 publisher 服务中定义测试方法，每秒产生 50 条消息，发送到 simple.queue</li>\n<li>在 consumer 服务中定义两个消息监听者，都监听 simple.queue 队列</li>\n<li>消费者 1 每秒处理 50 条消息，消费者 2 每秒处理 10 条消息</li>\n</ol>\n<h4 id=\"消息发送-1\">消息发送</h4>\n<p>这次我们循环发送，模拟大量消息堆积现象。</p>\n<p>在 publisher 服务中的 SpringAmqpTest 类中添加一个测试方法：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testWorkQueue</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> InterruptedException {\n    <span class=\"hljs-comment\">// 队列名称</span>\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">queueName</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;simple.queue&quot;</span>;\n    <span class=\"hljs-comment\">// 消息</span>\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">message</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;hello, message_&quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">50</span>; i++) {\n        <span class=\"hljs-comment\">// 发送消息</span>\n        rabbitTemplate.convertAndSend(queueName, message + i);\n        Thread.sleep(<span class=\"hljs-number\">20</span>);\n    }\n}\n</code></pre>\n<h4 id=\"消息接收-1\">消息接收</h4>\n<p>要模拟多个消费者绑定同一个队列，我们在 consumer 服务的 <code>SpringRabbitListener</code> 中添加 2 个新的方法：</p>\n<pre><code class=\"hljs language-java\">@<span class=\"hljs-constructor\">RabbitListener(<span class=\"hljs-params\">queues</span> = <span class=\"hljs-string\">&quot;simple.queue&quot;</span>)</span>\npublic void listen<span class=\"hljs-constructor\">WorkQueue1(String <span class=\"hljs-params\">msg</span>)</span> throws InterruptedException {\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;消费者-[1]-接收到消息：【&quot;</span> + msg + <span class=\"hljs-string\">&quot;】&quot;</span> + <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">LocalTime</span>.</span></span>now<span class=\"hljs-literal\">()</span>);\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Thread</span>.</span></span>sleep(<span class=\"hljs-number\">20</span>);\n}\n\n@<span class=\"hljs-constructor\">RabbitListener(<span class=\"hljs-params\">queues</span> = <span class=\"hljs-string\">&quot;simple.queue&quot;</span>)</span>\npublic void listen<span class=\"hljs-constructor\">WorkQueue2(String <span class=\"hljs-params\">msg</span>)</span> throws InterruptedException {\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>err.println(<span class=\"hljs-string\">&quot;消费者-[2]-接收到消息：【&quot;</span> + msg + <span class=\"hljs-string\">&quot;】&quot;</span> + <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">LocalTime</span>.</span></span>now<span class=\"hljs-literal\">()</span>);\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Thread</span>.</span></span>sleep(<span class=\"hljs-number\">200</span>);\n}\n</code></pre>\n<h4 id=\"测试分析\">测试分析</h4>\n<p>启动 <code>ConsumerApplication</code> 后，在执行 publisher 服务中刚刚编写的发送测试方法 <code>testWorkQueue</code>。</p>\n<p>可以看到消费者 1 很快完成了自己的 25 条消息。消费者 2 却在缓慢的处理自己的 25 条消息。</p>\n<p>也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。</p>\n<h4 id=\"能者多劳\">能者多劳</h4>\n<p>在 spring 中有一个简单的配置，可以解决这个问题。我们修改 consumer 服务的 application.yml 文件，添加配置：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-symbol\">spring:</span>\n<span class=\"hljs-symbol\">  rabbitmq:</span>\n<span class=\"hljs-symbol\">    listener:</span>\n<span class=\"hljs-symbol\">      simple:</span>\n<span class=\"hljs-symbol\">        prefetch:</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-meta\"># 每次只能获取一条消息，处理完成才能获取下一个消息</span>\n</code></pre>\n<p>设置 <code>preFetch</code> 这个值，可以控制预取消息的上限：</p>\n<h3 id=\"发布与订阅\">发布与订阅</h3>\n<p>发布订阅的模型如图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F.g64vagn8am0.svg\" alt=\"发布订阅模式\"></p>\n<p>可以看到，在订阅模型中，多了一个 exchange 角色，而且过程略有变化：</p>\n<ul>\n<li>Publisher（生产者）：也就是要发送消息的程序，但是不再发送到队列中，而是发给 exchange </li>\n<li>Exchange（交换机）：一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于 Exchange 的类型。Exchange 有以下 3 种类型：<ul>\n<li>Fanout：广播，将消息交给所有绑定到交换机的队列</li>\n<li>Direct：定向，把消息交给符合指定 routing key 的队列</li>\n<li>Topic：通配符，把消息交给符合 routing pattern（路由模式） 的队列</li>\n</ul>\n</li>\n<li>Consumer：消费者，与以前一样，订阅队列，没有变化</li>\n<li>Queue：消息队列也与以前一样，接收消息、缓存消息。</li>\n</ul>\n<p>Exchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与 Exchange 绑定，或者没有符合路由规则的队列，那么消息会丢失！</p>\n<h3 id=\"fanout-exchange\">Fanout Exchange</h3>\n<p>Fanout，英文翻译是扇出，在 MQ 中叫广播更合适。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Fanout.5ru00gaykjs0.svg\" alt=\"Fanout\"></p>\n<p>在广播模式下，消息发送流程是这样的：</p>\n<ul>\n<li>可以有多个队列</li>\n<li>每个队列都要绑定到 Exchange</li>\n<li>生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定</li>\n<li>交换机把消息发送给绑定过的所有队列</li>\n<li>订阅队列的消费者都能拿到消息</li>\n</ul>\n<p>利用 Spring AMQP 演示 Fanout Exchange 的使用，实现思路如下：</p>\n<ol>\n<li>在 consumer 服务中，利用代码声明队列、交换机（halo.fanout），并将两者绑定</li>\n<li>在 consumer 服务中，编写两个消费者方法，分别监听 fanout.queue1 和 fanout.queue2</li>\n<li>在 publisher 中编写测试方法，向 halo.fanout 发送消息</li>\n</ol>\n<h4 id=\"声明队列和交换机\">声明队列和交换机</h4>\n<p>Spring 提供了一个接口 Exchange，来表示所有不同类型的交换机：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.1jmh85mmwahs.png\" alt=\"image\"></p>\n<p>在 consumer 中创建一个类，声明 Exchange、Queue、Binding：</p>\n<pre><code class=\"hljs language-java\">package cn.<span class=\"hljs-property\">itcast</span>.<span class=\"hljs-property\">mq</span>.<span class=\"hljs-property\">config</span>;\n\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">springframework</span>.<span class=\"hljs-property\">amqp</span>.<span class=\"hljs-property\">core</span>.<span class=\"hljs-property\">Binding</span>;\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">springframework</span>.<span class=\"hljs-property\">amqp</span>.<span class=\"hljs-property\">core</span>.<span class=\"hljs-property\">BindingBuilder</span>;\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">springframework</span>.<span class=\"hljs-property\">amqp</span>.<span class=\"hljs-property\">core</span>.<span class=\"hljs-property\">FanoutExchange</span>;\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">springframework</span>.<span class=\"hljs-property\">amqp</span>.<span class=\"hljs-property\">core</span>.<span class=\"hljs-property\">Queue</span>;\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">springframework</span>.<span class=\"hljs-property\">context</span>.<span class=\"hljs-property\">annotation</span>.<span class=\"hljs-property\">Bean</span>;\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">springframework</span>.<span class=\"hljs-property\">context</span>.<span class=\"hljs-property\">annotation</span>.<span class=\"hljs-property\">Configuration</span>;\n\n<span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FanoutConfig</span> {\n    <span class=\"hljs-comment\">/**\n     * 声明交换机\n     *\n     * <span class=\"hljs-doctag\">@return</span> Fanout类型交换机\n     */</span>\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">FanoutExchange</span> <span class=\"hljs-title function_\">fanoutExchange</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">FanoutExchange</span>(<span class=\"hljs-string\">&quot;halo.fanout&quot;</span>);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 第1个队列\n     */</span>\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">Queue</span> <span class=\"hljs-title function_\">fanoutQueue1</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Queue</span>(<span class=\"hljs-string\">&quot;fanout.queue1&quot;</span>);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 绑定队列和交换机\n     */</span>\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">Binding</span> <span class=\"hljs-title function_\">bindingQueue1</span>(<span class=\"hljs-params\">Queue fanoutQueue1, FanoutExchange fanoutExchange</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">BindingBuilder</span>.<span class=\"hljs-title function_\">bind</span>(fanoutQueue1).<span class=\"hljs-title function_\">to</span>(fanoutExchange);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 第2个队列\n     */</span>\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">Queue</span> <span class=\"hljs-title function_\">fanoutQueue2</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Queue</span>(<span class=\"hljs-string\">&quot;fanout.queue2&quot;</span>);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 绑定队列和交换机\n     */</span>\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">Binding</span> <span class=\"hljs-title function_\">bindingQueue2</span>(<span class=\"hljs-params\">Queue fanoutQueue2, FanoutExchange fanoutExchange</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">BindingBuilder</span>.<span class=\"hljs-title function_\">bind</span>(fanoutQueue2).<span class=\"hljs-title function_\">to</span>(fanoutExchange);\n    }\n}\n</code></pre>\n<h4 id=\"消息发送-2\">消息发送</h4>\n<p>在 publisher 服务的 SpringAmqpTest 类中添加测试方法：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">testFanoutExchange</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// 队列名称</span>\n    <span class=\"hljs-title class_\">String</span> exchangeName = <span class=\"hljs-string\">&quot;halo.fanout&quot;</span>;\n    <span class=\"hljs-comment\">// 消息</span>\n    <span class=\"hljs-title class_\">String</span> message = <span class=\"hljs-string\">&quot;hello, everyone!&quot;</span>;\n    <span class=\"hljs-comment\">// 发送</span>\n    rabbitTemplate.<span class=\"hljs-title function_\">convertAndSend</span>(exchangeName, <span class=\"hljs-string\">&quot;&quot;</span>, message);\n}\n</code></pre>\n<h4 id=\"消息接收-2\">消息接收</h4>\n<p>在 consumer 服务的 <code>SpringRabbitListener</code> 中添加两个方法，作为消费者：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@RabbitListener</span>(queues = <span class=\"hljs-string\">&quot;fanout.queue1&quot;</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">listenFanoutQueue1</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span> msg</span>) {\n    <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;消费者-[1]-接收到Fanout消息：【&quot;</span> + msg + <span class=\"hljs-string\">&quot;】&quot;</span>);\n}\n\n<span class=\"hljs-meta\">@RabbitListener</span>(queues = <span class=\"hljs-string\">&quot;fanout.queue2&quot;</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">listenFanoutQueue2</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span> msg</span>) {\n    <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">err</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;消费者-[2]-接收到Fanout消息：【&quot;</span> + msg + <span class=\"hljs-string\">&quot;】&quot;</span>);\n}\n</code></pre>\n<h4 id=\"fanout-exchange-小结\">Fanout Exchange 小结</h4>\n<p>交换机的作用是什么？</p>\n<ul>\n<li>接收 publisher 发送的消息</li>\n<li>将消息按照规则路由到与之绑定的队列</li>\n<li>不能缓存消息，路由失败，消息丢失</li>\n<li>Fanout Exchange 的会将消息路由到每个绑定的队列</li>\n</ul>\n<p>声明队列、交换机、绑定关系的 Bean 是什么？</p>\n<ul>\n<li>Queue</li>\n<li>Fanout Exchange</li>\n<li>Binding</li>\n</ul>\n<h3 id=\"direct-exchange\">Direct Exchange</h3>\n<p>在 Fanout 模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到 Direct 类型的 Exchange。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/DirectExchange.1xsf8z6diw00.svg\" alt=\"DirectExchange\"></p>\n<p>Direct Exchange 会将接收到的消息根据规则路由到指定的 Queue，因此称为路由模式（routes）。</p>\n<ul>\n<li>每一个 Queue 都与 Exchange 设置一个 BindingKey</li>\n<li>发布者发送消息时，指定消息的 RoutingKey</li>\n<li>Exchange 将消息路由到 BindingKey 与消息 RoutingKey 一致的队列</li>\n</ul>\n<p>案例需求如下：</p>\n<ul>\n<li>利用 <code>@RabbitListener</code> 声明 Exchange、Queue、RoutingKey</li>\n<li>在 consumer 服务中，编写两个消费者方法，分别监听 direct.queue1 和 direct.queue2</li>\n<li>在 publisher 中编写测试方法，向 halo.direct发送消息</li>\n</ul>\n<h4 id=\"消息发送-3\">消息发送</h4>\n<p>在 publisher 服务的 SpringAmqpTest 类中添加测试方法：</p>\n<pre><code class=\"hljs language-java\">@Test\npublic void test<span class=\"hljs-constructor\">SendDirectExchange()</span> {\n    <span class=\"hljs-comment\">// 交换机名称</span>\n    String exchangeName = <span class=\"hljs-string\">&quot;halo.direct&quot;</span>;\n    <span class=\"hljs-comment\">// 发送消息</span>\n    rabbitTemplate.convert<span class=\"hljs-constructor\">AndSend(<span class=\"hljs-params\">exchangeName</span>, <span class=\"hljs-string\">&quot;red&quot;</span>, <span class=\"hljs-string\">&quot;halo-direct-red&quot;</span>)</span>;\n    rabbitTemplate.convert<span class=\"hljs-constructor\">AndSend(<span class=\"hljs-params\">exchangeName</span>, <span class=\"hljs-string\">&quot;yellow&quot;</span>, <span class=\"hljs-string\">&quot;halo-direct-yellow&quot;</span>)</span>;\n    rabbitTemplate.convert<span class=\"hljs-constructor\">AndSend(<span class=\"hljs-params\">exchangeName</span>, <span class=\"hljs-string\">&quot;blue&quot;</span>, <span class=\"hljs-string\">&quot;halo-direct-blue&quot;</span>)</span>;\n}\n</code></pre>\n<h4 id=\"基于注解声明队列和交换机\">基于注解声明队列和交换机</h4>\n<p>基于 <code>@Bean</code> 的方式声明队列和交换机比较麻烦，Spring 还提供了基于注解方式来声明。</p>\n<p>在 consumer 的 SpringRabbitListener 中添加两个消费者，同时基于注解来声明队列和交换机：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-variable\">@RabbitListener</span>(bindings = <span class=\"hljs-variable\">@QueueBinding</span>(\n    value = <span class=\"hljs-variable\">@Queue</span>(name = <span class=\"hljs-string\">&quot;direct.queue1&quot;</span>),\n    exchange = <span class=\"hljs-variable\">@Exchange</span>(name = <span class=\"hljs-string\">&quot;halo.direct&quot;</span>, type = ExchangeTypes.DIRECT),\n    key = {<span class=\"hljs-string\">&quot;red&quot;</span>, <span class=\"hljs-string\">&quot;blue&quot;</span>}\n))\npublic void listenDirectQueue1(String msg) {\n    <span class=\"hljs-selector-tag\">System</span><span class=\"hljs-selector-class\">.out</span><span class=\"hljs-selector-class\">.println</span>(<span class=\"hljs-string\">&quot;消费者接收到direct.queue1的消息：【&quot;</span> + msg + <span class=\"hljs-string\">&quot;】&quot;</span>);\n}\n\n@<span class=\"hljs-selector-tag\">RabbitListener</span>(bindings = <span class=\"hljs-variable\">@QueueBinding</span>(\n    value = <span class=\"hljs-variable\">@Queue</span>(name = <span class=\"hljs-string\">&quot;direct.queue2&quot;</span>),\n    exchange = <span class=\"hljs-variable\">@Exchange</span>(name = <span class=\"hljs-string\">&quot;halo.direct&quot;</span>, type = ExchangeTypes.DIRECT),\n    key = {<span class=\"hljs-string\">&quot;red&quot;</span>, <span class=\"hljs-string\">&quot;yellow&quot;</span>}\n))\n<span class=\"hljs-selector-tag\">public</span> <span class=\"hljs-selector-tag\">void</span> <span class=\"hljs-selector-tag\">listenDirectQueue2</span>(String msg) {\n    <span class=\"hljs-selector-tag\">System</span><span class=\"hljs-selector-class\">.out</span><span class=\"hljs-selector-class\">.println</span>(<span class=\"hljs-string\">&quot;消费者接收到direct.queue2的消息：【&quot;</span> + msg + <span class=\"hljs-string\">&quot;】&quot;</span>);\n}\n</code></pre>\n<h4 id=\"direct-exchange-小结\">Direct Exchange 小结</h4>\n<p>描述下 Direct 交换机与 Fanout 交换机的差异？</p>\n<ul>\n<li>Fanout 交换机将消息路由给每一个与之绑定的队列</li>\n<li>Direct 交换机根据 Routing Key 判断路由给哪个队列</li>\n<li>如果多个队列具有相同的 Routing Key，则与 Fanout 功能类似</li>\n</ul>\n<p>基于 <code>@RabbitListener</code> 注解声明队列和交换机有哪些常见注解？</p>\n<ul>\n<li><code>@Queue</code></li>\n<li><code>@Exchange</code></li>\n</ul>\n<h3 id=\"topic-exchange\">Topic Exchange</h3>\n<p>Topic 类型的 Exchange 与 Direct 相比，都是可以根据 Routing Key 把消息路由到不同的队列。</p>\n<p>只不过 Topic 类型 Exchange 可以让队列在绑定 Routing key 的时候使用通配符！</p>\n<p>Routing Key 一般都是有一个或多个单词组成，多个单词之间以 <code>.</code> 分割，例如：item.insert</p>\n<p> 通配符规则：</p>\n<p><code>#</code>：匹配一个或多个词</p>\n<p><code>*</code>：匹配不多不少恰好 1 个词</p>\n<p>举例：</p>\n<p><code>item.#</code>：能够匹配 <code>item.spu.insert</code> 或者 <code>item.spu</code></p>\n<p><code>item.*</code>：只能匹配 <code>item.spu</code></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Topic.60w0j0blgsw0.svg\" alt=\"Topic\"></p>\n<ul>\n<li>Queue1：绑定的是 <code>china.#</code> ，因此凡是以 <code>china.</code> 开头的 Routing Key 都会被匹配到。包括<code>china.news</code> 和 <code>china.weather</code></li>\n<li>Queue2：绑定的是 <code>#.news</code> ，因此凡是以 <code>.news</code> 结尾的 Routing Key 都会被匹配。包括 <code>china.news</code> 和 <code>japan.news</code></li>\n<li>其他队列同理</li>\n</ul>\n<p>实现思路如下：</p>\n<ol>\n<li><p>利用 <code>@RabbitListener</code> 声明 Exchange、Queue、RoutingKey</p>\n</li>\n<li><p>在 consumer 服务中，编写两个消费者方法，分别监听 topic.queue1 和 topic.queue2</p>\n</li>\n<li><p>在 publisher 中编写测试方法，向 halo. topic发送消息</p>\n</li>\n</ol>\n<h4 id=\"消息发送-4\">消息发送</h4>\n<p>在 publisher 服务的 SpringAmqpTest 类中添加测试方法：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">testSendTopicExchange</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// 交换机名称</span>\n    <span class=\"hljs-title class_\">String</span> exchangeName = <span class=\"hljs-string\">&quot;itcast.topic&quot;</span>;\n    <span class=\"hljs-comment\">// 消息</span>\n    <span class=\"hljs-title class_\">String</span> message = <span class=\"hljs-string\">&quot;喜报！孙悟空大战哥斯拉，胜!&quot;</span>;\n    <span class=\"hljs-comment\">// 发送消息</span>\n    rabbitTemplate.<span class=\"hljs-title function_\">convertAndSend</span>(exchangeName, <span class=\"hljs-string\">&quot;china.news&quot;</span>, message);\n}\n</code></pre>\n<h4 id=\"消息接收-3\">消息接收</h4>\n<p>在 consumer 服务的 SpringRabbitListener 中添加方法：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-variable\">@RabbitListener</span>(bindings = <span class=\"hljs-variable\">@QueueBinding</span>(\n    value = <span class=\"hljs-variable\">@Queue</span>(name = <span class=\"hljs-string\">&quot;topic.queue1&quot;</span>),\n    exchange = <span class=\"hljs-variable\">@Exchange</span>(name = <span class=\"hljs-string\">&quot;halo.topic&quot;</span>, type = ExchangeTypes.TOPIC),\n    key = <span class=\"hljs-string\">&quot;china.#&quot;</span>\n))\npublic void listenTopicQueue1(String msg){\n    <span class=\"hljs-selector-tag\">System</span><span class=\"hljs-selector-class\">.out</span><span class=\"hljs-selector-class\">.println</span>(<span class=\"hljs-string\">&quot;消费者接收到topic.queue1的消息：【&quot;</span> + msg + <span class=\"hljs-string\">&quot;】&quot;</span>);\n}\n\n@<span class=\"hljs-selector-tag\">RabbitListener</span>(bindings = <span class=\"hljs-variable\">@QueueBinding</span>(\n    value = <span class=\"hljs-variable\">@Queue</span>(name = <span class=\"hljs-string\">&quot;topic.queue2&quot;</span>),\n    exchange = <span class=\"hljs-variable\">@Exchange</span>(name = <span class=\"hljs-string\">&quot;halo.topic&quot;</span>, type = ExchangeTypes.TOPIC),\n    key = <span class=\"hljs-string\">&quot;#.news&quot;</span>\n))\n<span class=\"hljs-selector-tag\">public</span> <span class=\"hljs-selector-tag\">void</span> <span class=\"hljs-selector-tag\">listenTopicQueue2</span>(String msg){\n    <span class=\"hljs-selector-tag\">System</span><span class=\"hljs-selector-class\">.out</span><span class=\"hljs-selector-class\">.println</span>(<span class=\"hljs-string\">&quot;消费者接收到topic.queue2的消息：【&quot;</span> + msg + <span class=\"hljs-string\">&quot;】&quot;</span>);\n}\n</code></pre>\n<h3 id=\"消息转换器\">消息转换器</h3>\n<p>之前说过，Spring 会把你发送的消息序列化为字节发送给 MQ，接收消息的时候，还会把字节反序列化为 Java 对象。</p>\n<p>只不过，默认情况下 Spring 采用的序列化方式是 JDK 序列化。众所周知，JDK 序列化存在下列问题：</p>\n<ul>\n<li>数据体积过大</li>\n<li>有安全漏洞</li>\n<li>可读性差</li>\n</ul>\n<h4 id=\"测试默认转换器\">测试默认转换器</h4>\n<p>我们修改消息发送的代码，发送一个 Map 对象：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">testSendMap</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-comment\">// 队列名称</span>\n    <span class=\"hljs-title class_\">String</span> queueName = <span class=\"hljs-string\">&quot;object.queue&quot;</span>;\n    <span class=\"hljs-comment\">// 准备消息</span>\n    <span class=\"hljs-title class_\">Map</span>&lt;<span class=\"hljs-title class_\">String</span>, <span class=\"hljs-title class_\">Object</span>&gt; msg = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();\n    msg.<span class=\"hljs-title function_\">put</span>(<span class=\"hljs-string\">&quot;name&quot;</span>, <span class=\"hljs-string\">&quot;Jack&quot;</span>);\n    msg.<span class=\"hljs-title function_\">put</span>(<span class=\"hljs-string\">&quot;age&quot;</span>, <span class=\"hljs-number\">21</span>);\n    <span class=\"hljs-comment\">// 发送消息</span>\n    rabbitTemplate.<span class=\"hljs-title function_\">convertAndSend</span>(queueName, msg);\n}\n</code></pre>\n<p>发送消息后查看控制台：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2jjb6wxbs120.png\" alt=\"image\"></p>\n<p>Spring 的对消息对象的处理是由 <code>org.springframework.amqp.support.converter.MessageConverter</code> 来处理的。而默认实现是 <code>SimpleMessageConverter</code>，基于 JDK 的 <code>ObjectOutputStream</code> 完成序列化。</p>\n<h4 id=\"配置-json-转换器\">配置 JSON 转换器</h4>\n<p>显然，JDK 序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用 JSON 方式来做序列化和反序列化。如果要修改只需要定义一个 <code>MessageConverter</code> 类型的Bean即可，步骤如下：</p>\n<p>在 publisher 和 consumer 两个服务中都引入依赖：</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>jackson-databind<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>配置消息转换器。</p>\n<p>在启动类中添加一个 Bean 即可：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Bean</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">MessageConverter</span> <span class=\"hljs-title function_\">jsonMessageConverter</span>(<span class=\"hljs-params\"></span>){\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Jackson</span>2JsonMessageConverter();\n}\n</code></pre>\n');
INSERT INTO `m_blog` VALUES (9, 1, 'Test', 'Test', '## 你好\n\n', '2021-09-23 21:30:37', 1, 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/macos.6z1mshl4twk0.svg', 0, '2021-09-23 21:30:37', NULL, NULL, NULL, 1, 1, 0, NULL, 0, NULL);
INSERT INTO `m_blog` VALUES (12, 1, 'ElasticaSeach 入门', 'ElasticaSeach 入门', '\n## 初识 ElasticSearch\n\n### 了解 ElasticSearch\n\n#### ElasticSearch 的作用\n\nElasticSearch 是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容\n\n#### ELK 技术栈\n\nElasticSearch 结合 Kibana、Logstash、Beats，也就是 Elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域。\n\n#### ElasticSearch 和 Lucene\n\nElasticSearch 底层是基于 Lucene 来实现的。\n\nLucene 是一个 Java 语言的搜索引擎类库，是 Apache 公司的顶级项目，由 DougCutting 于 1999 年研发。\n\nLucene 官网地址：https://lucene.apache.org/ 。\n\nLucene 的优势：易扩展、高性能（基于倒排索引）\n\nLucene 的缺点：只限于 Java 语言开发、学习曲线陡峭、不支持水平扩展\n\nElasticSearch 的发展历史：\n\n- 2004 年 Shay Banon 基于 Lucene 开发了 Compass\n- 2010 年 Shay Banon 重写了 Compass，取名为 ElasticSearch。\n\nElasticSearch 官网地址: https://www.elastic.co/cn/\n\n相比与 Lucene ，ElasticSearch 具备下列优势：\n\n+ 支持分布式，可水平扩展\n+ 提供 Restful 接口，可被任何语言调用\n\n### 倒排索引\n\n倒排索引的概念是基于 MySQL 这样的正向索引而言的。\n\n#### 正向索引\n\n如果是根据 id 查询，那么直接走索引，查询速度非常快。\n\n但如果是基于 title 做模糊查询，只能是逐行扫描数据，流程如下：\n\n1. 用户搜索数据，条件是 title 符合 `\"%手机%\"`\n2. 逐行获取数据，比如 id 为 1 的数据\n3. 判断数据中的 title 是否符合用户搜索条件\n4. 如果符合则放入结果集，不符合则丢弃。回到步骤 1\n\n逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。\n\n#### 倒排索引\n\n倒排索引中有两个非常重要的概念：\n\n- 文档（Document）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息\n- 词条（Term）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条\n\n创建倒排索引是对正向索引的一种特殊处理，流程如下：\n\n- 将每一个文档的数据利用算法分词，得到一个个词条\n- 创建表，每行数据包括词条、词条所在文档 id、位置等信息\n- 因为词条唯一性，可以给词条创建索引，例如 hash 表结构索引\n\n如图：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5jp2imzxno00.png)\n\n倒排索引的搜索流程如下（以搜索“华为手机”为例）：\n\n1. 用户输入条件 `\"华为手机\"` 进行搜索。\n2. 对用户输入内容分词，得到词条：`华为`、`手机`。\n3. 拿着词条在倒排索引中查找，可以得到包含词条的文档 id：1、2、3。\n4. 拿着文档 id 到正向索引中查找具体文档。\n\n虽然要先查询倒排索引，再查询倒排索引，但是无论是词条、还是文档 id 都建立了索引，查询速度非常快！无需全表扫描。\n\n#### 正向和倒排\n\n那么为什么一个叫做正向索引，一个叫做倒排索引呢？\n\n- 正向索引是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是根据文档找词条的过程。\n\n- 倒排索引则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的 id，然后根据 id 获取文档。是根据词条找文档的过程。\n\n正向索引\n\n+ 优点：可以给多个字段创建索引、根据索引字段搜索、排序速度非常快\n\n- 缺点：根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。\n\n倒排索引：\n\n- 优点：根据词条搜索、模糊搜索时，速度非常快\n- 缺点：只能给词条创建索引，而不是字段、无法根据字段做排序\n\n### ElasticSearch 中的一些概念\n\nElasticSearch 中有很多独有的概念，与 MySQL 中略有差别，但也有相似之处。\n\n#### 文档和字段\n\nElasticSearch 是面向文档（Document）存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为 JSON 格式后存储在 ElasticSearch 中：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.lwpnpfcxvds.png)\n\n而 JSON 文档中往往包含很多的字段（Field），类似于数据库中的列。\n\n#### 索引和映射\n\n索引（Index），就是相同类型的文档的集合。例如：\n\n- 所有用户文档，就可以组织在一起，称为用户的索引；\n- 所有商品的文档，可以组织在一起，称为商品的索引；\n- 所有订单的文档，可以组织在一起，称为订单的索引；\n\n![索引](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/索引.67l5ib0vvgo0.svg)\n\n因此，我们可以把索引当做是数据库中的表。\n\n数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有映射（mapping），是索引中文档的字段约束信息，类似表的结构约束。\n\n#### MySQL 与 ElasticSearch\n\n我们统一的把 MySQL 与 ElasticSearch 的概念做一下对比：\n\n| MySQL  | Elasticsearch | **说明**                                                     |\n| ------ | ------------- | ------------------------------------------------------------ |\n| Table  | Index         | 索引（index），就是文档的集合，类似数据库的表（table）       |\n| Row    | Document      | 文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式 |\n| Column | Field         | 字段（Field），就是 JSON 文档中的字段，类似数据库中的列（Column） |\n| Schema | Mapping       | Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema） |\n| SQL    | DSL           | DSL是 ElasticSearch 提供的 JSON 风格的请求语句，用来操作 ElasticSearch，实现 CRUD |\n\n- MySQL ：擅长事务类型操作，可以确保数据的安全和一致性\n\n- ElasticSearch：擅长海量数据的搜索、分析、计算\n\n因此在企业中，往往是两者结合使用：\n\n- 对安全性要求较高的写操作，使用 MySQL 实现\n- 对查询性能要求较高的搜索需求，使用 ElasticSearch 实现\n- 两者再基于某种方式，实现数据的同步，保证一致性\n\n![ElasticSearch](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/ElasticSearch.4koj7qwgqge0.svg)\n\n### 安装 ElasticSearch 、Kibana\n\n#### 创建网络\n\n因为我们还需要部署 Kibana 容器，因此需要让 ElasticSearch 和 Kibana 容器互联。这里先创建一个网络：\n\n```sh\ndocker network create halo-es-net\n```\n\n#### 拉取或加载镜像\n\n```sh\ndocker pull elasticsearch:7.14.1\n```\n\n```sh\ndocker pull kibana:7.14.1\n```\n\n#### 运行（单点）\n\n运行 docker 命令，部署单点 ElasticSearch ：\n\n```sh\ndocker run -d \\\n	--name halo-es \\\n    -e \"ES_JAVA_OPTS=-Xms512m -Xmx512m\" \\\n    -e \"discovery.type=single-node\" \\\n    -v es-data:/usr/share/elasticsearch/data \\\n    -v es-plugins:/usr/share/elasticsearch/plugins \\\n    --privileged \\\n    --network halo-es-net \\\n    -p 9200:9200 \\\n    -p 9300:9300 \\\nelasticsearch:7.14.1\n```\n\n命令解释：\n\n- `-e \"cluster.name=es-docker-cluster\"`：设置集群名称\n- `-e \"http.host=0.0.0.0\"`：监听的地址，可以外网访问\n- `-e \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"`：内存大小\n- `-e \"discovery.type=single-node\"`：非集群模式\n- `-v es-data:/usr/share/elasticsearch/data`：挂载逻辑卷，绑定 ElasticSearch 的数据目录\n- `-v es-logs:/usr/share/elasticsearch/logs`：挂载逻辑卷，绑定 ElasticSearch 的日志目录\n- `-v es-plugins:/usr/share/elasticsearch/plugins`：挂载逻辑卷，绑定 ElasticSearch 的插件目录\n- `--privileged`：授予逻辑卷访问权\n- `--network halo-es-net` ：加入一个名为 halo-es-net 的网络中\n- `-p 9200:9200`：端口映射配置\n\n在浏览器中输入：http://halo:9200 即可看到 ElasticSearch 的响应结果：\n\n运行 docker 命令，部署 Kibana\n\n```sh\ndocker run -d \\\n--name halo-kibana \\\n-e ELASTICSEARCH_HOSTS=http://halo-es:9200 \\\n--network halo-es-net \\\n-p 5601:5601  \\\nkibana:7.14.1\n```\n\n- `--network es-net` ：加入一个名为es-net的网络中，与 elasticsearch 在同一个网络中\n- `-e ELASTICSEARCH_HOSTS=http://halo-es:9200\"`：设置 elasticsearch 的地址，因为 kibana 已经与elasticsearch 在一个网络，因此可以用容器名（halo-es）直接访问 elasticsearch\n- `-p 5601:5601`：端口映射配置\n\nkibana 启动一般比较慢，需要多等待一会，可以通过命令查看日志：\n\n```sh\ndocker logs -f kibana\n```\n\n在浏览器输入地址访问：http://halo:5601，即可看到结果\n\n### 安装 IK 分词器\n\nElasticSearch 在创建倒排索引时需要对文档分词；在搜索时，需要对用户输入内容分词。但默认的分词规则对中文处理并不友好。\n\n我们在 Kibana 的 DevTools 中测试：\n\n```json\nPOST /_analyze\n{\n  \"analyzer\": \"standard\",\n  \"text\": \"你好,世界! Hello,World!\"\n}\n```\n\n语法说明：\n\n+ POST：请求方式\n+ /_analyze：请求路径，这里省略了 http://halo:9200，有 kibana 帮我们补充\n+ 请求参数，JSON 风格：`analyzer`：分词器类型，这里是默认的 standard 分词器；`text`：要分词的内容\n\n```json\n{\n  \"tokens\" : [\n    {\n      \"token\" : \"你\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 1,\n      \"type\" : \"<IDEOGRAPHIC>\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"好\",\n      \"start_offset\" : 1,\n      \"end_offset\" : 2,\n      \"type\" : \"<IDEOGRAPHIC>\",\n      \"position\" : 1\n    },\n    {\n      \"token\" : \"世\",\n      \"start_offset\" : 3,\n      \"end_offset\" : 4,\n      \"type\" : \"<IDEOGRAPHIC>\",\n      \"position\" : 2\n    },\n    {\n      \"token\" : \"界\",\n      \"start_offset\" : 4,\n      \"end_offset\" : 5,\n      \"type\" : \"<IDEOGRAPHIC>\",\n      \"position\" : 3\n    },\n    {\n      \"token\" : \"hello\",\n      \"start_offset\" : 7,\n      \"end_offset\" : 12,\n      \"type\" : \"<ALPHANUM>\",\n      \"position\" : 4\n    },\n    {\n      \"token\" : \"world\",\n      \"start_offset\" : 13,\n      \"end_offset\" : 18,\n      \"type\" : \"<ALPHANUM>\",\n      \"position\" : 5\n    }\n  ]\n}\n```\n\n处理中文分词，一般会使用 IK 分词器。https://github.com/medcl/elasticsearch-analysis-ik\n\n#### 在线安装 IK 插件\n\n```sh\n# 进入容器内部\ndocker exec -it elasticsearch /bin/bash\n\n# 在线下载并安装\n./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.14.1/elasticsearch-analysis-ik-7.14.1.zip\n\n#退出\nexit\n#重启容器\ndocker restart elasticsearch\n```\n\n#### 离线安装 IK 插件\n\n查看数据卷目录\n\n安装插件需要知道 elasticsearch 的 plugins 目录位置，而我们用了数据卷挂载，因此需要查看 elasticsearch 的数据卷目录，通过下面命令查看:\n\n```sh\ndocker volume inspect es-plugins\n```\n\n显示结果：\n\n```\n[\n    {\n        \"CreatedAt\": \"2021-09-11T12:50:57+08:00\",\n        \"Driver\": \"local\",\n        \"Labels\": null,\n        \"Mountpoint\": \"/var/lib/docker/volumes/es-plugins/_data\",\n        \"Name\": \"es-plugins\",\n        \"Options\": null,\n        \"Scope\": \"local\"\n    }\n]\n```\n\n说明 plugins 目录被挂载到了：`/var/lib/docker/volumes/es-plugins/_data ` 这个目录中。\n\n将 ik 分词器解压缩，重命名为 ik，上传到 es 容器的插件数据卷中后重启容器\n\n```sh\ndocker restart halo-es\n```\n\n#### 测试分词器\n\nIK 分词器包含两种模式：\n\n* `ik_smart` ：最少切分，粗粒度\n\n* `ik_max_word` ：最细切分，细粒度\n\n```json\nPOST /_analyze\n{\n  \"analyzer\": \"ik_max_word\",\n  \"text\": \"你好,我的世界! Hello,World!\"\n}\n```\n\n结果：\n\n```json\n{\n  \"tokens\" : [\n    {\n      \"token\" : \"你好\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 2,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"我\",\n      \"start_offset\" : 3,\n      \"end_offset\" : 4,\n      \"type\" : \"CN_CHAR\",\n      \"position\" : 1\n    },\n    {\n      \"token\" : \"的\",\n      \"start_offset\" : 4,\n      \"end_offset\" : 5,\n      \"type\" : \"CN_CHAR\",\n      \"position\" : 2\n    },\n    {\n      \"token\" : \"世界\",\n      \"start_offset\" : 5,\n      \"end_offset\" : 7,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 3\n    },\n    {\n      \"token\" : \"hello\",\n      \"start_offset\" : 9,\n      \"end_offset\" : 14,\n      \"type\" : \"ENGLISH\",\n      \"position\" : 4\n    },\n    {\n      \"token\" : \"world\",\n      \"start_offset\" : 15,\n      \"end_offset\" : 20,\n      \"type\" : \"ENGLISH\",\n      \"position\" : 5\n    }\n  ]\n}\n```\n\n#### 扩展和停用词词典\n\n随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。\n\n所以我们的词汇也需要不断的更新，IK 分词器提供了扩展词汇的功能。\n\n打开 IK 分词器 config 目录：\n\n```sh\ncd /var/lib/docker/volumes/es-plugins/_data/ik/config\n```\n\n在 IKAnalyzer.cfg.xml 配置文件内容添加：\n\n```xml\n<!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\">\n<properties>\n        <comment>IK Analyzer 扩展配置</comment>\n        <!--用户可以在这里配置自己的扩展字典 -->\n        <entry key=\"ext_dict\">ext.dic</entry>\n         <!--用户可以在这里配置自己的扩展停止词字典-->\n        <entry key=\"ext_stopwords\">stopwort.dic</entry>\n        <!--用户可以在这里配置远程扩展字典 -->\n        <!-- <entry key=\"remote_ext_dict\">words_location</entry> -->\n        <!--用户可以在这里配置远程扩展停止词字典-->\n        <!-- <entry key=\"remote_ext_stopwords\">words_location</entry> -->\n</properties>\n```\n\n新建一个 ext.dic，可以参考 config 目录下复制一个配置文件进行修改\n\n```properties\n我的世界\n```\n\nstopwort.dic 添加\n\n```properties\n的\n```\n\n重启 ElasticSearch \n\n```sh\ndocker restart es\n\n# 查看 日志\ndocker logs -f elasticsearch\n```\n\n日志中已经成功加载 ext.dic 配置文件\n\n测试\n\n```json\nPOST /_analyze\n{\n  \"analyzer\": \"ik_max_word\",\n  \"text\": \"你好,我的世界! Hello,World!\"\n}\n```\n\n```json\n{\n  \"tokens\" : [\n    {\n      \"token\" : \"你好\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 2,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"我的世界\",\n      \"start_offset\" : 3,\n      \"end_offset\" : 7,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 1\n    },\n    {\n      \"token\" : \"世界\",\n      \"start_offset\" : 5,\n      \"end_offset\" : 7,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 2\n    },\n    {\n      \"token\" : \"hello\",\n      \"start_offset\" : 9,\n      \"end_offset\" : 14,\n      \"type\" : \"ENGLISH\",\n      \"position\" : 3\n    },\n    {\n      \"token\" : \"world\",\n      \"start_offset\" : 15,\n      \"end_offset\" : 20,\n      \"type\" : \"ENGLISH\",\n      \"position\" : 4\n    }\n  ]\n}\n```\n\n> 注意当前文件的编码必须是 UTF-8 格式，严禁使用 Windows 记事本编辑\n\n## DSL 索引库操作\n\n索引库就类似数据库表，mapping 映射就类似表的结构。我们要向 es 中存储数据，必须先创建“库”和“表”。\n\n### mapping 映射属性\n\nmapping 是对索引库中文档的约束，常见的mapping属性包括：\n\n- type：字段数据类型，常见的简单类型有：\n  - 字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip 地址）\n  - 数值：long、integer、short、byte、double、float、\n  - 布尔：boolean\n  - 日期：date\n  - 对象：object\n- index：是否创建索引，默认为 true\n- analyzer：使用哪种分词器\n- properties：该字段的子字段\n\n例如下面的 JSON 文档：\n\n```json\n{\n    \"age\": 21,\n    \"weight\": 52.1,\n    \"isMarried\": false,\n    \"info\": \"黑马程序员Java讲师\",\n    \"email\": \"zy@itcast.cn\",\n    \"score\": [99.1, 99.5, 98.9],\n    \"name\": {\n        \"firstName\": \"云\",\n        \"lastName\": \"赵\"\n    }\n}\n```\n\n对应的每个字段映射（mapping）：\n\n- age：类型为 integer；参与搜索，因此需要 index 为 true；无需分词器\n- weight：类型为 float；参与搜索，因此需要 index 为 true；无需分词器\n- isMarried：类型为 boolean；参与搜索，因此需要 index 为 true；无需分词器\n- info：类型为字符串，需要分词，因此是 text；参与搜索，因此需要 index 为 true；分词器可以用 ik_smart\n- email：类型为字符串，但是不需要分词，因此是 keyword；不参与搜索，因此需要 index 为 false；无需分词器\n- score：虽然是数组，但是我们只看元素的类型，类型为 float；参与搜索，因此需要 index 为 true；无需分词器\n- name：类型为 object，需要定义多个子属性\n  - name.firstName：类型为字符串，但是不需要分词，因此是 keyword；参与搜索，因此需要 index 为 true；无需分词器\n  - name.lastName：类型为字符串，但是不需要分词，因此是 keyword；参与搜索，因此需要 index 为 true；无需分词器\n\n### 索引库的 CRUD\n\n这里统一使用 Kibana 编写 DSL 的方式来演示。\n\n#### 创建索引库和映射\n\n基本语法：\n\n+ 请求方式：PUT\n+ 请求路径：/索引库名，可以自定义\n+ 请求参数：mapping 映射\n\n```json\nPUT /索引库名称\n{\n  \"mappings\": {\n    \"properties\": {\n      \"字段名\":{\n        \"type\": \"text\",\n        \"analyzer\": \"ik_smart\"\n      },\n      \"字段名2\":{\n        \"type\": \"keyword\",\n        \"index\": \"false\"\n      },\n      \"字段名3\":{\n        \"properties\": {\n          \"子字段\": {\n            \"type\": \"keyword\"\n          }\n        }\n      },\n      // ...略\n    }\n  }\n}\n```\n\n示例：\n\n```json\nPUT /heima\n{\n  \"mappings\": {\n    \"properties\": {\n      \"info\":{\n        \"type\": \"text\",\n        \"analyzer\": \"ik_smart\"\n      },\n      \"email\":{\n        \"type\": \"keyword\",\n        \"index\": \"falsae\"\n      },\n      \"name\":{\n        \"properties\": {\n          \"firstName\": {\n            \"type\": \"keyword\"\n          }\n        }\n      },\n      // ... 略\n    }\n  }\n}\n```\n\n#### 查询索引库\n\n基本语法：\n\n- 请求方式：GET\n\n- 请求路径：/索引库名\n\n- 请求参数：无\n\n```\nGET /索引库名\n```\n\n#### 删除索引库\n\n语法：\n\n- 请求方式：DELETE\n\n- 请求路径：/索引库名\n\n- 请求参数：无\n\n```\nDELETE /索引库名\n```\n\n#### 修改索引库\n\n倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库一旦创建，无法修改 mapping。\n\n虽然无法修改 mapping 中已有的字段，但是却允许添加新的字段到 mapping 中，因为不会对倒排索引产生影响。\n\n语法说明：\n\n```json\nPUT /索引库名/_mapping\n{\n  \"properties\": {\n    \"新字段名\": {\n      \"type\": \"xxxx\"\n    }\n  }\n}\n```\n\n#### 索引库的 CRUD 小结\n\n- 创建索引库：PUT /索引库名\n- 查询索引库：GET /索引库名\n- 删除索引库：DELETE /索引库名\n- 添加字段：PUT /索引库名/_mapping\n\n## DSL 文档操作\n\n### 新增文档\n\n 语法：\n\n```json\nPOST /索引库名/_doc/文档id\n{\n    \"字段1\": \"值1\",\n    \"字段2\": \"值2\",\n    \"字段3\": {\n        \"子属性1\": \"值3\",\n        \"子属性2\": \"值4\"\n    },\n    // ...\n}\n```\n\n示例：\n\n```json\nPOST /halo/_doc/1\n{\n  \"info\": \"黑马程序员Java讲师\",\n  \"email\": \"zy@itcast.cn\",\n  \"name\": {\n    \"firstName\": \"云\",\n    \"lastName\": \"赵\"\n  }\n}\n```\n\n### 查询文档\n\n根据 rest 风格，新增是 post，查询应该是 get，不过查询一般都需要条件，这里我们把文档 id 带上。\n\n语法：\n\n```\nGET /{索引库名称}/_doc/{id}\n```\n\n通过 kibana 查看数据：\n\n```\nGET /halo/_doc/1\n```\n\n### 删除文档\n\n删除使用 DELETE 请求，同样，需要根据 id 进行删除：\n\n语法：\n\n```\nDELETE /{索引库名}/_doc/id值\n```\n\n示例：\n\n```\nDELETE /halo/_doc/1\n```\n\n### 修改文档\n\n修改有两种方式：\n\n- 全量修改：直接覆盖原来的文档\n- 增量修改：修改文档中的部分字段\n\n#### 全量修改\n\n全量修改是覆盖原来的文档，其本质是：\n\n- 根据指定的 id 删除文档\n- 新增一个相同 id 的文档\n\n> 注意：如果根据 id 删除时，id 不存在，第二步的新增也会执行，也就从修改变成了新增操作了。\n\n语法：\n\n```json\nPUT /{索引库名}/_doc/文档id\n{\n    \"字段1\": \"值1\",\n    \"字段2\": \"值2\",\n    // ... 略\n}\n```\n\n示例：\n\n```json\nPUT /halo/_doc/1\n{\n  \"info\": \"黑马程序员高级Java讲师2\",\n  \"email\": \"zy@itcast.cn\",\n  \"name\": {\n    \"firstName\": \"云\",\n    \"lastName\": \"赵\"\n  }\n}\n```\n\n#### 增量修改\n\n增量修改是只修改指定 id 匹配的文档中的部分字段。\n\n语法：\n\n```json\nPOST /{索引库名}/_update/文档id\n{\n    \"doc\": {\n         \"字段名\": \"新的值\",\n    }\n}\n```\n\n示例：\n\n```\nPOST /halo/_update/1\n{\n  \"doc\": {\n    \"email\": \"ZhaoYun@itcast.cn\"\n  }\n}\n```\n\n### 文档操作总结\n\n- 创建文档：POST /{索引库名}/_doc/文档id   { JSON 文档 }\n- 查询文档：GET /{索引库名}/_doc/文档id\n- 删除文档：DELETE /{索引库名}/_doc/文档id\n- 修改文档：\n  - 全量修改：PUT /{索引库名}/_doc/文档id { JSON 文档 }\n  - 增量修改：POST /{索引库名}/_update/文档id { \"doc\": {字段}}\n\n## Rest Client 索引库操作\n\nElasticSearch 官方提供了各种不同语言的客户端，用来操作 ElasticSearch。这些客户端的本质就是组装 DSL 语句，通过 http 请求发送给 ElasticSearch。官方文档地址：https://www.elastic.co/guide/en/elasticsearch/client/index.html\n\n其中的 Java Rest Client 又包括两种：\n\n- Java Low Level Rest Client\n- Java High Level Rest Client\n\n我们学习的是 Java HighLevel Rest Client 客户端 API\n\n### 创建测试环境\n\n#### 初始化项目\n\n创建数据库，建立数据表\n\n```sql\nCREATE TABLE `tb_hotel`  (\n    `id` bigint(20) NOT NULL COMMENT \'酒店id\',\n    `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT \'酒店名称\',\n    `address` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT \'酒店地址\',\n    `price` int(10) NOT NULL COMMENT \'酒店价格\',\n    `score` int(2) NOT NULL COMMENT \'酒店评分\',\n    `brand` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT \'酒店品牌\',\n    `city` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT \'所在城市\',\n    `star_name` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'酒店星级，1星到5星，1钻到5钻\',\n    `business` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'商圈\',\n    `latitude` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT \'纬度\',\n    `longitude` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT \'经度\',\n    `pic` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'酒店图片\',\n    PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n```\n\n导入数据库数据：[链接](https://github.com/Lanqilu/HaloElasticSearch/blob/master/doc/database/tb_hotel.sql)\n\n初始项目代码：[链接](https://github.com/Lanqilu/HaloElasticSearch/commit/d64b305ccf9ca67b8a18bafee3df7163e7dd8246)\n\n#### mapping 映射分析\n\n创建索引库，最关键的是 mapping 映射，而 mapping 映射要考虑的信息包括：\n\n- 字段名\n- 字段数据类型\n- 是否参与搜索\n- 是否需要分词\n- 如果分词，分词器是什么？\n\n其中：\n\n- 字段名、字段数据类型，可以参考数据表结构的名称和类型\n- 是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索\n- 是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词\n- 分词器，我们可以统一使用 ik_max_word\n\n来看下酒店数据的索引库结构：\n\n```json\nPUT /hotel\n{\n  \"mappings\": {\n    \"properties\": {\n      \"id\": {\n        \"type\": \"keyword\"\n      },\n      \"name\":{\n        \"type\": \"text\",\n        \"analyzer\": \"ik_max_word\",\n        \"copy_to\": \"all\"\n      },\n      \"address\":{\n        \"type\": \"keyword\",\n        \"index\": false\n      },\n      \"price\":{\n        \"type\": \"integer\"\n      },\n      \"score\":{\n        \"type\": \"integer\"\n      },\n      \"brand\":{\n        \"type\": \"keyword\",\n        \"copy_to\": \"all\"\n      },\n      \"city\":{\n        \"type\": \"keyword\",\n        \"copy_to\": \"all\"\n      },\n      \"starName\":{\n        \"type\": \"keyword\"\n      },\n      \"business\":{\n        \"type\": \"keyword\"\n      },\n      \"location\":{\n        \"type\": \"geo_point\"\n      },\n      \"pic\":{\n        \"type\": \"keyword\",\n        \"index\": false\n      },\n      \"all\":{\n        \"type\": \"text\",\n        \"analyzer\": \"ik_max_word\"\n      }\n    }\n  }\n}\n```\n\n几个特殊字段说明：\n\n- location：地理坐标，里面包含精度、纬度\n- all：一个组合字段，其目的是将多字段的值 利用 copy_to 合并，提供给用户搜索\n\n ES 中支持两种地理坐标数据类型：\n\n•geo_point：由纬度（latitude）和经度（longitude）确定的一个点。例如：\"32.8752345, 120.2981576\"\n\n•geo_shape：有多个geo_point组成的复杂几何图形。例如一条直线，\"LINESTRING (-77.03653 38.897676, -77.009051 38.889939)\"\n\n字段拷贝可以使用 copy_to 属性将当前字段拷贝到指定字段。示例：\n\n```json\n\"all\": {\n  \"type\": \"text\",\n  \"analyzer\": \"ik_max_word\"\n},\n\"brand\": {\n  \"type\": \"keyword\",\n  \"copy_to\": \"all\"\n}\n```\n\n#### 初始化 RestClient\n\n在 ElasticSearch 提供的 API 中，与 ElasticSearch 一切交互都封装在一个名为 RestHighLevelClient 的类中，必须先完成这个对象的初始化，建立与 ElasticSearch 的连接。\n\n分为三步：\n\n① 引入 ElasticSearch 的 RestHighLevelClient 依赖：\n\n```xml\n<dependency>\n    <groupId>org.elasticsearch.client</groupId>\n    <artifactId>elasticsearch-rest-high-level-client</artifactId>\n</dependency>\n```\n\n② 因为 SpringBoot 默认的 ElasticSearch 版本是 7.6.2，所以我们需要覆盖默认的 ElasticSearch 版本，与 ElasticSearch 版本保持一致\n\n```xml\n<properties>\n    <java.version>1.8</java.version>\n    <elasticsearch.version>7.14.1</elasticsearch.version>\n</properties>\n```\n\n③ 初始化 RestHighLevelClient：\n\n初始化的代码如下：\n\n```java\nRestHighLevelClient client = new RestHighLevelClient(RestClient.builder(HttpHost.create(\"http://halo:9200\")));\n```\n\n这里为了单元测试方便，我们创建一个测试类 HotelIndexTest，然后将初始化的代码编写在 `@BeforeEach` 方法中：\n\n```java\npublic class HotelIndexTest {\n\n    private RestHighLevelClient client;\n\n    @Test\n    void testInit() {\n        System.out.println(\"client = \" + client);\n    }\n\n    @BeforeEach\n    void setUp() {\n        this.client = new RestHighLevelClient(RestClient.builder(HttpHost.create(\"http://halo:9200\")));\n    }\n\n    @AfterEach\n    void tearDown() throws IOException {\n        this.client.close();\n    }\n}\n```\n\n### 创建索引库\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.zlx2xrhd54w.png)\n\n代码分为三步：\n\n1. 创建 Request 对象。因为是创建索引库的操作，因此 Request 是 CreateIndexRequest\n2. 添加请求参数，其实就是 DSL 的 JSON 参数部分。因为 JSON 字符串很长，这里是定义了静态字符串常量 MAPPING_TEMPLATE，让代码看起来更加优雅。\n3. 发送请求，`client.indices()` 方法的返回值是 IndicesClient 类型，封装了所有与索引库操作有关的方法。\n\n在 hotel-demo 中的 HotelIndexTest 测试类中，编写单元测试，实现创建索引：\n\n```java\n@Test\nvoid createHotelIndex() throws IOException {\n    // 1.创建Request对象\n    CreateIndexRequest request = new CreateIndexRequest(\"hotel\");\n    // 2.准备请求的参数：DSL语句\n    request.source(MAPPING_TEMPLATE, XContentType.JSON);\n    // 3.发送请求\n    client.indices().create(request, RequestOptions.DEFAULT);\n}\n```\n\n### 删除索引库\n\n删除索引库的 DSL 语句非常简单：\n\n```json\nDELETE /hotel\n```\n\n与创建索引库相比：\n\n- 请求方式从 PUT 变为 DELTE\n- 请求路径不变\n- 无请求参数\n\n所以代码的差异，注意体现在 Request 对象上。依然是三步走：\n\n- 创建 Request 对象。这次是 DeleteIndexRequest 对象\n- 准备参数。这里是无参\n- 发送请求。改用 delete 方法\n\n在 hotel-demo 中的 HotelIndexTest 测试类中，编写单元测试，实现删除索引：\n\n```java\n@Test\nvoid testDeleteHotelIndex() throws IOException {\n    // 1.创建Request对象\n    DeleteIndexRequest request = new DeleteIndexRequest(\"hotel\");\n    // 2.发送请求\n    client.indices().delete(request, RequestOptions.DEFAULT);\n}\n```\n\n### 判断索引库是否存在\n\n判断索引库是否存在，本质就是查询，对应的DSL是：\n\n```json\nGET /hotel\n```\n\n因此与删除的 Java 代码流程是类似的。依然是三步走：\n\n- 创建 Request 对象。这次是 GetIndexRequest 对象\n- 准备参数。这里是无参\n- 发送请求。改用 exists 方法\n\n```java\n@Test\nvoid testExistsHotelIndex() throws IOException {\n    // 1.创建Request对象\n    GetIndexRequest request = new GetIndexRequest(\"hotel\");\n    // 2.发送请求\n    boolean exists = client.indices().exists(request, RequestOptions.DEFAULT);\n    // 3.输出\n    System.err.println(exists ? \"索引库已经存在！\" : \"索引库不存在！\");\n}\n```\n\n### RestAPI 小结\n\nJavaRestClient 操作 ElasticSearch 的流程基本类似。核心是 `client.indices()` 方法来获取索引库的操作对象。\n\n索引库操作的基本步骤：\n\n- 初始化 RestHighLevelClient\n- 创建 XxxIndexRequest。Xxx 是Create、Get、Delete\n- 准备 DSL（ Create时需要，其它是无参）\n- 发送请求。调用 `RestHighLevelClient#indices().xxx()` 方法，xxx 是  create、exists、delete\n\n## Rest Client 文档操作\n\n去数据库查询酒店数据，导入到 hotel 索引库，实现酒店数据的 CRUD。基本步骤如下：\n\n+ 初始化 JavaRestClient\n+ 利用 JavaRestClient 新增酒店数据\n+ 利用 JavaRestClient 根据id查询酒店数据\n+ 利用 JavaRestClient 删除酒店数据\n+ 利用 JavaRestClient 修改酒店数据\n\n### 初始化 JavaRestClient\n\n为了与索引库操作分离，我们再次参加一个测试类，做两件事情：\n\n- 初始化 RestHighLevelClient，同上\n- 我们的酒店数据在数据库，需要利用 IHotelService 去查询，所以注入这个接口\n\n```java\n@SpringBootTest\npublic class HotelDocumentTest {\n    @Autowired\n    private IHotelService hotelService;\n\n    private RestHighLevelClient client;\n\n    @BeforeEach\n    void setUp() {\n        this.client = new RestHighLevelClient(RestClient.builder(HttpHost.create(\"http://halo:9200\")));\n    }\n\n    @AfterEach\n    void tearDown() throws IOException {\n        this.client.close();\n    }\n}\n```\n\n### 新增文档\n\n我们要将数据库的酒店数据查询出来，写入 ElasticSearch 中。\n\n#### 索引库实体类\n\n数据库查询后的结果是一个 Hotel 类型的对象。结构如下：\n\n```java\n@Data\n@TableName(\"tb_hotel\")\npublic class Hotel {\n    @TableId(type = IdType.INPUT)\n    private Long id;\n    private String name;\n    private String address;\n    private Integer price;\n    private Integer score;\n    private String brand;\n    private String city;\n    private String starName;\n    private String business;\n    private String longitude;\n    private String latitude;\n    private String pic;\n}\n```\n\n与我们的索引库结构存在差异：\n\n- longitude 和 latitude 需要合并为 location\n\n因此，我们需要定义一个新的类型，与索引库结构吻合：\n\n```java\npackage cn.itcast.hotel.pojo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@NoArgsConstructor\npublic class HotelDoc {\n    private Long id;\n    private String name;\n    private String address;\n    private Integer price;\n    private Integer score;\n    private String brand;\n    private String city;\n    private String starName;\n    private String business;\n    private String location;\n    private String pic;\n\n    public HotelDoc(Hotel hotel) {\n        this.id = hotel.getId();\n        this.name = hotel.getName();\n        this.address = hotel.getAddress();\n        this.price = hotel.getPrice();\n        this.score = hotel.getScore();\n        this.brand = hotel.getBrand();\n        this.city = hotel.getCity();\n        this.starName = hotel.getStarName();\n        this.business = hotel.getBusiness();\n        this.location = hotel.getLatitude() + \", \" + hotel.getLongitude();\n        this.pic = hotel.getPic();\n    }\n}\n```\n\n#### 语法说明\n\n新增文档的 DSL 语句如下：\n\n```json\nPOST /{索引库名}/_doc/1\n{\n    \"name\": \"Jack\",\n    \"age\": 21\n}\n```\n\n对应的 Java 代码如下：\n\n```java\n@Test\nvoid testIndexDocument() throws IOException {\n    // 1.创建request对象\n    IndexRequest request = new IndexRequest(\"indexName\").id(\"1\");\n    // 2.准备JSON文档\n    request.source(\"{\\\"name\\\": \\\"Jack\\\", \\\"age\\\": 21}\", XContentType.JSON);\n    // 3.发送请求\n    client.index(request, RequestOptions.DEFAULT);\n}\n```\n\n可以看到与创建索引库类似，同样是三步走：\n\n- 创建 Request 对象\n- 准备请求参数，也就是 DSL 中的 JSON 文档\n- 发送请求\n\n变化的地方在于，这里直接使用 `client.xxx()` 的 API，不再需要 `client.indices()` 了。\n\n#### 完整代码\n\n我们导入酒店数据，基本流程一致，但是需要考虑几点变化：\n\n- 酒店数据来自于数据库，我们需要先查询出来，得到 Hotel 对象\n- Hotel 对象需要转为 HotelDoc对象\n- HotelDoc 需要序列化为 JSON 格式\n\n因此，代码整体步骤如下：\n\n- 根据 id 查询酒店数据 Hotel\n- 将 Hotel 封装为 HotelDoc\n- 将 HotelDoc 序列化为 JSON\n- 创建 IndexRequest，指定索引库名和 id\n- 准备请求参数，也就是 JSON 文档\n- 发送请求\n\n在 hotel-demo 的 HotelDocumentTest 测试类中，编写单元测试：\n\n```java\n@Test\nvoid testAddDocument() throws IOException {\n    // 1.根据id查询酒店数据\n    Hotel hotel = hotelService.getById(61083L);\n    // 2.转换为文档类型\n    HotelDoc hotelDoc = new HotelDoc(hotel);\n    // 3.将HotelDoc转json\n    String json = JSON.toJSONString(hotelDoc);\n\n    // 1.准备Request对象\n    IndexRequest request = new IndexRequest(\"hotel\").id(hotelDoc.getId().toString());\n    // 2.准备Json文档\n    request.source(json, XContentType.JSON);\n    // 3.发送请求\n    client.index(request, RequestOptions.DEFAULT);\n}\n```\n\n### 查询文档\n\n#### 语法说明\n\n查询的 DSL 语句如下：\n\n```json\nGET /hotel/_doc/{id}\n```\n\n非常简单，因此代码大概分两步：\n\n- 准备 Request 对象\n- 发送请求\n\n不过查询的目的是得到结果，解析为 HotelDoc，因此难点是结果的解析。示例代码如下：\n\n```java\n@Test\nvoid testGetDocumentById() throws IOException {\n    // 1.创建request对象\n    GetRequest request = new GetRequest(\"indexName\", \"1\");\n    // 2.发送请求，得到结果\n    GetResponse response = client.get(request, RequestOptions.DEFAULT);\n    // 3.解析结果\n    String json = response.getSourceAsString();\n    System.out.println(json);\n}\n```\n\n可以看到，结果是一个 JSON，其中文档放在一个 `_source` 属性中，因此解析就是拿到 `_source`，反序列化为 Java 对象即可。\n\n与之前类似，也是三步走：\n\n- 准备 Request 对象。这次是查询，所以是 GetRequest\n- 发送请求，得到结果。因为是查询，这里调用 `client.get()` 方法\n- 解析结果，就是对 JSON 做反序列化\n\n#### 完整代码\n\n在 hotel-demo 的 HotelDocumentTest 测试类中，编写单元测试：\n\n```java\n@Test\nvoid testGetDocumentById() throws IOException {\n    // 1.准备Request\n    GetRequest request = new GetRequest(\"hotel\", \"61083\");\n    // 2.发送请求，得到响应\n    GetResponse response = client.get(request, RequestOptions.DEFAULT);\n    // 3.解析响应结果\n    String json = response.getSourceAsString();\n    HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);\n    System.out.println(hotelDoc);\n}\n```\n\n### 修改文档\n\n#### 语法说明\n\n修改我们讲过两种方式：\n\n- 全量修改：本质是先根据id删除，再新增\n- 增量修改：修改文档中的指定字段值\n\n在 RestClient 的 API 中，全量修改与新增的 API 完全一致，判断依据是 ID：\n\n- 如果新增时，ID 已经存在，则修改\n- 如果新增时，ID 不存在，则新增\n\n这里不再赘述，我们主要关注增量修改。\n\n```java\n@Test\nvoid testUpdateDocumentById() throws IOException {\n    // 1.创建request对象\n    UpdateRequest request = new UpdateRequest(\"indexName\", \"1\");\n    // 2.准备参数，每2个参数为一对 key value    \n    request.doc(\"age\", 18, \"name\", \"Rose\");\n    // 3.更新文档\n    client.update(request, RequestOptions.DEFAULT);\n}\n```\n\n与之前类似，也是三步走：\n\n- 准备 Request 对象。这次是修改，所以是 UpdateRequest\n- 准备参数。也就是 JSON 文档，里面包含要修改的字段\n- 更新文档。这里调用 `client.update()` 方法\n\n#### 完整代码\n\n在 hotel-demo 的 HotelDocumentTest 测试类中，编写单元测试：\n\n```java\n@Test\nvoid testUpdateDocument() throws IOException {\n    // 1.准备Request\n    UpdateRequest request = new UpdateRequest(\"hotel\", \"61083\");\n    // 2.准备请求参数\n    request.doc(\n        \"price\", \"952\",\n        \"starName\", \"四钻\"\n    );\n    // 3.发送请求\n    client.update(request, RequestOptions.DEFAULT);\n}\n```\n\n### 删除文档\n\n删除的 DSL 为是这样的：\n\n```json\nDELETE /hotel/_doc/{id}\n```\n\n与查询相比，仅仅是请求方式从 DELETE 变成 GET，可以想象 Java 代码应该依然是三步走：\n\n- 准备 Request 对象，因为是删除，这次是 DeleteRequest 对象。要指定索引库名和 id\n- 准备参数，无参\n- 发送请求。因为是删除，所以是 `client.delete()` 方法\n\n```java\n@Test\nvoid testDeleteDocument() throws IOException {\n    // 1.准备Request\n    DeleteRequest request = new DeleteRequest(\"hotel\", \"61083\");\n    // 2.发送请求\n    client.delete(request, RequestOptions.DEFAULT);\n}\n```\n\n### 批量导入文档\n\n案例需求：利用 BulkRequest 批量将数据库数据导入到索引库中。\n\n步骤如下：\n\n- 利用 mybatis-plus 查询酒店数据\n\n- 将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）\n\n- 利用 JavaRestClient 中的 BulkRequest 批处理，实现批量新增文档\n\n#### 语法说明\n\n批量处理 BulkRequest，其本质就是将多个普通的 CRUD 请求组合在一起发送。\n\n其中提供了一个 add 方法，用来添加其他请求：\n\n- IndexRequest，也就是新增\n- UpdateRequest，也就是修改\n- DeleteRequest，也就是删除\n\n因此 Bulk 中添加了多个 IndexRequest，就是批量新增功能了。示例：\n\n```java\n@Test\nvoid testBulk() throws IOException {\n    // 1.创建Bulk请求\n    BulkRequest request = new BulkRequest();\n    // 2.添加要批量提交的请求：这里添加了两个新增文档的请求\n    request.add(new IndexRequest(\"hotel\")\n                .id(\"101\").source(\"json source\", XContentType.JSON));\n    request.add(new IndexRequest(\"hotel\")\n                .id(\"102\").source(\"json source2\", XContentType.JSON));\n    // 3.发起bulk请求\n    client.bulk(request, RequestOptions.DEFAULT);\n}\n```\n\n其实还是三步走：\n\n- 创建 Request 对象。这里是 BulkRequest\n- 准备参数。批处理的参数，就是其它 Request 对象，这里就是多个 IndexRequest\n- 发起请求。这里是批处理，调用的方法为 `client.bulk()` 方法\n\n我们在导入酒店数据时，将上述代码改造成 for 循环处理即可。\n\n#### 完整代码\n\n在 hotel-demo 的 HotelDocumentTest 测试类中，编写单元测试：\n\n```java\n@Test\nvoid testBulkRequest() throws IOException {\n    // 批量查询酒店数据\n    List<Hotel> hotels = hotelService.list();\n\n    // 1.创建 Request\n    BulkRequest request = new BulkRequest();\n    // 2.准备参数，添加多个新增的 Request\n    for (Hotel hotel : hotels) {\n        // 2.1.转换为文档类型 HotelDoc\n        HotelDoc hotelDoc = new HotelDoc(hotel);\n        // 2.2.创建新增文档的 Request 对象\n        request.add(new IndexRequest(\"hotel\")\n                    .id(hotelDoc.getId().toString())\n                    .source(JSON.toJSONString(hotelDoc), XContentType.JSON));\n    }\n    // 3.发送请求\n    client.bulk(request, RequestOptions.DEFAULT);\n}\n```\n\n测试，批量查询\n\n```\nGET /hotel/_search\n```\n\n### Rest Client 文档操作小结\n\n文档操作的基本步骤：\n\n- 初始化 RestHighLevelClient\n- 创建 XxxRequest。Xxx 是 Index、Get、Update、Delete、Bulk\n- 准备参数（Index、Update、Bulk时需要）\n- 发送请求。调用 `RestHighLevelClient#.xxx()` 方法，xxx 是 index、get、update、delete、bulk\n- 解析结果（Get时需要）\n\n## DSL 查询文档\n\nElasticSearch 的查询依然是基于 JSON 风格的 DSL 来实现的。\n\n### DSL 查询分类\n\nElasticSearch 提供了基于 JSON 的 DSL（[Domain Specific Language](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html)）来定义查询。常见的查询类型包括：\n\n- 查询所有：查询出所有数据，一般测试用。例如：match_all\n\n- 全文检索查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：\n  - match_query\n  - multi_match_query\n- 精确查询：根据精确词条值查找数据，一般是查找 keyword、数值、日期、boolean 等类型字段。例如：\n  - ids\n  - range\n  - term\n- 地理（geo）查询：根据经纬度查询。例如：\n  - geo_distance\n  - geo_bounding_box\n- 复合（compound）查询：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：\n  - bool\n  - function_score\n\n查询的语法基本一致：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"查询类型\": {\n      \"查询条件\": \"条件值\"\n    }\n  }\n}\n```\n\n 我们以查询所有为例，其中：\n\n- 查询类型为 match_all\n- 没有查询条件\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  }\n}\n```\n\n其它查询无非就是查询类型、查询条件的变化。\n\n### 全文检索查询\n\n#### 使用场景\n\n全文检索查询的基本流程如下：\n\n- 对用户搜索的内容做分词，得到词条\n- 根据词条去倒排索引库中匹配，得到文档 id\n- 根据文档 id 找到文档，返回给用户\n\n比较常用的场景包括：\n\n- 商城的输入框搜索\n- 百度输入框搜索\n\n因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的 text 类型的字段。\n\n#### 基本语法\n\n常见的全文检索查询包括：\n\n- match 查询：单字段查询\n- multi_match 查询：多字段查询，任意一个字段符合条件就算符合查询条件\n\nmatch 查询语法如下：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"match\": {\n      \"FIELD\": \"TEXT\"\n    }\n  }\n}\n```\n\nmulit_match 语法如下：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"multi_match\": {\n      \"query\": \"TEXT\",\n      \"fields\": [\"FIELD1\", \" FIELD12\"]\n    }\n  }\n}\n```\n\n#### 使用示例\n\nmatch 查询示例：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match\": {\n      \"all\": \"如家外滩\"\n    }\n  }\n}\n```\n\nmulti_match 查询示例：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"multi_match\": {\n      \"query\": \"如家外滩\",\n      \"fields\": [\"brand\",\"name\",\"business\"]\n    }\n  }\n}\n```\n\n可以看到，两种查询结果是一样的，为什么？\n\n因为我们将 brand、name、business 值都利用 copy_to 复制到了 all 字段中。因此你根据三个字段搜索，和根据 all 字段搜索效果当然一样了。\n\n但是，搜索字段越多，对查询性能影响越大，因此建议采用 copy_to，然后单字段查询的方式。\n\nmatch 和 multi_match 的区别是什么？\n\n- match：根据一个字段查询\n- multi_match：根据多个字段查询，参与查询字段越多，查询性能越差\n\n### 精准查询\n\n精确查询一般是查找 keyword、数值、日期、boolean 等类型字段。所以不会对搜索条件分词。常见的有：\n\n- term：根据词条精确值查询\n- range：根据值的范围查询\n\n#### term 查询\n\n因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是**不分词**的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。\n\n语法说明：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"term\": {\n      \"FIELD\": {\n        \"value\": \"VALUE\"\n      }\n    }\n  }\n}\n```\n\n示例：\n\n当我搜索的是精确词条时，能正确查询出结果：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"term\": {\n      \"city\": {\n        \"value\": \"上海\"\n      }\n    }\n  }\n}\n```\n\n但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"term\": {\n      \"city\": {\n        \"value\": \"上海杭州\"\n      }\n    }\n  }\n}\n```\n\n#### range 查询\n\n范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。\n\n基本语法：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"range\": {\n      \"FIELD\": {\n        \"gte\": 10,\n        \"lte\": 20\n      }\n    }\n  }\n}\n```\n\n+ gte 代表大于等于，gt 则代表大于\n+ lte 代表小于等于，lt 则代表小于\n\n示例：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"range\": {\n      \"price\": {\n        \"gte\": 1000,\n        \"lte\": 3000\n      }\n    }\n  }\n}\n```\n\n#### 精准查询小结\n\n精确查询常见的有哪些？\n\n- term 查询：根据词条精确匹配，一般搜索 keyword 类型、数值类型、布尔类型、日期类型字段\n- range 查询：根据数值范围查询，可以是数值、日期的范围\n\n### 地理坐标查询\n\n所谓的地理坐标查询，其实就是根据经纬度查询，[官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html)\n\n常见的使用场景包括：\n\n- 携程：搜索我附近的酒店\n- 滴滴：搜索我附近的出租车\n- 微信：搜索我附近的人\n\n#### 矩形范围查询\n\n矩形范围查询，也就是 geo_bounding_box 查询，查询坐标落在某个矩形范围的所有文档：\n\n查询时，需要指定矩形的**左上**、**右下**两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。\n\n语法如下：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"geo_bounding_box\": {\n      \"FIELD\": {\n        \"top_left\": {\n          \"lat\": 31.1,\n          \"lon\": 121.5\n        },\n        \"bottom_right\": {\n          \"lat\": 30.9,\n          \"lon\": 121.7\n        }\n      }\n    }\n  }\n}\n```\n\n#### 附近查询\n\n附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。\n\n换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：\n\n语法说明：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"geo_distance\": {\n      \"distance\": \"15km\",\n      \"FIELD\": \"31.21,121.5\"\n    }\n  }\n}\n```\n\n我们先搜索陆家嘴附近 15km 的酒店：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"geo_distance\": {\n      \"distance\": \"2km\",\n      \"location\": \"31.21,121.5\"\n    }\n  }\n}\n```\n\n### 复合查询\n\n复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：\n\n- fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名\n- bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索\n\n#### 相关性算分\n\n当我们利用 match 查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。\n\n例如，我们搜索 \"虹桥如家\"，结果如下：\n\n```json\n[\n  {\n    \"_score\" : 17.850193,\n    \"_source\" : {\n      \"name\" : \"虹桥如家酒店真不错\",\n    }\n  },\n  {\n    \"_score\" : 12.259849,\n    \"_source\" : {\n      \"name\" : \"外滩如家酒店真不错\",\n    }\n  },\n  {\n    \"_score\" : 11.91091,\n    \"_source\" : {\n      \"name\" : \"迪士尼如家酒店真不错\",\n    }\n  }\n]\n```\n\n在 ElasticSearch 中，早期使用的打分算法是 [TF-IDF 算法](https://www.ruanyifeng.com/blog/2013/03/tf-idf.html)，在后来的 5.1 版本升级中，ElasticSearch 将算法改进为 [BM25 算法](https://www.jianshu.com/p/1e498888f505)\n\nTF-IDF 算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而 BM25 则会让单个词条的算分有一个上限，曲线更加平滑：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.32gad6dlyzu0.png)\n\n#### 算分函数查询\n\n根据相关度打分是比较合理的需求，但合理的不一定是产品经理需要的。\n\n以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。要想认为控制相关性算分，就需要利用 ElasticSearch 中的 function score 查询了。\n\n语法说明：\n\n![算分函数查询](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/算分函数查询.epggagjz1ts.svg)\n\nfunction score 查询中包含四部分内容：\n\n- 原始查询条件：query 部分，基于这个条件搜索文档，并且基于 BM25 算法给文档打分，原始算分（query score)\n- 过滤条件：filter 部分，符合该条件的文档才会重新算分\n- 算分函数：符合 filter 条件的文档要根据这个函数做运算，得到的函数算分（function score），有四种函数\n  - weight：函数结果是常量\n  - field_value_factor：以文档中的某个字段值作为函数结果\n  - random_score：以随机数作为函数结果\n  - script_score：自定义算分函数算法\n- 运算模式：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：\n  - multiply：相乘\n  - replace：用 function score 替换 query score\n  - 其它，例如：sum、avg、max、min\n\nfunction score 的运行流程如下：\n\n- 根据原始条件查询搜索文档，并且计算相关性算分，称为原始算分（query score）\n- 根据过滤条件，过滤文档\n- 符合**过滤条件**的文档，基于算分函数运算，得到函数算分（function score）\n- 将原始算分（query score）和函数算分（function score）基于运算模式做运算，得到最终结果，作为相关性算分。\n\n因此，其中的关键点是：\n\n- 过滤条件：决定哪些文档的算分被修改\n- 算分函数：决定函数算分的算法\n- 运算模式：决定最终算分结果\n\n示例\n\n需求：给“如家”这个品牌的酒店排名靠前一些。翻译一下这个需求，转换为之前说的四个要点：\n\n- 原始条件：不确定，可以任意变化\n- 过滤条件：brand = \"如家\"\n- 算分函数：可以简单粗暴，直接给固定的算分结果，weight\n- 运算模式：比如求和\n\n因此最终的 DSL 语句如下：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"function_score\": {\n      \"query\": {\n        \"match\": {\n          \"all\": \"外滩\"\n        }\n      },\n      \"functions\": [\n        {\n          \"filter\": {\n            \"term\": {\n              \"brand\": \"如家\"\n            }\n          },\n          \"weight\": 10\n        }\n      ],\n      \"boost_mode\": \"sum\"\n    }\n  }\n}\n```\n\n#### 布尔查询\n\n布尔查询是一个或多个查询子句的组合，每一个子句就是一个子查询。子查询的组合方式有：\n\n- must：必须匹配每个子查询，类似“与”\n- should：选择性匹配子查询，类似“或”\n- must_not：必须不匹配，**不参与算分**，类似“非”\n- filter：必须匹配，不参与算分\n\n比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤。\n\n每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用 bool 查询了。\n\n需要注意的是，搜索时，参与打分的字段越多，查询的性能也越差。因此这种多条件查询时，建议这样做：\n\n- 搜索框的关键字搜索，是全文检索查询，使用 must 查询，参与算分\n- 其它过滤条件，采用 filter 查询。不参与算分\n\n语法示例：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\n          \"term\": {\n            \"city\": \"上海\"\n          }\n        }\n      ],\n      \"should\": [\n        {\n          \"term\": {\n            \"brand\": \"皇冠假日\"\n          }\n        },\n        {\n          \"term\": {\n            \"brand\": \"华美达\"\n          }\n        }\n      ],\n      \"must_not\": [\n        {\n          \"range\": {\n            \"price\": {\n              \"lte\": 500\n            }\n          }\n        }\n      ],\n      \"filter\": [\n        {\n          \"range\": {\n            \"score\": {\n              \"gte\": 45\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n案例示例：\n\n需求：搜索名字包含“如家”，价格不高于 400，在坐标 31.21,121.5 周围 10km 范围内的酒店。\n\n分析：\n\n- 名称搜索，属于全文检索查询，应该参与算分。放到 must 中\n- 价格不高于 400，用 range 查询，属于过滤条件，不参与算分。放到 must_not 中\n- 周围 10km 范围内，用 geo_distance 查询，属于过滤条件，不参与算分。放到 filter 中\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\n          \"match\": {\n            \"name\": \"如家\"\n          }\n        }\n      ],\n      \"must_not\": [\n        {\n          \"range\": {\n            \"price\": {\n              \"gt\": 400\n            }\n          }\n        }\n      ],\n      \"filter\": [\n        {\n          \"geo_distance\": {\n            \"distance\": \"10km\",\n            \"location\": {\n              \"lat\": 31.21,\n              \"lon\": 121.5\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\nbool 查询有几种逻辑关系？\n\n- must：必须匹配的条件，可以理解为“与”\n- should：选择性匹配的条件，可以理解为“或”\n- must_not：必须不匹配的条件，不参与打分\n- filter：必须匹配的条件，不参与打分\n\n## DSL 搜索结果处理\n\n搜索的结果可以按照用户指定的方式去处理或展示。\n\n### 排序\n\nElasticSearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索[结果排序](https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html)。可以排序字段类型有：keyword 类型、数值类型、地理坐标类型、日期类型等。\n\n#### 普通字段排序\n\nkeyword、数值、日期类型排序的语法基本一致。\n\n**语法**：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": [\n    {\n      \"FIELD\": \"desc\"  // 排序字段、排序方式ASC、DESC\n    }\n  ]\n}\n```\n\n排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推\n\n**示例**：\n\n需求描述：酒店数据按照用户评价（score）降序排序，评价相同的按照价格（price）升序排序\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": [\n    {\n      \"score\": \"desc\"\n    },\n    {\n      \"price\": \"asc\"\n    }\n  ]\n}\n```\n\n#### 地理坐标排序\n\n地理坐标排序略有不同。\n\n**语法说明**：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": [\n    {\n      \"_geo_distance\" : {\n          \"FIELD\" : \"纬度，经度\", // 文档中geo_point类型的字段名、目标坐标点\n          \"order\" : \"asc\", // 排序方式\n          \"unit\" : \"km\" // 排序的距离单位\n      }\n    }\n  ]\n}\n```\n\n这个查询的含义是：\n\n- 指定一个坐标，作为目标点\n- 计算每一个文档中，指定字段（必须是 geo_point 类型）的坐标到目标点的距离是多少\n- 根据距离排序\n\n**示例：**\n\n需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序\n\n提示：获取经纬度的方式：https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/\n\n假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": [\n    {\n      \"_geo_distance\": {\n        \"location\": {\n          \"lat\": 31.034661,\n          \"lon\": 121.612282\n        },\n        \"order\": \"asc\",\n        \"unit\": \"km\"\n      }\n    }\n  ]\n}\n```\n\n### 分页\n\nElasticSearch 默认情况下只返回 top10 的数据。而如果要查询更多数据就需要修改分页参数了。ElasticSearch中通过修改 from、size 参数来控制要返回的分页结果：\n\n- from：从第几个文档开始\n- size：总共查询几个文档\n\n类似于 MySQL 中的 `limit ?, ?`\n\n#### 基本的分页\n\n分页的基本语法如下：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": [\n    {\n      \"price\": {\n        \"order\": \"asc\"\n      }\n    }\n  ],\n  \"from\": 0,\n  \"size\": 5\n}\n```\n\n#### 深度分页问题\n\n现在，我要查询 990~1000 的数据，查询逻辑要这么写：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"from\": 990, // 分页开始的位置，默认为0\n  \"size\": 10, // 期望获取的文档总数\n  \"sort\": [\n    {\"price\": \"asc\"}\n  ]\n}\n```\n\n这里是查询 990 开始的数据，也就是 第 990~1000 条 数据。\n\n不过，ElasticSearch 内部分页时，必须先查询 0~1000 条，然后截取其中的 990 ~ 1000 的这 10 条：\n\n查询 top 1000，如果 ElasticSearch 是单点模式，这并无太大影响。\n\n但是 ElasticSearch 将来一定是集群，例如我集群有 5 个节点，我要查询 top 1000 的数据，并不是每个节点查询 200 条就可以了。\n\n因为节点 A 的 top 200，在另一个节点可能排到 10000 名以外了。\n\n因此要想获取整个集群的 top 1000，必须先查询出每个节点的 top 1000，汇总结果后，重新排名，重新截取 top 1000。\n\n那如果我要查询 9900~10000 的数据呢？是不是要先查询 top 10000呢？那每个节点都要查询 10000 条？汇总到内存中？\n\n当查询分页深度较大时，汇总数据过多，对内存和 CPU 会产生非常大的压力，因此 ElasticSearch 会禁止 from + size 超过 10000 的请求。\n\n针对深度分页，ElasticSearch 提供了两种解决方案，[官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html)：\n\n- search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。\n- scroll：原理将排序后的文档 id 形成快照，保存在内存。官方已经不推荐使用。\n\n#### 分页小结\n\n分页查询的常见实现方案以及优缺点：\n\n- `from + size`：\n  - 优点：支持随机翻页\n  - 缺点：深度分页问题，默认查询上限（from + size）是 10000\n  - 场景：百度、京东、谷歌、淘宝这样的随机翻页搜索\n- `after search`：\n  - 优点：没有查询上限（单次查询的 size 不超过 10000）\n  - 缺点：只能向后逐页查询，不支持随机翻页\n  - 场景：没有随机翻页需求的搜索，例如手机向下滚动翻页\n\n- `scroll`：\n  - 优点：没有查询上限（单次查询的 size 不超过 10000）\n  - 缺点：会有额外内存消耗，并且搜索结果是非实时的\n  - 场景：海量数据的获取和迁移。从 ES 7.1开始不推荐，建议用 after search 方案。\n\n### 高亮\n\n高亮显示的实现分为两步：\n\n- 给文档中的所有关键字都添加一个标签，例如 `<em>` 标签\n- 页面给 `<em>` 标签编写 CSS 样式\n\n高亮的语法：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match\": {\n      \"FIELD\": \"TEXT\"\n    }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"FIELD\": {\n        \"pre_tags\": \"<em>\",\n        \"post_tags\": \"</em>\"\n      }\n    }\n  }\n}\n```\n\n**注意：**\n\n- 高亮是对关键字高亮，因此搜索条件必须带有关键字，而不能是范围这样的查询。\n- 默认情况下，高亮的字段，必须与搜索指定的字段一致，否则无法高亮\n- 如果要对非搜索字段高亮，则需要添加一个属性： `\"require_field_match\": \"false\"`\n\n示例：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match\": {\n      \"all\": \"如家\"\n    }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"name\": {\n        \"require_field_match\": \"false\"\n      }\n    }\n  }\n}\n```\n\n### 搜索结果处理小结\n\n查询的 DSL 是一个大的 JSON 对象，包含下列属性：\n\n- query：查询条件\n- from 和 size：分页条件\n- sort：排序条件\n- highlight：高亮条件\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match\": {\n      \"name\": \"如家\"\n    }\n  },\n  \"from\": 0, // 分页开始的位置\n  \"size\": 20, // 期望获取的文档总数\n  \"sort\": [ \n    {  \"price\": \"asc\" }, // 普通排序\n    {\n      \"_geo_distance\" : { // 距离排序\n          \"location\" : \"31.040699,121.618075\", \n          \"order\" : \"asc\",\n          \"unit\" : \"km\"\n      }\n    }\n  ],\n  \"highlight\": {\n    \"fields\": { // 高亮字段\n      \"name\": {\n        \"pre_tags\": \"<em>\",  // 用来标记高亮字段的前置标签\n        \"post_tags\": \"</em>\" // 用来标记高亮字段的后置标签\n      }\n    }\n  }\n}\n```\n\n## Rest Client 查询文档\n\n文档的查询同样适用 RestHighLevelClient 对象，基本步骤包括：\n\n- 准备 Request 对象\n- 准备请求参数\n- 发起请求\n- 解析响应\n\n### 快速入门\n\n我们以 match_all 查询为例\n\n#### 发起查询请求\n\n```java\n@Test\nvoid testMatchAll() throws IOException {\n    // 1.准备Request\n    SearchRequest request = new SearchRequest(\"hotel\");\n    // 2.组织DSL参数\n    request.source().query(QueryBuilders.matchAllQuery());\n    // 3.发送请求，得到响应结果\n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n    // ...解析响应结果\n}\n```\n\n代码解读：\n\n- 第一步，创建 `SearchRequest` 对象，指定索引库名\n\n- 第二步，利用 `request.source()` 构建 DSL，DSL 中可以包含查询、分页、排序、高亮等\n  - `query()`：代表查询条件，利用 `QueryBuilders.matchAllQuery()` 构建一个 match_all 查询的 DSL\n- 第三步，利用 `client.search()` 发送请求，得到响应\n\n这里关键的 API 有两个：\n\n+ 一个是 `request.source()`，其中包含了查询、排序、分页、高亮等所有功能。\n+ 另一个是 `QueryBuilders`，其中包含 match、term、function_score、bool 等各种查询：\n\n#### 解析响应\n\nElasticSearch 返回的结果是一个 JSON 字符串，结构包含：\n\n```json\n{\n   \"took\" : 0,\n   \"timed_out\" : false,\n   \"hits\" : {\n    \"total\" : {\n      \"value\" : 2,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"heima\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"1\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"info\" : \"Java讲师\", 	\"name\" : \"赵云\",\n       }\n      },\n      // ...\n    ]\n  }\n}\n```\n\n- `hits`：命中的结果\n  - `total`：总条数，其中的 value 是具体的总条数值\n  - `max_score`：所有结果中得分最高的文档的相关性算分\n  - `hits`：搜索结果的文档数组，其中的每个文档都是一个 JSON 对象\n    - `_source`：文档中的原始数据，也是 JSON 对象\n\n因此，我们解析响应结果，就是逐层解析 JSON 字符串，流程如下：\n\n```java\n@Test\nvoid testMatchAll() throws IOException {\n    // ... 略\n    // 4.解析结果\n    SearchHits searchHits = response.getHits();\n    // 4.1.查询的总条数\n    long total = searchHits.getTotalHits().value;\n    // 4.2.查询的结果数组\n    SearchHit[] hits = searchHits.getHits();\n    for (SearchHit hit : hits) {\n        // 4.3.得到source\n        String json = hit.getSourceAsString();\n        // 4.4.打印\n        System.out.println(json);\n    }\n}\n```\n\n- `SearchHits`：通过 `response.getHits()` 获取，就是 JSON 中的最外层的hits，代表命中的结果\n  - `SearchHits#getTotalHits().value`：获取总条数信息\n  - `SearchHits#getHits()`：获取 SearchHit 数组，也就是文档数组\n    - `SearchHit#getSourceAsString()`：获取文档结果中的_source，也就是原始的 JSON 文档数据\n\n#### 完整代码\n\n```java\n    @Test\n    void testMatchAll() throws IOException {\n        // 1.准备 Request\n        SearchRequest request = new SearchRequest(\"hotel\");\n        // 2.组织 DSL 参数\n        request.source().query(QueryBuilders.matchAllQuery());\n        // 3.发送请求，得到响应结果\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n        // 4.解析结果\n        SearchHits searchHits = response.getHits();\n        // 4.1.查询的总条数\n        long total = searchHits.getTotalHits().value;\n        System.err.println(\"total = \" + total);\n        // 4.2.查询的结果数组\n        SearchHit[] hits = searchHits.getHits();\n        for (SearchHit hit : hits) {\n            // 4.3.得到source\n            String json = hit.getSourceAsString();\n            // 反序列化\n            HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);\n            // 4.4.打印\n            System.out.println(hotelDoc);\n        }\n    }\n```\n\n#### 快速入门小结\n\n查询的基本步骤是：\n\n1. 创建 SearchRequest 对象\n2. 准备 `Request.source()`，也就是 DSL。\n   + QueryBuilders 来构建查询条件\n   + 传入 `Request.source()` 的 `query()` 方法\n3. 发送请求，得到结果\n4. 解析结果（参考 JSON 结果，从外到内，逐层解析）\n\n### match 查询\n\n全文检索的 match 和 multi_match 查询与 match_all 的 API 基本一致。差别是查询条件，也就是 query 的部分。\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  }\n}\n\nGET /hotel/_search\n{\n  \"query\": {\n    \"match\": {\n      \"all\": \"如家\"\n    }\n  }\n}\n\nGET /hotel/_search\n{\n  \"query\": {\n    \"multi_match\": {\n      \"query\": \"如家\",\n      \"fields\": [\"brand\", \"name\"]\n    }\n  }\n}\n```\n\n因此，Java 代码上的差异主要是 `request.source().query()` 中的参数了。同样是利用 QueryBuilders 提供的方法：\n\n```java\n// 单字段查询\nQueryBuilders.matchQuery(\"all\", \"如家\");\n// 多字段查询\nQueryBuilders.multiMatchQuery(\"如家\", \"name\", \"business\");\n```\n\n而结果解析代码则完全一致，可以抽取并共享。\n\n完整代码如下：\n\n```java\n@Test\nvoid testMatch() throws IOException {\n    // 1.准备Request\n    SearchRequest request = new SearchRequest(\"hotel\");\n    // 2.准备DSL\n    request.source().query(QueryBuilders.matchQuery(\"all\", \"如家\"));\n    // 3.发送请求\n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n    // 4.解析响应\n    handleResponse(response);\n}\n```\n\n> IDEA 代码抽取 Ctrl + Alt + M\n\n### 精确查询\n\n精确查询主要是两者：\n\n- term：词条精确匹配\n- range：范围查询\n\n与之前的查询相比，差异同样在查询条件，其它都一样。\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"term\": {\n      \"city\": \"杭州\"\n    }\n  }\n}\nGET /hotel/_search\n{\n  \"query\": {\n    \"range\": {\n      \"price\": { \"gte\": 100, \"lte\": 150 }\n    }\n  }\n}\n```\n\n查询条件构造的 API 如下：\n\n```java\n// 词条查询\nQueryBuilders.termQuery(\"city\", \"杭州\"); \n// 范围查询\nQueryBuilders.rangeQuery(\"price\").gte(100).lte(150);\n```\n\n### 布尔查询\n\n布尔查询是用 must、must_not、filter 等方式组合其它查询，代码示例如下：\n\n```java\n// 创建布尔查询\nBoolQueryBuilder boolQuery = QueryBuilders.boolQuery();\n// 添加must条件\nboolQuery.must(QueryBuilders.termQuery(\"city\", \"杭州\")); \n// 添加filter条件\nboolQuery.filter(QueryBuilders.rangeQuery(\"price\").lte(250));\n```\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\n          \"term\": { \"city\": \"杭州\" }\n        }\n      ],\n      \"filter\": [\n        {\n          \"range\": {\n            \"price\": { \"lte\": 250 }\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n可以看到，API 与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。\n\n示例代码：\n\n```java\n@Test\nvoid testBool() throws IOException {\n    // 1.准备Request\n    SearchRequest request = new SearchRequest(\"hotel\");\n    \n    // 2.准备DSL\n    // 2.1.准备BooleanQuery\n    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();\n    // 2.2.添加term\n    boolQuery.must(QueryBuilders.termQuery(\"city\", \"上海\"));\n    // 2.3.添加range\n    boolQuery.filter(QueryBuilders.rangeQuery(\"price\").lte(250));\n    \n    request.source().query(boolQuery);\n    \n    // 3.发送请求\n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n    \n    // 4.解析响应\n    handleResponse(response);\n}\n```\n\n\n\n## Rest Client 搜索结果处理\n\n### 排序与分页\n\n搜索结果的排序和分页是与 query 同级的参数，因此同样是使用 `request.source()` 来设置。\n\n对应的 API 如下：\n\n```java\n// 查询 \nrequest.source().query(QueryBuilders.matchAllQuery());\n// 排序\nrequest.source().sort(\"price\", SortOrder.ASC);\n// 分页\nrequest.source().from(0).size(5);\n```\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"from\": 0,\n  \"size\": 5, \n  \"sort\": [\n    {\n      \"FIELD\": \"desc\"  \n    },\n  ]\n}\n```\n\n代码示例：\n\n```java\n@Test\nvoid testPageAndSort() throws IOException {\n    // 页码，每页大小\n    int page = 1, size = 5;\n    // 1.准备Request\n    SearchRequest request = new SearchRequest(\"hotel\");\n    // 2.准备DSL\n    // 2.1.query\n    request.source().query(QueryBuilders.matchAllQuery());\n    // 2.2.排序 sort\n    request.source().sort(\"price\", SortOrder.ASC);\n    // 2.3.分页 from、size\n    request.source().from((page - 1) * size).size(size);\n    // 3.发送请求\n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n    // 4.解析响应\n    handleResponse(response);\n}\n```\n\n### 高亮\n\n高亮的代码与之前代码差异较大，有两点：\n\n- 查询的 DSL：其中除了查询条件，还需要添加高亮条件，同样是与 query 同级。\n- 结果解析：结果除了要解析 _source 文档数据，还要解析高亮结果\n\n#### 高亮请求构建\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match\": {\n      \"all\": \"如家\"\n    }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"name\": {\n        \"require_field_match\": \"false\"\n      }\n    }\n  }\n}\n```\n\n高亮请求的构建 API 如下：\n\n```java\nrequest.source().highlighter(new HighlightBuilder().field(\"name\").requireFieldMatch(false));\n```\n\n上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。\n\n示例代码如下：\n\n```java\n@Test\nvoid testHighlight() throws IOException {\n    // 1.准备Request\n    SearchRequest request = new SearchRequest(\"hotel\");\n    // 2.准备DSL\n    // 2.1.query\n    request.source().query(QueryBuilders.matchQuery(\"all\", \"如家\"));\n    // 2.2.高亮\n    request.source().highlighter(new HighlightBuilder().field(\"name\").requireFieldMatch(false));\n    // 3.发送请求\n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n    // 4.解析响应\n    handleResponse(response);\n}\n```\n\n#### 高亮结果解析\n\n高亮的结果与查询的文档结果默认是分离的，并不在一起。\n\n```json\n{\n  \"_index\" : \"hotel\",\n  \"_type\" : \"_doc\",\n  \"_id\" : \"339952837\",\n  \"_score\" : 2.8947515,\n  \"_source\" : {\n    \"id\" : 339952837,\n    \"name\" : \"如家酒店(北京良乡西路店)\",\n    \"price\" : 159,\n    \"score\" : 46,\n    \"brand\" : \"如家\",\n    \"city\" : \"北京\",\n    \"location\" : \"39.73167, 116.132482\",\n    \"pic\" : \"t0.jpg\"\n  },\n  \"highlight\" : {\n    \"name\" : [\n      \"<em>如家</em>酒店(北京良乡西路店)\",\n    ]\n  }\n}\n```\n\n因此解析高亮的代码需要额外处理：\n\n```java\n// 获取source\nHotelDoc hotelDoc = JSON.parseObject(hit.getSourceAsString(), HotelDoc.class);\n// 处理高亮\nMap<String, HighlightField> highlightFields = hit.getHighlightFields();\nif (!CollectionUtils.isEmpty(highlightFields)) {\n    // 获取高亮字段结果\n    HighlightField highlightField = highlightFields.get(\"name\");\n    if (highlightField != null) {\n        // 取出高亮结果数组中的第一个，就是酒店名称\n        String name = highlightField.getFragments()[0].string();\n        hotelDoc.setName(name);\n    }\n}\n```\n\n代码解读：\n\n- 第一步：从结果中获取 source。`hit.getSourceAsString()`，这部分是非高亮结果，JSON 字符串。还需要反序列为 HotelDoc 对象\n- 第二步：获取高亮结果。`hit.getHighlightFields()`，返回值是一个 Map，key 是高亮字段名称，值是 HighlightField 对象，代表高亮值\n- 第三步：从 Map 中根据高亮字段名称，获取高亮字段值对象HighlightField\n- 第四步：从HighlightField 中获取 Fragments，并且转为字符串。这部分就是真正的高亮字符串了\n- 第五步：用高亮的结果替换 HotelDoc 中的非高亮结果\n\n## 酒店搜索案例\n\n下面，我们通过酒店搜索案例来实战演练下之前学习的知识。\n\n我们实现四部分功能：\n\n- 酒店搜索和分页\n- 酒店结果过滤\n- 我周边的酒店\n- 酒店竞价排名\n\n启动 hotel-demo 项目，其默认端口是 8089，访问 http://localhost:8090，就能看到项目页面了。\n\n### 酒店搜索和分页\n\n案例需求：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页\n\n#### 需求分析\n\n- 请求方式：POST\n- 请求路径：/hotel/list\n- 请求参数：JSON 对象，包含4个字段：\n  - key：搜索关键字\n  - page：页码\n  - size：每页大小\n  - sortBy：排序，目前暂不实现\n- 返回值：分页查询，需要返回分页结果 PageResult，包含两个属性：\n  - `total`：总条数\n  - `List<HotelDoc>`：当前页的数据\n\n因此，我们实现业务的流程如下：\n\n- 步骤一：定义实体类，接收请求参数的 JSON 对象\n- 步骤二：编写 controller，接收页面的请求\n- 步骤三：编写业务实现，利用 RestHighLevelClient 实现搜索、分页\n\n#### 定义实体类\n\n实体类有两个，一个是前端的请求参数实体，一个是服务端应该返回的响应结果实体。\n\n① 请求参数，前端请求的 JSON 结构如下：\n\n```json\n{\n    \"key\": \"搜索关键字\",\n    \"page\": 1,\n    \"size\": 3,\n    \"sortBy\": \"default\"\n}\n```\n\n因此，我们在 `cn.itcast.hotel.pojo` 包下定义一个实体类：\n\n```java\npackage cn.itcast.hotel.pojo;\n\nimport lombok.Data;\n\n@Data\npublic class RequestParams {\n    private String key;\n    private Integer page;\n    private Integer size;\n    private String sortBy;\n}\n```\n\n② 返回值，分页查询，需要返回分页结果 PageResult，包含两个属性：\n\n- `total` ：总条数\n- `List<HotelDoc>` ：当前页的数据\n\n因此，我们在 `cn.itcast.hotel.pojo` 中定义返回结果：\n\n```java\npackage cn.itcast.hotel.pojo;\n\nimport lombok.Data;\n\nimport java.util.List;\n\n@Data\npublic class PageResult {\n    private Long total;\n    private List<HotelDoc> hotels;\n\n    public PageResult() {\n    }\n\n    public PageResult(Long total, List<HotelDoc> hotels) {\n        this.total = total;\n        this.hotels = hotels;\n    }\n}\n```\n\n#### 定义 controller\n\n定义一个 HotelController，声明查询接口，满足下列要求：\n\n- 请求方式：Post\n- 请求路径：/hotel/list\n- 请求参数：对象，类型为 RequestParam\n- 返回值：PageResult，包含两个属性\n  - `Long total`：总条数\n  - `List<HotelDoc> hotels`：酒店数据\n\n因此，我们在 `cn.itcast.hotel.web` 中定义 HotelController：\n\n```java\n@RestController\n@RequestMapping(\"/hotel\")\npublic class HotelController {\n\n    @Autowired\n    private IHotelService hotelService;\n	// 搜索酒店数据\n    @PostMapping(\"/list\")\n    public PageResult search(@RequestBody RequestParams params){\n        return hotelService.search(params);\n    }\n}\n```\n\n#### 实现搜索业务\n\n我们在 controller 调用了 IHotelService，并没有实现该方法，因此下面我们就在 IHotelService 中定义方法，并且去实现业务逻辑。\n\n① 在 `cn.itcast.hotel.service` 中的 `IHotelService` 接口中定义一个方法：\n\n```java\n/**\n * 根据关键字搜索酒店信息\n * @param params 请求参数对象，包含用户输入的关键字 \n * @return 酒店文档列表\n */\nPageResult search(RequestParams params);\n```\n\n② 实现搜索业务，肯定离不开 RestHighLevelClient，我们需要把它注册到 Spring 中作为一个 Bean。在 `cn.itcast.hotel` 中的 `HotelDemoApplication` 中声明这个 Bean：\n\n```java\n@Bean\npublic RestHighLevelClient client() {\n    return new RestHighLevelClient(RestClient.builder(HttpHost.create(\"http://halo:9200\")));\n}\n```\n\n③ 在 `cn.itcast.hotel.service.impl` 中的 `HotelService` 中实现 search 方法：\n\n```java\n@Autowired\nprivate RestHighLevelClient client;\n\n@Override\npublic PageResult search(RequestParams params) {\n    try {\n        // 1.准备Request\n        SearchRequest request = new SearchRequest(\"hotel\");\n        // 2.准备DSL\n        // 2.1.query\n        String key = params.getKey();\n        if (key == null || \"\".equals(key)) {\n            request.source().query(QueryBuilders.matchAllQuery());\n        } else {\n            request.source().query(QueryBuilders.matchQuery(\"all\", key));\n        }\n\n        // 2.2.分页\n        int page = params.getPage();\n        int size = params.getSize();\n        request.source().from((page - 1) * size).size(size);\n\n        // 3.发送请求\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n        // 4.解析响应\n        return handleResponse(response);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n\n// 结果解析\nprivate PageResult handleResponse(SearchResponse response) {\n    // 4.解析响应\n    SearchHits searchHits = response.getHits();\n    // 4.1.获取总条数\n    long total = searchHits.getTotalHits().value;\n    // 4.2.文档数组\n    SearchHit[] hits = searchHits.getHits();\n    // 4.3.遍历\n    List<HotelDoc> hotels = new ArrayList<>();\n    for (SearchHit hit : hits) {\n        // 获取文档source\n        String json = hit.getSourceAsString();\n        // 反序列化\n        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);\n        // 放入集合\n        hotels.add(hotelDoc);\n    }\n    // 4.4.封装返回\n    return new PageResult(total, hotels);\n}\n```\n\n### 酒店结果过滤\n\n需求：添加品牌、城市、星级、价格等过滤功能\n\n#### 需求分析\n\n包含的过滤条件有：\n\n- brand：品牌值\n- city：城市\n- minPrice~maxPrice：价格范围\n- starName：星级\n\n我们需要做两件事情：\n\n- 修改请求参数的对象 RequestParams，接收上述参数\n- 修改业务逻辑，在搜索条件之外，添加一些过滤条件\n\n#### 修改实体类\n\n修改在 `cn.itcast.hotel.pojo` 包下的实体类 RequestParams：\n\n```java\n@Data\npublic class RequestParams {\n    private String key;\n    private Integer page;\n    private Integer size;\n    private String sortBy;\n    // 下面是新增的过滤条件参数\n    private String city;\n    private String brand;\n    private String starName;\n    private Integer minPrice;\n    private Integer maxPrice;\n}\n```\n\n#### 修改搜索业务\n\n在 HotelService 的 search 方法中，只有一个地方需要修改：`requet.source().query( ... )` 其中的查询条件。\n\n在之前的业务中，只有 match 查询，根据关键字搜索，现在要添加条件过滤，包括：\n\n- 品牌过滤：是 keyword 类型，用 term 查询\n- 星级过滤：是 keyword 类型，用 term 查询\n- 价格过滤：是数值类型，用 range 查询\n- 城市过滤：是 keyword 类型，用 term 查询\n\n多个查询条件组合，肯定是 boolean 查询来组合：\n\n- 关键字搜索放到 must 中，参与算分\n- 其它过滤条件放到 filter 中，不参与算分\n\n因为条件构建的逻辑比较复杂，这里封装为一个函数，getBoolQueryBuilder 的代码如下：\n\n```java\nprivate BoolQueryBuilder getBoolQueryBuilder(RequestParams params) {\n    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();\n    String key = params.getKey();\n    if (key == null || \"\".equals(key)) {\n        boolQuery.must(QueryBuilders.matchAllQuery());\n    } else {\n        boolQuery.must(QueryBuilders.matchQuery(\"all\", key));\n    }\n    // 条件过滤\n    // 城市条件\n    if (params.getCity() != null && !params.getCity().equals(\"\")) {\n        boolQuery.filter(QueryBuilders.termQuery(\"city\", params.getCity()));\n    }\n    // 品牌条件\n    if (params.getBrand() != null && !params.getBrand().equals(\"\")) {\n        boolQuery.filter(QueryBuilders.termQuery(\"brand\", params.getBrand()));\n    }\n    // 星级\n    if (params.getStarName() != null && !params.getStarName().equals(\"\")) {\n        boolQuery.filter(QueryBuilders.termQuery(\"starName\", params.getStarName()));\n    }\n    // 价格\n    if (params.getMinPrice() != null && params.getMaxPrice() != null) {\n        boolQuery.filter(QueryBuilders.rangeQuery(\"price\")\n                         .gte(params.getMinPrice()).lte(params.getMaxPrice()));\n    }\n    return boolQuery;\n}\n```\n\n### 我周边的酒店\n\n需求：我附近的酒店\n\n#### 需求分析\n\n在酒店列表页的右侧，有一个小地图，点击地图的定位按钮，地图会找到你所在的位置，并且，在前端会发起查询请求，将你的坐标发送到服务端。\n\n我们要做的事情就是基于这个 location 坐标，然后按照距离对周围酒店排序。实现思路如下：\n\n- 修改 RequestParams 参数，接收 location 字段\n- 修改 search 方法业务逻辑，如果 location 有值，添加根据 geo_distance 排序的功能\n\n#### 修改实体类\n\n修改在 `cn.itcast.hotel.pojo` 包下的实体类 RequestParams：\n\n```java\npackage cn.itcast.hotel.pojo;\n\nimport lombok.Data;\n\n@Data\npublic class RequestParams {\n    private String key;\n    private Integer page;\n    private Integer size;\n    private String sortBy;\n    private String city;\n    private String brand;\n    private String starName;\n    private Integer minPrice;\n    private Integer maxPrice;\n    // 我当前的地理坐标\n    private String location;\n}\n```\n\n#### 距离排序 API\n\n我们以前学习过排序功能，包括两种：\n\n- 普通字段排序\n- 地理坐标排序\n\n我们只讲了普通字段排序对应的 Java 写法。地理坐标排序只学过 DSL 语法，如下：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": [\n    {\n      \"price\": \"asc\"  \n    },\n    {\n      \"_geo_distance\" : {\n          \"FIELD\" : \"纬度，经度\",\n          \"order\" : \"asc\",\n          \"unit\" : \"km\"\n      }\n    }\n  ]\n}\n```\n\n对应 Java 代码\n\n```java\n// 价格排序\nrequest.source().sort(\"price\", SortOrder.ASC);\n// 距离排序\nrequest.source().sort(SortBuilders.geoDistanceSort(\"location\", new GeoPoint(\"31.21, 121.5\"))\n                      .order(SortOrder.ASC).unit(DistanceUnit.KILOMETERS));\n```\n\n#### 添加距离排序\n\n在 `cn.itcast.hotel.service.impl` 的 `HotelService` 的 `search` 方法中，添加一个排序功能：\n\n```java\n@Override\npublic PageResult search(RequestParams params) {\n    try {\n        // 1.准备Request\n        SearchRequest request = new SearchRequest(\"hotel\");\n        // 2.准备DSL\n        // 2.1.query\n        // 构建 boolQuery\n        BoolQueryBuilder boolQuery = getBoolQueryBuilder(params);\n        request.source().query(boolQuery);\n\n        // 2.2.分页\n        int page = params.getPage();\n        int size = params.getSize();\n        request.source().from((page - 1) * size).size(size);\n\n        // 排序\n        String location = params.getLocation();\n        if (location != null && !location.equals(\"\")) {\n            request.source().sort(SortBuilders\n                                  .geoDistanceSort(\"location\", new GeoPoint(location))\n                                  .order(SortOrder.ASC)\n                                  .unit(DistanceUnit.KILOMETERS));\n        }\n\n        // 3.发送请求\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n        // 4.解析响应\n        return handleResponse(response);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n\n#### 排序距离显示\n\n排序完成后，页面还要获取我附近每个酒店的具体**距离**值，这个值在响应结果中是独立的：\n\n因此，我们在结果解析阶段，除了解析 source 部分以外，还要得到 sort 部分，也就是排序的距离，然后放到响应结果中。\n\n我们要做两件事：\n\n- 修改 HotelDoc，添加排序距离字段，用于页面显示\n- 修改 HotelService 类中的 handleResponse 方法，添加对 sort 值的获取\n\n① 修改HotelDoc类，添加距离字段\n\n```java\npackage cn.itcast.hotel.pojo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n\n@Data\n@NoArgsConstructor\npublic class HotelDoc {\n    private Long id;\n    private String name;\n    private String address;\n    private Integer price;\n    private Integer score;\n    private String brand;\n    private String city;\n    private String starName;\n    private String business;\n    private String location;\n    private String pic;\n    // 排序时的 距离值\n    private Object distance;\n\n    public HotelDoc(Hotel hotel) {\n        this.id = hotel.getId();\n        this.name = hotel.getName();\n        this.address = hotel.getAddress();\n        this.price = hotel.getPrice();\n        this.score = hotel.getScore();\n        this.brand = hotel.getBrand();\n        this.city = hotel.getCity();\n        this.starName = hotel.getStarName();\n        this.business = hotel.getBusiness();\n        this.location = hotel.getLatitude() + \", \" + hotel.getLongitude();\n        this.pic = hotel.getPic();\n    }\n}\n```\n\n② 修改 HotelService 中的 handleResponse 方法\n\n```java\n// 结果解析\nprivate PageResult handleResponse(SearchResponse response) {\n    // 4.解析响应\n    SearchHits searchHits = response.getHits();\n    // 4.1.获取总条数\n    long total = searchHits.getTotalHits().value;\n    // 4.2.文档数组\n    SearchHit[] hits = searchHits.getHits();\n    // 4.3.遍历\n    List<HotelDoc> hotels = new ArrayList<>();\n    for (SearchHit hit : hits) {\n        // 获取文档source\n        String json = hit.getSourceAsString();\n        // 反序列化\n        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);\n        // 获取排序值 - location\n        Object[] sortValues = hit.getSortValues();\n        if (sortValues.length > 0) {\n            Object sortValue = sortValues[0];\n            hotelDoc.setDistance(sortValue);\n        }\n\n        // 放入集合\n        hotels.add(hotelDoc);\n    }\n    // 4.4.封装返回\n    return new PageResult(total, hotels);\n}\n```\n\n### 酒店竞价排名\n\n需求：让指定的酒店在搜索结果中排名置顶\n\n#### 需求分析\n\n要让指定酒店在搜索结果中排名置顶，页面会给指定的酒店添加**广告**标记。\n\n我们之前学习过的 function_score 查询可以影响算分，算分高了，自然排名也就高了。而 function_score 包含 3 个要素：\n\n- 过滤条件：哪些文档要加分\n- 算分函数：如何计算 function score\n- 加权方式：function score 与 query score 如何运算\n\n这里的需求是：让**指定酒店**排名靠前。因此我们需要给这些酒店添加一个标记，这样在过滤条件中就可以根据这个标记来判断，是否要提高算分。\n\n比如，我们给酒店添加一个字段：isAD，Boolean 类型：\n\n- true：是广告\n- false：不是广告\n\n这样 function_score 包含 3 个要素就很好确定了：\n\n- 过滤条件：判断 isAD 是否为 true\n- 算分函数：我们可以用最简单暴力的 weight，固定加权值\n- 加权方式：可以用默认的相乘，大大提高算分\n\n因此，业务的实现步骤包括：\n\n1. 给 HotelDoc 类添加 isAD 字段，Boolean 类型\n\n2. 挑选几个你喜欢的酒店，给它的文档数据添加 isAD 字段，值为 true\n\n3. 修改 search方法，添加 function score 功能，给 isAD 值为 true 的酒店增加权重\n\n#### 修改 HotelDoc 实体\n\n给 `cn.itcast.hotel.pojo` 包下的 HotelDoc 类添加 isAD 字段：\n\n```java\n@Data\n@NoArgsConstructor\npublic class HotelDoc {\n    private Long id;\n    private String name;\n    private String address;\n    private Integer price;\n    private Integer score;\n    private String brand;\n    private String city;\n    private String starName;\n    private String business;\n    private String location;\n    private String pic;\n    // 排序时的距离值\n    private Object distance;\n    private Boolean isAD;\n\n    public HotelDoc(Hotel hotel) {\n        this.id = hotel.getId();\n        this.name = hotel.getName();\n        this.address = hotel.getAddress();\n        this.price = hotel.getPrice();\n        this.score = hotel.getScore();\n        this.brand = hotel.getBrand();\n        this.city = hotel.getCity();\n        this.starName = hotel.getStarName();\n        this.business = hotel.getBusiness();\n        this.location = hotel.getLatitude() + \", \" + hotel.getLongitude();\n        this.pic = hotel.getPic();\n    }\n}\n```\n\n#### 添加广告标记\n\n用 DSL 添加酒店广告标记\n\n```java\nPOST /hotel/_update/36934\n{\n  \"doc\": {\n    \"isAD\": true\n  }\n}\n```\n\n#### 添加算分函数查询\n\n接下来我们就要修改查询条件了。之前是用的 boolean 查询，现在要改成 function_socre 查询。\n\nfunction_score 查询结构如下：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"function_score\": {\n      \"query\": {\n        \"match\": {\n          \"name\": \"外滩\"\n        }\n      },\n      \"functions\": [ \n        {\n          \"filter\": {\n            \"term\": {\n              \"brand\": \"如家\"\n            }\n          },\n          \"weight\": 5\n        }\n      ]\n    }\n  }\n}\n```\n\n对应的 JavaAPI 如下\n\n```java\nFunctionScoreQueryBuilder functionScoreQueryBuilder = \n    QueryBuilders.functionScoreQuery(\n        QueryBuilders.matchQuery(\"name\", \"外滩\"),\n        new FunctionScoreQueryBuilder.FilterFunctionBuilder[]{\n            new FunctionScoreQueryBuilder.FilterFunctionBuilder(\n                QueryBuilders.termQuery(\"brand\", \"如家\"), \n                ScoreFunctionBuilders.weightFactorFunction(5)\n            )\n        }\n	);\nsourceBuilder.query(functionScoreQueryBuilder);\n```\n\n我们可以将之前写的 boolean 查询作为**原始查询**条件放到 query 中，接下来就是添加过滤条件、算分函数、加权模式了。所以原来的代码依然可以沿用。\n\n修改 `cn.itcast.hotel.service.impl` 包下的 `HotelService` 类中的 `getQueryBuilder` 方法，添加算分函数查询：\n\n```java\nprivate FunctionScoreQueryBuilder getQueryBuilder(RequestParams params) {\n    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();\n    String key = params.getKey();\n    if (key == null || \"\".equals(key)) {\n        boolQuery.must(QueryBuilders.matchAllQuery());\n    } else {\n        boolQuery.must(QueryBuilders.matchQuery(\"all\", key));\n    }\n    // 条件过滤\n    // 城市条件\n    if (params.getCity() != null && !params.getCity().equals(\"\")) {\n        boolQuery.filter(QueryBuilders.termQuery(\"city\", params.getCity()));\n    }\n    // 品牌条件\n    if (params.getBrand() != null && !params.getBrand().equals(\"\")) {\n        boolQuery.filter(QueryBuilders.termQuery(\"brand\", params.getBrand()));\n    }\n    // 星级\n    if (params.getStarName() != null && !params.getStarName().equals(\"\")) {\n        boolQuery.filter(QueryBuilders.termQuery(\"starName\", params.getStarName()));\n    }\n    // 价格\n    if (params.getMinPrice() != null && params.getMaxPrice() != null) {\n        boolQuery.filter(QueryBuilders.rangeQuery(\"price\")\n                         .gte(params.getMinPrice()).lte(params.getMaxPrice()));\n    }\n\n    // 算分控制\n    FunctionScoreQueryBuilder functionScoreQueryBuilder =\n        QueryBuilders.functionScoreQuery(\n        // 原始查询，相关性算分\n        boolQuery,\n        // function score\n        new FunctionScoreQueryBuilder.FilterFunctionBuilder[]{\n            // 一个 function score 元素\n            new FunctionScoreQueryBuilder.FilterFunctionBuilder(\n                // 过滤条件\n                QueryBuilders.termQuery(\"isAD\", true),\n                // 算分函数\n                ScoreFunctionBuilders.weightFactorFunction(10)\n            )\n        });\n\n    return functionScoreQueryBuilder;\n}\n```\n\n## 数据聚合\n\n[聚合](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html)（aggregation） 可以让我们极其方便的实现对数据的统计、分析、运算。例如：\n\n- 什么品牌的手机最受欢迎？\n- 这些手机的平均价格、最高价格、最低价格？\n- 这些手机每月的销售情况如何？\n\n实现这些统计功能的比数据库的 SQL 要方便的多，而且查询速度非常快，可以实现近实时搜索效果。\n\n### 聚合的种类\n\n聚合常见的有三类：\n\n- 桶（Bucket）聚合：用来对文档做分组\n  - TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组\n  - Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组\n\n- 度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等\n  - Avg：求平均值\n  - Max：求最大值\n  - Min：求最小值\n  - Stats：同时求 max、min、avg、sum 等\n- 管道（pipeline）聚合：其它聚合的结果为基础做聚合\n\n> **注意：**参加聚合的字段必须是 keyword、日期、数值、布尔类型\n\n### DSL 实现聚合\n\n现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。\n\n此时可以根据酒店品牌的名称做聚合，也就是 Bucket 聚合。\n\n#### Bucket 聚合语法\n\n语法如下：\n\n```json\nGET /hotel/_search\n{\n  \"size\": 0,  // 设置 size 为 0，结果中不包含文档，只包含聚合结果\n  \"aggs\": { // 定义聚合\n    \"brandAgg\": { //给聚合起个名字\n      \"terms\": { // 聚合的类型，按照品牌值聚合，所以选择term\n        \"field\": \"brand\", // 参与聚合的字段\n        \"size\": 5 // 希望获取的聚合结果数量\n      }\n    }\n  }\n}\n```\n\n结果如下：\n\n```json\n{\n  \"took\" : 36,\n  \"timed_out\" : false,\n  \"_shards\" : {\n    \"total\" : 1,\n    \"successful\" : 1,\n    \"skipped\" : 0,\n    \"failed\" : 0\n  },\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 201,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : null,\n    \"hits\" : [ ]\n  },\n  \"aggregations\" : {\n    \"brandAgg\" : {\n      \"doc_count_error_upper_bound\" : 0,\n      \"sum_other_doc_count\" : 96,\n      \"buckets\" : [\n        {\n          \"key\" : \"7天酒店\",\n          \"doc_count\" : 30\n        },\n        {\n          \"key\" : \"如家\",\n          \"doc_count\" : 30\n        },\n        {\n          \"key\" : \"皇冠假日\",\n          \"doc_count\" : 17\n        },\n        {\n          \"key\" : \"速8\",\n          \"doc_count\" : 15\n        },\n        {\n          \"key\" : \"万怡\",\n          \"doc_count\" : 13\n        }\n      ]\n    }\n  }\n}\n```\n\n#### 聚合结果排序\n\n默认情况下，Bucket 聚合会统计 Bucket 内的文档数量，记为 `_count`，并且按照 `_count` 降序排序。\n\n我们可以指定 order 属性，自定义聚合的排序方式：\n\n```json\nGET /hotel/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"brandAgg\": {\n      \"terms\": {\n        \"field\": \"brand\",\n        \"order\": {\n          \"_count\": \"asc\" // 按照 _count 升序排列\n        }, \n        \"size\": 5\n      }\n    }\n  }\n}\n```\n\n#### 限定聚合范围\n\n默认情况下，Bucket 聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。\n\n我们可以限定要聚合的文档范围，只要添加 query 条件即可：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"range\": {\n      \"price\": {\n        \"lte\": 200 // 只对200元以下的文档聚合\n      }\n    }\n  }, \n  \"size\": 0,\n  \"aggs\": {\n    \"brandAgg\": {\n      \"terms\": {\n        \"field\": \"brand\",\n        \"size\": 5\n      }\n    }\n  }\n}\n```\n\n#### Metric 聚合语法\n\n现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的 min、max、avg 等值。\n\n这就要用到 Metric 聚合了，例如 stats 聚合：就可以获取 min、max、avg 等结果。\n\n语法如下：\n\n```json\nGET /hotel/_search\n{\n  \"size\": 0, \n  \"aggs\": {\n    \"brandAgg\": { \n      \"terms\": { \n        \"field\": \"brand\", \n        \"size\": 5\n      },\n      \"aggs\": { // 是brands聚合的子聚合，也就是分组后对每组分别计算\n        \"score_stats\": { // 聚合名称\n          \"stats\": { // 聚合类型，这里stats可以计算min、max、avg等\n            \"field\": \"score\" // 聚合字段，这里是score\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n这次的 score_stats 聚合是在 brandAgg 的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。\n\n另外，我们还可以给聚合结果做个排序：\n\n```json\nGET /hotel/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"brandAgg\": {\n      \"terms\": {\n        \"field\": \"brand\",\n        \"size\": 5,\n        \"order\": {\n          \"scoreAgg.avg\": \"desc\"\n        }\n      },\n      \"aggs\": {\n        \"scoreAgg\": {\n          \"stats\": {\n            \"field\": \"score\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n#### DSL 实现聚合小结\n\naggs 代表聚合，与 query 同级，此时 query 的作用是？\n\n- 限定聚合的的文档范围\n\n聚合必须的三要素：\n\n- 聚合名称\n- 聚合类型\n- 聚合字段\n\n聚合可配置属性有：\n\n- size：指定聚合结果数量\n- order：指定聚合结果排序方式\n- field：指定聚合字段\n\n### Rest Client 实现聚合\n\n#### API 语法\n\n聚合条件与 query 条件同级别，因此需要使用 `request.source()` 来指定聚合条件。\n\n聚合条件的语法：\n\n```java\nrequest.source().size(0);\nrequest.source().aggregation(\n    AggregationBuilders\n    .terms(\"brand_agg\")\n    .field(\"brand\")\n    .size(20)\n);\n```\n\n聚合的结果也与查询结果不同，API 也比较特殊。不过同样是 JSON 逐层解析：\n\n```java\n// 4. 解析结果\n// 4.1 获取 aggregations\nAggregations aggregations = response.getAggregations();\n// 4.2 根据名称获取聚合结果\nTerms brandTerms = aggregations.get(\"brandAgg\");\n// 4.3 获取 buckets 并遍历\nfor (Terms.Bucket bucket : brandTerms.getBuckets()) {\n    // 获取 key\n    String key = bucket.getKeyAsString();\n    System.out.println(key);\n}\n```\n\n#### 业务需求\n\n需求：搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的\n\n分析：目前，页面的城市列表、星级列表、品牌列表都是写死的，并不会随着搜索结果的变化而变化。但是用户搜索条件改变时，搜索结果会跟着变化。\n\n例如：用户搜索“东方明珠”，那搜索的酒店肯定是在上海东方明珠附近，因此，城市只能是上海，此时城市列表中就不应该显示北京、深圳、杭州这些信息了。也就是说，搜索结果中包含哪些城市，页面就应该列出哪些城市；搜索结果中包含哪些品牌，页面就应该列出哪些品牌。\n\n如何得知搜索结果中包含哪些品牌？如何得知搜索结果中包含哪些城市？\n\n使用聚合功能，利用 Bucket 聚合，对搜索结果中的文档基于品牌分组、基于城市分组，就能得知包含哪些品牌、哪些城市了。\n\n因为是对搜索结果聚合，因此聚合是限定范围的聚合，也就是说聚合的限定条件跟搜索文档的条件一致。\n\n返回结果是一个 Map 结构：\n\n- key 是字符串，城市、星级、品牌、价格\n- value 是集合，例如多个城市的名称\n\n#### 业务实现\n\n在 `cn.itcast.hotel.web` 包的 `HotelController` 中添加一个方法，遵循下面的要求：\n\n- 请求方式：`POST`\n- 请求路径：`/hotel/filters`\n- 请求参数：`RequestParams`，与搜索文档的参数一致\n- 返回值类型：`Map<String, List<String>>`\n\n代码：\n\n```java\n@PostMapping(\"filters\")\npublic Map<String, List<String>> getFilters(@RequestBody RequestParams params){\n    return hotelService.getFilters(params);\n}\n```\n\n这里调用了 IHotelService 中的 getFilters 方法，尚未实现。\n\n在 `cn.itcast.hotel.service.IHotelService` 中定义新方法：\n\n```java\nMap<String, List<String>> filters(RequestParams params);\n```\n\n在 `cn.itcast.hotel.service.impl.HotelService` 中实现该方法：\n\n```java\n@Override\npublic Map<String, List<String>> getFilters(RequestParams params) {\n    try {\n        // 1. 准备 request\n        SearchRequest request = new SearchRequest(\"hotel\");\n\n        // 2. 准备 DSL\n        // query\n        FunctionScoreQueryBuilder query = getQueryBuilder(params);\n        request.source().highlighter(new HighlightBuilder().field(\"name\").requireFieldMatch(false));\n        request.source().query(query);\n        // 2.1 设置 size = 0\n        request.source().size(0);\n        // 2.2 聚合\n        HashMap<String, String> items = new HashMap<>();\n        items.put(\"brand\", \"品牌\");\n        items.put(\"city\", \"城市\");\n        items.put(\"starName\", \"星级\");\n        for (String item : items.keySet()) {\n            request.source().aggregation(AggregationBuilders\n                                         .terms(item + \"Agg\")\n                                         .field(item)\n                                         .size(100));\n        }\n        // 3. 发出请求\n        SearchResponse response = null;\n\n        response = client.search(request, RequestOptions.DEFAULT);\n\n\n        // 4. 解析结果\n        // 4.1 获取 aggregations\n        Aggregations aggregations = response.getAggregations();\n\n        HashMap<String, List<String>> itemListHashMap = new HashMap<>();\n\n        for (String item : items.keySet()) {\n            // 4.2 根据名称获取聚合结果\n            Terms brandTerms = aggregations.get(item + \"Agg\");\n            // 4.3 获取 buckets 并遍历\n            ArrayList<String> itemList = new ArrayList<>();\n            for (Terms.Bucket bucket : brandTerms.getBuckets()) {\n                // 获取 key\n                itemList.add(bucket.getKeyAsString());\n            }\n            itemListHashMap.put(item, itemList);\n        }\n        return itemListHashMap;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n\n## 自动补全\n\n当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。\n\n因为需要根据拼音字母来推断，因此要用到拼音分词功能。\n\n### 拼音分词器\n\n要实现根据字母做补全，就必须对文档按照拼音分词。在 GitHub 上有 ElasticSearch的拼音分词插件。地址：https://github.com/medcl/elasticsearch-analysis-pinyin\n\n安装方式与 IK 分词器一样，分三步：\n\n1. 解压\n2. 上传到虚拟机中，ElasticSearch 的 plugin 目录\n3. 重启 ElasticSearch\n4. 测试\n\n详细安装步骤可以参考 IK 分词器的安装过程。\n\n测试用法如下：\n\n```json\nPOST /_analyze\n{\n  \"text\": \"如家酒店还不错\",\n  \"analyzer\": \"pinyin\"\n}\n```\n\n结果如下：\n\n```json\n{\n  \"tokens\" : [\n    {\n      \"token\" : \"ru\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 0,\n      \"type\" : \"word\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"rjjdhbc\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 0,\n      \"type\" : \"word\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"jia\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 0,\n      \"type\" : \"word\",\n      \"position\" : 1\n    },\n    {\n      \"token\" : \"jiu\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 0,\n      \"type\" : \"word\",\n      \"position\" : 2\n    },\n    {\n      \"token\" : \"dian\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 0,\n      \"type\" : \"word\",\n      \"position\" : 3\n    },\n    {\n      \"token\" : \"hai\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 0,\n      \"type\" : \"word\",\n      \"position\" : 4\n    },\n    {\n      \"token\" : \"bu\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 0,\n      \"type\" : \"word\",\n      \"position\" : 5\n    },\n    {\n      \"token\" : \"cuo\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 0,\n      \"type\" : \"word\",\n      \"position\" : 6\n    }\n  ]\n}\n```\n\n### 自定义分词器\n\n默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。\n\nElasticSearch 中分词器（analyzer）的组成包含三部分：\n\n- character filters：在 tokenizer 之前对文本进行处理。例如删除字符、替换字符\n- tokenizer：将文本按照一定的规则切割成词条（term）。例如 keyword，就是不分词；还有 ik_smart\n- tokenizer filter：将 tokenizer 输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等\n\n声明自定义分词器的语法如下：\n\n```json\nPUT /test\n{\n  \"settings\": {\n    \"analysis\": {\n      \"analyzer\": {\n        \"my_analyzer\": {\n          \"tokenizer\": \"ik_max_word\",\n          \"filter\": \"py\"\n        }\n      },\n      \"filter\": {\n        \"py\": {\n          \"type\": \"pinyin\",\n          \"keep_full_pinyin\": false,\n          \"keep_joined_full_pinyin\": true,\n          \"keep_original\": true,\n          \"limit_first_letter_length\": 16,\n          \"remove_duplicated_term\": true,\n          \"none_chinese_pinyin_tokenize\": false\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"name\": {\n        \"type\": \"text\",\n        \"analyzer\": \"my_analyzer\",\n        \"search_analyzer\": \"ik_smart\"\n      }\n    }\n  }\n}\n```\n\n总结：\n\n如何使用拼音分词器？\n\n- 下载 pinyin 分词器\n\n- 解压并放到 ElasticSearch 的 plugin 目录\n\n- 重启即可\n\n如何自定义分词器？\n\n- 创建索引库时，在 settings 中配置，可以包含三部分：character filter、tokenizer、filter\n\n\n拼音分词器注意事项？\n\n- 为了避免搜索到同音字，搜索时不要使用拼音分词器\n\n### 自动补全查询\n\nElasticSearch 提供了 [Completion Suggester](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html) 查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：\n\n- 参与补全查询的字段必须是 completion 类型。\n\n- 字段的内容一般是用来补全的多个词条形成的数组。\n\n比如，一个这样的索引库：\n\n```json\nPUT /test2\n{\n  \"mappings\": {\n    \"properties\": {\n      \"title\":{\n        \"type\": \"completion\"\n      }\n    }\n  }\n}\n```\n\n然后插入下面的数据：\n\n```json\nPOST /test2/_doc\n{\n  \"title\": [\"Sony\", \"WH-1000XM3\"]\n}\nPOST /test2/_doc\n{\n  \"title\": [\"SK-II\", \"PITERA\"]\n}\nPOST /test2/_doc\n{\n  \"title\": [\"Nintendo\", \"switch\"]\n}\n```\n\n查询的 DSL 语句如下：\n\n```json\nPOST /test2/_search\n{\n  \"suggest\": {\n    \"title_suggest\": {\n      \"text\": \"s\", \n      \"completion\": {\n        \"field\": \"title\", \n        \"skip_duplicates\": true, \n        \"size\": 10 \n      }\n    }\n  }\n}\n```\n\n### 实现酒店搜索框自动补全\n\n现在，我们的 hotel 索引库还没有设置拼音分词器，需要修改索引库中的配置。但是我们知道索引库是无法修改的，只能删除然后重新创建。\n\n另外，我们需要添加一个字段，用来做自动补全，将 brand、suggestion、city 等都放进去，作为自动补全的提示。\n\n因此，总结一下，我们需要做的事情包括：\n\n1. 修改 hotel 索引库结构，设置自定义拼音分词器\n\n2. 修改索引库的 name、all 字段，使用自定义分词器\n\n3. 索引库添加一个新字段 suggestion，类型为 completion 类型，使用自定义的分词器\n\n4. 给 HotelDoc 类添加 suggestion 字段，内容包含 brand、business\n\n5. 重新导入数据到 hotel 库\n\n#### 修改酒店映射结构\n\n代码如下：\n\n```json\n// 酒店数据索引库\nPUT /hotel\n{\n  \"settings\": {\n    \"analysis\": {\n      \"analyzer\": {\n        \"text_anlyzer\": {\n          \"tokenizer\": \"ik_max_word\",\n          \"filter\": \"py\"\n        },\n        \"completion_analyzer\": {\n          \"tokenizer\": \"keyword\",\n          \"filter\": \"py\"\n        }\n      },\n      \"filter\": {\n        \"py\": {\n          \"type\": \"pinyin\",\n          \"keep_full_pinyin\": false,\n          \"keep_joined_full_pinyin\": true,\n          \"keep_original\": true,\n          \"limit_first_letter_length\": 16,\n          \"remove_duplicated_term\": true,\n          \"none_chinese_pinyin_tokenize\": false\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"id\":{\n        \"type\": \"keyword\"\n      },\n      \"name\":{\n        \"type\": \"text\",\n        \"analyzer\": \"text_anlyzer\",\n        \"search_analyzer\": \"ik_smart\",\n        \"copy_to\": \"all\"\n      },\n      \"address\":{\n        \"type\": \"keyword\",\n        \"index\": false\n      },\n      \"price\":{\n        \"type\": \"integer\"\n      },\n      \"score\":{\n        \"type\": \"integer\"\n      },\n      \"brand\":{\n        \"type\": \"keyword\",\n        \"copy_to\": \"all\"\n      },\n      \"city\":{\n        \"type\": \"keyword\"\n      },\n      \"starName\":{\n        \"type\": \"keyword\"\n      },\n      \"business\":{\n        \"type\": \"keyword\",\n        \"copy_to\": \"all\"\n      },\n      \"location\":{\n        \"type\": \"geo_point\"\n      },\n      \"pic\":{\n        \"type\": \"keyword\",\n        \"index\": false\n      },\n      \"all\":{\n        \"type\": \"text\",\n        \"analyzer\": \"text_anlyzer\",\n        \"search_analyzer\": \"ik_smart\"\n      },\n      \"suggestion\":{\n          \"type\": \"completion\",\n          \"analyzer\": \"completion_analyzer\"\n      }\n    }\n  }\n}\n```\n\n#### 修改 HotelDoc 实体\n\nHotelDoc 中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。\n\n因此我们在 HotelDoc 中添加一个 suggestion 字段，类型为 `List<String>`，然后将 brand、city、business 等信息放到里面。\n\n代码如下：\n\n```java\n@Data\n@NoArgsConstructor\npublic class HotelDoc {\n    private Long id;\n    private String name;\n    private String address;\n    private Integer price;\n    private Integer score;\n    private String brand;\n    private String city;\n    private String starName;\n    private String business;\n    private String location;\n    private String pic;\n    private Object distance;\n    private Boolean isAD;\n    private List<String> suggestion;\n\n    public HotelDoc(Hotel hotel) {\n        this.id = hotel.getId();\n        this.name = hotel.getName();\n        this.address = hotel.getAddress();\n        this.price = hotel.getPrice();\n        this.score = hotel.getScore();\n        this.brand = hotel.getBrand();\n        this.city = hotel.getCity();\n        this.starName = hotel.getStarName();\n        this.business = hotel.getBusiness();\n        this.location = hotel.getLatitude() + \", \" + hotel.getLongitude();\n        this.pic = hotel.getPic();\n        // 组装suggestion\n        if (this.business.contains(\"/\")) {\n            // business有多个值，需要切割\n            String[] arr = this.business.split(\"/\");\n            // 添加元素\n            this.suggestion = new ArrayList<>();\n            this.suggestion.add(this.brand);\n            Collections.addAll(this.suggestion, arr);\n        } else {\n            this.suggestion = Arrays.asList(this.brand, this.business);\n        }\n    }\n}\n```\n\n#### 重新导入并测试\n\n重新执行之前编写的导入数据功能 `testBulkRequest()`，并搜索测试\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  }\n}\n```\n\n可以看到新的酒店数据中包含了 suggestion，接下来测试自动补全功能\n\n```json\nGET /hotel/_search\n{\n  \"suggest\": {\n    \"suggestions\": {\n      \"text\": \"sd\",\n      \"completion\": {\n        \"field\": \"suggestion\",\n        \"skip_duplicates\": true, \n        \"size\": 10 \n      }\n    }\n  }\n}\n```\n\n#### 自动补全查询的 Java API\n\n```java\n// 1.准备请求\nSearchRequest request = new SearchRequest(\"hotel\");\n// 2.请求参数\nrequest.source().suggest(new SuggestBuilder().addSuggestion(\n    \"mySuggestion\",\n    SuggestBuilders\n    .completionSuggestion(\"title\")\n    .prefix(\"h\")\n    .skipDuplicates(true)\n    .size(10)\n));\n// 3.发送请求\nclient.search(request, RequestOptions.DEFAULT);\n```\n\n而自动补全的结果也比较特殊，解析的代码如下：\n\n```java\n// 4.处理结果\nSuggest suggest = response.getSuggest();\n// 4.1.根据名称获取补全结果\nCompletionSuggestion suggestion = suggest.getSuggestion(\"mySuggestion\");\n// 4.2.获取options并遍历\nfor (CompletionSuggestion.Entry.Option option : suggestion.getOptions()) {\n    // 4.3.获取一个option中的text，也就是补全的词条\n    String text = option.getText().string();\n    System.out.println(text);\n}\n```\n\n#### 实现搜索框自动补全\n\n在 `cn.itcast.hotel.web` 包下的 `HotelController` 中添加新接口，接收新的请求：\n\n```java\n@GetMapping(\"suggestion\")\npublic List<String> getSuggestions(@RequestParam(\"key\") String prefix) {\n    return hotelService.getSuggestions(prefix);\n}\n```\n\n在 `cn.itcast.hotel.service` 包下的 `IhotelService` 中添加方法：\n\n```java\nList<String> getSuggestions(String prefix);\n```\n\n在 `cn.itcast.hotel.service.impl.HotelService` 中实现该方法：\n\n```java\n@Override\npublic List<String> getSuggestions(String prefix) {\n    try {\n        // 1.准备请求\n        SearchRequest request = new SearchRequest(\"hotel\");\n        // 2.请求参数\n        request.source().suggest(new SuggestBuilder().addSuggestion(\n            \"suggestions\",\n            SuggestBuilders\n            .completionSuggestion(\"suggestion\")\n            .prefix(prefix)\n            .skipDuplicates(true)\n            .size(10)\n        ));\n        // 3.发送请求\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n        // 4.处理结果\n        Suggest suggest = response.getSuggest();\n        // 4.1.根据名称获取补全结果\n        CompletionSuggestion suggestion = suggest.getSuggestion(\"suggestions\");\n        // 4.2.获取options并遍历\n        ArrayList<String> result = new ArrayList<>();\n        for (CompletionSuggestion.Entry.Option option : suggestion.getOptions()) {\n            // 4.3.获取一个option中的text，也就是补全的词条\n            String text = option.getText().string();\n            result.add(text);\n        }\n        return result;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n\n## 数据同步\n\nElasticSearch 中的酒店数据来自于 MySQL 数据库，因此 MySQL 数据发生改变时，ElasticSearch 也必须跟着改变，这个就是 ElasticSearch 与 MySQL 之间的数据同步。\n\n### 思路分析\n\n常见的数据同步方案有三种：\n\n- 同步调用\n- 异步通知\n- 监听 binlog\n\n#### 同步调用\n\n![同步调用](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/同步调用.i2rj0d3cpwg.svg)\n\n基本步骤如下：\n\n- hotel-demo 对外提供接口，用来修改 ElasticSearch 中的数据\n- 酒店管理服务在完成数据库操作后，直接调用 hotel-demo 提供的接口\n\n#### 异步通知\n\n![异步通知](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/异步通知.1p2ptlc5nrs0.svg)\n\n流程如下：\n\n- hotel-admin 对 MySQL 数据库数据完成增、删、改后，发送 MQ 消息\n- hotel-demo 监听 MQ，接收到消息后完成 ElasticSearch 数据修改\n\n#### 监听 binlog\n\n![监听binlog](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/监听binlog.1n6hcbad4pb4.svg)\n\n流程如下：\n\n- 给 MySQL 开启 binlog 功能\n- MySQL 完成增、删、改操作都会记录在 binlog 中\n- hotel-demo 基于 canal 监听 binlog 变化，实时更新 ElasticSearch 中的内容\n\n#### 不同数据同步方案优缺点\n\n方式一：同步调用\n\n- 优点：实现简单，粗暴\n- 缺点：业务耦合度高\n\n方式二：异步通知\n\n- 优点：低耦合，实现难度一般\n- 缺点：依赖 MQ 的可靠性\n\n方式三：监听 binlog\n\n- 优点：完全解除服务间耦合\n- 缺点：开启 binlog 增加数据库负担、实现复杂度高\n\n### 实现数据同步\n\n#### 基于 MQ 的实现思路\n\n利用提供的 hotel-admin 项目作为酒店管理的微服务。当酒店数据发生增、删、改时，要求对 ElasticSearch 中数据也要完成相同操作。\n\n步骤：\n\n- 导入 hotel-admin 项目，启动并测试酒店数据的 CRUD\n\n- 声明 exchange、queue、RoutingKey\n\n- 在 hotel-admin 中的增、删、改业务中完成消息发送\n\n- 在 hotel-demo 中完成消息监听，并更新 ElasticSearch 中数据\n\n- 启动并测试数据同步功能\n\n### 导入 demo\n\n代码链接：[GitHub](https://github.com/Lanqilu/HaloElasticSearch/commit/b9d7c724b44d6ea8e307ac5d54778bba635bd314)\n\n运行后，访问 http://localhost:8099\n\n### 声明交换机、队列\n\nMQ 结构如图：\n\n![MQ结构](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/MQ结构.lv1ecla6gvk.svg)\n\n#### 引入依赖并修改配置文件 \n\n在 hotel-admin、hotel-demo 中引入 rabbitmq 的依赖：\n\n```xml\n<!--amqp-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n\n```yaml\nspring:\n  rabbitmq:\n    host: rabbitmq\n    port: 5672\n    username: halo\n    password: halo\n    virtual-host: /\n```\n\n#### 声明交换机、队列\n\n在 hotel-admin 和 hotel-demo 中的 `cn.itcast.hotel.constatnts` 包下新建一个类 `MqConstants`：\n\n```java\npublic class MqConstants {\n    /**\n     * 交换机\n     */\n    public final static String HOTEL_EXCHANGE = \"hotel.topic\";\n    /**\n     * 监听新增和修改的队列\n     */\n    public final static String HOTEL_INSERT_QUEUE = \"hotel.insert.queue\";\n    /**\n     * 监听删除的队列\n     */\n    public final static String HOTEL_DELETE_QUEUE = \"hotel.delete.queue\";\n    /**\n     * 新增或修改的RoutingKey\n     */\n    public final static String HOTEL_INSERT_KEY = \"hotel.insert\";\n    /**\n     * 删除的RoutingKey\n     */\n    public final static String HOTEL_DELETE_KEY = \"hotel.delete\";\n}\n```\n\n在 hotel-demo 中，定义配置类，声明队列、交换机：\n\n```java\n@Configuration\npublic class MqConfig {\n    @Bean\n    public TopicExchange topicExchange(){\n        return new TopicExchange(MqConstants.HOTEL_EXCHANGE, true, false);\n    }\n\n    @Bean\n    public Queue insertQueue(){\n        return new Queue(MqConstants.HOTEL_INSERT_QUEUE, true);\n    }\n\n    @Bean\n    public Queue deleteQueue(){\n        return new Queue(MqConstants.HOTEL_DELETE_QUEUE, true);\n    }\n\n    @Bean\n    public Binding insertQueueBinding(){\n        return BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY);\n    }\n\n    @Bean\n    public Binding deleteQueueBinding(){\n        return BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY);\n    }\n}\n```\n\n### 发送 MQ 消息\n\n在 hotel-admin 中的增、删、改业务中分别发送 MQ 消息：\n\n```java\n@Autowired\nprivate RabbitTemplate rabbitTemplate;\n\n@PostMapping\npublic void saveHotel(@RequestBody Hotel hotel){\n    hotelService.save(hotel);\n    rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE,MqConstants.HOTEL_INSERT_KEY,hotel.getId());\n}\n\n@PutMapping()\npublic void updateById(@RequestBody Hotel hotel){\n    if (hotel.getId() == null) {\n        throw new InvalidParameterException(\"id不能为空\");\n    }\n    hotelService.updateById(hotel);\n    rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE,MqConstants.HOTEL_INSERT_KEY,hotel.getId());\n}\n\n@DeleteMapping(\"/{id}\")\npublic void deleteById(@PathVariable(\"id\") Long id) {\n    hotelService.removeById(id);\n    rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE,MqConstants.HOTEL_DELETE_KEY,id);\n}\n```\n\n### 接收 MQ 消息\n\nhotel-demo 接收到 MQ 消息要做的事情包括：\n\n- 新增消息：根据传递的 hotel 的 id 查询 hotel 信息，然后新增一条数据到索引库\n- 删除消息：根据传递的 hotel 的 id 删除索引库中的一条数据\n\n首先在 hotel-demo 的 `cn.itcast.hotel.service` 包下的 `IHotelService` 中新增新增、删除业务\n\n```java\nvoid deleteById(Long id);\n\nvoid insertById(Long id);\n```\n\n给 hotel-demo 中的 `cn.itcast.hotel.service.impl` 包下的 HotelService 中实现业务：\n\n```java\n@Override\npublic void deleteById(Long id) {\n    try {\n        // 1.准备Request\n        DeleteRequest request = new DeleteRequest(\"hotel\", id.toString());\n        // 2.发送请求\n        client.delete(request, RequestOptions.DEFAULT);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n\n@Override\npublic void insertById(Long id) {\n    try {\n        // 0.根据id查询酒店数据\n        Hotel hotel = getById(id);\n        // 转换为文档类型\n        HotelDoc hotelDoc = new HotelDoc(hotel);\n\n        // 1.准备Request对象\n        IndexRequest request = new IndexRequest(\"hotel\").id(hotel.getId().toString());\n        // 2.准备Json文档\n        request.source(JSON.toJSONString(hotelDoc), XContentType.JSON);\n        // 3.发送请求\n        client.index(request, RequestOptions.DEFAULT);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n\n编写监听器，在 hotel-demo 中的 `cn.itcast.hotel.mq` 包新增一个类：\n\n```java\n@Component\npublic class HotelListener {\n\n    @Autowired\n    private IHotelService hotelService;\n\n    /**\n     * 监听酒店新增或修改的业务\n     * @param id 酒店id\n     */\n    @RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE)\n    public void listenHotelInsertOrUpdate(Long id){\n        hotelService.insertById(id);\n    }\n\n    /**\n     * 监听酒店删除的业务\n     * @param id 酒店id\n     */\n    @RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE)\n    public void listenHotelDelete(Long id){\n        hotelService.deleteById(id);\n    }\n}\n```\n\n## ElasticSearch 集群\n\n单机的 ElasticSearch 做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。\n\n- 海量数据存储问题：将索引库从逻辑上拆分为 N 个分片（shard），存储到多个节点\n- 单点故障问题：将分片数据在不同节点备份（replica）\n\nES 集群相关概念:\n\n* 集群（cluster）：一组拥有共同的 cluster name 的 节点。\n* 节点（node)   ：集群中的一个 Elasticearch 实例\n* 分片（shard）：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中\n\n解决问题：数据量太大，单点存储量有限的问题。\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4pwzs1lq4540.png)\n\n此处，我们把数据分成 3 片：shard0、shard1、shard2\n\n* 主分片（Primary shard）：相对于副本分片的定义。\n\n* 副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。\n\n数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！\n\n为了在高可用和成本间寻求平衡，我们可以这样做：\n\n- 首先对数据分片，存储到不同节点\n- 然后对每个分片进行备份，放到对方节点，完成互相备份\n\n这样可以大大减少所需要的服务节点数量，如图，我们以 3 分片，每个分片备份一份为例：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3jlk46u66q60.png)\n\n现在，每个分片都有 1 个备份，存储在 3 个节点：\n\n- node0：保存了分片 0 和 1\n- node1：保存了分片 0 和 2\n- node2：保存了分片 1 和 2\n\n### 部署 ElasticSearch 集群\n\n我们会在单机上利用 docker 容器运行多个 ElasticSearch 实例来模拟 ElasticSearch 集群。不过生产环境推荐大家每一台服务节点仅部署一个 ElasticSearch 的实例。\n\n部署 ElasticSearch 集群可以直接使用 docker-compose 来完成，但这要求你的 Linux 虚拟机至少有 4G 的内存空间\n\n#### 创建 ElasticSearch 集群\n\n首先编写一个 docker-compose 文件，内容如下：\n\n```sh\nversion: \'2.2\'\nservices:\n  es01:\n    image: elasticsearch:7.12.1\n    container_name: es01\n    environment:\n      - node.name=es01\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es02,es03\n      - cluster.initial_master_nodes=es01,es02,es03\n      - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\n    volumes:\n      - data01:/usr/share/elasticsearch/data\n    ports:\n      - 9200:9200\n    networks:\n      - elastic\n  es02:\n    image: elasticsearch:7.12.1\n    container_name: es02\n    environment:\n      - node.name=es02\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es01,es03\n      - cluster.initial_master_nodes=es01,es02,es03\n      - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\n    volumes:\n      - data02:/usr/share/elasticsearch/data\n    ports:\n      - 9201:9200\n    networks:\n      - elastic\n  es03:\n    image: elasticsearch:7.12.1\n    container_name: es03\n    environment:\n      - node.name=es03\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es01,es02\n      - cluster.initial_master_nodes=es01,es02,es03\n      - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\n    volumes:\n      - data03:/usr/share/elasticsearch/data\n    networks:\n      - elastic\n    ports:\n      - 9202:9200\nvolumes:\n  data01:\n    driver: local\n  data02:\n    driver: local\n  data03:\n    driver: local\n\nnetworks:\n  elastic:\n    driver: bridge\n```\n\nElasticSearch  运行需要修改一些 Linux 系统权限，修改 `/etc/sysctl.conf` 文件\n\n```sh\nvi /etc/sysctl.conf\n```\n\n添加下面的内容：\n\n```sh\nvm.max_map_count=262144\n```\n\n然后执行命令，让配置生效：\n\n```sh\nsysctl -p\n```\n\n通过 docker-compose 启动集群：\n\n```sh\ndocker-compose up -d\n```\n\n#### 集群状态监控\n\nkibana 可以监控 ElasticSearch  集群，不过新版本需要依赖 ElasticSearch  的 x-pack 功能，配置比较复杂。\n\n这里推荐使用 cerebro 来监控 ElasticSearch  集群状态，官方网址：https://github.com/lmenezes/cerebro\n\n双击其中的 cerebro.bat 文件即可启动服务。访问 http://localhost:9000 即可进入管理界面：\n\n输入你的 ElasticSearch 的任意节点的地址和端口，点击 connect 即可\n\n#### 创建索引库\n\n利用 kibana 的 DevTools 创建索引库，在 DevTools 中输入指令：\n\n```json\nPUT /test\n{\n  \"settings\": {\n    \"number_of_shards\": 3, // 分片数量\n    \"number_of_replicas\": 1 // 副本数量\n  },\n  \"mappings\": {\n    \"properties\": {\n      // mapping映射定义 ...\n    }\n  }\n}\n```\n\n或利用 cerebro 创建索引库\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.29xen9tqfmvw.png)\n\n查看分片效果，回到首页，即可查看索引库分片效果：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2jn8zaht2280.png)\n\n### 集群脑裂问题\n\n#### 集群职责划分\n\nElasticSearch 中集群节点有不同的职责划分：\n\n| 节点类型         | 配置参数                                       | 默认值 | 节点职责                                                     |\n| ---------------- | ---------------------------------------------- | ------ | ------------------------------------------------------------ |\n| master  eligible | node.master                                    | true   | 备选主节点：主节点可以管理和记录集群状态、决定分片在哪个节点、处理创建和删除索引库的请求 |\n| data             | node.data                                      | true   | 数据节点：存储数据、搜索、聚合、CRUD                         |\n| ingest           | node.ingest                                    | true   | 数据存储之前的预处理                                         |\n| coordinating     | 上面 3 个参数都为 false 则为 coordinating 节点 | 无     | 路由请求到其它节点  合并其它节点处理的结果，返回给用户       |\n\n默认情况下，集群中的任何一个节点都同时具备上述四种角色。\n\n但是真实的集群一定要将集群职责分离：\n\n- master 节点：对 CPU 要求高，但是内存要求低\n- data 节点：对 CPU 和内存要求都高\n- coordinating 节点：对网络带宽、CPU 要求高\n\n职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。\n\n一个典型的 ElasticSearch 集群职责划分如图：\n\n![ES集群](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/ES集群.2rrl7g78cxs0.svg)\n\n#### 脑裂问题\n\n脑裂是因为集群中的节点失联导致的。\n\n例如一个集群中，主节点与其它节点失联，\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.6ry0qp2sxiw0.png)\n\n此时 node2 和 node3 认为 node1 宕机，就会重新选主：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5qon8j1rbak0.png)\n\n当 node3 当选后，集群继续对外提供服务，node2 和 node3 自成集群，node1 自成集群，两个集群数据不同步，出现数据差异。\n\n当网络恢复后，因为集群中有两个 master 节点，集群状态的不一致，出现脑裂的情况：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.wmlcqz00rls.png)\n\n解决脑裂的方案是，要求选票超过 ( eligible节点数量 + 1 ）/ 2 才能当选为主，因此 eligible 节点数量最好是奇数。对应配置项是 discovery.zen.minimum_master_nodes，在 ElasticSearch 7.0 以后，已经成为默认配置，因此一般不会发生脑裂问题\n\n例如：3 个节点形成的集群，选票必须超过 （3 + 1） / 2 ，也就是 2 票。node3 得到 node2 和 node3 的选票，当选为主。node1 只有自己 1 票，没有当选。集群中依然只有 1 个主节点，没有出现脑裂。\n\n### 集群分布式存储\n\n当新增文档时，应该保存到不同分片，保证数据均衡，那么 coordinating node 如何确定数据该存储到哪个分片呢？\n\n#### 分片存储测试\n\n在一个节点中加入数据，后可以通过 explain 命令查询\n\n```json\nPOST /test/_search\n{\n  \"explain\": true,\n  \"query\": {\n    \"match_all\": {}\n  }\n}\n```\n\n发现数据在不同的节点中，形成分片存储\n\n#### 分片存储原理\n\nElasticSearch 会通过 hash 算法来计算文档应该存储到哪个分片：`shard = hash(_routing) % number_of_shards`\n\n说明：\n\n- `_routing` 默认是文档的id\n- 算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！\n\n新增文档的流程如下：\n\n![ES集群](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/ES集群.akvhs79fwq0.svg)\n\n解读：\n\n- 新增一个 id=1 的文档\n- 对 id 做 hash 运算，假如得到的是 2，则应该存储到 P-2\n- P-2 的主分片在 node3 节点，将数据路由到 node3\n- 保存文档\n- 同步给 P-2 的副本 R-2，在 node2 节点\n- 返回结果给 coordinating-node 节点\n\n#### 集群分布式查询\n\nElasticSearch 的查询分成两个阶段：\n\n- scatter phase：分散阶段，coordinating node 会把请求分发到每一个分片\n\n- gather phase：聚集阶段，coordinating node 汇总 data node 的搜索结果，并处理为最终结果集返回给用户\n\n#### 集群故障转移\n\n集群的 master 节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。\n\n+ 假如，node1 发生了故障\n+ 宕机后的第一件事，需要重新选主，例如选中了 node2，\n+ node2 成为主节点后，会检测集群监控状态，发现：shard-1、shard-0 没有副本节点。因此需要将 node1 上的数据迁移到 node2、node3\n+ 但 node1 恢复，此时 node1 不在是主节点，但数据会重新平衡\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '2021-10-14 06:08:02', 1, 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/macos.6z1mshl4twk0.svg', 14, '2021-10-14 11:14:58', NULL, NULL, NULL, 1, 1, 0, NULL, 0, '<h2 id=\"初识-elasticsearch\">初识 ElasticSearch</h2>\n<h3 id=\"了解-elasticsearch\">了解 ElasticSearch</h3>\n<h4 id=\"elasticsearch-的作用\">ElasticSearch 的作用</h4>\n<p>ElasticSearch 是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容</p>\n<h4 id=\"elk-技术栈\">ELK 技术栈</h4>\n<p>ElasticSearch 结合 Kibana、Logstash、Beats，也就是 Elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域。</p>\n<h4 id=\"elasticsearch-和-lucene\">ElasticSearch 和 Lucene</h4>\n<p>ElasticSearch 底层是基于 Lucene 来实现的。</p>\n<p>Lucene 是一个 Java 语言的搜索引擎类库，是 Apache 公司的顶级项目，由 DougCutting 于 1999 年研发。</p>\n<p>Lucene 官网地址：<a href=\"https://lucene.apache.org/\">https://lucene.apache.org/</a> 。</p>\n<p>Lucene 的优势：易扩展、高性能（基于倒排索引）</p>\n<p>Lucene 的缺点：只限于 Java 语言开发、学习曲线陡峭、不支持水平扩展</p>\n<p>ElasticSearch 的发展历史：</p>\n<ul>\n<li>2004 年 Shay Banon 基于 Lucene 开发了 Compass</li>\n<li>2010 年 Shay Banon 重写了 Compass，取名为 ElasticSearch。</li>\n</ul>\n<p>ElasticSearch 官网地址: <a href=\"https://www.elastic.co/cn/\">https://www.elastic.co/cn/</a></p>\n<p>相比与 Lucene ，ElasticSearch 具备下列优势：</p>\n<ul>\n<li>支持分布式，可水平扩展</li>\n<li>提供 Restful 接口，可被任何语言调用</li>\n</ul>\n<h3 id=\"倒排索引\">倒排索引</h3>\n<p>倒排索引的概念是基于 MySQL 这样的正向索引而言的。</p>\n<h4 id=\"正向索引\">正向索引</h4>\n<p>如果是根据 id 查询，那么直接走索引，查询速度非常快。</p>\n<p>但如果是基于 title 做模糊查询，只能是逐行扫描数据，流程如下：</p>\n<ol>\n<li>用户搜索数据，条件是 title 符合 <code>&quot;%手机%&quot;</code></li>\n<li>逐行获取数据，比如 id 为 1 的数据</li>\n<li>判断数据中的 title 是否符合用户搜索条件</li>\n<li>如果符合则放入结果集，不符合则丢弃。回到步骤 1</li>\n</ol>\n<p>逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。</p>\n<h4 id=\"倒排索引-1\">倒排索引</h4>\n<p>倒排索引中有两个非常重要的概念：</p>\n<ul>\n<li>文档（Document）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息</li>\n<li>词条（Term）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条</li>\n</ul>\n<p>创建倒排索引是对正向索引的一种特殊处理，流程如下：</p>\n<ul>\n<li>将每一个文档的数据利用算法分词，得到一个个词条</li>\n<li>创建表，每行数据包括词条、词条所在文档 id、位置等信息</li>\n<li>因为词条唯一性，可以给词条创建索引，例如 hash 表结构索引</li>\n</ul>\n<p>如图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5jp2imzxno00.png\" alt=\"image\"></p>\n<p>倒排索引的搜索流程如下（以搜索“华为手机”为例）：</p>\n<ol>\n<li>用户输入条件 <code>&quot;华为手机&quot;</code> 进行搜索。</li>\n<li>对用户输入内容分词，得到词条：<code>华为</code>、<code>手机</code>。</li>\n<li>拿着词条在倒排索引中查找，可以得到包含词条的文档 id：1、2、3。</li>\n<li>拿着文档 id 到正向索引中查找具体文档。</li>\n</ol>\n<p>虽然要先查询倒排索引，再查询倒排索引，但是无论是词条、还是文档 id 都建立了索引，查询速度非常快！无需全表扫描。</p>\n<h4 id=\"正向和倒排\">正向和倒排</h4>\n<p>那么为什么一个叫做正向索引，一个叫做倒排索引呢？</p>\n<ul>\n<li><p>正向索引是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是根据文档找词条的过程。</p>\n</li>\n<li><p>倒排索引则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的 id，然后根据 id 获取文档。是根据词条找文档的过程。</p>\n</li>\n</ul>\n<p>正向索引</p>\n<ul>\n<li>优点：可以给多个字段创建索引、根据索引字段搜索、排序速度非常快</li>\n</ul>\n<ul>\n<li>缺点：根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。</li>\n</ul>\n<p>倒排索引：</p>\n<ul>\n<li>优点：根据词条搜索、模糊搜索时，速度非常快</li>\n<li>缺点：只能给词条创建索引，而不是字段、无法根据字段做排序</li>\n</ul>\n<h3 id=\"elasticsearch-中的一些概念\">ElasticSearch 中的一些概念</h3>\n<p>ElasticSearch 中有很多独有的概念，与 MySQL 中略有差别，但也有相似之处。</p>\n<h4 id=\"文档和字段\">文档和字段</h4>\n<p>ElasticSearch 是面向文档（Document）存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为 JSON 格式后存储在 ElasticSearch 中：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.lwpnpfcxvds.png\" alt=\"image\"></p>\n<p>而 JSON 文档中往往包含很多的字段（Field），类似于数据库中的列。</p>\n<h4 id=\"索引和映射\">索引和映射</h4>\n<p>索引（Index），就是相同类型的文档的集合。例如：</p>\n<ul>\n<li>所有用户文档，就可以组织在一起，称为用户的索引；</li>\n<li>所有商品的文档，可以组织在一起，称为商品的索引；</li>\n<li>所有订单的文档，可以组织在一起，称为订单的索引；</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E7%B4%A2%E5%BC%95.67l5ib0vvgo0.svg\" alt=\"索引\"></p>\n<p>因此，我们可以把索引当做是数据库中的表。</p>\n<p>数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有映射（mapping），是索引中文档的字段约束信息，类似表的结构约束。</p>\n<h4 id=\"mysql-与-elasticsearch\">MySQL 与 ElasticSearch</h4>\n<p>我们统一的把 MySQL 与 ElasticSearch 的概念做一下对比：</p>\n<table>\n<thead>\n<tr>\n<th>MySQL</th>\n<th>Elasticsearch</th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Table</td>\n<td>Index</td>\n<td>索引（index），就是文档的集合，类似数据库的表（table）</td>\n</tr>\n<tr>\n<td>Row</td>\n<td>Document</td>\n<td>文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式</td>\n</tr>\n<tr>\n<td>Column</td>\n<td>Field</td>\n<td>字段（Field），就是 JSON 文档中的字段，类似数据库中的列（Column）</td>\n</tr>\n<tr>\n<td>Schema</td>\n<td>Mapping</td>\n<td>Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema）</td>\n</tr>\n<tr>\n<td>SQL</td>\n<td>DSL</td>\n<td>DSL是 ElasticSearch 提供的 JSON 风格的请求语句，用来操作 ElasticSearch，实现 CRUD</td>\n</tr>\n</tbody></table>\n<ul>\n<li><p>MySQL ：擅长事务类型操作，可以确保数据的安全和一致性</p>\n</li>\n<li><p>ElasticSearch：擅长海量数据的搜索、分析、计算</p>\n</li>\n</ul>\n<p>因此在企业中，往往是两者结合使用：</p>\n<ul>\n<li>对安全性要求较高的写操作，使用 MySQL 实现</li>\n<li>对查询性能要求较高的搜索需求，使用 ElasticSearch 实现</li>\n<li>两者再基于某种方式，实现数据的同步，保证一致性</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/ElasticSearch.4koj7qwgqge0.svg\" alt=\"ElasticSearch\"></p>\n<h3 id=\"安装-elasticsearch-、kibana\">安装 ElasticSearch 、Kibana</h3>\n<h4 id=\"创建网络\">创建网络</h4>\n<p>因为我们还需要部署 Kibana 容器，因此需要让 ElasticSearch 和 Kibana 容器互联。这里先创建一个网络：</p>\n<pre><code class=\"hljs language-sh\">docker network create halo-es-<span class=\"hljs-built_in\">net</span>\n</code></pre>\n<h4 id=\"拉取或加载镜像\">拉取或加载镜像</h4>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-attribute\">docker</span> pull elasticsearch:<span class=\"hljs-number\">7</span>.<span class=\"hljs-number\">14</span>.<span class=\"hljs-number\">1</span>\n</code></pre>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-attribute\">docker</span> pull kibana:<span class=\"hljs-number\">7</span>.<span class=\"hljs-number\">14</span>.<span class=\"hljs-number\">1</span>\n</code></pre>\n<h4 id=\"运行（单点）\">运行（单点）</h4>\n<p>运行 docker 命令，部署单点 ElasticSearch ：</p>\n<pre><code class=\"hljs language-sh\">docker run -d <span class=\"hljs-string\">\\</span>\n    --name halo-es <span class=\"hljs-string\">\\</span>\n    -e <span class=\"hljs-string\">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span> <span class=\"hljs-string\">\\</span>\n    -e <span class=\"hljs-string\">&quot;discovery.type=single-node&quot;</span> <span class=\"hljs-string\">\\</span>\n    -v es-data:/usr/share/elasticsearch/data <span class=\"hljs-string\">\\</span>\n    -v es-plugins:/usr/share/elasticsearch/plugins <span class=\"hljs-string\">\\</span>\n    --privileged <span class=\"hljs-string\">\\</span>\n    --network halo-es-net <span class=\"hljs-string\">\\</span>\n    -p <span class=\"hljs-number\">9200</span>:<span class=\"hljs-number\">9200</span> <span class=\"hljs-string\">\\</span>\n    -p <span class=\"hljs-number\">9300</span>:<span class=\"hljs-number\">9300</span> <span class=\"hljs-string\">\\</span>\nelasticsearch:<span class=\"hljs-number\">7.14</span>.<span class=\"hljs-number\">1</span>\n</code></pre>\n<p>命令解释：</p>\n<ul>\n<li><code>-e &quot;cluster.name=es-docker-cluster&quot;</code>：设置集群名称</li>\n<li><code>-e &quot;http.host=0.0.0.0&quot;</code>：监听的地址，可以外网访问</li>\n<li><code>-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</code>：内存大小</li>\n<li><code>-e &quot;discovery.type=single-node&quot;</code>：非集群模式</li>\n<li><code>-v es-data:/usr/share/elasticsearch/data</code>：挂载逻辑卷，绑定 ElasticSearch 的数据目录</li>\n<li><code>-v es-logs:/usr/share/elasticsearch/logs</code>：挂载逻辑卷，绑定 ElasticSearch 的日志目录</li>\n<li><code>-v es-plugins:/usr/share/elasticsearch/plugins</code>：挂载逻辑卷，绑定 ElasticSearch 的插件目录</li>\n<li><code>--privileged</code>：授予逻辑卷访问权</li>\n<li><code>--network halo-es-net</code> ：加入一个名为 halo-es-net 的网络中</li>\n<li><code>-p 9200:9200</code>：端口映射配置</li>\n</ul>\n<p>在浏览器中输入：<a href=\"http://halo:9200\">http://halo:9200</a> 即可看到 ElasticSearch 的响应结果：</p>\n<p>运行 docker 命令，部署 Kibana</p>\n<pre><code class=\"hljs language-sh\">docker run -d \\\n--name halo-kibana \\\n-e ELASTICSEARCH_HOSTS=http:<span class=\"hljs-comment\">//halo-es:9200 \\\n--network halo-es-net \\\n-p 5601:5601  \\\nkibana:7.14.1</span>\n</code></pre>\n<ul>\n<li><code>--network es-net</code> ：加入一个名为es-net的网络中，与 elasticsearch 在同一个网络中</li>\n<li><code>-e ELASTICSEARCH_HOSTS=http://halo-es:9200&quot;</code>：设置 elasticsearch 的地址，因为 kibana 已经与elasticsearch 在一个网络，因此可以用容器名（halo-es）直接访问 elasticsearch</li>\n<li><code>-p 5601:5601</code>：端口映射配置</li>\n</ul>\n<p>kibana 启动一般比较慢，需要多等待一会，可以通过命令查看日志：</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-attribute\">docker logs -f kibana</span>\n</code></pre>\n<p>在浏览器输入地址访问：<a href=\"http://halo:5601%EF%BC%8C%E5%8D%B3%E5%8F%AF%E7%9C%8B%E5%88%B0%E7%BB%93%E6%9E%9C\">http://halo:5601，即可看到结果</a></p>\n<h3 id=\"安装-ik-分词器\">安装 IK 分词器</h3>\n<p>ElasticSearch 在创建倒排索引时需要对文档分词；在搜索时，需要对用户输入内容分词。但默认的分词规则对中文处理并不友好。</p>\n<p>我们在 Kibana 的 DevTools 中测试：</p>\n<pre><code class=\"hljs language-json\">POST /<span class=\"hljs-title class_\">_analyze</span>\n<span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-string\">&quot;analyzer&quot;</span>: <span class=\"hljs-string\">&quot;standard&quot;</span>,\n  <span class=\"hljs-string\">&quot;text&quot;</span>: <span class=\"hljs-string\">&quot;你好,世界! Hello,World!&quot;</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>语法说明：</p>\n<ul>\n<li>POST：请求方式</li>\n<li>/_analyze：请求路径，这里省略了 <a href=\"http://halo:9200%EF%BC%8C%E6%9C%89\">http://halo:9200，有</a> kibana 帮我们补充</li>\n<li>请求参数，JSON 风格：<code>analyzer</code>：分词器类型，这里是默认的 standard 分词器；<code>text</code>：要分词的内容</li>\n</ul>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-string\">&quot;tokens&quot;</span> : [\n    {\n      <span class=\"hljs-string\">&quot;token&quot;</span> : &quot;你&quot;,\n      <span class=\"hljs-string\">&quot;start_offset&quot;</span> : 0,\n      <span class=\"hljs-string\">&quot;end_offset&quot;</span> : 1,\n      <span class=\"hljs-string\">&quot;type&quot;</span> : &quot;&lt;<span class=\"hljs-type\">IDEOGRAPHIC</span>&gt;<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 0\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>好<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 1,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 2,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>&lt;IDEOGRAPHIC&gt;<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 1\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>世<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 3,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 4,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>&lt;IDEOGRAPHIC&gt;<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 2\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>界<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 4,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 5,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>&lt;IDEOGRAPHIC&gt;<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 3\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>hello<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 7,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 12,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>&lt;ALPHANUM&gt;<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 4\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>world<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 13,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 18,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>&lt;ALPHANUM&gt;<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 5\n    }\n  ]\n}</span>\n</code></pre>\n<p>处理中文分词，一般会使用 IK 分词器。<a href=\"https://github.com/medcl/elasticsearch-analysis-ik\">https://github.com/medcl/elasticsearch-analysis-ik</a></p>\n<h4 id=\"在线安装-ik-插件\">在线安装 IK 插件</h4>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-comment\"># 进入容器内部</span>\ndocker exec -it elasticsearch <span class=\"hljs-regexp\">/bin/</span>bash\n\n<span class=\"hljs-comment\"># 在线下载并安装</span>\n.<span class=\"hljs-regexp\">/bin/</span>elasticsearch-plugin install https:<span class=\"hljs-regexp\">//gi</span>thub.com<span class=\"hljs-regexp\">/medcl/</span>elasticsearch-analysis-ik<span class=\"hljs-regexp\">/releases/</span>download<span class=\"hljs-regexp\">/v7.14.1/</span>elasticsearch-analysis-ik-<span class=\"hljs-number\">7.14</span>.<span class=\"hljs-number\">1</span>.zip\n\n<span class=\"hljs-comment\">#退出</span>\n<span class=\"hljs-keyword\">exit</span>\n<span class=\"hljs-comment\">#重启容器</span>\ndocker restart elasticsearch\n</code></pre>\n<h4 id=\"离线安装-ik-插件\">离线安装 IK 插件</h4>\n<p>查看数据卷目录</p>\n<p>安装插件需要知道 elasticsearch 的 plugins 目录位置，而我们用了数据卷挂载，因此需要查看 elasticsearch 的数据卷目录，通过下面命令查看:</p>\n<pre><code class=\"hljs language-sh\">docker <span class=\"hljs-keyword\">volume</span><span class=\"language-bash\"> inspect es-plugins</span>\n</code></pre>\n<p>显示结果：</p>\n<pre><code><span class=\"hljs-punctuation\">[</span>\n    <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">&quot;CreatedAt&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;2021-09-11T12:50:57+08:00&quot;</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">&quot;Driver&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;local&quot;</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">&quot;Labels&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">null</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">&quot;Mountpoint&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;/var/lib/docker/volumes/es-plugins/_data&quot;</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">&quot;Name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;es-plugins&quot;</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">&quot;Options&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">null</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">&quot;Scope&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;local&quot;</span>\n    <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">]</span>\n</code></pre>\n<p>说明 plugins 目录被挂载到了：<code>/var/lib/docker/volumes/es-plugins/_data </code> 这个目录中。</p>\n<p>将 ik 分词器解压缩，重命名为 ik，上传到 es 容器的插件数据卷中后重启容器</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-attribute\">docker restart halo-es</span>\n</code></pre>\n<h4 id=\"测试分词器\">测试分词器</h4>\n<p>IK 分词器包含两种模式：</p>\n<ul>\n<li><p><code>ik_smart</code> ：最少切分，粗粒度</p>\n</li>\n<li><p><code>ik_max_word</code> ：最细切分，细粒度</p>\n</li>\n</ul>\n<pre><code class=\"hljs language-json\">POST /<span class=\"hljs-title class_\">_analyze</span>\n<span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-string\">&quot;analyzer&quot;</span>: <span class=\"hljs-string\">&quot;ik_max_word&quot;</span>,\n  <span class=\"hljs-string\">&quot;text&quot;</span>: <span class=\"hljs-string\">&quot;你好,我的世界! Hello,World!&quot;</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>结果：</p>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-string\">&quot;tokens&quot;</span> : [\n    {\n      <span class=\"hljs-string\">&quot;token&quot;</span> : &quot;你好&quot;,\n      <span class=\"hljs-string\">&quot;start_offset&quot;</span> : 0,\n      <span class=\"hljs-string\">&quot;end_offset&quot;</span> : 2,\n      <span class=\"hljs-string\">&quot;type&quot;</span> : &quot;<span class=\"hljs-type\">CN_WORD</span><span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 0\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>我<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 3,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 4,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>CN_CHAR<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 1\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>的<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 4,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 5,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>CN_CHAR<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 2\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>世界<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 5,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 7,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>CN_WORD<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 3\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>hello<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 9,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 14,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>ENGLISH<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 4\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>world<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 15,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 20,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>ENGLISH<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 5\n    }\n  ]\n}</span>\n</code></pre>\n<h4 id=\"扩展和停用词词典\">扩展和停用词词典</h4>\n<p>随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。</p>\n<p>所以我们的词汇也需要不断的更新，IK 分词器提供了扩展词汇的功能。</p>\n<p>打开 IK 分词器 config 目录：</p>\n<pre><code class=\"hljs language-sh\">cd <span class=\"hljs-regexp\">/var/</span>lib<span class=\"hljs-regexp\">/docker/</span>volumes<span class=\"hljs-regexp\">/es-plugins/</span>_data<span class=\"hljs-regexp\">/ik/</span>config\n</code></pre>\n<p>在 IKAnalyzer.cfg.xml 配置文件内容添加：</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">properties</span> <span class=\"hljs-keyword\">SYSTEM</span> <span class=\"hljs-string\">&quot;http://java.sun.com/dtd/properties.dtd&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">properties</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">comment</span>&gt;</span>IK Analyzer 扩展配置<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">comment</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!--用户可以在这里配置自己的扩展字典 --&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">entry</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&quot;ext_dict&quot;</span>&gt;</span>ext.dic<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">entry</span>&gt;</span>\n         <span class=\"hljs-comment\">&lt;!--用户可以在这里配置自己的扩展停止词字典--&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">entry</span> <span class=\"hljs-attr\">key</span>=<span class=\"hljs-string\">&quot;ext_stopwords&quot;</span>&gt;</span>stopwort.dic<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">entry</span>&gt;</span>\n        <span class=\"hljs-comment\">&lt;!--用户可以在这里配置远程扩展字典 --&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- &lt;entry key=&quot;remote_ext_dict&quot;&gt;words_location&lt;/entry&gt; --&gt;</span>\n        <span class=\"hljs-comment\">&lt;!--用户可以在这里配置远程扩展停止词字典--&gt;</span>\n        <span class=\"hljs-comment\">&lt;!-- &lt;entry key=&quot;remote_ext_stopwords&quot;&gt;words_location&lt;/entry&gt; --&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">properties</span>&gt;</span>\n</code></pre>\n<p>新建一个 ext.dic，可以参考 config 目录下复制一个配置文件进行修改</p>\n<pre><code class=\"hljs language-properties\">我的世界\n</code></pre>\n<p>stopwort.dic 添加</p>\n<pre><code class=\"hljs language-properties\">的\n</code></pre>\n<p>重启 ElasticSearch </p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-attribute\">docker</span> restart es\n\n<span class=\"hljs-comment\"># 查看 日志</span>\ndocker logs -f elasticsearch\n</code></pre>\n<p>日志中已经成功加载 ext.dic 配置文件</p>\n<p>测试</p>\n<pre><code class=\"hljs language-json\">POST /<span class=\"hljs-title class_\">_analyze</span>\n<span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-string\">&quot;analyzer&quot;</span>: <span class=\"hljs-string\">&quot;ik_max_word&quot;</span>,\n  <span class=\"hljs-string\">&quot;text&quot;</span>: <span class=\"hljs-string\">&quot;你好,我的世界! Hello,World!&quot;</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-string\">&quot;tokens&quot;</span> : [\n    {\n      <span class=\"hljs-string\">&quot;token&quot;</span> : &quot;你好&quot;,\n      <span class=\"hljs-string\">&quot;start_offset&quot;</span> : 0,\n      <span class=\"hljs-string\">&quot;end_offset&quot;</span> : 2,\n      <span class=\"hljs-string\">&quot;type&quot;</span> : &quot;<span class=\"hljs-type\">CN_WORD</span><span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 0\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>我的世界<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 3,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 7,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>CN_WORD<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 1\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>世界<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 5,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 7,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>CN_WORD<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 2\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>hello<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 9,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 14,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>ENGLISH<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 3\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>world<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 15,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 20,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>ENGLISH<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 4\n    }\n  ]\n}</span>\n</code></pre>\n<blockquote>\n<p>注意当前文件的编码必须是 UTF-8 格式，严禁使用 Windows 记事本编辑</p>\n</blockquote>\n<h2 id=\"dsl-索引库操作\">DSL 索引库操作</h2>\n<p>索引库就类似数据库表，mapping 映射就类似表的结构。我们要向 es 中存储数据，必须先创建“库”和“表”。</p>\n<h3 id=\"mapping-映射属性\">mapping 映射属性</h3>\n<p>mapping 是对索引库中文档的约束，常见的mapping属性包括：</p>\n<ul>\n<li>type：字段数据类型，常见的简单类型有：<ul>\n<li>字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip 地址）</li>\n<li>数值：long、integer、short、byte、double、float、</li>\n<li>布尔：boolean</li>\n<li>日期：date</li>\n<li>对象：object</li>\n</ul>\n</li>\n<li>index：是否创建索引，默认为 true</li>\n<li>analyzer：使用哪种分词器</li>\n<li>properties：该字段的子字段</li>\n</ul>\n<p>例如下面的 JSON 文档：</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;age&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">21</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;weight&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">52.1</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;isMarried&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-keyword\">false</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;info&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;黑马程序员Java讲师&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;email&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;zy@itcast.cn&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;score&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">[</span><span class=\"hljs-number\">99.1</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-number\">99.5</span><span class=\"hljs-punctuation\">,</span> <span class=\"hljs-number\">98.9</span><span class=\"hljs-punctuation\">]</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;name&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-attr\">&quot;firstName&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;云&quot;</span><span class=\"hljs-punctuation\">,</span>\n        <span class=\"hljs-attr\">&quot;lastName&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;赵&quot;</span>\n    <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>对应的每个字段映射（mapping）：</p>\n<ul>\n<li>age：类型为 integer；参与搜索，因此需要 index 为 true；无需分词器</li>\n<li>weight：类型为 float；参与搜索，因此需要 index 为 true；无需分词器</li>\n<li>isMarried：类型为 boolean；参与搜索，因此需要 index 为 true；无需分词器</li>\n<li>info：类型为字符串，需要分词，因此是 text；参与搜索，因此需要 index 为 true；分词器可以用 ik_smart</li>\n<li>email：类型为字符串，但是不需要分词，因此是 keyword；不参与搜索，因此需要 index 为 false；无需分词器</li>\n<li>score：虽然是数组，但是我们只看元素的类型，类型为 float；参与搜索，因此需要 index 为 true；无需分词器</li>\n<li>name：类型为 object，需要定义多个子属性<ul>\n<li>name.firstName：类型为字符串，但是不需要分词，因此是 keyword；参与搜索，因此需要 index 为 true；无需分词器</li>\n<li>name.lastName：类型为字符串，但是不需要分词，因此是 keyword；参与搜索，因此需要 index 为 true；无需分词器</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"索引库的-crud\">索引库的 CRUD</h3>\n<p>这里统一使用 Kibana 编写 DSL 的方式来演示。</p>\n<h4 id=\"创建索引库和映射\">创建索引库和映射</h4>\n<p>基本语法：</p>\n<ul>\n<li>请求方式：PUT</li>\n<li>请求路径：/索引库名，可以自定义</li>\n<li>请求参数：mapping 映射</li>\n</ul>\n<pre><code class=\"hljs language-json\">PUT /索引库名称\n{\n  <span class=\"hljs-string\">&quot;mappings&quot;</span>: {\n    <span class=\"hljs-string\">&quot;properties&quot;</span>: {\n      <span class=\"hljs-string\">&quot;字段名&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;text&quot;</span>,\n        <span class=\"hljs-string\">&quot;analyzer&quot;</span>: <span class=\"hljs-string\">&quot;ik_smart&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;字段名2&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>,\n        <span class=\"hljs-string\">&quot;index&quot;</span>: <span class=\"hljs-string\">&quot;false&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;字段名3&quot;</span>:{\n        <span class=\"hljs-string\">&quot;properties&quot;</span>: {\n          <span class=\"hljs-string\">&quot;子字段&quot;</span>: {\n            <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>\n          }\n        }\n      },\n      <span class=\"hljs-regexp\">//</span> ...略\n    }\n  }\n}\n</code></pre>\n<p>示例：</p>\n<pre><code class=\"hljs language-json\">PUT <span class=\"hljs-string\">/heima</span>\n{\n  <span class=\"hljs-string\">&quot;mappings&quot;</span>: {\n    <span class=\"hljs-string\">&quot;properties&quot;</span>: {\n      <span class=\"hljs-string\">&quot;info&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;text&quot;</span>,\n        <span class=\"hljs-string\">&quot;analyzer&quot;</span>: <span class=\"hljs-string\">&quot;ik_smart&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;email&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>,\n        <span class=\"hljs-string\">&quot;index&quot;</span>: <span class=\"hljs-string\">&quot;falsae&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;name&quot;</span>:{\n        <span class=\"hljs-string\">&quot;properties&quot;</span>: {\n          <span class=\"hljs-string\">&quot;firstName&quot;</span>: {\n            <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>\n          }\n        }\n      },\n      <span class=\"hljs-string\">//</span> <span class=\"hljs-string\">...</span> 略\n    }\n  }\n}\n</code></pre>\n<h4 id=\"查询索引库\">查询索引库</h4>\n<p>基本语法：</p>\n<ul>\n<li><p>请求方式：GET</p>\n</li>\n<li><p>请求路径：/索引库名</p>\n</li>\n<li><p>请求参数：无</p>\n</li>\n</ul>\n<pre><code><span class=\"hljs-built_in\">GET</span> /索引库名\n</code></pre>\n<h4 id=\"删除索引库\">删除索引库</h4>\n<p>语法：</p>\n<ul>\n<li><p>请求方式：DELETE</p>\n</li>\n<li><p>请求路径：/索引库名</p>\n</li>\n<li><p>请求参数：无</p>\n</li>\n</ul>\n<pre><code><span class=\"hljs-keyword\">DELETE</span> /索引库名\n</code></pre>\n<h4 id=\"修改索引库\">修改索引库</h4>\n<p>倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库一旦创建，无法修改 mapping。</p>\n<p>虽然无法修改 mapping 中已有的字段，但是却允许添加新的字段到 mapping 中，因为不会对倒排索引产生影响。</p>\n<p>语法说明：</p>\n<pre><code class=\"hljs language-json\">PUT <span class=\"hljs-regexp\">/索引库名/</span>_mapping\n{\n  <span class=\"hljs-string\">&quot;properties&quot;</span>: {\n    <span class=\"hljs-string\">&quot;新字段名&quot;</span>: {\n      <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;xxxx&quot;</span>\n    }\n  }\n}\n</code></pre>\n<h4 id=\"索引库的-crud-小结\">索引库的 CRUD 小结</h4>\n<ul>\n<li>创建索引库：PUT /索引库名</li>\n<li>查询索引库：GET /索引库名</li>\n<li>删除索引库：DELETE /索引库名</li>\n<li>添加字段：PUT /索引库名/_mapping</li>\n</ul>\n<h2 id=\"dsl-文档操作\">DSL 文档操作</h2>\n<h3 id=\"新增文档\">新增文档</h3>\n<p> 语法：</p>\n<pre><code class=\"hljs language-json\">POST <span class=\"hljs-regexp\">/索引库名/</span>_doc/文档id\n{\n    <span class=\"hljs-string\">&quot;字段1&quot;</span>: <span class=\"hljs-string\">&quot;值1&quot;</span>,\n    <span class=\"hljs-string\">&quot;字段2&quot;</span>: <span class=\"hljs-string\">&quot;值2&quot;</span>,\n    <span class=\"hljs-string\">&quot;字段3&quot;</span>: {\n        <span class=\"hljs-string\">&quot;子属性1&quot;</span>: <span class=\"hljs-string\">&quot;值3&quot;</span>,\n        <span class=\"hljs-string\">&quot;子属性2&quot;</span>: <span class=\"hljs-string\">&quot;值4&quot;</span>\n    },\n    <span class=\"hljs-regexp\">//</span> ...\n}\n</code></pre>\n<p>示例：</p>\n<pre><code class=\"hljs language-json\">POST <span class=\"hljs-regexp\">/halo/</span>_doc/<span class=\"hljs-number\">1</span>\n{\n  <span class=\"hljs-string\">&quot;info&quot;</span>: <span class=\"hljs-string\">&quot;黑马程序员Java讲师&quot;</span>,\n  <span class=\"hljs-string\">&quot;email&quot;</span>: <span class=\"hljs-string\">&quot;zy@itcast.cn&quot;</span>,\n  <span class=\"hljs-string\">&quot;name&quot;</span>: {\n    <span class=\"hljs-string\">&quot;firstName&quot;</span>: <span class=\"hljs-string\">&quot;云&quot;</span>,\n    <span class=\"hljs-string\">&quot;lastName&quot;</span>: <span class=\"hljs-string\">&quot;赵&quot;</span>\n  }\n}\n</code></pre>\n<h3 id=\"查询文档\">查询文档</h3>\n<p>根据 rest 风格，新增是 post，查询应该是 get，不过查询一般都需要条件，这里我们把文档 id 带上。</p>\n<p>语法：</p>\n<pre><code>GET <span class=\"hljs-regexp\">/{索引库名称}/</span>_doc/{id}\n</code></pre>\n<p>通过 kibana 查看数据：</p>\n<pre><code>GET <span class=\"hljs-regexp\">/halo/</span>_doc/<span class=\"hljs-number\">1</span>\n</code></pre>\n<h3 id=\"删除文档\">删除文档</h3>\n<p>删除使用 DELETE 请求，同样，需要根据 id 进行删除：</p>\n<p>语法：</p>\n<pre><code><span class=\"hljs-keyword\">DELETE</span> <span class=\"hljs-regexp\">/{索引库名}/</span>_doc/id值\n</code></pre>\n<p>示例：</p>\n<pre><code><span class=\"hljs-keyword\">DELETE</span> <span class=\"hljs-regexp\">/halo/</span>_doc/<span class=\"hljs-number\">1</span>\n</code></pre>\n<h3 id=\"修改文档\">修改文档</h3>\n<p>修改有两种方式：</p>\n<ul>\n<li>全量修改：直接覆盖原来的文档</li>\n<li>增量修改：修改文档中的部分字段</li>\n</ul>\n<h4 id=\"全量修改\">全量修改</h4>\n<p>全量修改是覆盖原来的文档，其本质是：</p>\n<ul>\n<li>根据指定的 id 删除文档</li>\n<li>新增一个相同 id 的文档</li>\n</ul>\n<blockquote>\n<p>注意：如果根据 id 删除时，id 不存在，第二步的新增也会执行，也就从修改变成了新增操作了。</p>\n</blockquote>\n<p>语法：</p>\n<pre><code class=\"hljs language-json\">PUT <span class=\"hljs-regexp\">/{索引库名}/</span>_doc/文档id\n{\n    <span class=\"hljs-string\">&quot;字段1&quot;</span>: <span class=\"hljs-string\">&quot;值1&quot;</span>,\n    <span class=\"hljs-string\">&quot;字段2&quot;</span>: <span class=\"hljs-string\">&quot;值2&quot;</span>,\n    <span class=\"hljs-regexp\">//</span> ... 略\n}\n</code></pre>\n<p>示例：</p>\n<pre><code class=\"hljs language-json\">PUT <span class=\"hljs-regexp\">/halo/</span>_doc/<span class=\"hljs-number\">1</span>\n{\n  <span class=\"hljs-string\">&quot;info&quot;</span>: <span class=\"hljs-string\">&quot;黑马程序员高级Java讲师2&quot;</span>,\n  <span class=\"hljs-string\">&quot;email&quot;</span>: <span class=\"hljs-string\">&quot;zy@itcast.cn&quot;</span>,\n  <span class=\"hljs-string\">&quot;name&quot;</span>: {\n    <span class=\"hljs-string\">&quot;firstName&quot;</span>: <span class=\"hljs-string\">&quot;云&quot;</span>,\n    <span class=\"hljs-string\">&quot;lastName&quot;</span>: <span class=\"hljs-string\">&quot;赵&quot;</span>\n  }\n}\n</code></pre>\n<h4 id=\"增量修改\">增量修改</h4>\n<p>增量修改是只修改指定 id 匹配的文档中的部分字段。</p>\n<p>语法：</p>\n<pre><code class=\"hljs language-json\">POST <span class=\"hljs-regexp\">/{索引库名}/</span>_update/文档id\n{\n    <span class=\"hljs-string\">&quot;doc&quot;</span>: {\n         <span class=\"hljs-string\">&quot;字段名&quot;</span>: <span class=\"hljs-string\">&quot;新的值&quot;</span>,\n    }\n}\n</code></pre>\n<p>示例：</p>\n<pre><code>POST <span class=\"hljs-regexp\">/halo/</span>_update/<span class=\"hljs-number\">1</span>\n{\n  <span class=\"hljs-string\">&quot;doc&quot;</span>: {\n    <span class=\"hljs-string\">&quot;email&quot;</span>: <span class=\"hljs-string\">&quot;ZhaoYun@itcast.cn&quot;</span>\n  }\n}\n</code></pre>\n<h3 id=\"文档操作总结\">文档操作总结</h3>\n<ul>\n<li>创建文档：POST /{索引库名}/_doc/文档id   { JSON 文档 }</li>\n<li>查询文档：GET /{索引库名}/_doc/文档id</li>\n<li>删除文档：DELETE /{索引库名}/_doc/文档id</li>\n<li>修改文档：<ul>\n<li>全量修改：PUT /{索引库名}/_doc/文档id { JSON 文档 }</li>\n<li>增量修改：POST /{索引库名}/_update/文档id { “doc”: {字段}}</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"rest-client-索引库操作\">Rest Client 索引库操作</h2>\n<p>ElasticSearch 官方提供了各种不同语言的客户端，用来操作 ElasticSearch。这些客户端的本质就是组装 DSL 语句，通过 http 请求发送给 ElasticSearch。官方文档地址：<a href=\"https://www.elastic.co/guide/en/elasticsearch/client/index.html\">https://www.elastic.co/guide/en/elasticsearch/client/index.html</a></p>\n<p>其中的 Java Rest Client 又包括两种：</p>\n<ul>\n<li>Java Low Level Rest Client</li>\n<li>Java High Level Rest Client</li>\n</ul>\n<p>我们学习的是 Java HighLevel Rest Client 客户端 API</p>\n<h3 id=\"创建测试环境\">创建测试环境</h3>\n<h4 id=\"初始化项目\">初始化项目</h4>\n<p>创建数据库，建立数据表</p>\n<pre><code class=\"hljs language-sql\"><span class=\"hljs-keyword\">CREATE</span> <span class=\"hljs-keyword\">TABLE</span> `tb_hotel`  (\n    `id` <span class=\"hljs-type\">bigint</span>(<span class=\"hljs-number\">20</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">&#x27;酒店id&#x27;</span>,\n    `<span class=\"hljs-type\">name</span>` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8 <span class=\"hljs-keyword\">COLLATE</span> utf8_general_ci <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">&#x27;酒店名称&#x27;</span>,\n    `address` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8 <span class=\"hljs-keyword\">COLLATE</span> utf8_general_ci <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">&#x27;酒店地址&#x27;</span>,\n    `price` <span class=\"hljs-type\">int</span>(<span class=\"hljs-number\">10</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">&#x27;酒店价格&#x27;</span>,\n    `score` <span class=\"hljs-type\">int</span>(<span class=\"hljs-number\">2</span>) <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">&#x27;酒店评分&#x27;</span>,\n    `brand` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">32</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8 <span class=\"hljs-keyword\">COLLATE</span> utf8_general_ci <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">&#x27;酒店品牌&#x27;</span>,\n    `city` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">32</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8 <span class=\"hljs-keyword\">COLLATE</span> utf8_general_ci <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">&#x27;所在城市&#x27;</span>,\n    `star_name` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">16</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8 <span class=\"hljs-keyword\">COLLATE</span> utf8_general_ci <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">&#x27;酒店星级，1星到5星，1钻到5钻&#x27;</span>,\n    `business` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8 <span class=\"hljs-keyword\">COLLATE</span> utf8_general_ci <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">&#x27;商圈&#x27;</span>,\n    `latitude` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">32</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8 <span class=\"hljs-keyword\">COLLATE</span> utf8_general_ci <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">&#x27;纬度&#x27;</span>,\n    `longitude` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">32</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8 <span class=\"hljs-keyword\">COLLATE</span> utf8_general_ci <span class=\"hljs-keyword\">NOT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">&#x27;经度&#x27;</span>,\n    `pic` <span class=\"hljs-type\">varchar</span>(<span class=\"hljs-number\">255</span>) <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> utf8 <span class=\"hljs-keyword\">COLLATE</span> utf8_general_ci <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">DEFAULT</span> <span class=\"hljs-keyword\">NULL</span> <span class=\"hljs-keyword\">COMMENT</span> <span class=\"hljs-string\">&#x27;酒店图片&#x27;</span>,\n    <span class=\"hljs-keyword\">PRIMARY KEY</span> (`id`) <span class=\"hljs-keyword\">USING</span> BTREE\n) ENGINE = InnoDB <span class=\"hljs-type\">CHARACTER</span> <span class=\"hljs-keyword\">SET</span> = utf8 <span class=\"hljs-keyword\">COLLATE</span> = utf8_general_ci ROW_FORMAT = Compact;\n</code></pre>\n<p>导入数据库数据：<a href=\"https://github.com/Lanqilu/HaloElasticSearch/blob/master/doc/database/tb_hotel.sql\">链接</a></p>\n<p>初始项目代码：<a href=\"https://github.com/Lanqilu/HaloElasticSearch/commit/d64b305ccf9ca67b8a18bafee3df7163e7dd8246\">链接</a></p>\n<h4 id=\"mapping-映射分析\">mapping 映射分析</h4>\n<p>创建索引库，最关键的是 mapping 映射，而 mapping 映射要考虑的信息包括：</p>\n<ul>\n<li>字段名</li>\n<li>字段数据类型</li>\n<li>是否参与搜索</li>\n<li>是否需要分词</li>\n<li>如果分词，分词器是什么？</li>\n</ul>\n<p>其中：</p>\n<ul>\n<li>字段名、字段数据类型，可以参考数据表结构的名称和类型</li>\n<li>是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索</li>\n<li>是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词</li>\n<li>分词器，我们可以统一使用 ik_max_word</li>\n</ul>\n<p>来看下酒店数据的索引库结构：</p>\n<pre><code class=\"hljs language-json\">PUT <span class=\"hljs-string\">/hotel</span>\n{\n  <span class=\"hljs-string\">&quot;mappings&quot;</span>: {\n    <span class=\"hljs-string\">&quot;properties&quot;</span>: {\n      <span class=\"hljs-string\">&quot;id&quot;</span>: {\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;name&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;text&quot;</span>,\n        <span class=\"hljs-string\">&quot;analyzer&quot;</span>: <span class=\"hljs-string\">&quot;ik_max_word&quot;</span>,\n        <span class=\"hljs-string\">&quot;copy_to&quot;</span>: <span class=\"hljs-string\">&quot;all&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;address&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>,\n        <span class=\"hljs-string\">&quot;index&quot;</span>: <span class=\"hljs-literal\">false</span>\n      },\n      <span class=\"hljs-string\">&quot;price&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;integer&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;score&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;integer&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;brand&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>,\n        <span class=\"hljs-string\">&quot;copy_to&quot;</span>: <span class=\"hljs-string\">&quot;all&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;city&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>,\n        <span class=\"hljs-string\">&quot;copy_to&quot;</span>: <span class=\"hljs-string\">&quot;all&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;starName&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;business&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;location&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;geo_point&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;pic&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>,\n        <span class=\"hljs-string\">&quot;index&quot;</span>: <span class=\"hljs-literal\">false</span>\n      },\n      <span class=\"hljs-string\">&quot;all&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;text&quot;</span>,\n        <span class=\"hljs-string\">&quot;analyzer&quot;</span>: <span class=\"hljs-string\">&quot;ik_max_word&quot;</span>\n      }\n    }\n  }\n}\n</code></pre>\n<p>几个特殊字段说明：</p>\n<ul>\n<li>location：地理坐标，里面包含精度、纬度</li>\n<li>all：一个组合字段，其目的是将多字段的值 利用 copy_to 合并，提供给用户搜索</li>\n</ul>\n<p> ES 中支持两种地理坐标数据类型：</p>\n<p>•geo_point：由纬度（latitude）和经度（longitude）确定的一个点。例如：”32.8752345, 120.2981576”</p>\n<p>•geo_shape：有多个geo_point组成的复杂几何图形。例如一条直线，”LINESTRING (-77.03653 38.897676, -77.009051 38.889939)”</p>\n<p>字段拷贝可以使用 copy_to 属性将当前字段拷贝到指定字段。示例：</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-attr\">&quot;all&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;type&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;text&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;analyzer&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;ik_max_word&quot;</span>\n<span class=\"hljs-punctuation\">}</span><span class=\"hljs-punctuation\">,</span>\n<span class=\"hljs-attr\">&quot;brand&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-attr\">&quot;type&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;keyword&quot;</span><span class=\"hljs-punctuation\">,</span>\n  <span class=\"hljs-attr\">&quot;copy_to&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;all&quot;</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<h4 id=\"初始化-restclient\">初始化 RestClient</h4>\n<p>在 ElasticSearch 提供的 API 中，与 ElasticSearch 一切交互都封装在一个名为 RestHighLevelClient 的类中，必须先完成这个对象的初始化，建立与 ElasticSearch 的连接。</p>\n<p>分为三步：</p>\n<p>① 引入 ElasticSearch 的 RestHighLevelClient 依赖：</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.elasticsearch.client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>② 因为 SpringBoot 默认的 ElasticSearch 版本是 7.6.2，所以我们需要覆盖默认的 ElasticSearch 版本，与 ElasticSearch 版本保持一致</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-section\">&lt;properties&gt;</span>\n    <span class=\"hljs-section\">&lt;java.version&gt;</span><span class=\"hljs-attribute\">1</span>.<span class=\"hljs-number\">8</span>&lt;/java.version&gt;\n    <span class=\"hljs-section\">&lt;elasticsearch.version&gt;</span><span class=\"hljs-attribute\">7</span>.<span class=\"hljs-number\">14</span>.<span class=\"hljs-number\">1</span>&lt;/elasticsearch.version&gt;\n<span class=\"hljs-section\">&lt;/properties&gt;</span>\n</code></pre>\n<p>③ 初始化 RestHighLevelClient：</p>\n<p>初始化的代码如下：</p>\n<pre><code class=\"hljs language-java\">RestHighLevelClient client = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">RestHighLevelClient(RestClient.<span class=\"hljs-params\">builder</span>(HttpHost.<span class=\"hljs-params\">create</span>(<span class=\"hljs-string\">&quot;http://halo:9200&quot;</span>)</span>));\n</code></pre>\n<p>这里为了单元测试方便，我们创建一个测试类 HotelIndexTest，然后将初始化的代码编写在 <code>@BeforeEach</code> 方法中：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HotelIndexTest</span> </span>{\n\n    <span class=\"hljs-keyword\">private</span> RestHighLevelClient client;\n\n    <span class=\"hljs-meta\">@Test</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">testInit</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.println(<span class=\"hljs-string\">&quot;client = &quot;</span> + client);\n    }\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setUp</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.client = <span class=\"hljs-keyword\">new</span> RestHighLevelClient(RestClient.builder(HttpHost.create(<span class=\"hljs-string\">&quot;http://halo:9200&quot;</span>)));\n    }\n\n    <span class=\"hljs-meta\">@AfterEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">tearDown</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        <span class=\"hljs-keyword\">this</span>.client.close();\n    }\n}\n</code></pre>\n<h3 id=\"创建索引库\">创建索引库</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.zlx2xrhd54w.png\" alt=\"image\"></p>\n<p>代码分为三步：</p>\n<ol>\n<li>创建 Request 对象。因为是创建索引库的操作，因此 Request 是 CreateIndexRequest</li>\n<li>添加请求参数，其实就是 DSL 的 JSON 参数部分。因为 JSON 字符串很长，这里是定义了静态字符串常量 MAPPING_TEMPLATE，让代码看起来更加优雅。</li>\n<li>发送请求，<code>client.indices()</code> 方法的返回值是 IndicesClient 类型，封装了所有与索引库操作有关的方法。</li>\n</ol>\n<p>在 hotel-demo 中的 HotelIndexTest 测试类中，编写单元测试，实现创建索引：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">createHotelIndex</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException {\n    <span class=\"hljs-comment\">// 1.创建Request对象</span>\n    <span class=\"hljs-type\">CreateIndexRequest</span> <span class=\"hljs-variable\">request</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CreateIndexRequest</span>(<span class=\"hljs-string\">&quot;hotel&quot;</span>);\n    <span class=\"hljs-comment\">// 2.准备请求的参数：DSL语句</span>\n    request.source(MAPPING_TEMPLATE, XContentType.JSON);\n    <span class=\"hljs-comment\">// 3.发送请求</span>\n    client.indices().create(request, RequestOptions.DEFAULT);\n}\n</code></pre>\n<h3 id=\"删除索引库-1\">删除索引库</h3>\n<p>删除索引库的 DSL 语句非常简单：</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-keyword\">DELETE</span> /hotel\n</code></pre>\n<p>与创建索引库相比：</p>\n<ul>\n<li>请求方式从 PUT 变为 DELTE</li>\n<li>请求路径不变</li>\n<li>无请求参数</li>\n</ul>\n<p>所以代码的差异，注意体现在 Request 对象上。依然是三步走：</p>\n<ul>\n<li>创建 Request 对象。这次是 DeleteIndexRequest 对象</li>\n<li>准备参数。这里是无参</li>\n<li>发送请求。改用 delete 方法</li>\n</ul>\n<p>在 hotel-demo 中的 HotelIndexTest 测试类中，编写单元测试，实现删除索引：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testDeleteHotelIndex</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException {\n    <span class=\"hljs-comment\">// 1.创建Request对象</span>\n    <span class=\"hljs-type\">DeleteIndexRequest</span> <span class=\"hljs-variable\">request</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DeleteIndexRequest</span>(<span class=\"hljs-string\">&quot;hotel&quot;</span>);\n    <span class=\"hljs-comment\">// 2.发送请求</span>\n    client.indices().delete(request, RequestOptions.DEFAULT);\n}\n</code></pre>\n<h3 id=\"判断索引库是否存在\">判断索引库是否存在</h3>\n<p>判断索引库是否存在，本质就是查询，对应的DSL是：</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-built_in\">GET</span> /hotel\n</code></pre>\n<p>因此与删除的 Java 代码流程是类似的。依然是三步走：</p>\n<ul>\n<li>创建 Request 对象。这次是 GetIndexRequest 对象</li>\n<li>准备参数。这里是无参</li>\n<li>发送请求。改用 exists 方法</li>\n</ul>\n<pre><code class=\"hljs language-java\">@<span class=\"hljs-function\">Test\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title\">testExistsHotelIndex</span><span class=\"hljs-params\">()</span> throws IOException </span>{\n    <span class=\"hljs-comment\">// 1.创建Request对象</span>\n    GetIndexRequest request = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">GetIndexRequest</span>(<span class=\"hljs-string\">&quot;hotel&quot;</span>);\n    <span class=\"hljs-comment\">// 2.发送请求</span>\n    <span class=\"hljs-type\">boolean</span> exists = client.<span class=\"hljs-built_in\">indices</span>().<span class=\"hljs-built_in\">exists</span>(request, RequestOptions.<span class=\"hljs-literal\">DEFAULT</span>);\n    <span class=\"hljs-comment\">// 3.输出</span>\n    System.err.<span class=\"hljs-built_in\">println</span>(exists ? <span class=\"hljs-string\">&quot;索引库已经存在！&quot;</span> : <span class=\"hljs-string\">&quot;索引库不存在！&quot;</span>);\n}\n</code></pre>\n<h3 id=\"restapi-小结\">RestAPI 小结</h3>\n<p>JavaRestClient 操作 ElasticSearch 的流程基本类似。核心是 <code>client.indices()</code> 方法来获取索引库的操作对象。</p>\n<p>索引库操作的基本步骤：</p>\n<ul>\n<li>初始化 RestHighLevelClient</li>\n<li>创建 XxxIndexRequest。Xxx 是Create、Get、Delete</li>\n<li>准备 DSL（ Create时需要，其它是无参）</li>\n<li>发送请求。调用 <code>RestHighLevelClient#indices().xxx()</code> 方法，xxx 是  create、exists、delete</li>\n</ul>\n<h2 id=\"rest-client-文档操作\">Rest Client 文档操作</h2>\n<p>去数据库查询酒店数据，导入到 hotel 索引库，实现酒店数据的 CRUD。基本步骤如下：</p>\n<ul>\n<li>初始化 JavaRestClient</li>\n<li>利用 JavaRestClient 新增酒店数据</li>\n<li>利用 JavaRestClient 根据id查询酒店数据</li>\n<li>利用 JavaRestClient 删除酒店数据</li>\n<li>利用 JavaRestClient 修改酒店数据</li>\n</ul>\n<h3 id=\"初始化-javarestclient\">初始化 JavaRestClient</h3>\n<p>为了与索引库操作分离，我们再次参加一个测试类，做两件事情：</p>\n<ul>\n<li>初始化 RestHighLevelClient，同上</li>\n<li>我们的酒店数据在数据库，需要利用 IHotelService 去查询，所以注入这个接口</li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@SpringBootTest</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HotelDocumentTest</span> </span>{\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> IHotelService hotelService;\n\n    <span class=\"hljs-keyword\">private</span> RestHighLevelClient client;\n\n    <span class=\"hljs-meta\">@BeforeEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setUp</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">this</span>.client = <span class=\"hljs-keyword\">new</span> RestHighLevelClient(RestClient.builder(HttpHost.create(<span class=\"hljs-string\">&quot;http://halo:9200&quot;</span>)));\n    }\n\n    <span class=\"hljs-meta\">@AfterEach</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">tearDown</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException </span>{\n        <span class=\"hljs-keyword\">this</span>.client.close();\n    }\n}\n</code></pre>\n<h3 id=\"新增文档-1\">新增文档</h3>\n<p>我们要将数据库的酒店数据查询出来，写入 ElasticSearch 中。</p>\n<h4 id=\"索引库实体类\">索引库实体类</h4>\n<p>数据库查询后的结果是一个 Hotel 类型的对象。结构如下：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Data</span>\n<span class=\"hljs-meta\">@TableName</span>(<span class=\"hljs-string\">&quot;tb_hotel&quot;</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Hotel</span> {\n    <span class=\"hljs-meta\">@TableId</span>(<span class=\"hljs-keyword\">type</span> = <span class=\"hljs-title class_\">IdType</span>.<span class=\"hljs-property\">INPUT</span>)\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">Long</span> id;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">String</span> name;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">String</span> address;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">Integer</span> price;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">Integer</span> score;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">String</span> brand;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">String</span> city;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">String</span> starName;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">String</span> business;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">String</span> longitude;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">String</span> latitude;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">String</span> pic;\n}\n</code></pre>\n<p>与我们的索引库结构存在差异：</p>\n<ul>\n<li>longitude 和 latitude 需要合并为 location</li>\n</ul>\n<p>因此，我们需要定义一个新的类型，与索引库结构吻合：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">package</span> cn.itcast.hotel.pojo;\n\n<span class=\"hljs-keyword\">import</span> lombok.Data;\n<span class=\"hljs-keyword\">import</span> lombok.NoArgsConstructor;\n\n<span class=\"hljs-meta\">@Data</span>\n<span class=\"hljs-meta\">@NoArgsConstructor</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HotelDoc</span> </span>{\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">Long</span> id;\n    <span class=\"hljs-keyword\">private</span> String name;\n    <span class=\"hljs-keyword\">private</span> String address;\n    <span class=\"hljs-keyword\">private</span> Integer price;\n    <span class=\"hljs-keyword\">private</span> Integer score;\n    <span class=\"hljs-keyword\">private</span> String brand;\n    <span class=\"hljs-keyword\">private</span> String city;\n    <span class=\"hljs-keyword\">private</span> String starName;\n    <span class=\"hljs-keyword\">private</span> String business;\n    <span class=\"hljs-keyword\">private</span> String location;\n    <span class=\"hljs-keyword\">private</span> String pic;\n\n    <span class=\"hljs-keyword\">public</span> HotelDoc(Hotel hotel) {\n        <span class=\"hljs-keyword\">this</span>.id = hotel.getId();\n        <span class=\"hljs-keyword\">this</span>.name = hotel.getName();\n        <span class=\"hljs-keyword\">this</span>.address = hotel.getAddress();\n        <span class=\"hljs-keyword\">this</span>.price = hotel.getPrice();\n        <span class=\"hljs-keyword\">this</span>.score = hotel.getScore();\n        <span class=\"hljs-keyword\">this</span>.brand = hotel.getBrand();\n        <span class=\"hljs-keyword\">this</span>.city = hotel.getCity();\n        <span class=\"hljs-keyword\">this</span>.starName = hotel.getStarName();\n        <span class=\"hljs-keyword\">this</span>.business = hotel.getBusiness();\n        <span class=\"hljs-keyword\">this</span>.location = hotel.getLatitude() + <span class=\"hljs-string\">&quot;, &quot;</span> + hotel.getLongitude();\n        <span class=\"hljs-keyword\">this</span>.pic = hotel.getPic();\n    }\n}\n</code></pre>\n<h4 id=\"语法说明\">语法说明</h4>\n<p>新增文档的 DSL 语句如下：</p>\n<pre><code class=\"hljs language-json\">POST <span class=\"hljs-regexp\">/{索引库名}/</span>_doc/<span class=\"hljs-number\">1</span>\n{\n    <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;Jack&quot;</span>,\n    <span class=\"hljs-string\">&quot;age&quot;</span>: <span class=\"hljs-number\">21</span>\n}\n</code></pre>\n<p>对应的 Java 代码如下：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Test</span>\nvoid testIndexDocument() <span class=\"hljs-keyword\">throws</span> <span class=\"hljs-type\">IOException</span> {\n    <span class=\"hljs-comment\">// 1.创建request对象</span>\n    <span class=\"hljs-type\">IndexRequest</span> request <span class=\"hljs-operator\">=</span> new <span class=\"hljs-type\">IndexRequest</span>(<span class=\"hljs-string\">&quot;indexName&quot;</span>).id(<span class=\"hljs-string\">&quot;1&quot;</span>);\n    <span class=\"hljs-comment\">// 2.准备JSON文档</span>\n    request.source(<span class=\"hljs-string\">&quot;{<span class=\"hljs-subst\">\\&quot;</span>name<span class=\"hljs-subst\">\\&quot;</span>: <span class=\"hljs-subst\">\\&quot;</span>Jack<span class=\"hljs-subst\">\\&quot;</span>, <span class=\"hljs-subst\">\\&quot;</span>age<span class=\"hljs-subst\">\\&quot;</span>: 21}&quot;</span>, <span class=\"hljs-type\">XContentType</span>.<span class=\"hljs-type\">JSON</span>);\n    <span class=\"hljs-comment\">// 3.发送请求</span>\n    client.index(request, <span class=\"hljs-type\">RequestOptions</span>.<span class=\"hljs-type\">DEFAULT</span>);\n}\n</code></pre>\n<p>可以看到与创建索引库类似，同样是三步走：</p>\n<ul>\n<li>创建 Request 对象</li>\n<li>准备请求参数，也就是 DSL 中的 JSON 文档</li>\n<li>发送请求</li>\n</ul>\n<p>变化的地方在于，这里直接使用 <code>client.xxx()</code> 的 API，不再需要 <code>client.indices()</code> 了。</p>\n<h4 id=\"完整代码\">完整代码</h4>\n<p>我们导入酒店数据，基本流程一致，但是需要考虑几点变化：</p>\n<ul>\n<li>酒店数据来自于数据库，我们需要先查询出来，得到 Hotel 对象</li>\n<li>Hotel 对象需要转为 HotelDoc对象</li>\n<li>HotelDoc 需要序列化为 JSON 格式</li>\n</ul>\n<p>因此，代码整体步骤如下：</p>\n<ul>\n<li>根据 id 查询酒店数据 Hotel</li>\n<li>将 Hotel 封装为 HotelDoc</li>\n<li>将 HotelDoc 序列化为 JSON</li>\n<li>创建 IndexRequest，指定索引库名和 id</li>\n<li>准备请求参数，也就是 JSON 文档</li>\n<li>发送请求</li>\n</ul>\n<p>在 hotel-demo 的 HotelDocumentTest 测试类中，编写单元测试：</p>\n<pre><code class=\"hljs language-java\">@Test\nvoid test<span class=\"hljs-constructor\">AddDocument()</span> throws IOException {\n    <span class=\"hljs-comment\">// 1.根据id查询酒店数据</span>\n    Hotel hotel = hotelService.get<span class=\"hljs-constructor\">ById(61083L)</span>;\n    <span class=\"hljs-comment\">// 2.转换为文档类型</span>\n    HotelDoc hotelDoc = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">HotelDoc(<span class=\"hljs-params\">hotel</span>)</span>;\n    <span class=\"hljs-comment\">// 3.将HotelDoc转json</span>\n    String json = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">JSON</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">JSONString(<span class=\"hljs-params\">hotelDoc</span>)</span>;\n\n    <span class=\"hljs-comment\">// 1.准备Request对象</span>\n    IndexRequest request = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">IndexRequest(<span class=\"hljs-string\">&quot;hotel&quot;</span>)</span>.id(hotelDoc.get<span class=\"hljs-constructor\">Id()</span>.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String()</span>);\n    <span class=\"hljs-comment\">// 2.准备Json文档</span>\n    request.source(json, XContentType.JSON);\n    <span class=\"hljs-comment\">// 3.发送请求</span>\n    client.index(request, RequestOptions.DEFAULT);\n}\n</code></pre>\n<h3 id=\"查询文档-1\">查询文档</h3>\n<h4 id=\"语法说明-1\">语法说明</h4>\n<p>查询的 DSL 语句如下：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_doc/{id}\n</code></pre>\n<p>非常简单，因此代码大概分两步：</p>\n<ul>\n<li>准备 Request 对象</li>\n<li>发送请求</li>\n</ul>\n<p>不过查询的目的是得到结果，解析为 HotelDoc，因此难点是结果的解析。示例代码如下：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testGetDocumentById</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException {\n    <span class=\"hljs-comment\">// 1.创建request对象</span>\n    <span class=\"hljs-type\">GetRequest</span> <span class=\"hljs-variable\">request</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">GetRequest</span>(<span class=\"hljs-string\">&quot;indexName&quot;</span>, <span class=\"hljs-string\">&quot;1&quot;</span>);\n    <span class=\"hljs-comment\">// 2.发送请求，得到结果</span>\n    <span class=\"hljs-type\">GetResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> client.get(request, RequestOptions.DEFAULT);\n    <span class=\"hljs-comment\">// 3.解析结果</span>\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">json</span> <span class=\"hljs-operator\">=</span> response.getSourceAsString();\n    System.out.println(json);\n}\n</code></pre>\n<p>可以看到，结果是一个 JSON，其中文档放在一个 <code>_source</code> 属性中，因此解析就是拿到 <code>_source</code>，反序列化为 Java 对象即可。</p>\n<p>与之前类似，也是三步走：</p>\n<ul>\n<li>准备 Request 对象。这次是查询，所以是 GetRequest</li>\n<li>发送请求，得到结果。因为是查询，这里调用 <code>client.get()</code> 方法</li>\n<li>解析结果，就是对 JSON 做反序列化</li>\n</ul>\n<h4 id=\"完整代码-1\">完整代码</h4>\n<p>在 hotel-demo 的 HotelDocumentTest 测试类中，编写单元测试：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testGetDocumentById</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException {\n    <span class=\"hljs-comment\">// 1.准备Request</span>\n    <span class=\"hljs-type\">GetRequest</span> <span class=\"hljs-variable\">request</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">GetRequest</span>(<span class=\"hljs-string\">&quot;hotel&quot;</span>, <span class=\"hljs-string\">&quot;61083&quot;</span>);\n    <span class=\"hljs-comment\">// 2.发送请求，得到响应</span>\n    <span class=\"hljs-type\">GetResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> client.get(request, RequestOptions.DEFAULT);\n    <span class=\"hljs-comment\">// 3.解析响应结果</span>\n    <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">json</span> <span class=\"hljs-operator\">=</span> response.getSourceAsString();\n    <span class=\"hljs-type\">HotelDoc</span> <span class=\"hljs-variable\">hotelDoc</span> <span class=\"hljs-operator\">=</span> JSON.parseObject(json, HotelDoc.class);\n    System.out.println(hotelDoc);\n}\n</code></pre>\n<h3 id=\"修改文档-1\">修改文档</h3>\n<h4 id=\"语法说明-2\">语法说明</h4>\n<p>修改我们讲过两种方式：</p>\n<ul>\n<li>全量修改：本质是先根据id删除，再新增</li>\n<li>增量修改：修改文档中的指定字段值</li>\n</ul>\n<p>在 RestClient 的 API 中，全量修改与新增的 API 完全一致，判断依据是 ID：</p>\n<ul>\n<li>如果新增时，ID 已经存在，则修改</li>\n<li>如果新增时，ID 不存在，则新增</li>\n</ul>\n<p>这里不再赘述，我们主要关注增量修改。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testUpdateDocumentById</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException {\n    <span class=\"hljs-comment\">// 1.创建request对象</span>\n    <span class=\"hljs-type\">UpdateRequest</span> <span class=\"hljs-variable\">request</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">UpdateRequest</span>(<span class=\"hljs-string\">&quot;indexName&quot;</span>, <span class=\"hljs-string\">&quot;1&quot;</span>);\n    <span class=\"hljs-comment\">// 2.准备参数，每2个参数为一对 key value    </span>\n    request.doc(<span class=\"hljs-string\">&quot;age&quot;</span>, <span class=\"hljs-number\">18</span>, <span class=\"hljs-string\">&quot;name&quot;</span>, <span class=\"hljs-string\">&quot;Rose&quot;</span>);\n    <span class=\"hljs-comment\">// 3.更新文档</span>\n    client.update(request, RequestOptions.DEFAULT);\n}\n</code></pre>\n<p>与之前类似，也是三步走：</p>\n<ul>\n<li>准备 Request 对象。这次是修改，所以是 UpdateRequest</li>\n<li>准备参数。也就是 JSON 文档，里面包含要修改的字段</li>\n<li>更新文档。这里调用 <code>client.update()</code> 方法</li>\n</ul>\n<h4 id=\"完整代码-2\">完整代码</h4>\n<p>在 hotel-demo 的 HotelDocumentTest 测试类中，编写单元测试：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testUpdateDocument</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException {\n    <span class=\"hljs-comment\">// 1.准备Request</span>\n    <span class=\"hljs-type\">UpdateRequest</span> <span class=\"hljs-variable\">request</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">UpdateRequest</span>(<span class=\"hljs-string\">&quot;hotel&quot;</span>, <span class=\"hljs-string\">&quot;61083&quot;</span>);\n    <span class=\"hljs-comment\">// 2.准备请求参数</span>\n    request.doc(\n        <span class=\"hljs-string\">&quot;price&quot;</span>, <span class=\"hljs-string\">&quot;952&quot;</span>,\n        <span class=\"hljs-string\">&quot;starName&quot;</span>, <span class=\"hljs-string\">&quot;四钻&quot;</span>\n    );\n    <span class=\"hljs-comment\">// 3.发送请求</span>\n    client.update(request, RequestOptions.DEFAULT);\n}\n</code></pre>\n<h3 id=\"删除文档-1\">删除文档</h3>\n<p>删除的 DSL 为是这样的：</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-keyword\">DELETE</span> <span class=\"hljs-regexp\">/hotel/</span>_doc/{id}\n</code></pre>\n<p>与查询相比，仅仅是请求方式从 DELETE 变成 GET，可以想象 Java 代码应该依然是三步走：</p>\n<ul>\n<li>准备 Request 对象，因为是删除，这次是 DeleteRequest 对象。要指定索引库名和 id</li>\n<li>准备参数，无参</li>\n<li>发送请求。因为是删除，所以是 <code>client.delete()</code> 方法</li>\n</ul>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testDeleteDocument</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException {\n    <span class=\"hljs-comment\">// 1.准备Request</span>\n    <span class=\"hljs-type\">DeleteRequest</span> <span class=\"hljs-variable\">request</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">DeleteRequest</span>(<span class=\"hljs-string\">&quot;hotel&quot;</span>, <span class=\"hljs-string\">&quot;61083&quot;</span>);\n    <span class=\"hljs-comment\">// 2.发送请求</span>\n    client.delete(request, RequestOptions.DEFAULT);\n}\n</code></pre>\n<h3 id=\"批量导入文档\">批量导入文档</h3>\n<p>案例需求：利用 BulkRequest 批量将数据库数据导入到索引库中。</p>\n<p>步骤如下：</p>\n<ul>\n<li><p>利用 mybatis-plus 查询酒店数据</p>\n</li>\n<li><p>将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）</p>\n</li>\n<li><p>利用 JavaRestClient 中的 BulkRequest 批处理，实现批量新增文档</p>\n</li>\n</ul>\n<h4 id=\"语法说明-3\">语法说明</h4>\n<p>批量处理 BulkRequest，其本质就是将多个普通的 CRUD 请求组合在一起发送。</p>\n<p>其中提供了一个 add 方法，用来添加其他请求：</p>\n<ul>\n<li>IndexRequest，也就是新增</li>\n<li>UpdateRequest，也就是修改</li>\n<li>DeleteRequest，也就是删除</li>\n</ul>\n<p>因此 Bulk 中添加了多个 IndexRequest，就是批量新增功能了。示例：</p>\n<pre><code class=\"hljs language-java\">@Test\n<span class=\"hljs-keyword\">void</span> testBulk() <span class=\"hljs-keyword\">throws</span> IOException {\n    <span class=\"hljs-comment\">// 1.创建Bulk请求</span>\n    BulkRequest request = <span class=\"hljs-keyword\">new</span> BulkRequest();\n    <span class=\"hljs-comment\">// 2.添加要批量提交的请求：这里添加了两个新增文档的请求</span>\n    request.add(<span class=\"hljs-keyword\">new</span> IndexRequest(<span class=\"hljs-string\">&quot;hotel&quot;</span>)\n                .id(<span class=\"hljs-string\">&quot;101&quot;</span>).<span class=\"hljs-keyword\">source</span>(<span class=\"hljs-string\">&quot;json source&quot;</span>, XContentType.JSON));\n    request.add(<span class=\"hljs-keyword\">new</span> IndexRequest(<span class=\"hljs-string\">&quot;hotel&quot;</span>)\n                .id(<span class=\"hljs-string\">&quot;102&quot;</span>).<span class=\"hljs-keyword\">source</span>(<span class=\"hljs-string\">&quot;json source2&quot;</span>, XContentType.JSON));\n    <span class=\"hljs-comment\">// 3.发起bulk请求</span>\n    client.bulk(request, RequestOptions.<span class=\"hljs-keyword\">DEFAULT</span>);\n}\n</code></pre>\n<p>其实还是三步走：</p>\n<ul>\n<li>创建 Request 对象。这里是 BulkRequest</li>\n<li>准备参数。批处理的参数，就是其它 Request 对象，这里就是多个 IndexRequest</li>\n<li>发起请求。这里是批处理，调用的方法为 <code>client.bulk()</code> 方法</li>\n</ul>\n<p>我们在导入酒店数据时，将上述代码改造成 for 循环处理即可。</p>\n<h4 id=\"完整代码-3\">完整代码</h4>\n<p>在 hotel-demo 的 HotelDocumentTest 测试类中，编写单元测试：</p>\n<pre><code class=\"hljs language-java\">@Test\nvoid test<span class=\"hljs-constructor\">BulkRequest()</span> throws IOException {\n    <span class=\"hljs-comment\">// 批量查询酒店数据</span>\n    List&lt;Hotel&gt; hotels = hotelService.<span class=\"hljs-built_in\">list</span><span class=\"hljs-literal\">()</span>;\n\n    <span class=\"hljs-comment\">// 1.创建 Request</span>\n    BulkRequest request = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">BulkRequest()</span>;\n    <span class=\"hljs-comment\">// 2.准备参数，添加多个新增的 Request</span>\n    <span class=\"hljs-keyword\">for</span> (Hotel hotel : hotels) {\n        <span class=\"hljs-comment\">// 2.1.转换为文档类型 HotelDoc</span>\n        HotelDoc hotelDoc = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">HotelDoc(<span class=\"hljs-params\">hotel</span>)</span>;\n        <span class=\"hljs-comment\">// 2.2.创建新增文档的 Request 对象</span>\n        request.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">IndexRequest(<span class=\"hljs-string\">&quot;hotel&quot;</span>)</span>\n                    .id(hotelDoc.get<span class=\"hljs-constructor\">Id()</span>.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String()</span>)\n                    .source(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">JSON</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">JSONString(<span class=\"hljs-params\">hotelDoc</span>)</span>, XContentType.JSON));\n    }\n    <span class=\"hljs-comment\">// 3.发送请求</span>\n    client.bulk(request, RequestOptions.DEFAULT);\n}\n</code></pre>\n<p>测试，批量查询</p>\n<pre><code>GET <span class=\"hljs-regexp\">/hotel/</span>_search\n</code></pre>\n<h3 id=\"rest-client-文档操作小结\">Rest Client 文档操作小结</h3>\n<p>文档操作的基本步骤：</p>\n<ul>\n<li>初始化 RestHighLevelClient</li>\n<li>创建 XxxRequest。Xxx 是 Index、Get、Update、Delete、Bulk</li>\n<li>准备参数（Index、Update、Bulk时需要）</li>\n<li>发送请求。调用 <code>RestHighLevelClient#.xxx()</code> 方法，xxx 是 index、get、update、delete、bulk</li>\n<li>解析结果（Get时需要）</li>\n</ul>\n<h2 id=\"dsl-查询文档\">DSL 查询文档</h2>\n<p>ElasticSearch 的查询依然是基于 JSON 风格的 DSL 来实现的。</p>\n<h3 id=\"dsl-查询分类\">DSL 查询分类</h3>\n<p>ElasticSearch 提供了基于 JSON 的 DSL（<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html\">Domain Specific Language</a>）来定义查询。常见的查询类型包括：</p>\n<ul>\n<li><p>查询所有：查询出所有数据，一般测试用。例如：match_all</p>\n</li>\n<li><p>全文检索查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：</p>\n<ul>\n<li>match_query</li>\n<li>multi_match_query</li>\n</ul>\n</li>\n<li><p>精确查询：根据精确词条值查找数据，一般是查找 keyword、数值、日期、boolean 等类型字段。例如：</p>\n<ul>\n<li>ids</li>\n<li>range</li>\n<li>term</li>\n</ul>\n</li>\n<li><p>地理（geo）查询：根据经纬度查询。例如：</p>\n<ul>\n<li>geo_distance</li>\n<li>geo_bounding_box</li>\n</ul>\n</li>\n<li><p>复合（compound）查询：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：</p>\n<ul>\n<li>bool</li>\n<li>function_score</li>\n</ul>\n</li>\n</ul>\n<p>查询的语法基本一致：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/indexName/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;查询类型&quot;</span>: {\n      <span class=\"hljs-string\">&quot;查询条件&quot;</span>: <span class=\"hljs-string\">&quot;条件值&quot;</span>\n    }\n  }\n}\n</code></pre>\n<p> 我们以查询所有为例，其中：</p>\n<ul>\n<li>查询类型为 match_all</li>\n<li>没有查询条件</li>\n</ul>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match_all&quot;</span>: {}\n  }\n}\n</code></pre>\n<p>其它查询无非就是查询类型、查询条件的变化。</p>\n<h3 id=\"全文检索查询\">全文检索查询</h3>\n<h4 id=\"使用场景\">使用场景</h4>\n<p>全文检索查询的基本流程如下：</p>\n<ul>\n<li>对用户搜索的内容做分词，得到词条</li>\n<li>根据词条去倒排索引库中匹配，得到文档 id</li>\n<li>根据文档 id 找到文档，返回给用户</li>\n</ul>\n<p>比较常用的场景包括：</p>\n<ul>\n<li>商城的输入框搜索</li>\n<li>百度输入框搜索</li>\n</ul>\n<p>因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的 text 类型的字段。</p>\n<h4 id=\"基本语法\">基本语法</h4>\n<p>常见的全文检索查询包括：</p>\n<ul>\n<li>match 查询：单字段查询</li>\n<li>multi_match 查询：多字段查询，任意一个字段符合条件就算符合查询条件</li>\n</ul>\n<p>match 查询语法如下：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/indexName/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match&quot;</span>: {\n      <span class=\"hljs-string\">&quot;FIELD&quot;</span>: <span class=\"hljs-string\">&quot;TEXT&quot;</span>\n    }\n  }\n}\n</code></pre>\n<p>mulit_match 语法如下：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/indexName/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;multi_match&quot;</span>: {\n      <span class=\"hljs-string\">&quot;query&quot;</span>: <span class=\"hljs-string\">&quot;TEXT&quot;</span>,\n      <span class=\"hljs-string\">&quot;fields&quot;</span>: [<span class=\"hljs-string\">&quot;FIELD1&quot;</span>, <span class=\"hljs-string\">&quot; FIELD12&quot;</span>]\n    }\n  }\n}\n</code></pre>\n<h4 id=\"使用示例\">使用示例</h4>\n<p>match 查询示例：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match&quot;</span>: {\n      <span class=\"hljs-string\">&quot;all&quot;</span>: <span class=\"hljs-string\">&quot;如家外滩&quot;</span>\n    }\n  }\n}\n</code></pre>\n<p>multi_match 查询示例：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;multi_match&quot;</span>: {\n      <span class=\"hljs-string\">&quot;query&quot;</span>: <span class=\"hljs-string\">&quot;如家外滩&quot;</span>,\n      <span class=\"hljs-string\">&quot;fields&quot;</span>: [<span class=\"hljs-string\">&quot;brand&quot;</span>,<span class=\"hljs-string\">&quot;name&quot;</span>,<span class=\"hljs-string\">&quot;business&quot;</span>]\n    }\n  }\n}\n</code></pre>\n<p>可以看到，两种查询结果是一样的，为什么？</p>\n<p>因为我们将 brand、name、business 值都利用 copy_to 复制到了 all 字段中。因此你根据三个字段搜索，和根据 all 字段搜索效果当然一样了。</p>\n<p>但是，搜索字段越多，对查询性能影响越大，因此建议采用 copy_to，然后单字段查询的方式。</p>\n<p>match 和 multi_match 的区别是什么？</p>\n<ul>\n<li>match：根据一个字段查询</li>\n<li>multi_match：根据多个字段查询，参与查询字段越多，查询性能越差</li>\n</ul>\n<h3 id=\"精准查询\">精准查询</h3>\n<p>精确查询一般是查找 keyword、数值、日期、boolean 等类型字段。所以不会对搜索条件分词。常见的有：</p>\n<ul>\n<li>term：根据词条精确值查询</li>\n<li>range：根据值的范围查询</li>\n</ul>\n<h4 id=\"term-查询\">term 查询</h4>\n<p>因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是<strong>不分词</strong>的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。</p>\n<p>语法说明：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/indexName/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;term&quot;</span>: {\n      <span class=\"hljs-string\">&quot;FIELD&quot;</span>: {\n        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;VALUE&quot;</span>\n      }\n    }\n  }\n}\n</code></pre>\n<p>示例：</p>\n<p>当我搜索的是精确词条时，能正确查询出结果：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;term&quot;</span>: {\n      <span class=\"hljs-string\">&quot;city&quot;</span>: {\n        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;上海&quot;</span>\n      }\n    }\n  }\n}\n</code></pre>\n<p>但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;term&quot;</span>: {\n      <span class=\"hljs-string\">&quot;city&quot;</span>: {\n        <span class=\"hljs-string\">&quot;value&quot;</span>: <span class=\"hljs-string\">&quot;上海杭州&quot;</span>\n      }\n    }\n  }\n}\n</code></pre>\n<h4 id=\"range-查询\">range 查询</h4>\n<p>范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。</p>\n<p>基本语法：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/indexName/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;range&quot;</span>: {\n      <span class=\"hljs-string\">&quot;FIELD&quot;</span>: {\n        <span class=\"hljs-string\">&quot;gte&quot;</span>: <span class=\"hljs-number\">10</span>,\n        <span class=\"hljs-string\">&quot;lte&quot;</span>: <span class=\"hljs-number\">20</span>\n      }\n    }\n  }\n}\n</code></pre>\n<ul>\n<li>gte 代表大于等于，gt 则代表大于</li>\n<li>lte 代表小于等于，lt 则代表小于</li>\n</ul>\n<p>示例：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;range&quot;</span>: {\n      <span class=\"hljs-string\">&quot;price&quot;</span>: {\n        <span class=\"hljs-string\">&quot;gte&quot;</span>: <span class=\"hljs-number\">1000</span>,\n        <span class=\"hljs-string\">&quot;lte&quot;</span>: <span class=\"hljs-number\">3000</span>\n      }\n    }\n  }\n}\n</code></pre>\n<h4 id=\"精准查询小结\">精准查询小结</h4>\n<p>精确查询常见的有哪些？</p>\n<ul>\n<li>term 查询：根据词条精确匹配，一般搜索 keyword 类型、数值类型、布尔类型、日期类型字段</li>\n<li>range 查询：根据数值范围查询，可以是数值、日期的范围</li>\n</ul>\n<h3 id=\"地理坐标查询\">地理坐标查询</h3>\n<p>所谓的地理坐标查询，其实就是根据经纬度查询，<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html\">官方文档</a></p>\n<p>常见的使用场景包括：</p>\n<ul>\n<li>携程：搜索我附近的酒店</li>\n<li>滴滴：搜索我附近的出租车</li>\n<li>微信：搜索我附近的人</li>\n</ul>\n<h4 id=\"矩形范围查询\">矩形范围查询</h4>\n<p>矩形范围查询，也就是 geo_bounding_box 查询，查询坐标落在某个矩形范围的所有文档：</p>\n<p>查询时，需要指定矩形的<strong>左上</strong>、<strong>右下</strong>两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。</p>\n<p>语法如下：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/indexName/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;geo_bounding_box&quot;</span>: {\n      <span class=\"hljs-string\">&quot;FIELD&quot;</span>: {\n        <span class=\"hljs-string\">&quot;top_left&quot;</span>: {\n          <span class=\"hljs-string\">&quot;lat&quot;</span>: <span class=\"hljs-number\">31.1</span>,\n          <span class=\"hljs-string\">&quot;lon&quot;</span>: <span class=\"hljs-number\">121.5</span>\n        },\n        <span class=\"hljs-string\">&quot;bottom_right&quot;</span>: {\n          <span class=\"hljs-string\">&quot;lat&quot;</span>: <span class=\"hljs-number\">30.9</span>,\n          <span class=\"hljs-string\">&quot;lon&quot;</span>: <span class=\"hljs-number\">121.7</span>\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<h4 id=\"附近查询\">附近查询</h4>\n<p>附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。</p>\n<p>换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：</p>\n<p>语法说明：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/indexName/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;geo_distance&quot;</span>: {\n      <span class=\"hljs-string\">&quot;distance&quot;</span>: <span class=\"hljs-string\">&quot;15km&quot;</span>,\n      <span class=\"hljs-string\">&quot;FIELD&quot;</span>: <span class=\"hljs-string\">&quot;31.21,121.5&quot;</span>\n    }\n  }\n}\n</code></pre>\n<p>我们先搜索陆家嘴附近 15km 的酒店：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;geo_distance&quot;</span>: {\n      <span class=\"hljs-string\">&quot;distance&quot;</span>: <span class=\"hljs-string\">&quot;2km&quot;</span>,\n      <span class=\"hljs-string\">&quot;location&quot;</span>: <span class=\"hljs-string\">&quot;31.21,121.5&quot;</span>\n    }\n  }\n}\n</code></pre>\n<h3 id=\"复合查询\">复合查询</h3>\n<p>复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：</p>\n<ul>\n<li>fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名</li>\n<li>bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索</li>\n</ul>\n<h4 id=\"相关性算分\">相关性算分</h4>\n<p>当我们利用 match 查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。</p>\n<p>例如，我们搜索 “虹桥如家”，结果如下：</p>\n<pre><code class=\"hljs language-json\">[\n  {\n    <span class=\"hljs-string\">&quot;_score&quot;</span> : 17.850193,\n    <span class=\"hljs-string\">&quot;_source&quot;</span> : {\n      <span class=\"hljs-string\">&quot;name&quot;</span> : &quot;虹桥如家酒店真不错&quot;,\n    }\n  },\n  {\n    <span class=\"hljs-string\">&quot;_score&quot;</span> : 12.259849,\n    <span class=\"hljs-string\">&quot;_source&quot;</span> : {\n      <span class=\"hljs-string\">&quot;name&quot;</span> : &quot;外滩如家酒店真不错&quot;,\n    }\n  },\n  {\n    <span class=\"hljs-string\">&quot;_score&quot;</span> : 11.91091,\n    <span class=\"hljs-string\">&quot;_source&quot;</span> : {\n      <span class=\"hljs-string\">&quot;name&quot;</span> : &quot;迪士尼如家酒店真不错&quot;,\n    }\n  }\n]\n</code></pre>\n<p>在 ElasticSearch 中，早期使用的打分算法是 <a href=\"https://www.ruanyifeng.com/blog/2013/03/tf-idf.html\">TF-IDF 算法</a>，在后来的 5.1 版本升级中，ElasticSearch 将算法改进为 <a href=\"https://www.jianshu.com/p/1e498888f505\">BM25 算法</a></p>\n<p>TF-IDF 算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而 BM25 则会让单个词条的算分有一个上限，曲线更加平滑：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.32gad6dlyzu0.png\" alt=\"image\"></p>\n<h4 id=\"算分函数查询\">算分函数查询</h4>\n<p>根据相关度打分是比较合理的需求，但合理的不一定是产品经理需要的。</p>\n<p>以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。要想认为控制相关性算分，就需要利用 ElasticSearch 中的 function score 查询了。</p>\n<p>语法说明：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E7%AE%97%E5%88%86%E5%87%BD%E6%95%B0%E6%9F%A5%E8%AF%A2.epggagjz1ts.svg\" alt=\"算分函数查询\"></p>\n<p>function score 查询中包含四部分内容：</p>\n<ul>\n<li>原始查询条件：query 部分，基于这个条件搜索文档，并且基于 BM25 算法给文档打分，原始算分（query score)</li>\n<li>过滤条件：filter 部分，符合该条件的文档才会重新算分</li>\n<li>算分函数：符合 filter 条件的文档要根据这个函数做运算，得到的函数算分（function score），有四种函数<ul>\n<li>weight：函数结果是常量</li>\n<li>field_value_factor：以文档中的某个字段值作为函数结果</li>\n<li>random_score：以随机数作为函数结果</li>\n<li>script_score：自定义算分函数算法</li>\n</ul>\n</li>\n<li>运算模式：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：<ul>\n<li>multiply：相乘</li>\n<li>replace：用 function score 替换 query score</li>\n<li>其它，例如：sum、avg、max、min</li>\n</ul>\n</li>\n</ul>\n<p>function score 的运行流程如下：</p>\n<ul>\n<li>根据原始条件查询搜索文档，并且计算相关性算分，称为原始算分（query score）</li>\n<li>根据过滤条件，过滤文档</li>\n<li>符合<strong>过滤条件</strong>的文档，基于算分函数运算，得到函数算分（function score）</li>\n<li>将原始算分（query score）和函数算分（function score）基于运算模式做运算，得到最终结果，作为相关性算分。</li>\n</ul>\n<p>因此，其中的关键点是：</p>\n<ul>\n<li>过滤条件：决定哪些文档的算分被修改</li>\n<li>算分函数：决定函数算分的算法</li>\n<li>运算模式：决定最终算分结果</li>\n</ul>\n<p>示例</p>\n<p>需求：给“如家”这个品牌的酒店排名靠前一些。翻译一下这个需求，转换为之前说的四个要点：</p>\n<ul>\n<li>原始条件：不确定，可以任意变化</li>\n<li>过滤条件：brand = “如家”</li>\n<li>算分函数：可以简单粗暴，直接给固定的算分结果，weight</li>\n<li>运算模式：比如求和</li>\n</ul>\n<p>因此最终的 DSL 语句如下：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;function_score&quot;</span>: {\n      <span class=\"hljs-string\">&quot;query&quot;</span>: {\n        <span class=\"hljs-string\">&quot;match&quot;</span>: {\n          <span class=\"hljs-string\">&quot;all&quot;</span>: <span class=\"hljs-string\">&quot;外滩&quot;</span>\n        }\n      },\n      <span class=\"hljs-string\">&quot;functions&quot;</span>: [\n        {\n          <span class=\"hljs-string\">&quot;filter&quot;</span>: {\n            <span class=\"hljs-string\">&quot;term&quot;</span>: {\n              <span class=\"hljs-string\">&quot;brand&quot;</span>: <span class=\"hljs-string\">&quot;如家&quot;</span>\n            }\n          },\n          <span class=\"hljs-string\">&quot;weight&quot;</span>: <span class=\"hljs-number\">10</span>\n        }\n      ],\n      <span class=\"hljs-string\">&quot;boost_mode&quot;</span>: <span class=\"hljs-string\">&quot;sum&quot;</span>\n    }\n  }\n}\n</code></pre>\n<h4 id=\"布尔查询\">布尔查询</h4>\n<p>布尔查询是一个或多个查询子句的组合，每一个子句就是一个子查询。子查询的组合方式有：</p>\n<ul>\n<li>must：必须匹配每个子查询，类似“与”</li>\n<li>should：选择性匹配子查询，类似“或”</li>\n<li>must_not：必须不匹配，<strong>不参与算分</strong>，类似“非”</li>\n<li>filter：必须匹配，不参与算分</li>\n</ul>\n<p>比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤。</p>\n<p>每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用 bool 查询了。</p>\n<p>需要注意的是，搜索时，参与打分的字段越多，查询的性能也越差。因此这种多条件查询时，建议这样做：</p>\n<ul>\n<li>搜索框的关键字搜索，是全文检索查询，使用 must 查询，参与算分</li>\n<li>其它过滤条件，采用 filter 查询。不参与算分</li>\n</ul>\n<p>语法示例：</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-symbol\">GET</span> /hotel/<span class=\"hljs-symbol\">_search</span>\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;bool&quot;</span>: {\n      <span class=\"hljs-string\">&quot;must&quot;</span>: [\n        {\n          <span class=\"hljs-string\">&quot;term&quot;</span>: {\n            <span class=\"hljs-string\">&quot;city&quot;</span>: <span class=\"hljs-string\">&quot;上海&quot;</span>\n          }\n        }\n      ],\n      <span class=\"hljs-string\">&quot;should&quot;</span>: [\n        {\n          <span class=\"hljs-string\">&quot;term&quot;</span>: {\n            <span class=\"hljs-string\">&quot;brand&quot;</span>: <span class=\"hljs-string\">&quot;皇冠假日&quot;</span>\n          }\n        },\n        {\n          <span class=\"hljs-string\">&quot;term&quot;</span>: {\n            <span class=\"hljs-string\">&quot;brand&quot;</span>: <span class=\"hljs-string\">&quot;华美达&quot;</span>\n          }\n        }\n      ],\n      <span class=\"hljs-string\">&quot;must_not&quot;</span>: [\n        {\n          <span class=\"hljs-string\">&quot;range&quot;</span>: {\n            <span class=\"hljs-string\">&quot;price&quot;</span>: {\n              <span class=\"hljs-string\">&quot;lte&quot;</span>: <span class=\"hljs-number\">500</span>\n            }\n          }\n        }\n      ],\n      <span class=\"hljs-string\">&quot;filter&quot;</span>: [\n        {\n          <span class=\"hljs-string\">&quot;range&quot;</span>: {\n            <span class=\"hljs-string\">&quot;score&quot;</span>: {\n              <span class=\"hljs-string\">&quot;gte&quot;</span>: <span class=\"hljs-number\">45</span>\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre>\n<p>案例示例：</p>\n<p>需求：搜索名字包含“如家”，价格不高于 400，在坐标 31.21,121.5 周围 10km 范围内的酒店。</p>\n<p>分析：</p>\n<ul>\n<li>名称搜索，属于全文检索查询，应该参与算分。放到 must 中</li>\n<li>价格不高于 400，用 range 查询，属于过滤条件，不参与算分。放到 must_not 中</li>\n<li>周围 10km 范围内，用 geo_distance 查询，属于过滤条件，不参与算分。放到 filter 中</li>\n</ul>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-symbol\">GET</span> /hotel/<span class=\"hljs-symbol\">_search</span>\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;bool&quot;</span>: {\n      <span class=\"hljs-string\">&quot;must&quot;</span>: [\n        {\n          <span class=\"hljs-string\">&quot;match&quot;</span>: {\n            <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;如家&quot;</span>\n          }\n        }\n      ],\n      <span class=\"hljs-string\">&quot;must_not&quot;</span>: [\n        {\n          <span class=\"hljs-string\">&quot;range&quot;</span>: {\n            <span class=\"hljs-string\">&quot;price&quot;</span>: {\n              <span class=\"hljs-string\">&quot;gt&quot;</span>: <span class=\"hljs-number\">400</span>\n            }\n          }\n        }\n      ],\n      <span class=\"hljs-string\">&quot;filter&quot;</span>: [\n        {\n          <span class=\"hljs-string\">&quot;geo_distance&quot;</span>: {\n            <span class=\"hljs-string\">&quot;distance&quot;</span>: <span class=\"hljs-string\">&quot;10km&quot;</span>,\n            <span class=\"hljs-string\">&quot;location&quot;</span>: {\n              <span class=\"hljs-string\">&quot;lat&quot;</span>: <span class=\"hljs-number\">31.21</span>,\n              <span class=\"hljs-string\">&quot;lon&quot;</span>: <span class=\"hljs-number\">121.5</span>\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre>\n<p>bool 查询有几种逻辑关系？</p>\n<ul>\n<li>must：必须匹配的条件，可以理解为“与”</li>\n<li>should：选择性匹配的条件，可以理解为“或”</li>\n<li>must_not：必须不匹配的条件，不参与打分</li>\n<li>filter：必须匹配的条件，不参与打分</li>\n</ul>\n<h2 id=\"dsl-搜索结果处理\">DSL 搜索结果处理</h2>\n<p>搜索的结果可以按照用户指定的方式去处理或展示。</p>\n<h3 id=\"排序\">排序</h3>\n<p>ElasticSearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html\">结果排序</a>。可以排序字段类型有：keyword 类型、数值类型、地理坐标类型、日期类型等。</p>\n<h4 id=\"普通字段排序\">普通字段排序</h4>\n<p>keyword、数值、日期类型排序的语法基本一致。</p>\n<p><strong>语法</strong>：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/indexName/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match_all&quot;</span>: {}\n  },\n  <span class=\"hljs-string\">&quot;sort&quot;</span>: [\n    {\n      <span class=\"hljs-string\">&quot;FIELD&quot;</span>: <span class=\"hljs-string\">&quot;desc&quot;</span>  <span class=\"hljs-regexp\">//</span> 排序字段、排序方式ASC、DESC\n    }\n  ]\n}\n</code></pre>\n<p>排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推</p>\n<p><strong>示例</strong>：</p>\n<p>需求描述：酒店数据按照用户评价（score）降序排序，评价相同的按照价格（price）升序排序</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match_all&quot;</span>: {}\n  },\n  <span class=\"hljs-string\">&quot;sort&quot;</span>: [\n    {\n      <span class=\"hljs-string\">&quot;score&quot;</span>: <span class=\"hljs-string\">&quot;desc&quot;</span>\n    },\n    {\n      <span class=\"hljs-string\">&quot;price&quot;</span>: <span class=\"hljs-string\">&quot;asc&quot;</span>\n    }\n  ]\n}\n</code></pre>\n<h4 id=\"地理坐标排序\">地理坐标排序</h4>\n<p>地理坐标排序略有不同。</p>\n<p><strong>语法说明</strong>：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/indexName/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match_all&quot;</span>: {}\n  },\n  <span class=\"hljs-string\">&quot;sort&quot;</span>: [\n    {\n      <span class=\"hljs-string\">&quot;_geo_distance&quot;</span> : {\n          <span class=\"hljs-string\">&quot;FIELD&quot;</span> : <span class=\"hljs-string\">&quot;纬度，经度&quot;</span>, <span class=\"hljs-regexp\">//</span> 文档中geo_point类型的字段名、目标坐标点\n          <span class=\"hljs-string\">&quot;order&quot;</span> : <span class=\"hljs-string\">&quot;asc&quot;</span>, <span class=\"hljs-regexp\">//</span> 排序方式\n          <span class=\"hljs-string\">&quot;unit&quot;</span> : <span class=\"hljs-string\">&quot;km&quot;</span> <span class=\"hljs-regexp\">//</span> 排序的距离单位\n      }\n    }\n  ]\n}\n</code></pre>\n<p>这个查询的含义是：</p>\n<ul>\n<li>指定一个坐标，作为目标点</li>\n<li>计算每一个文档中，指定字段（必须是 geo_point 类型）的坐标到目标点的距离是多少</li>\n<li>根据距离排序</li>\n</ul>\n<p><strong>示例：</strong></p>\n<p>需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序</p>\n<p>提示：获取经纬度的方式：<a href=\"https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/\">https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/</a></p>\n<p>假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match_all&quot;</span>: {}\n  },\n  <span class=\"hljs-string\">&quot;sort&quot;</span>: [\n    {\n      <span class=\"hljs-string\">&quot;_geo_distance&quot;</span>: {\n        <span class=\"hljs-string\">&quot;location&quot;</span>: {\n          <span class=\"hljs-string\">&quot;lat&quot;</span>: <span class=\"hljs-number\">31.034661</span>,\n          <span class=\"hljs-string\">&quot;lon&quot;</span>: <span class=\"hljs-number\">121.612282</span>\n        },\n        <span class=\"hljs-string\">&quot;order&quot;</span>: <span class=\"hljs-string\">&quot;asc&quot;</span>,\n        <span class=\"hljs-string\">&quot;unit&quot;</span>: <span class=\"hljs-string\">&quot;km&quot;</span>\n      }\n    }\n  ]\n}\n</code></pre>\n<h3 id=\"分页\">分页</h3>\n<p>ElasticSearch 默认情况下只返回 top10 的数据。而如果要查询更多数据就需要修改分页参数了。ElasticSearch中通过修改 from、size 参数来控制要返回的分页结果：</p>\n<ul>\n<li>from：从第几个文档开始</li>\n<li>size：总共查询几个文档</li>\n</ul>\n<p>类似于 MySQL 中的 <code>limit ?, ?</code></p>\n<h4 id=\"基本的分页\">基本的分页</h4>\n<p>分页的基本语法如下：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match_all&quot;</span>: {}\n  },\n  <span class=\"hljs-string\">&quot;sort&quot;</span>: [\n    {\n      <span class=\"hljs-string\">&quot;price&quot;</span>: {\n        <span class=\"hljs-string\">&quot;order&quot;</span>: <span class=\"hljs-string\">&quot;asc&quot;</span>\n      }\n    }\n  ],\n  <span class=\"hljs-string\">&quot;from&quot;</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-string\">&quot;size&quot;</span>: <span class=\"hljs-number\">5</span>\n}\n</code></pre>\n<h4 id=\"深度分页问题\">深度分页问题</h4>\n<p>现在，我要查询 990~1000 的数据，查询逻辑要这么写：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match_all&quot;</span>: {}\n  },\n  <span class=\"hljs-string\">&quot;from&quot;</span>: <span class=\"hljs-number\">990</span>, <span class=\"hljs-regexp\">//</span> 分页开始的位置，默认为<span class=\"hljs-number\">0</span>\n  <span class=\"hljs-string\">&quot;size&quot;</span>: <span class=\"hljs-number\">10</span>, <span class=\"hljs-regexp\">//</span> 期望获取的文档总数\n  <span class=\"hljs-string\">&quot;sort&quot;</span>: [\n    {<span class=\"hljs-string\">&quot;price&quot;</span>: <span class=\"hljs-string\">&quot;asc&quot;</span>}\n  ]\n}\n</code></pre>\n<p>这里是查询 990 开始的数据，也就是 第 990~1000 条 数据。</p>\n<p>不过，ElasticSearch 内部分页时，必须先查询 0~1000 条，然后截取其中的 990 ~ 1000 的这 10 条：</p>\n<p>查询 top 1000，如果 ElasticSearch 是单点模式，这并无太大影响。</p>\n<p>但是 ElasticSearch 将来一定是集群，例如我集群有 5 个节点，我要查询 top 1000 的数据，并不是每个节点查询 200 条就可以了。</p>\n<p>因为节点 A 的 top 200，在另一个节点可能排到 10000 名以外了。</p>\n<p>因此要想获取整个集群的 top 1000，必须先查询出每个节点的 top 1000，汇总结果后，重新排名，重新截取 top 1000。</p>\n<p>那如果我要查询 9900~10000 的数据呢？是不是要先查询 top 10000呢？那每个节点都要查询 10000 条？汇总到内存中？</p>\n<p>当查询分页深度较大时，汇总数据过多，对内存和 CPU 会产生非常大的压力，因此 ElasticSearch 会禁止 from + size 超过 10000 的请求。</p>\n<p>针对深度分页，ElasticSearch 提供了两种解决方案，<a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html\">官方文档</a>：</p>\n<ul>\n<li>search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。</li>\n<li>scroll：原理将排序后的文档 id 形成快照，保存在内存。官方已经不推荐使用。</li>\n</ul>\n<h4 id=\"分页小结\">分页小结</h4>\n<p>分页查询的常见实现方案以及优缺点：</p>\n<ul>\n<li><p><code>from + size</code>：</p>\n<ul>\n<li>优点：支持随机翻页</li>\n<li>缺点：深度分页问题，默认查询上限（from + size）是 10000</li>\n<li>场景：百度、京东、谷歌、淘宝这样的随机翻页搜索</li>\n</ul>\n</li>\n<li><p><code>after search</code>：</p>\n<ul>\n<li>优点：没有查询上限（单次查询的 size 不超过 10000）</li>\n<li>缺点：只能向后逐页查询，不支持随机翻页</li>\n<li>场景：没有随机翻页需求的搜索，例如手机向下滚动翻页</li>\n</ul>\n</li>\n<li><p><code>scroll</code>：</p>\n<ul>\n<li>优点：没有查询上限（单次查询的 size 不超过 10000）</li>\n<li>缺点：会有额外内存消耗，并且搜索结果是非实时的</li>\n<li>场景：海量数据的获取和迁移。从 ES 7.1开始不推荐，建议用 after search 方案。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"高亮\">高亮</h3>\n<p>高亮显示的实现分为两步：</p>\n<ul>\n<li>给文档中的所有关键字都添加一个标签，例如 <code>&lt;em&gt;</code> 标签</li>\n<li>页面给 <code>&lt;em&gt;</code> 标签编写 CSS 样式</li>\n</ul>\n<p>高亮的语法：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match&quot;</span>: {\n      <span class=\"hljs-string\">&quot;FIELD&quot;</span>: <span class=\"hljs-string\">&quot;TEXT&quot;</span>\n    }\n  },\n  <span class=\"hljs-string\">&quot;highlight&quot;</span>: {\n    <span class=\"hljs-string\">&quot;fields&quot;</span>: {\n      <span class=\"hljs-string\">&quot;FIELD&quot;</span>: {\n        <span class=\"hljs-string\">&quot;pre_tags&quot;</span>: <span class=\"hljs-string\">&quot;&lt;em&gt;&quot;</span>,\n        <span class=\"hljs-string\">&quot;post_tags&quot;</span>: <span class=\"hljs-string\">&quot;&lt;/em&gt;&quot;</span>\n      }\n    }\n  }\n}\n</code></pre>\n<p><strong>注意：</strong></p>\n<ul>\n<li>高亮是对关键字高亮，因此搜索条件必须带有关键字，而不能是范围这样的查询。</li>\n<li>默认情况下，高亮的字段，必须与搜索指定的字段一致，否则无法高亮</li>\n<li>如果要对非搜索字段高亮，则需要添加一个属性： <code>&quot;require_field_match&quot;: &quot;false&quot;</code></li>\n</ul>\n<p>示例：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match&quot;</span>: {\n      <span class=\"hljs-string\">&quot;all&quot;</span>: <span class=\"hljs-string\">&quot;如家&quot;</span>\n    }\n  },\n  <span class=\"hljs-string\">&quot;highlight&quot;</span>: {\n    <span class=\"hljs-string\">&quot;fields&quot;</span>: {\n      <span class=\"hljs-string\">&quot;name&quot;</span>: {\n        <span class=\"hljs-string\">&quot;require_field_match&quot;</span>: <span class=\"hljs-string\">&quot;false&quot;</span>\n      }\n    }\n  }\n}\n</code></pre>\n<h3 id=\"搜索结果处理小结\">搜索结果处理小结</h3>\n<p>查询的 DSL 是一个大的 JSON 对象，包含下列属性：</p>\n<ul>\n<li>query：查询条件</li>\n<li>from 和 size：分页条件</li>\n<li>sort：排序条件</li>\n<li>highlight：高亮条件</li>\n</ul>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match&quot;</span>: {\n      <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;如家&quot;</span>\n    }\n  },\n  <span class=\"hljs-string\">&quot;from&quot;</span>: <span class=\"hljs-number\">0</span>, <span class=\"hljs-regexp\">//</span> 分页开始的位置\n  <span class=\"hljs-string\">&quot;size&quot;</span>: <span class=\"hljs-number\">20</span>, <span class=\"hljs-regexp\">//</span> 期望获取的文档总数\n  <span class=\"hljs-string\">&quot;sort&quot;</span>: [ \n    {  <span class=\"hljs-string\">&quot;price&quot;</span>: <span class=\"hljs-string\">&quot;asc&quot;</span> }, <span class=\"hljs-regexp\">//</span> 普通排序\n    {\n      <span class=\"hljs-string\">&quot;_geo_distance&quot;</span> : { <span class=\"hljs-regexp\">//</span> 距离排序\n          <span class=\"hljs-string\">&quot;location&quot;</span> : <span class=\"hljs-string\">&quot;31.040699,121.618075&quot;</span>, \n          <span class=\"hljs-string\">&quot;order&quot;</span> : <span class=\"hljs-string\">&quot;asc&quot;</span>,\n          <span class=\"hljs-string\">&quot;unit&quot;</span> : <span class=\"hljs-string\">&quot;km&quot;</span>\n      }\n    }\n  ],\n  <span class=\"hljs-string\">&quot;highlight&quot;</span>: {\n    <span class=\"hljs-string\">&quot;fields&quot;</span>: { <span class=\"hljs-regexp\">//</span> 高亮字段\n      <span class=\"hljs-string\">&quot;name&quot;</span>: {\n        <span class=\"hljs-string\">&quot;pre_tags&quot;</span>: <span class=\"hljs-string\">&quot;&lt;em&gt;&quot;</span>,  <span class=\"hljs-regexp\">//</span> 用来标记高亮字段的前置标签\n        <span class=\"hljs-string\">&quot;post_tags&quot;</span>: <span class=\"hljs-string\">&quot;&lt;/em&gt;&quot;</span> <span class=\"hljs-regexp\">//</span> 用来标记高亮字段的后置标签\n      }\n    }\n  }\n}\n</code></pre>\n<h2 id=\"rest-client-查询文档\">Rest Client 查询文档</h2>\n<p>文档的查询同样适用 RestHighLevelClient 对象，基本步骤包括：</p>\n<ul>\n<li>准备 Request 对象</li>\n<li>准备请求参数</li>\n<li>发起请求</li>\n<li>解析响应</li>\n</ul>\n<h3 id=\"快速入门\">快速入门</h3>\n<p>我们以 match_all 查询为例</p>\n<h4 id=\"发起查询请求\">发起查询请求</h4>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testMatchAll</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException {\n    <span class=\"hljs-comment\">// 1.准备Request</span>\n    <span class=\"hljs-type\">SearchRequest</span> <span class=\"hljs-variable\">request</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">SearchRequest</span>(<span class=\"hljs-string\">&quot;hotel&quot;</span>);\n    <span class=\"hljs-comment\">// 2.组织DSL参数</span>\n    request.source().query(QueryBuilders.matchAllQuery());\n    <span class=\"hljs-comment\">// 3.发送请求，得到响应结果</span>\n    <span class=\"hljs-type\">SearchResponse</span> <span class=\"hljs-variable\">response</span> <span class=\"hljs-operator\">=</span> client.search(request, RequestOptions.DEFAULT);\n    <span class=\"hljs-comment\">// ...解析响应结果</span>\n}\n</code></pre>\n<p>代码解读：</p>\n<ul>\n<li><p>第一步，创建 <code>SearchRequest</code> 对象，指定索引库名</p>\n</li>\n<li><p>第二步，利用 <code>request.source()</code> 构建 DSL，DSL 中可以包含查询、分页、排序、高亮等</p>\n<ul>\n<li><code>query()</code>：代表查询条件，利用 <code>QueryBuilders.matchAllQuery()</code> 构建一个 match_all 查询的 DSL</li>\n</ul>\n</li>\n<li><p>第三步，利用 <code>client.search()</code> 发送请求，得到响应</p>\n</li>\n</ul>\n<p>这里关键的 API 有两个：</p>\n<ul>\n<li>一个是 <code>request.source()</code>，其中包含了查询、排序、分页、高亮等所有功能。</li>\n<li>另一个是 <code>QueryBuilders</code>，其中包含 match、term、function_score、bool 等各种查询：</li>\n</ul>\n<h4 id=\"解析响应\">解析响应</h4>\n<p>ElasticSearch 返回的结果是一个 JSON 字符串，结构包含：</p>\n<pre><code class=\"hljs language-json\">{\n   <span class=\"hljs-string\">&quot;took&quot;</span> : 0,\n   <span class=\"hljs-string\">&quot;timed_out&quot;</span> : <span class=\"hljs-type\">false</span>,\n   <span class=\"hljs-string\">&quot;hits&quot;</span> : {\n    <span class=\"hljs-string\">&quot;total&quot;</span> : {\n      <span class=\"hljs-string\">&quot;value&quot;</span> : 2,\n      <span class=\"hljs-string\">&quot;relation&quot;</span> : &quot;<span class=\"hljs-type\">eq</span><span class=\"hljs-string\">&quot;\n    },\n    &quot;</span>max_score<span class=\"hljs-string\">&quot; : 1.0,\n    &quot;</span>hits<span class=\"hljs-string\">&quot; : [\n      {\n        &quot;</span>_index<span class=\"hljs-string\">&quot; : &quot;</span>heima<span class=\"hljs-string\">&quot;,\n        &quot;</span>_type<span class=\"hljs-string\">&quot; : &quot;</span>_doc<span class=\"hljs-string\">&quot;,\n        &quot;</span>_id<span class=\"hljs-string\">&quot; : &quot;</span><span class=\"hljs-number\">1</span><span class=\"hljs-string\">&quot;,\n        &quot;</span>_score<span class=\"hljs-string\">&quot; : 1.0,\n        &quot;</span>_source<span class=\"hljs-string\">&quot; : {\n          &quot;</span>info<span class=\"hljs-string\">&quot; : &quot;</span>Java讲师<span class=\"hljs-string\">&quot;,     &quot;</span>name<span class=\"hljs-string\">&quot; : &quot;</span>赵云<span class=\"hljs-string\">&quot;,\n       }\n      },\n      // ...\n    ]\n  }\n}</span>\n</code></pre>\n<ul>\n<li><code>hits</code>：命中的结果<ul>\n<li><code>total</code>：总条数，其中的 value 是具体的总条数值</li>\n<li><code>max_score</code>：所有结果中得分最高的文档的相关性算分</li>\n<li><code>hits</code>：搜索结果的文档数组，其中的每个文档都是一个 JSON 对象<ul>\n<li><code>_source</code>：文档中的原始数据，也是 JSON 对象</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>因此，我们解析响应结果，就是逐层解析 JSON 字符串，流程如下：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Test</span>\n<span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">testMatchAll</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> IOException {\n    <span class=\"hljs-comment\">// ... 略</span>\n    <span class=\"hljs-comment\">// 4.解析结果</span>\n    <span class=\"hljs-type\">SearchHits</span> <span class=\"hljs-variable\">searchHits</span> <span class=\"hljs-operator\">=</span> response.getHits();\n    <span class=\"hljs-comment\">// 4.1.查询的总条数</span>\n    <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">total</span> <span class=\"hljs-operator\">=</span> searchHits.getTotalHits().value;\n    <span class=\"hljs-comment\">// 4.2.查询的结果数组</span>\n    SearchHit[] hits = searchHits.getHits();\n    <span class=\"hljs-keyword\">for</span> (SearchHit hit : hits) {\n        <span class=\"hljs-comment\">// 4.3.得到source</span>\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">json</span> <span class=\"hljs-operator\">=</span> hit.getSourceAsString();\n        <span class=\"hljs-comment\">// 4.4.打印</span>\n        System.out.println(json);\n    }\n}\n</code></pre>\n<ul>\n<li><code>SearchHits</code>：通过 <code>response.getHits()</code> 获取，就是 JSON 中的最外层的hits，代表命中的结果<ul>\n<li><code>SearchHits#getTotalHits().value</code>：获取总条数信息</li>\n<li><code>SearchHits#getHits()</code>：获取 SearchHit 数组，也就是文档数组<ul>\n<li><code>SearchHit#getSourceAsString()</code>：获取文档结果中的_source，也就是原始的 JSON 文档数据</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"完整代码-4\">完整代码</h4>\n<pre><code class=\"hljs language-java\">    @Test\n    void test<span class=\"hljs-constructor\">MatchAll()</span> throws IOException {\n        <span class=\"hljs-comment\">// 1.准备 Request</span>\n        SearchRequest request = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SearchRequest(<span class=\"hljs-string\">&quot;hotel&quot;</span>)</span>;\n        <span class=\"hljs-comment\">// 2.组织 DSL 参数</span>\n        request.source<span class=\"hljs-literal\">()</span>.query(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span><span class=\"hljs-keyword\">match</span><span class=\"hljs-constructor\">AllQuery()</span>);\n        <span class=\"hljs-comment\">// 3.发送请求，得到响应结果</span>\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n        <span class=\"hljs-comment\">// 4.解析结果</span>\n        SearchHits searchHits = response.get<span class=\"hljs-constructor\">Hits()</span>;\n        <span class=\"hljs-comment\">// 4.1.查询的总条数</span>\n        long total = searchHits.get<span class=\"hljs-constructor\">TotalHits()</span>.value;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>err.println(<span class=\"hljs-string\">&quot;total = &quot;</span> + total);\n        <span class=\"hljs-comment\">// 4.2.查询的结果数组</span>\n        SearchHit<span class=\"hljs-literal\">[]</span> hits = searchHits.get<span class=\"hljs-constructor\">Hits()</span>;\n        <span class=\"hljs-keyword\">for</span> (SearchHit hit : hits) {\n            <span class=\"hljs-comment\">// 4.3.得到source</span>\n            String json = hit.get<span class=\"hljs-constructor\">SourceAsString()</span>;\n            <span class=\"hljs-comment\">// 反序列化</span>\n            HotelDoc hotelDoc = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">JSON</span>.</span></span>parse<span class=\"hljs-constructor\">Object(<span class=\"hljs-params\">json</span>, HotelDoc.<span class=\"hljs-params\">class</span>)</span>;\n            <span class=\"hljs-comment\">// 4.4.打印</span>\n            <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(hotelDoc);\n        }\n    }\n</code></pre>\n<h4 id=\"快速入门小结\">快速入门小结</h4>\n<p>查询的基本步骤是：</p>\n<ol>\n<li>创建 SearchRequest 对象</li>\n<li>准备 <code>Request.source()</code>，也就是 DSL。<ul>\n<li>QueryBuilders 来构建查询条件</li>\n<li>传入 <code>Request.source()</code> 的 <code>query()</code> 方法</li>\n</ul>\n</li>\n<li>发送请求，得到结果</li>\n<li>解析结果（参考 JSON 结果，从外到内，逐层解析）</li>\n</ol>\n<h3 id=\"match-查询\">match 查询</h3>\n<p>全文检索的 match 和 multi_match 查询与 match_all 的 API 基本一致。差别是查询条件，也就是 query 的部分。</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match_all&quot;</span>: {}\n  }\n}\n\nGET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match&quot;</span>: {\n      <span class=\"hljs-string\">&quot;all&quot;</span>: <span class=\"hljs-string\">&quot;如家&quot;</span>\n    }\n  }\n}\n\nGET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;multi_match&quot;</span>: {\n      <span class=\"hljs-string\">&quot;query&quot;</span>: <span class=\"hljs-string\">&quot;如家&quot;</span>,\n      <span class=\"hljs-string\">&quot;fields&quot;</span>: [<span class=\"hljs-string\">&quot;brand&quot;</span>, <span class=\"hljs-string\">&quot;name&quot;</span>]\n    }\n  }\n}\n</code></pre>\n<p>因此，Java 代码上的差异主要是 <code>request.source().query()</code> 中的参数了。同样是利用 QueryBuilders 提供的方法：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// 单字段查询</span>\n<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span><span class=\"hljs-keyword\">match</span><span class=\"hljs-constructor\">Query(<span class=\"hljs-string\">&quot;all&quot;</span>, <span class=\"hljs-string\">&quot;如家&quot;</span>)</span>;\n<span class=\"hljs-comment\">// 多字段查询</span>\n<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span>multi<span class=\"hljs-constructor\">MatchQuery(<span class=\"hljs-string\">&quot;如家&quot;</span>, <span class=\"hljs-string\">&quot;name&quot;</span>, <span class=\"hljs-string\">&quot;business&quot;</span>)</span>;\n</code></pre>\n<p>而结果解析代码则完全一致，可以抽取并共享。</p>\n<p>完整代码如下：</p>\n<pre><code class=\"hljs language-java\">@Test\nvoid test<span class=\"hljs-constructor\">Match()</span> throws IOException {\n    <span class=\"hljs-comment\">// 1.准备Request</span>\n    SearchRequest request = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SearchRequest(<span class=\"hljs-string\">&quot;hotel&quot;</span>)</span>;\n    <span class=\"hljs-comment\">// 2.准备DSL</span>\n    request.source<span class=\"hljs-literal\">()</span>.query(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span><span class=\"hljs-keyword\">match</span><span class=\"hljs-constructor\">Query(<span class=\"hljs-string\">&quot;all&quot;</span>, <span class=\"hljs-string\">&quot;如家&quot;</span>)</span>);\n    <span class=\"hljs-comment\">// 3.发送请求</span>\n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n    <span class=\"hljs-comment\">// 4.解析响应</span>\n    handle<span class=\"hljs-constructor\">Response(<span class=\"hljs-params\">response</span>)</span>;\n}\n</code></pre>\n<blockquote>\n<p>IDEA 代码抽取 Ctrl + Alt + M</p>\n</blockquote>\n<h3 id=\"精确查询\">精确查询</h3>\n<p>精确查询主要是两者：</p>\n<ul>\n<li>term：词条精确匹配</li>\n<li>range：范围查询</li>\n</ul>\n<p>与之前的查询相比，差异同样在查询条件，其它都一样。</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;term&quot;</span>: {\n      <span class=\"hljs-string\">&quot;city&quot;</span>: <span class=\"hljs-string\">&quot;杭州&quot;</span>\n    }\n  }\n}\nGET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;range&quot;</span>: {\n      <span class=\"hljs-string\">&quot;price&quot;</span>: { <span class=\"hljs-string\">&quot;gte&quot;</span>: <span class=\"hljs-number\">100</span>, <span class=\"hljs-string\">&quot;lte&quot;</span>: <span class=\"hljs-number\">150</span> }\n    }\n  }\n}\n</code></pre>\n<p>查询条件构造的 API 如下：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// 词条查询</span>\n<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span>term<span class=\"hljs-constructor\">Query(<span class=\"hljs-string\">&quot;city&quot;</span>, <span class=\"hljs-string\">&quot;杭州&quot;</span>)</span>; \n<span class=\"hljs-comment\">// 范围查询</span>\n<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span>range<span class=\"hljs-constructor\">Query(<span class=\"hljs-string\">&quot;price&quot;</span>)</span>.gte(<span class=\"hljs-number\">100</span>).lte(<span class=\"hljs-number\">150</span>);\n</code></pre>\n<h3 id=\"布尔查询-1\">布尔查询</h3>\n<p>布尔查询是用 must、must_not、filter 等方式组合其它查询，代码示例如下：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// 创建布尔查询</span>\nBoolQueryBuilder boolQuery = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span><span class=\"hljs-built_in\">bool</span><span class=\"hljs-constructor\">Query()</span>;\n<span class=\"hljs-comment\">// 添加must条件</span>\nboolQuery.must(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span>term<span class=\"hljs-constructor\">Query(<span class=\"hljs-string\">&quot;city&quot;</span>, <span class=\"hljs-string\">&quot;杭州&quot;</span>)</span>); \n<span class=\"hljs-comment\">// 添加filter条件</span>\nboolQuery.filter(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span>range<span class=\"hljs-constructor\">Query(<span class=\"hljs-string\">&quot;price&quot;</span>)</span>.lte(<span class=\"hljs-number\">250</span>));\n</code></pre>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;bool&quot;</span>: {\n      <span class=\"hljs-string\">&quot;must&quot;</span>: [\n        {\n          <span class=\"hljs-string\">&quot;term&quot;</span>: { <span class=\"hljs-string\">&quot;city&quot;</span>: <span class=\"hljs-string\">&quot;杭州&quot;</span> }\n        }\n      ],\n      <span class=\"hljs-string\">&quot;filter&quot;</span>: [\n        {\n          <span class=\"hljs-string\">&quot;range&quot;</span>: {\n            <span class=\"hljs-string\">&quot;price&quot;</span>: { <span class=\"hljs-string\">&quot;lte&quot;</span>: <span class=\"hljs-number\">250</span> }\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre>\n<p>可以看到，API 与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。</p>\n<p>示例代码：</p>\n<pre><code class=\"hljs language-java\">@Test\nvoid test<span class=\"hljs-constructor\">Bool()</span> throws IOException {\n    <span class=\"hljs-comment\">// 1.准备Request</span>\n    SearchRequest request = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SearchRequest(<span class=\"hljs-string\">&quot;hotel&quot;</span>)</span>;\n    \n    <span class=\"hljs-comment\">// 2.准备DSL</span>\n    <span class=\"hljs-comment\">// 2.1.准备BooleanQuery</span>\n    BoolQueryBuilder boolQuery = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span><span class=\"hljs-built_in\">bool</span><span class=\"hljs-constructor\">Query()</span>;\n    <span class=\"hljs-comment\">// 2.2.添加term</span>\n    boolQuery.must(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span>term<span class=\"hljs-constructor\">Query(<span class=\"hljs-string\">&quot;city&quot;</span>, <span class=\"hljs-string\">&quot;上海&quot;</span>)</span>);\n    <span class=\"hljs-comment\">// 2.3.添加range</span>\n    boolQuery.filter(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span>range<span class=\"hljs-constructor\">Query(<span class=\"hljs-string\">&quot;price&quot;</span>)</span>.lte(<span class=\"hljs-number\">250</span>));\n    \n    request.source<span class=\"hljs-literal\">()</span>.query(boolQuery);\n    \n    <span class=\"hljs-comment\">// 3.发送请求</span>\n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n    \n    <span class=\"hljs-comment\">// 4.解析响应</span>\n    handle<span class=\"hljs-constructor\">Response(<span class=\"hljs-params\">response</span>)</span>;\n}\n</code></pre>\n<h2 id=\"rest-client-搜索结果处理\">Rest Client 搜索结果处理</h2>\n<h3 id=\"排序与分页\">排序与分页</h3>\n<p>搜索结果的排序和分页是与 query 同级的参数，因此同样是使用 <code>request.source()</code> 来设置。</p>\n<p>对应的 API 如下：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// 查询 </span>\nrequest.source<span class=\"hljs-comment\">()</span>.query<span class=\"hljs-comment\">(QueryBuilders.matchAllQuery()</span>);\n<span class=\"hljs-comment\">// 排序</span>\nrequest.source<span class=\"hljs-comment\">()</span>.sort<span class=\"hljs-comment\">(&quot;price&quot;, SortOrder.ASC)</span>;\n<span class=\"hljs-comment\">// 分页</span>\nrequest.source<span class=\"hljs-comment\">()</span>.from<span class=\"hljs-comment\">(0)</span>.size<span class=\"hljs-comment\">(5)</span>;\n</code></pre>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/indexName/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match_all&quot;</span>: {}\n  },\n  <span class=\"hljs-string\">&quot;from&quot;</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-string\">&quot;size&quot;</span>: <span class=\"hljs-number\">5</span>, \n  <span class=\"hljs-string\">&quot;sort&quot;</span>: [\n    {\n      <span class=\"hljs-string\">&quot;FIELD&quot;</span>: <span class=\"hljs-string\">&quot;desc&quot;</span>  \n    },\n  ]\n}\n</code></pre>\n<p>代码示例：</p>\n<pre><code class=\"hljs language-java\">@Test\n<span class=\"hljs-keyword\">void</span> testPageAndSort() <span class=\"hljs-keyword\">throws</span> IOException {\n    <span class=\"hljs-comment\">// 页码，每页大小</span>\n    <span class=\"hljs-keyword\">int</span> page = <span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">size</span> = <span class=\"hljs-number\">5</span>;\n    <span class=\"hljs-comment\">// 1.准备Request</span>\n    SearchRequest request = <span class=\"hljs-keyword\">new</span> SearchRequest(<span class=\"hljs-string\">&quot;hotel&quot;</span>);\n    <span class=\"hljs-comment\">// 2.准备DSL</span>\n    <span class=\"hljs-comment\">// 2.1.query</span>\n    request.<span class=\"hljs-keyword\">source</span>().query(QueryBuilders.matchAllQuery());\n    <span class=\"hljs-comment\">// 2.2.排序 sort</span>\n    request.<span class=\"hljs-keyword\">source</span>().<span class=\"hljs-keyword\">sort</span>(<span class=\"hljs-string\">&quot;price&quot;</span>, SortOrder.ASC);\n    <span class=\"hljs-comment\">// 2.3.分页 from、size</span>\n    request.<span class=\"hljs-keyword\">source</span>().<span class=\"hljs-keyword\">from</span>((page - <span class=\"hljs-number\">1</span>) * <span class=\"hljs-keyword\">size</span>).<span class=\"hljs-keyword\">size</span>(<span class=\"hljs-keyword\">size</span>);\n    <span class=\"hljs-comment\">// 3.发送请求</span>\n    SearchResponse response = client.search(request, RequestOptions.<span class=\"hljs-keyword\">DEFAULT</span>);\n    <span class=\"hljs-comment\">// 4.解析响应</span>\n    handleResponse(response);\n}\n</code></pre>\n<h3 id=\"高亮-1\">高亮</h3>\n<p>高亮的代码与之前代码差异较大，有两点：</p>\n<ul>\n<li>查询的 DSL：其中除了查询条件，还需要添加高亮条件，同样是与 query 同级。</li>\n<li>结果解析：结果除了要解析 _source 文档数据，还要解析高亮结果</li>\n</ul>\n<h4 id=\"高亮请求构建\">高亮请求构建</h4>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match&quot;</span>: {\n      <span class=\"hljs-string\">&quot;all&quot;</span>: <span class=\"hljs-string\">&quot;如家&quot;</span>\n    }\n  },\n  <span class=\"hljs-string\">&quot;highlight&quot;</span>: {\n    <span class=\"hljs-string\">&quot;fields&quot;</span>: {\n      <span class=\"hljs-string\">&quot;name&quot;</span>: {\n        <span class=\"hljs-string\">&quot;require_field_match&quot;</span>: <span class=\"hljs-string\">&quot;false&quot;</span>\n      }\n    }\n  }\n}\n</code></pre>\n<p>高亮请求的构建 API 如下：</p>\n<pre><code class=\"hljs language-java\">request.source<span class=\"hljs-literal\">()</span>.highlighter(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">HighlightBuilder()</span>.field(<span class=\"hljs-string\">&quot;name&quot;</span>).require<span class=\"hljs-constructor\">FieldMatch(<span class=\"hljs-params\">false</span>)</span>);\n</code></pre>\n<p>上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。</p>\n<p>示例代码如下：</p>\n<pre><code class=\"hljs language-java\">@Test\nvoid test<span class=\"hljs-constructor\">Highlight()</span> throws IOException {\n    <span class=\"hljs-comment\">// 1.准备Request</span>\n    SearchRequest request = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SearchRequest(<span class=\"hljs-string\">&quot;hotel&quot;</span>)</span>;\n    <span class=\"hljs-comment\">// 2.准备DSL</span>\n    <span class=\"hljs-comment\">// 2.1.query</span>\n    request.source<span class=\"hljs-literal\">()</span>.query(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span><span class=\"hljs-keyword\">match</span><span class=\"hljs-constructor\">Query(<span class=\"hljs-string\">&quot;all&quot;</span>, <span class=\"hljs-string\">&quot;如家&quot;</span>)</span>);\n    <span class=\"hljs-comment\">// 2.2.高亮</span>\n    request.source<span class=\"hljs-literal\">()</span>.highlighter(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">HighlightBuilder()</span>.field(<span class=\"hljs-string\">&quot;name&quot;</span>).require<span class=\"hljs-constructor\">FieldMatch(<span class=\"hljs-params\">false</span>)</span>);\n    <span class=\"hljs-comment\">// 3.发送请求</span>\n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n    <span class=\"hljs-comment\">// 4.解析响应</span>\n    handle<span class=\"hljs-constructor\">Response(<span class=\"hljs-params\">response</span>)</span>;\n}\n</code></pre>\n<h4 id=\"高亮结果解析\">高亮结果解析</h4>\n<p>高亮的结果与查询的文档结果默认是分离的，并不在一起。</p>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-string\">&quot;_index&quot;</span> : <span class=\"hljs-string\">&quot;hotel&quot;</span>,\n  <span class=\"hljs-string\">&quot;_type&quot;</span> : <span class=\"hljs-string\">&quot;_doc&quot;</span>,\n  <span class=\"hljs-string\">&quot;_id&quot;</span> : <span class=\"hljs-string\">&quot;339952837&quot;</span>,\n  <span class=\"hljs-string\">&quot;_score&quot;</span> : <span class=\"hljs-number\">2.8947515</span>,\n  <span class=\"hljs-string\">&quot;_source&quot;</span> : {\n    <span class=\"hljs-string\">&quot;id&quot;</span> : <span class=\"hljs-number\">339952837</span>,\n    <span class=\"hljs-string\">&quot;name&quot;</span> : <span class=\"hljs-string\">&quot;如家酒店(北京良乡西路店)&quot;</span>,\n    <span class=\"hljs-string\">&quot;price&quot;</span> : <span class=\"hljs-number\">159</span>,\n    <span class=\"hljs-string\">&quot;score&quot;</span> : <span class=\"hljs-number\">46</span>,\n    <span class=\"hljs-string\">&quot;brand&quot;</span> : <span class=\"hljs-string\">&quot;如家&quot;</span>,\n    <span class=\"hljs-string\">&quot;city&quot;</span> : <span class=\"hljs-string\">&quot;北京&quot;</span>,\n    <span class=\"hljs-string\">&quot;location&quot;</span> : <span class=\"hljs-string\">&quot;39.73167, 116.132482&quot;</span>,\n    <span class=\"hljs-string\">&quot;pic&quot;</span> : <span class=\"hljs-string\">&quot;t0.jpg&quot;</span>\n  },\n  <span class=\"hljs-string\">&quot;highlight&quot;</span> : {\n    <span class=\"hljs-string\">&quot;name&quot;</span> : [\n      <span class=\"hljs-string\">&quot;&lt;em&gt;如家&lt;/em&gt;酒店(北京良乡西路店)&quot;</span>,\n    ]\n  }\n}\n</code></pre>\n<p>因此解析高亮的代码需要额外处理：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// 获取source</span>\nHotelDoc hotelDoc = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">JSON</span>.</span></span>parse<span class=\"hljs-constructor\">Object(<span class=\"hljs-params\">hit</span>.<span class=\"hljs-params\">getSourceAsString</span>()</span>, <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">HotelDoc</span>.</span></span><span class=\"hljs-keyword\">class</span>);\n<span class=\"hljs-comment\">// 处理高亮</span>\nMap&lt;String, HighlightField&gt; highlightFields = hit.get<span class=\"hljs-constructor\">HighlightFields()</span>;\n<span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">CollectionUtils</span>.</span></span>is<span class=\"hljs-constructor\">Empty(<span class=\"hljs-params\">highlightFields</span>)</span>) {\n    <span class=\"hljs-comment\">// 获取高亮字段结果</span>\n    HighlightField highlightField = highlightFields.get(<span class=\"hljs-string\">&quot;name&quot;</span>);\n    <span class=\"hljs-keyword\">if</span> (highlightField != null) {\n        <span class=\"hljs-comment\">// 取出高亮结果数组中的第一个，就是酒店名称</span>\n        String name = highlightField.get<span class=\"hljs-constructor\">Fragments()</span><span class=\"hljs-literal\">[<span class=\"hljs-number\">0</span>]</span>.<span class=\"hljs-built_in\">string</span><span class=\"hljs-literal\">()</span>;\n        hotelDoc.set<span class=\"hljs-constructor\">Name(<span class=\"hljs-params\">name</span>)</span>;\n    }\n}\n</code></pre>\n<p>代码解读：</p>\n<ul>\n<li>第一步：从结果中获取 source。<code>hit.getSourceAsString()</code>，这部分是非高亮结果，JSON 字符串。还需要反序列为 HotelDoc 对象</li>\n<li>第二步：获取高亮结果。<code>hit.getHighlightFields()</code>，返回值是一个 Map，key 是高亮字段名称，值是 HighlightField 对象，代表高亮值</li>\n<li>第三步：从 Map 中根据高亮字段名称，获取高亮字段值对象HighlightField</li>\n<li>第四步：从HighlightField 中获取 Fragments，并且转为字符串。这部分就是真正的高亮字符串了</li>\n<li>第五步：用高亮的结果替换 HotelDoc 中的非高亮结果</li>\n</ul>\n<h2 id=\"酒店搜索案例\">酒店搜索案例</h2>\n<p>下面，我们通过酒店搜索案例来实战演练下之前学习的知识。</p>\n<p>我们实现四部分功能：</p>\n<ul>\n<li>酒店搜索和分页</li>\n<li>酒店结果过滤</li>\n<li>我周边的酒店</li>\n<li>酒店竞价排名</li>\n</ul>\n<p>启动 hotel-demo 项目，其默认端口是 8089，访问 <a href=\"http://localhost:8090%EF%BC%8C%E5%B0%B1%E8%83%BD%E7%9C%8B%E5%88%B0%E9%A1%B9%E7%9B%AE%E9%A1%B5%E9%9D%A2%E4%BA%86%E3%80%82\">http://localhost:8090，就能看到项目页面了。</a></p>\n<h3 id=\"酒店搜索和分页\">酒店搜索和分页</h3>\n<p>案例需求：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页</p>\n<h4 id=\"需求分析\">需求分析</h4>\n<ul>\n<li>请求方式：POST</li>\n<li>请求路径：/hotel/list</li>\n<li>请求参数：JSON 对象，包含4个字段：<ul>\n<li>key：搜索关键字</li>\n<li>page：页码</li>\n<li>size：每页大小</li>\n<li>sortBy：排序，目前暂不实现</li>\n</ul>\n</li>\n<li>返回值：分页查询，需要返回分页结果 PageResult，包含两个属性：<ul>\n<li><code>total</code>：总条数</li>\n<li><code>List&lt;HotelDoc&gt;</code>：当前页的数据</li>\n</ul>\n</li>\n</ul>\n<p>因此，我们实现业务的流程如下：</p>\n<ul>\n<li>步骤一：定义实体类，接收请求参数的 JSON 对象</li>\n<li>步骤二：编写 controller，接收页面的请求</li>\n<li>步骤三：编写业务实现，利用 RestHighLevelClient 实现搜索、分页</li>\n</ul>\n<h4 id=\"定义实体类\">定义实体类</h4>\n<p>实体类有两个，一个是前端的请求参数实体，一个是服务端应该返回的响应结果实体。</p>\n<p>① 请求参数，前端请求的 JSON 结构如下：</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-attr\">&quot;key&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;搜索关键字&quot;</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;page&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">1</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;size&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-number\">3</span><span class=\"hljs-punctuation\">,</span>\n    <span class=\"hljs-attr\">&quot;sortBy&quot;</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&quot;default&quot;</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>因此，我们在 <code>cn.itcast.hotel.pojo</code> 包下定义一个实体类：</p>\n<pre><code class=\"hljs language-java\">package <span class=\"hljs-literal\">cn</span>.itcast.hotel.pojo;\n\n<span class=\"hljs-keyword\">import</span> lombok.<span class=\"hljs-built_in\">Data</span>;\n\n@<span class=\"hljs-built_in\">Data</span>\n<span class=\"hljs-keyword\">public</span> class RequestParams {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">String</span> key;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">Integer</span> page;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">Integer</span> size;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">String</span> sortBy;\n}\n</code></pre>\n<p>② 返回值，分页查询，需要返回分页结果 PageResult，包含两个属性：</p>\n<ul>\n<li><code>total</code> ：总条数</li>\n<li><code>List&lt;HotelDoc&gt;</code> ：当前页的数据</li>\n</ul>\n<p>因此，我们在 <code>cn.itcast.hotel.pojo</code> 中定义返回结果：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">package</span> cn.itcast.hotel.pojo;\n\n<span class=\"hljs-keyword\">import</span> lombok.Data;\n\n<span class=\"hljs-keyword\">import</span> java.util.List;\n\n<span class=\"hljs-meta\">@Data</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PageResult</span> {\n    <span class=\"hljs-keyword\">private</span> Long total;\n    <span class=\"hljs-keyword\">private</span> List&lt;HotelDoc&gt; hotels;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">PageResult</span><span class=\"hljs-params\">()</span> {\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">PageResult</span><span class=\"hljs-params\">(Long total, List&lt;HotelDoc&gt; hotels)</span> {\n        <span class=\"hljs-built_in\">this</span>.total = total;\n        <span class=\"hljs-built_in\">this</span>.hotels = hotels;\n    }\n}\n</code></pre>\n<h4 id=\"定义-controller\">定义 controller</h4>\n<p>定义一个 HotelController，声明查询接口，满足下列要求：</p>\n<ul>\n<li>请求方式：Post</li>\n<li>请求路径：/hotel/list</li>\n<li>请求参数：对象，类型为 RequestParam</li>\n<li>返回值：PageResult，包含两个属性<ul>\n<li><code>Long total</code>：总条数</li>\n<li><code>List&lt;HotelDoc&gt; hotels</code>：酒店数据</li>\n</ul>\n</li>\n</ul>\n<p>因此，我们在 <code>cn.itcast.hotel.web</code> 中定义 HotelController：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-variable\">@RestController</span>\n<span class=\"hljs-variable\">@RequestMapping</span>(<span class=\"hljs-string\">&quot;/hotel&quot;</span>)\npublic class HotelController {\n\n    <span class=\"hljs-variable\">@Autowired</span>\n    private IHotelService hotelService;\n    <span class=\"hljs-comment\">// 搜索酒店数据</span>\n    <span class=\"hljs-variable\">@PostMapping</span>(<span class=\"hljs-string\">&quot;/list&quot;</span>)\n    public PageResult search(<span class=\"hljs-variable\">@RequestBody</span> RequestParams params){\n        <span class=\"hljs-selector-tag\">return</span> <span class=\"hljs-selector-tag\">hotelService</span><span class=\"hljs-selector-class\">.search</span>(params);\n    }\n}\n</code></pre>\n<h4 id=\"实现搜索业务\">实现搜索业务</h4>\n<p>我们在 controller 调用了 IHotelService，并没有实现该方法，因此下面我们就在 IHotelService 中定义方法，并且去实现业务逻辑。</p>\n<p>① 在 <code>cn.itcast.hotel.service</code> 中的 <code>IHotelService</code> 接口中定义一个方法：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">/**\n * 根据关键字搜索酒店信息\n * <span class=\"hljs-doctag\">@param</span> params 请求参数对象，包含用户输入的关键字 \n * <span class=\"hljs-doctag\">@return</span> 酒店文档列表\n */</span>\n<span class=\"hljs-function\">PageResult <span class=\"hljs-title\">search</span><span class=\"hljs-params\">(RequestParams params)</span></span>;\n</code></pre>\n<p>② 实现搜索业务，肯定离不开 RestHighLevelClient，我们需要把它注册到 Spring 中作为一个 Bean。在 <code>cn.itcast.hotel</code> 中的 <code>HotelDemoApplication</code> 中声明这个 Bean：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Bean</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">RestHighLevelClient</span> <span class=\"hljs-title function_\">client</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RestHighLevelClient</span>(<span class=\"hljs-title class_\">RestClient</span>.<span class=\"hljs-title function_\">builder</span>(<span class=\"hljs-title class_\">HttpHost</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-string\">&quot;http://halo:9200&quot;</span>)));\n}\n</code></pre>\n<p>③ 在 <code>cn.itcast.hotel.service.impl</code> 中的 <code>HotelService</code> 中实现 search 方法：</p>\n<pre><code class=\"hljs language-java\">@Autowired\n<span class=\"hljs-keyword\">private</span> RestHighLevelClient client;\n\n@Override\npublic PageResult search(RequestParams params) {\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-comment\">// 1.准备Request</span>\n        SearchRequest request = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">SearchRequest(<span class=\"hljs-string\">&quot;hotel&quot;</span>)</span>;\n        <span class=\"hljs-comment\">// 2.准备DSL</span>\n        <span class=\"hljs-comment\">// 2.1.query</span>\n        String key = params.get<span class=\"hljs-constructor\">Key()</span>;\n        <span class=\"hljs-keyword\">if</span> (key<span class=\"hljs-operator\"> == </span>null<span class=\"hljs-operator\"> || </span><span class=\"hljs-string\">&quot;&quot;</span>.equals(key)) {\n            request.source<span class=\"hljs-literal\">()</span>.query(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span><span class=\"hljs-keyword\">match</span><span class=\"hljs-constructor\">AllQuery()</span>);\n        } <span class=\"hljs-keyword\">else</span> {\n            request.source<span class=\"hljs-literal\">()</span>.query(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span><span class=\"hljs-keyword\">match</span><span class=\"hljs-constructor\">Query(<span class=\"hljs-string\">&quot;all&quot;</span>, <span class=\"hljs-params\">key</span>)</span>);\n        }\n\n        <span class=\"hljs-comment\">// 2.2.分页</span>\n        <span class=\"hljs-built_in\">int</span> page = params.get<span class=\"hljs-constructor\">Page()</span>;\n        <span class=\"hljs-built_in\">int</span> size = params.get<span class=\"hljs-constructor\">Size()</span>;\n        request.source<span class=\"hljs-literal\">()</span>.from((page - <span class=\"hljs-number\">1</span>)<span class=\"hljs-operator\"> * </span>size).size(size);\n\n        <span class=\"hljs-comment\">// 3.发送请求</span>\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n        <span class=\"hljs-comment\">// 4.解析响应</span>\n        return handle<span class=\"hljs-constructor\">Response(<span class=\"hljs-params\">response</span>)</span>;\n    } catch (IOException e) {\n        throw <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">RuntimeException(<span class=\"hljs-params\">e</span>)</span>;\n    }\n}\n\n<span class=\"hljs-comment\">// 结果解析</span>\n<span class=\"hljs-keyword\">private</span> PageResult handle<span class=\"hljs-constructor\">Response(SearchResponse <span class=\"hljs-params\">response</span>)</span> {\n    <span class=\"hljs-comment\">// 4.解析响应</span>\n    SearchHits searchHits = response.get<span class=\"hljs-constructor\">Hits()</span>;\n    <span class=\"hljs-comment\">// 4.1.获取总条数</span>\n    long total = searchHits.get<span class=\"hljs-constructor\">TotalHits()</span>.value;\n    <span class=\"hljs-comment\">// 4.2.文档数组</span>\n    SearchHit<span class=\"hljs-literal\">[]</span> hits = searchHits.get<span class=\"hljs-constructor\">Hits()</span>;\n    <span class=\"hljs-comment\">// 4.3.遍历</span>\n    List&lt;HotelDoc&gt; hotels = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;<span class=\"hljs-literal\">()</span>;\n    <span class=\"hljs-keyword\">for</span> (SearchHit hit : hits) {\n        <span class=\"hljs-comment\">// 获取文档source</span>\n        String json = hit.get<span class=\"hljs-constructor\">SourceAsString()</span>;\n        <span class=\"hljs-comment\">// 反序列化</span>\n        HotelDoc hotelDoc = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">JSON</span>.</span></span>parse<span class=\"hljs-constructor\">Object(<span class=\"hljs-params\">json</span>, HotelDoc.<span class=\"hljs-params\">class</span>)</span>;\n        <span class=\"hljs-comment\">// 放入集合</span>\n        hotels.add(hotelDoc);\n    }\n    <span class=\"hljs-comment\">// 4.4.封装返回</span>\n    return <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">PageResult(<span class=\"hljs-params\">total</span>, <span class=\"hljs-params\">hotels</span>)</span>;\n}\n</code></pre>\n<h3 id=\"酒店结果过滤\">酒店结果过滤</h3>\n<p>需求：添加品牌、城市、星级、价格等过滤功能</p>\n<h4 id=\"需求分析-1\">需求分析</h4>\n<p>包含的过滤条件有：</p>\n<ul>\n<li>brand：品牌值</li>\n<li>city：城市</li>\n<li>minPrice~maxPrice：价格范围</li>\n<li>starName：星级</li>\n</ul>\n<p>我们需要做两件事情：</p>\n<ul>\n<li>修改请求参数的对象 RequestParams，接收上述参数</li>\n<li>修改业务逻辑，在搜索条件之外，添加一些过滤条件</li>\n</ul>\n<h4 id=\"修改实体类\">修改实体类</h4>\n<p>修改在 <code>cn.itcast.hotel.pojo</code> 包下的实体类 RequestParams：</p>\n<pre><code class=\"hljs language-java\">@<span class=\"hljs-built_in\">Data</span>\n<span class=\"hljs-keyword\">public</span> class RequestParams {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">String</span> key;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">Integer</span> page;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">Integer</span> size;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">String</span> sortBy;\n    <span class=\"hljs-comment\">// 下面是新增的过滤条件参数</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">String</span> city;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">String</span> brand;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">String</span> starName;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">Integer</span> minPrice;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">Integer</span> maxPrice;\n}\n</code></pre>\n<h4 id=\"修改搜索业务\">修改搜索业务</h4>\n<p>在 HotelService 的 search 方法中，只有一个地方需要修改：<code>requet.source().query( ... )</code> 其中的查询条件。</p>\n<p>在之前的业务中，只有 match 查询，根据关键字搜索，现在要添加条件过滤，包括：</p>\n<ul>\n<li>品牌过滤：是 keyword 类型，用 term 查询</li>\n<li>星级过滤：是 keyword 类型，用 term 查询</li>\n<li>价格过滤：是数值类型，用 range 查询</li>\n<li>城市过滤：是 keyword 类型，用 term 查询</li>\n</ul>\n<p>多个查询条件组合，肯定是 boolean 查询来组合：</p>\n<ul>\n<li>关键字搜索放到 must 中，参与算分</li>\n<li>其它过滤条件放到 filter 中，不参与算分</li>\n</ul>\n<p>因为条件构建的逻辑比较复杂，这里封装为一个函数，getBoolQueryBuilder 的代码如下：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">private</span> BoolQueryBuilder get<span class=\"hljs-constructor\">BoolQueryBuilder(RequestParams <span class=\"hljs-params\">params</span>)</span> {\n    BoolQueryBuilder boolQuery = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span><span class=\"hljs-built_in\">bool</span><span class=\"hljs-constructor\">Query()</span>;\n    String key = params.get<span class=\"hljs-constructor\">Key()</span>;\n    <span class=\"hljs-keyword\">if</span> (key<span class=\"hljs-operator\"> == </span>null<span class=\"hljs-operator\"> || </span><span class=\"hljs-string\">&quot;&quot;</span>.equals(key)) {\n        boolQuery.must(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span><span class=\"hljs-keyword\">match</span><span class=\"hljs-constructor\">AllQuery()</span>);\n    } <span class=\"hljs-keyword\">else</span> {\n        boolQuery.must(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span><span class=\"hljs-keyword\">match</span><span class=\"hljs-constructor\">Query(<span class=\"hljs-string\">&quot;all&quot;</span>, <span class=\"hljs-params\">key</span>)</span>);\n    }\n    <span class=\"hljs-comment\">// 条件过滤</span>\n    <span class=\"hljs-comment\">// 城市条件</span>\n    <span class=\"hljs-keyword\">if</span> (params.get<span class=\"hljs-constructor\">City()</span> != null<span class=\"hljs-operator\"> &amp;&amp; </span>!params.get<span class=\"hljs-constructor\">City()</span>.equals(<span class=\"hljs-string\">&quot;&quot;</span>)) {\n        boolQuery.filter(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span>term<span class=\"hljs-constructor\">Query(<span class=\"hljs-string\">&quot;city&quot;</span>, <span class=\"hljs-params\">params</span>.<span class=\"hljs-params\">getCity</span>()</span>));\n    }\n    <span class=\"hljs-comment\">// 品牌条件</span>\n    <span class=\"hljs-keyword\">if</span> (params.get<span class=\"hljs-constructor\">Brand()</span> != null<span class=\"hljs-operator\"> &amp;&amp; </span>!params.get<span class=\"hljs-constructor\">Brand()</span>.equals(<span class=\"hljs-string\">&quot;&quot;</span>)) {\n        boolQuery.filter(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span>term<span class=\"hljs-constructor\">Query(<span class=\"hljs-string\">&quot;brand&quot;</span>, <span class=\"hljs-params\">params</span>.<span class=\"hljs-params\">getBrand</span>()</span>));\n    }\n    <span class=\"hljs-comment\">// 星级</span>\n    <span class=\"hljs-keyword\">if</span> (params.get<span class=\"hljs-constructor\">StarName()</span> != null<span class=\"hljs-operator\"> &amp;&amp; </span>!params.get<span class=\"hljs-constructor\">StarName()</span>.equals(<span class=\"hljs-string\">&quot;&quot;</span>)) {\n        boolQuery.filter(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span>term<span class=\"hljs-constructor\">Query(<span class=\"hljs-string\">&quot;starName&quot;</span>, <span class=\"hljs-params\">params</span>.<span class=\"hljs-params\">getStarName</span>()</span>));\n    }\n    <span class=\"hljs-comment\">// 价格</span>\n    <span class=\"hljs-keyword\">if</span> (params.get<span class=\"hljs-constructor\">MinPrice()</span> != null<span class=\"hljs-operator\"> &amp;&amp; </span>params.get<span class=\"hljs-constructor\">MaxPrice()</span> != null) {\n        boolQuery.filter(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">QueryBuilders</span>.</span></span>range<span class=\"hljs-constructor\">Query(<span class=\"hljs-string\">&quot;price&quot;</span>)</span>\n                         .gte(params.get<span class=\"hljs-constructor\">MinPrice()</span>).lte(params.get<span class=\"hljs-constructor\">MaxPrice()</span>));\n    }\n    return boolQuery;\n}\n</code></pre>\n<h3 id=\"我周边的酒店\">我周边的酒店</h3>\n<p>需求：我附近的酒店</p>\n<h4 id=\"需求分析-2\">需求分析</h4>\n<p>在酒店列表页的右侧，有一个小地图，点击地图的定位按钮，地图会找到你所在的位置，并且，在前端会发起查询请求，将你的坐标发送到服务端。</p>\n<p>我们要做的事情就是基于这个 location 坐标，然后按照距离对周围酒店排序。实现思路如下：</p>\n<ul>\n<li>修改 RequestParams 参数，接收 location 字段</li>\n<li>修改 search 方法业务逻辑，如果 location 有值，添加根据 geo_distance 排序的功能</li>\n</ul>\n<h4 id=\"修改实体类-1\">修改实体类</h4>\n<p>修改在 <code>cn.itcast.hotel.pojo</code> 包下的实体类 RequestParams：</p>\n<pre><code class=\"hljs language-java\">package <span class=\"hljs-literal\">cn</span>.itcast.hotel.pojo;\n\n<span class=\"hljs-keyword\">import</span> lombok.<span class=\"hljs-built_in\">Data</span>;\n\n@<span class=\"hljs-built_in\">Data</span>\n<span class=\"hljs-keyword\">public</span> class RequestParams {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">String</span> key;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">Integer</span> page;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">Integer</span> size;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">String</span> sortBy;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">String</span> city;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">String</span> brand;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">String</span> starName;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">Integer</span> minPrice;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">Integer</span> maxPrice;\n    <span class=\"hljs-comment\">// 我当前的地理坐标</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">String</span> location;\n}\n</code></pre>\n<h4 id=\"距离排序-api\">距离排序 API</h4>\n<p>我们以前学习过排序功能，包括两种：</p>\n<ul>\n<li>普通字段排序</li>\n<li>地理坐标排序</li>\n</ul>\n<p>我们只讲了普通字段排序对应的 Java 写法。地理坐标排序只学过 DSL 语法，如下：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/indexName/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match_all&quot;</span>: {}\n  },\n  <span class=\"hljs-string\">&quot;sort&quot;</span>: [\n    {\n      <span class=\"hljs-string\">&quot;price&quot;</span>: <span class=\"hljs-string\">&quot;asc&quot;</span>  \n    },\n    {\n      <span class=\"hljs-string\">&quot;_geo_distance&quot;</span> : {\n          <span class=\"hljs-string\">&quot;FIELD&quot;</span> : <span class=\"hljs-string\">&quot;纬度，经度&quot;</span>,\n          <span class=\"hljs-string\">&quot;order&quot;</span> : <span class=\"hljs-string\">&quot;asc&quot;</span>,\n          <span class=\"hljs-string\">&quot;unit&quot;</span> : <span class=\"hljs-string\">&quot;km&quot;</span>\n      }\n    }\n  ]\n}\n</code></pre>\n<p>对应 Java 代码</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// 价格排序</span>\nrequest.<span class=\"hljs-keyword\">source</span>().<span class=\"hljs-keyword\">sort</span>(<span class=\"hljs-string\">&quot;price&quot;</span>, SortOrder.ASC);\n<span class=\"hljs-comment\">// 距离排序</span>\nrequest.<span class=\"hljs-keyword\">source</span>().<span class=\"hljs-keyword\">sort</span>(SortBuilders.geoDistanceSort(<span class=\"hljs-string\">&quot;location&quot;</span>, <span class=\"hljs-keyword\">new</span> GeoPoint(<span class=\"hljs-string\">&quot;31.21, 121.5&quot;</span>))\n                      .order(SortOrder.ASC).unit(DistanceUnit.KILOMETERS));\n</code></pre>\n<h4 id=\"添加距离排序\">添加距离排序</h4>\n<p>在 <code>cn.itcast.hotel.service.impl</code> 的 <code>HotelService</code> 的 <code>search</code> 方法中，添加一个排序功能：</p>\n<pre><code class=\"hljs language-java\">@Override\n<span class=\"hljs-keyword\">public</span> PageResult search(RequestParams params) {\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-comment\">// 1.准备Request</span>\n        SearchRequest request = <span class=\"hljs-keyword\">new</span> SearchRequest(<span class=\"hljs-string\">&quot;hotel&quot;</span>);\n        <span class=\"hljs-comment\">// 2.准备DSL</span>\n        <span class=\"hljs-comment\">// 2.1.query</span>\n        <span class=\"hljs-comment\">// 构建 boolQuery</span>\n        BoolQueryBuilder boolQuery = getBoolQueryBuilder(params);\n        request.<span class=\"hljs-keyword\">source</span>().query(boolQuery);\n\n        <span class=\"hljs-comment\">// 2.2.分页</span>\n        <span class=\"hljs-keyword\">int</span> page = params.getPage();\n        <span class=\"hljs-keyword\">int</span> <span class=\"hljs-keyword\">size</span> = params.getSize();\n        request.<span class=\"hljs-keyword\">source</span>().<span class=\"hljs-keyword\">from</span>((page - <span class=\"hljs-number\">1</span>) * <span class=\"hljs-keyword\">size</span>).<span class=\"hljs-keyword\">size</span>(<span class=\"hljs-keyword\">size</span>);\n\n        <span class=\"hljs-comment\">// 排序</span>\n        String location = params.getLocation();\n        <span class=\"hljs-keyword\">if</span> (location != <span class=\"hljs-keyword\">null</span> &amp;&amp; !location.equals(<span class=\"hljs-string\">&quot;&quot;</span>)) {\n            request.<span class=\"hljs-keyword\">source</span>().<span class=\"hljs-keyword\">sort</span>(SortBuilders\n                                  .geoDistanceSort(<span class=\"hljs-string\">&quot;location&quot;</span>, <span class=\"hljs-keyword\">new</span> GeoPoint(location))\n                                  .order(SortOrder.ASC)\n                                  .unit(DistanceUnit.KILOMETERS));\n        }\n\n        <span class=\"hljs-comment\">// 3.发送请求</span>\n        SearchResponse response = client.search(request, RequestOptions.<span class=\"hljs-keyword\">DEFAULT</span>);\n        <span class=\"hljs-comment\">// 4.解析响应</span>\n        <span class=\"hljs-keyword\">return</span> handleResponse(response);\n    } <span class=\"hljs-keyword\">catch</span> (IOException e) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> RuntimeException(e);\n    }\n}\n</code></pre>\n<h4 id=\"排序距离显示\">排序距离显示</h4>\n<p>排序完成后，页面还要获取我附近每个酒店的具体<strong>距离</strong>值，这个值在响应结果中是独立的：</p>\n<p>因此，我们在结果解析阶段，除了解析 source 部分以外，还要得到 sort 部分，也就是排序的距离，然后放到响应结果中。</p>\n<p>我们要做两件事：</p>\n<ul>\n<li>修改 HotelDoc，添加排序距离字段，用于页面显示</li>\n<li>修改 HotelService 类中的 handleResponse 方法，添加对 sort 值的获取</li>\n</ul>\n<p>① 修改HotelDoc类，添加距离字段</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">package</span> cn.itcast.hotel.pojo;\n\n<span class=\"hljs-keyword\">import</span> lombok.Data;\n<span class=\"hljs-keyword\">import</span> lombok.NoArgsConstructor;\n\n\n<span class=\"hljs-meta\">@Data</span>\n<span class=\"hljs-meta\">@NoArgsConstructor</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HotelDoc</span> </span>{\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">Long</span> id;\n    <span class=\"hljs-keyword\">private</span> String name;\n    <span class=\"hljs-keyword\">private</span> String address;\n    <span class=\"hljs-keyword\">private</span> Integer price;\n    <span class=\"hljs-keyword\">private</span> Integer score;\n    <span class=\"hljs-keyword\">private</span> String brand;\n    <span class=\"hljs-keyword\">private</span> String city;\n    <span class=\"hljs-keyword\">private</span> String starName;\n    <span class=\"hljs-keyword\">private</span> String business;\n    <span class=\"hljs-keyword\">private</span> String location;\n    <span class=\"hljs-keyword\">private</span> String pic;\n    <span class=\"hljs-comment\">// 排序时的 距离值</span>\n    <span class=\"hljs-keyword\">private</span> Object distance;\n\n    <span class=\"hljs-keyword\">public</span> HotelDoc(Hotel hotel) {\n        <span class=\"hljs-keyword\">this</span>.id = hotel.getId();\n        <span class=\"hljs-keyword\">this</span>.name = hotel.getName();\n        <span class=\"hljs-keyword\">this</span>.address = hotel.getAddress();\n        <span class=\"hljs-keyword\">this</span>.price = hotel.getPrice();\n        <span class=\"hljs-keyword\">this</span>.score = hotel.getScore();\n        <span class=\"hljs-keyword\">this</span>.brand = hotel.getBrand();\n        <span class=\"hljs-keyword\">this</span>.city = hotel.getCity();\n        <span class=\"hljs-keyword\">this</span>.starName = hotel.getStarName();\n        <span class=\"hljs-keyword\">this</span>.business = hotel.getBusiness();\n        <span class=\"hljs-keyword\">this</span>.location = hotel.getLatitude() + <span class=\"hljs-string\">&quot;, &quot;</span> + hotel.getLongitude();\n        <span class=\"hljs-keyword\">this</span>.pic = hotel.getPic();\n    }\n}\n</code></pre>\n<p>② 修改 HotelService 中的 handleResponse 方法</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// 结果解析</span>\n<span class=\"hljs-keyword\">private</span> PageResult handle<span class=\"hljs-constructor\">Response(SearchResponse <span class=\"hljs-params\">response</span>)</span> {\n    <span class=\"hljs-comment\">// 4.解析响应</span>\n    SearchHits searchHits = response.get<span class=\"hljs-constructor\">Hits()</span>;\n    <span class=\"hljs-comment\">// 4.1.获取总条数</span>\n    long total = searchHits.get<span class=\"hljs-constructor\">TotalHits()</span>.value;\n    <span class=\"hljs-comment\">// 4.2.文档数组</span>\n    SearchHit<span class=\"hljs-literal\">[]</span> hits = searchHits.get<span class=\"hljs-constructor\">Hits()</span>;\n    <span class=\"hljs-comment\">// 4.3.遍历</span>\n    List&lt;HotelDoc&gt; hotels = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;<span class=\"hljs-literal\">()</span>;\n    <span class=\"hljs-keyword\">for</span> (SearchHit hit : hits) {\n        <span class=\"hljs-comment\">// 获取文档source</span>\n        String json = hit.get<span class=\"hljs-constructor\">SourceAsString()</span>;\n        <span class=\"hljs-comment\">// 反序列化</span>\n        HotelDoc hotelDoc = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">JSON</span>.</span></span>parse<span class=\"hljs-constructor\">Object(<span class=\"hljs-params\">json</span>, HotelDoc.<span class=\"hljs-params\">class</span>)</span>;\n        <span class=\"hljs-comment\">// 获取排序值 - location</span>\n        Object<span class=\"hljs-literal\">[]</span> sortValues = hit.get<span class=\"hljs-constructor\">SortValues()</span>;\n        <span class=\"hljs-keyword\">if</span> (sortValues.length &gt; <span class=\"hljs-number\">0</span>) {\n            Object sortValue = sortValues<span class=\"hljs-literal\">[<span class=\"hljs-number\">0</span>]</span>;\n            hotelDoc.set<span class=\"hljs-constructor\">Distance(<span class=\"hljs-params\">sortValue</span>)</span>;\n        }\n\n        <span class=\"hljs-comment\">// 放入集合</span>\n        hotels.add(hotelDoc);\n    }\n    <span class=\"hljs-comment\">// 4.4.封装返回</span>\n    return <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">PageResult(<span class=\"hljs-params\">total</span>, <span class=\"hljs-params\">hotels</span>)</span>;\n}\n</code></pre>\n<h3 id=\"酒店竞价排名\">酒店竞价排名</h3>\n<p>需求：让指定的酒店在搜索结果中排名置顶</p>\n<h4 id=\"需求分析-3\">需求分析</h4>\n<p>要让指定酒店在搜索结果中排名置顶，页面会给指定的酒店添加<strong>广告</strong>标记。</p>\n<p>我们之前学习过的 function_score 查询可以影响算分，算分高了，自然排名也就高了。而 function_score 包含 3 个要素：</p>\n<ul>\n<li>过滤条件：哪些文档要加分</li>\n<li>算分函数：如何计算 function score</li>\n<li>加权方式：function score 与 query score 如何运算</li>\n</ul>\n<p>这里的需求是：让<strong>指定酒店</strong>排名靠前。因此我们需要给这些酒店添加一个标记，这样在过滤条件中就可以根据这个标记来判断，是否要提高算分。</p>\n<p>比如，我们给酒店添加一个字段：isAD，Boolean 类型：</p>\n<ul>\n<li>true：是广告</li>\n<li>false：不是广告</li>\n</ul>\n<p>这样 function_score 包含 3 个要素就很好确定了：</p>\n<ul>\n<li>过滤条件：判断 isAD 是否为 true</li>\n<li>算分函数：我们可以用最简单暴力的 weight，固定加权值</li>\n<li>加权方式：可以用默认的相乘，大大提高算分</li>\n</ul>\n<p>因此，业务的实现步骤包括：</p>\n<ol>\n<li><p>给 HotelDoc 类添加 isAD 字段，Boolean 类型</p>\n</li>\n<li><p>挑选几个你喜欢的酒店，给它的文档数据添加 isAD 字段，值为 true</p>\n</li>\n<li><p>修改 search方法，添加 function score 功能，给 isAD 值为 true 的酒店增加权重</p>\n</li>\n</ol>\n<h4 id=\"修改-hoteldoc-实体\">修改 HotelDoc 实体</h4>\n<p>给 <code>cn.itcast.hotel.pojo</code> 包下的 HotelDoc 类添加 isAD 字段：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Data</span>\n<span class=\"hljs-meta\">@NoArgsConstructor</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HotelDoc</span> </span>{\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">Long</span> id;\n    <span class=\"hljs-keyword\">private</span> String name;\n    <span class=\"hljs-keyword\">private</span> String address;\n    <span class=\"hljs-keyword\">private</span> Integer price;\n    <span class=\"hljs-keyword\">private</span> Integer score;\n    <span class=\"hljs-keyword\">private</span> String brand;\n    <span class=\"hljs-keyword\">private</span> String city;\n    <span class=\"hljs-keyword\">private</span> String starName;\n    <span class=\"hljs-keyword\">private</span> String business;\n    <span class=\"hljs-keyword\">private</span> String location;\n    <span class=\"hljs-keyword\">private</span> String pic;\n    <span class=\"hljs-comment\">// 排序时的距离值</span>\n    <span class=\"hljs-keyword\">private</span> Object distance;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">Boolean</span> isAD;\n\n    <span class=\"hljs-keyword\">public</span> HotelDoc(Hotel hotel) {\n        <span class=\"hljs-keyword\">this</span>.id = hotel.getId();\n        <span class=\"hljs-keyword\">this</span>.name = hotel.getName();\n        <span class=\"hljs-keyword\">this</span>.address = hotel.getAddress();\n        <span class=\"hljs-keyword\">this</span>.price = hotel.getPrice();\n        <span class=\"hljs-keyword\">this</span>.score = hotel.getScore();\n        <span class=\"hljs-keyword\">this</span>.brand = hotel.getBrand();\n        <span class=\"hljs-keyword\">this</span>.city = hotel.getCity();\n        <span class=\"hljs-keyword\">this</span>.starName = hotel.getStarName();\n        <span class=\"hljs-keyword\">this</span>.business = hotel.getBusiness();\n        <span class=\"hljs-keyword\">this</span>.location = hotel.getLatitude() + <span class=\"hljs-string\">&quot;, &quot;</span> + hotel.getLongitude();\n        <span class=\"hljs-keyword\">this</span>.pic = hotel.getPic();\n    }\n}\n</code></pre>\n<h4 id=\"添加广告标记\">添加广告标记</h4>\n<p>用 DSL 添加酒店广告标记</p>\n<pre><code class=\"hljs language-java\">POST <span class=\"hljs-regexp\">/hotel/</span>_update/<span class=\"hljs-number\">36934</span>\n{\n  <span class=\"hljs-string\">&quot;doc&quot;</span>: {\n    <span class=\"hljs-string\">&quot;isAD&quot;</span>: <span class=\"hljs-keyword\">true</span>\n  }\n}\n</code></pre>\n<h4 id=\"添加算分函数查询\">添加算分函数查询</h4>\n<p>接下来我们就要修改查询条件了。之前是用的 boolean 查询，现在要改成 function_socre 查询。</p>\n<p>function_score 查询结构如下：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;function_score&quot;</span>: {\n      <span class=\"hljs-string\">&quot;query&quot;</span>: {\n        <span class=\"hljs-string\">&quot;match&quot;</span>: {\n          <span class=\"hljs-string\">&quot;name&quot;</span>: <span class=\"hljs-string\">&quot;外滩&quot;</span>\n        }\n      },\n      <span class=\"hljs-string\">&quot;functions&quot;</span>: [ \n        {\n          <span class=\"hljs-string\">&quot;filter&quot;</span>: {\n            <span class=\"hljs-string\">&quot;term&quot;</span>: {\n              <span class=\"hljs-string\">&quot;brand&quot;</span>: <span class=\"hljs-string\">&quot;如家&quot;</span>\n            }\n          },\n          <span class=\"hljs-string\">&quot;weight&quot;</span>: <span class=\"hljs-number\">5</span>\n        }\n      ]\n    }\n  }\n}\n</code></pre>\n<p>对应的 JavaAPI 如下</p>\n<pre><code class=\"hljs language-java\">FunctionScoreQueryBuilder functionScoreQueryBuilder = \n    QueryBuilders.functionScoreQuery(\n        QueryBuilders.matchQuery(<span class=\"hljs-string\">&quot;name&quot;</span>, <span class=\"hljs-string\">&quot;外滩&quot;</span>),\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder[]{\n            <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">FunctionScoreQueryBuilder</span>.FilterFunctionBuilder(\n                QueryBuilders.termQuery(<span class=\"hljs-string\">&quot;brand&quot;</span>, <span class=\"hljs-string\">&quot;如家&quot;</span>), \n                ScoreFunctionBuilders.weightFactorFunction(<span class=\"hljs-number\">5</span>)\n            )\n        }\n    );\nsourceBuilder.query(functionScoreQueryBuilder);\n</code></pre>\n<p>我们可以将之前写的 boolean 查询作为<strong>原始查询</strong>条件放到 query 中，接下来就是添加过滤条件、算分函数、加权模式了。所以原来的代码依然可以沿用。</p>\n<p>修改 <code>cn.itcast.hotel.service.impl</code> 包下的 <code>HotelService</code> 类中的 <code>getQueryBuilder</code> 方法，添加算分函数查询：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> FunctionScoreQueryBuilder <span class=\"hljs-title\">getQueryBuilder</span>(<span class=\"hljs-params\">RequestParams <span class=\"hljs-keyword\">params</span></span>)</span> {\n    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();\n    String key = <span class=\"hljs-keyword\">params</span>.getKey();\n    <span class=\"hljs-keyword\">if</span> (key == <span class=\"hljs-literal\">null</span> || <span class=\"hljs-string\">&quot;&quot;</span>.<span class=\"hljs-keyword\">equals</span>(key)) {\n        boolQuery.must(QueryBuilders.matchAllQuery());\n    } <span class=\"hljs-keyword\">else</span> {\n        boolQuery.must(QueryBuilders.matchQuery(<span class=\"hljs-string\">&quot;all&quot;</span>, key));\n    }\n    <span class=\"hljs-comment\">// 条件过滤</span>\n    <span class=\"hljs-comment\">// 城市条件</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">params</span>.getCity() != <span class=\"hljs-literal\">null</span> &amp;&amp; !<span class=\"hljs-keyword\">params</span>.getCity().<span class=\"hljs-keyword\">equals</span>(<span class=\"hljs-string\">&quot;&quot;</span>)) {\n        boolQuery.filter(QueryBuilders.termQuery(<span class=\"hljs-string\">&quot;city&quot;</span>, <span class=\"hljs-keyword\">params</span>.getCity()));\n    }\n    <span class=\"hljs-comment\">// 品牌条件</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">params</span>.getBrand() != <span class=\"hljs-literal\">null</span> &amp;&amp; !<span class=\"hljs-keyword\">params</span>.getBrand().<span class=\"hljs-keyword\">equals</span>(<span class=\"hljs-string\">&quot;&quot;</span>)) {\n        boolQuery.filter(QueryBuilders.termQuery(<span class=\"hljs-string\">&quot;brand&quot;</span>, <span class=\"hljs-keyword\">params</span>.getBrand()));\n    }\n    <span class=\"hljs-comment\">// 星级</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">params</span>.getStarName() != <span class=\"hljs-literal\">null</span> &amp;&amp; !<span class=\"hljs-keyword\">params</span>.getStarName().<span class=\"hljs-keyword\">equals</span>(<span class=\"hljs-string\">&quot;&quot;</span>)) {\n        boolQuery.filter(QueryBuilders.termQuery(<span class=\"hljs-string\">&quot;starName&quot;</span>, <span class=\"hljs-keyword\">params</span>.getStarName()));\n    }\n    <span class=\"hljs-comment\">// 价格</span>\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">params</span>.getMinPrice() != <span class=\"hljs-literal\">null</span> &amp;&amp; <span class=\"hljs-keyword\">params</span>.getMaxPrice() != <span class=\"hljs-literal\">null</span>) {\n        boolQuery.filter(QueryBuilders.rangeQuery(<span class=\"hljs-string\">&quot;price&quot;</span>)\n                         .gte(<span class=\"hljs-keyword\">params</span>.getMinPrice()).lte(<span class=\"hljs-keyword\">params</span>.getMaxPrice()));\n    }\n\n    <span class=\"hljs-comment\">// 算分控制</span>\n    FunctionScoreQueryBuilder functionScoreQueryBuilder =\n        QueryBuilders.functionScoreQuery(\n        <span class=\"hljs-comment\">// 原始查询，相关性算分</span>\n        boolQuery,\n        <span class=\"hljs-comment\">// function score</span>\n        <span class=\"hljs-keyword\">new</span> FunctionScoreQueryBuilder.FilterFunctionBuilder[]{\n            <span class=\"hljs-comment\">// 一个 function score 元素</span>\n            <span class=\"hljs-keyword\">new</span> FunctionScoreQueryBuilder.FilterFunctionBuilder(\n                <span class=\"hljs-comment\">// 过滤条件</span>\n                QueryBuilders.termQuery(<span class=\"hljs-string\">&quot;isAD&quot;</span>, <span class=\"hljs-literal\">true</span>),\n                <span class=\"hljs-comment\">// 算分函数</span>\n                ScoreFunctionBuilders.weightFactorFunction(<span class=\"hljs-number\">10</span>)\n            )\n        });\n\n    <span class=\"hljs-keyword\">return</span> functionScoreQueryBuilder;\n}\n</code></pre>\n<h2 id=\"数据聚合\">数据聚合</h2>\n<p><a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html\">聚合</a>（aggregation） 可以让我们极其方便的实现对数据的统计、分析、运算。例如：</p>\n<ul>\n<li>什么品牌的手机最受欢迎？</li>\n<li>这些手机的平均价格、最高价格、最低价格？</li>\n<li>这些手机每月的销售情况如何？</li>\n</ul>\n<p>实现这些统计功能的比数据库的 SQL 要方便的多，而且查询速度非常快，可以实现近实时搜索效果。</p>\n<h3 id=\"聚合的种类\">聚合的种类</h3>\n<p>聚合常见的有三类：</p>\n<ul>\n<li><p>桶（Bucket）聚合：用来对文档做分组</p>\n<ul>\n<li>TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组</li>\n<li>Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组</li>\n</ul>\n</li>\n<li><p>度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等</p>\n<ul>\n<li>Avg：求平均值</li>\n<li>Max：求最大值</li>\n<li>Min：求最小值</li>\n<li>Stats：同时求 max、min、avg、sum 等</li>\n</ul>\n</li>\n<li><p>管道（pipeline）聚合：其它聚合的结果为基础做聚合</p>\n</li>\n</ul>\n<blockquote>\n<p><strong>注意：</strong>参加聚合的字段必须是 keyword、日期、数值、布尔类型</p>\n</blockquote>\n<h3 id=\"dsl-实现聚合\">DSL 实现聚合</h3>\n<p>现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。</p>\n<p>此时可以根据酒店品牌的名称做聚合，也就是 Bucket 聚合。</p>\n<h4 id=\"bucket-聚合语法\">Bucket 聚合语法</h4>\n<p>语法如下：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;size&quot;</span>: <span class=\"hljs-number\">0</span>,  <span class=\"hljs-regexp\">//</span> 设置 size 为 <span class=\"hljs-number\">0</span>，结果中不包含文档，只包含聚合结果\n  <span class=\"hljs-string\">&quot;aggs&quot;</span>: { <span class=\"hljs-regexp\">//</span> 定义聚合\n    <span class=\"hljs-string\">&quot;brandAgg&quot;</span>: { <span class=\"hljs-regexp\">//</span>给聚合起个名字\n      <span class=\"hljs-string\">&quot;terms&quot;</span>: { <span class=\"hljs-regexp\">//</span> 聚合的类型，按照品牌值聚合，所以选择term\n        <span class=\"hljs-string\">&quot;field&quot;</span>: <span class=\"hljs-string\">&quot;brand&quot;</span>, <span class=\"hljs-regexp\">//</span> 参与聚合的字段\n        <span class=\"hljs-string\">&quot;size&quot;</span>: <span class=\"hljs-number\">5</span> <span class=\"hljs-regexp\">//</span> 希望获取的聚合结果数量\n      }\n    }\n  }\n}\n</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-string\">&quot;took&quot;</span> : 36,\n  <span class=\"hljs-string\">&quot;timed_out&quot;</span> : <span class=\"hljs-type\">false</span>,\n  <span class=\"hljs-string\">&quot;_shards&quot;</span> : {\n    <span class=\"hljs-string\">&quot;total&quot;</span> : 1,\n    <span class=\"hljs-string\">&quot;successful&quot;</span> : 1,\n    <span class=\"hljs-string\">&quot;skipped&quot;</span> : 0,\n    <span class=\"hljs-string\">&quot;failed&quot;</span> : 0\n  },\n  <span class=\"hljs-string\">&quot;hits&quot;</span> : {\n    <span class=\"hljs-string\">&quot;total&quot;</span> : {\n      <span class=\"hljs-string\">&quot;value&quot;</span> : 201,\n      <span class=\"hljs-string\">&quot;relation&quot;</span> : &quot;<span class=\"hljs-type\">eq</span><span class=\"hljs-string\">&quot;\n    },\n    &quot;</span>max_score<span class=\"hljs-string\">&quot; : null,\n    &quot;</span>hits<span class=\"hljs-string\">&quot; : [ ]\n  },\n  &quot;</span>aggregations<span class=\"hljs-string\">&quot; : {\n    &quot;</span>brandAgg<span class=\"hljs-string\">&quot; : {\n      &quot;</span>doc_count_error_upper_bound<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span>sum_other_doc_count<span class=\"hljs-string\">&quot; : 96,\n      &quot;</span>buckets<span class=\"hljs-string\">&quot; : [\n        {\n          &quot;</span>key<span class=\"hljs-string\">&quot; : &quot;</span><span class=\"hljs-number\">7</span>天酒店<span class=\"hljs-string\">&quot;,\n          &quot;</span>doc_count<span class=\"hljs-string\">&quot; : 30\n        },\n        {\n          &quot;</span>key<span class=\"hljs-string\">&quot; : &quot;</span>如家<span class=\"hljs-string\">&quot;,\n          &quot;</span>doc_count<span class=\"hljs-string\">&quot; : 30\n        },\n        {\n          &quot;</span>key<span class=\"hljs-string\">&quot; : &quot;</span>皇冠假日<span class=\"hljs-string\">&quot;,\n          &quot;</span>doc_count<span class=\"hljs-string\">&quot; : 17\n        },\n        {\n          &quot;</span>key<span class=\"hljs-string\">&quot; : &quot;</span>速<span class=\"hljs-number\">8</span><span class=\"hljs-string\">&quot;,\n          &quot;</span>doc_count<span class=\"hljs-string\">&quot; : 15\n        },\n        {\n          &quot;</span>key<span class=\"hljs-string\">&quot; : &quot;</span>万怡<span class=\"hljs-string\">&quot;,\n          &quot;</span>doc_count<span class=\"hljs-string\">&quot; : 13\n        }\n      ]\n    }\n  }\n}</span>\n</code></pre>\n<h4 id=\"聚合结果排序\">聚合结果排序</h4>\n<p>默认情况下，Bucket 聚合会统计 Bucket 内的文档数量，记为 <code>_count</code>，并且按照 <code>_count</code> 降序排序。</p>\n<p>我们可以指定 order 属性，自定义聚合的排序方式：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;size&quot;</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-string\">&quot;aggs&quot;</span>: {\n    <span class=\"hljs-string\">&quot;brandAgg&quot;</span>: {\n      <span class=\"hljs-string\">&quot;terms&quot;</span>: {\n        <span class=\"hljs-string\">&quot;field&quot;</span>: <span class=\"hljs-string\">&quot;brand&quot;</span>,\n        <span class=\"hljs-string\">&quot;order&quot;</span>: {\n          <span class=\"hljs-string\">&quot;_count&quot;</span>: <span class=\"hljs-string\">&quot;asc&quot;</span> <span class=\"hljs-regexp\">//</span> 按照 _count 升序排列\n        }, \n        <span class=\"hljs-string\">&quot;size&quot;</span>: <span class=\"hljs-number\">5</span>\n      }\n    }\n  }\n}\n</code></pre>\n<h4 id=\"限定聚合范围\">限定聚合范围</h4>\n<p>默认情况下，Bucket 聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。</p>\n<p>我们可以限定要聚合的文档范围，只要添加 query 条件即可：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;range&quot;</span>: {\n      <span class=\"hljs-string\">&quot;price&quot;</span>: {\n        <span class=\"hljs-string\">&quot;lte&quot;</span>: <span class=\"hljs-number\">200</span> <span class=\"hljs-regexp\">//</span> 只对<span class=\"hljs-number\">200</span>元以下的文档聚合\n      }\n    }\n  }, \n  <span class=\"hljs-string\">&quot;size&quot;</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-string\">&quot;aggs&quot;</span>: {\n    <span class=\"hljs-string\">&quot;brandAgg&quot;</span>: {\n      <span class=\"hljs-string\">&quot;terms&quot;</span>: {\n        <span class=\"hljs-string\">&quot;field&quot;</span>: <span class=\"hljs-string\">&quot;brand&quot;</span>,\n        <span class=\"hljs-string\">&quot;size&quot;</span>: <span class=\"hljs-number\">5</span>\n      }\n    }\n  }\n}\n</code></pre>\n<h4 id=\"metric-聚合语法\">Metric 聚合语法</h4>\n<p>现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的 min、max、avg 等值。</p>\n<p>这就要用到 Metric 聚合了，例如 stats 聚合：就可以获取 min、max、avg 等结果。</p>\n<p>语法如下：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;size&quot;</span>: <span class=\"hljs-number\">0</span>, \n  <span class=\"hljs-string\">&quot;aggs&quot;</span>: {\n    <span class=\"hljs-string\">&quot;brandAgg&quot;</span>: { \n      <span class=\"hljs-string\">&quot;terms&quot;</span>: { \n        <span class=\"hljs-string\">&quot;field&quot;</span>: <span class=\"hljs-string\">&quot;brand&quot;</span>, \n        <span class=\"hljs-string\">&quot;size&quot;</span>: <span class=\"hljs-number\">5</span>\n      },\n      <span class=\"hljs-string\">&quot;aggs&quot;</span>: { <span class=\"hljs-regexp\">//</span> 是brands聚合的子聚合，也就是分组后对每组分别计算\n        <span class=\"hljs-string\">&quot;score_stats&quot;</span>: { <span class=\"hljs-regexp\">//</span> 聚合名称\n          <span class=\"hljs-string\">&quot;stats&quot;</span>: { <span class=\"hljs-regexp\">//</span> 聚合类型，这里stats可以计算min、max、avg等\n            <span class=\"hljs-string\">&quot;field&quot;</span>: <span class=\"hljs-string\">&quot;score&quot;</span> <span class=\"hljs-regexp\">//</span> 聚合字段，这里是score\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<p>这次的 score_stats 聚合是在 brandAgg 的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。</p>\n<p>另外，我们还可以给聚合结果做个排序：</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;size&quot;</span>: <span class=\"hljs-number\">0</span>,\n  <span class=\"hljs-string\">&quot;aggs&quot;</span>: {\n    <span class=\"hljs-string\">&quot;brandAgg&quot;</span>: {\n      <span class=\"hljs-string\">&quot;terms&quot;</span>: {\n        <span class=\"hljs-string\">&quot;field&quot;</span>: <span class=\"hljs-string\">&quot;brand&quot;</span>,\n        <span class=\"hljs-string\">&quot;size&quot;</span>: <span class=\"hljs-number\">5</span>,\n        <span class=\"hljs-string\">&quot;order&quot;</span>: {\n          <span class=\"hljs-string\">&quot;scoreAgg.avg&quot;</span>: <span class=\"hljs-string\">&quot;desc&quot;</span>\n        }\n      },\n      <span class=\"hljs-string\">&quot;aggs&quot;</span>: {\n        <span class=\"hljs-string\">&quot;scoreAgg&quot;</span>: {\n          <span class=\"hljs-string\">&quot;stats&quot;</span>: {\n            <span class=\"hljs-string\">&quot;field&quot;</span>: <span class=\"hljs-string\">&quot;score&quot;</span>\n          }\n        }\n      }\n    }\n  }\n}\n</code></pre>\n<h4 id=\"dsl-实现聚合小结\">DSL 实现聚合小结</h4>\n<p>aggs 代表聚合，与 query 同级，此时 query 的作用是？</p>\n<ul>\n<li>限定聚合的的文档范围</li>\n</ul>\n<p>聚合必须的三要素：</p>\n<ul>\n<li>聚合名称</li>\n<li>聚合类型</li>\n<li>聚合字段</li>\n</ul>\n<p>聚合可配置属性有：</p>\n<ul>\n<li>size：指定聚合结果数量</li>\n<li>order：指定聚合结果排序方式</li>\n<li>field：指定聚合字段</li>\n</ul>\n<h3 id=\"rest-client-实现聚合\">Rest Client 实现聚合</h3>\n<h4 id=\"api-语法\">API 语法</h4>\n<p>聚合条件与 query 条件同级别，因此需要使用 <code>request.source()</code> 来指定聚合条件。</p>\n<p>聚合条件的语法：</p>\n<pre><code class=\"hljs language-java\">request.<span class=\"hljs-keyword\">source</span>().<span class=\"hljs-keyword\">size</span>(<span class=\"hljs-number\">0</span>);\nrequest.<span class=\"hljs-keyword\">source</span>().aggregation(\n    AggregationBuilders\n    .terms(<span class=\"hljs-string\">&quot;brand_agg&quot;</span>)\n    .field(<span class=\"hljs-string\">&quot;brand&quot;</span>)\n    .<span class=\"hljs-keyword\">size</span>(<span class=\"hljs-number\">20</span>)\n);\n</code></pre>\n<p>聚合的结果也与查询结果不同，API 也比较特殊。不过同样是 JSON 逐层解析：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">4</span>. 解析结果\n<span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">4.1</span> 获取 aggregations\nAggregations aggregations = response.getAggregations();\n<span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">4.2</span> 根据名称获取聚合结果\nTerms brandTerms = aggregations.get(<span class=\"hljs-string\">&quot;brandAgg&quot;</span>);\n<span class=\"hljs-regexp\">//</span> <span class=\"hljs-number\">4.3</span> 获取 buckets 并遍历\n<span class=\"hljs-keyword\">for</span> (Terms.Bucket bucket : brandTerms.getBuckets()) {\n    <span class=\"hljs-regexp\">//</span> 获取 key\n    String key = bucket.getKeyAsString();\n    System.out.println(key);\n}\n</code></pre>\n<h4 id=\"业务需求\">业务需求</h4>\n<p>需求：搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的</p>\n<p>分析：目前，页面的城市列表、星级列表、品牌列表都是写死的，并不会随着搜索结果的变化而变化。但是用户搜索条件改变时，搜索结果会跟着变化。</p>\n<p>例如：用户搜索“东方明珠”，那搜索的酒店肯定是在上海东方明珠附近，因此，城市只能是上海，此时城市列表中就不应该显示北京、深圳、杭州这些信息了。也就是说，搜索结果中包含哪些城市，页面就应该列出哪些城市；搜索结果中包含哪些品牌，页面就应该列出哪些品牌。</p>\n<p>如何得知搜索结果中包含哪些品牌？如何得知搜索结果中包含哪些城市？</p>\n<p>使用聚合功能，利用 Bucket 聚合，对搜索结果中的文档基于品牌分组、基于城市分组，就能得知包含哪些品牌、哪些城市了。</p>\n<p>因为是对搜索结果聚合，因此聚合是限定范围的聚合，也就是说聚合的限定条件跟搜索文档的条件一致。</p>\n<p>返回结果是一个 Map 结构：</p>\n<ul>\n<li>key 是字符串，城市、星级、品牌、价格</li>\n<li>value 是集合，例如多个城市的名称</li>\n</ul>\n<h4 id=\"业务实现\">业务实现</h4>\n<p>在 <code>cn.itcast.hotel.web</code> 包的 <code>HotelController</code> 中添加一个方法，遵循下面的要求：</p>\n<ul>\n<li>请求方式：<code>POST</code></li>\n<li>请求路径：<code>/hotel/filters</code></li>\n<li>请求参数：<code>RequestParams</code>，与搜索文档的参数一致</li>\n<li>返回值类型：<code>Map&lt;String, List&lt;String&gt;&gt;</code></li>\n</ul>\n<p>代码：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-variable\">@PostMapping</span>(<span class=\"hljs-string\">&quot;filters&quot;</span>)\npublic Map&lt;String, List&lt;String&gt;&gt; getFilters(<span class=\"hljs-variable\">@RequestBody</span> RequestParams params){\n    <span class=\"hljs-selector-tag\">return</span> <span class=\"hljs-selector-tag\">hotelService</span><span class=\"hljs-selector-class\">.getFilters</span>(params);\n}\n</code></pre>\n<p>这里调用了 IHotelService 中的 getFilters 方法，尚未实现。</p>\n<p>在 <code>cn.itcast.hotel.service.IHotelService</code> 中定义新方法：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-built_in\">Map</span>&lt;<span class=\"hljs-built_in\">String</span>, <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">String</span>&gt;&gt; filters(RequestParams <span class=\"hljs-keyword\">params</span>);\n</code></pre>\n<p>在 <code>cn.itcast.hotel.service.impl.HotelService</code> 中实现该方法：</p>\n<pre><code class=\"hljs language-java\">@Override\n<span class=\"hljs-keyword\">public</span> Map&lt;<span class=\"hljs-keyword\">String</span>, List&lt;<span class=\"hljs-keyword\">String</span>&gt;&gt; getFilters(RequestParams params) {\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-comment\">// 1. 准备 request</span>\n        SearchRequest request = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">SearchRequest</span>(<span class=\"hljs-string\">&quot;hotel&quot;</span>);\n\n        <span class=\"hljs-comment\">// 2. 准备 DSL</span>\n        <span class=\"hljs-comment\">// query</span>\n        FunctionScoreQueryBuilder query = getQueryBuilder(params);\n        request.source().highlighter(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">HighlightBuilder</span>().field(<span class=\"hljs-string\">&quot;name&quot;</span>).requireFieldMatch(<span class=\"hljs-literal\">false</span>));\n        request.source().query(query);\n        <span class=\"hljs-comment\">// 2.1 设置 size = 0</span>\n        request.source().size(<span class=\"hljs-number\">0</span>);\n        <span class=\"hljs-comment\">// 2.2 聚合</span>\n        HashMap&lt;<span class=\"hljs-keyword\">String</span>, <span class=\"hljs-keyword\">String</span>&gt; items = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">HashMap</span>&lt;&gt;();\n        items.put(<span class=\"hljs-string\">&quot;brand&quot;</span>, <span class=\"hljs-string\">&quot;品牌&quot;</span>);\n        items.put(<span class=\"hljs-string\">&quot;city&quot;</span>, <span class=\"hljs-string\">&quot;城市&quot;</span>);\n        items.put(<span class=\"hljs-string\">&quot;starName&quot;</span>, <span class=\"hljs-string\">&quot;星级&quot;</span>);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">String</span> item : <span class=\"hljs-type\">items</span>.keySet()) {\n            request.source().aggregation(AggregationBuilders\n                                         .terms(item + <span class=\"hljs-string\">&quot;Agg&quot;</span>)\n                                         .field(item)\n                                         .size(<span class=\"hljs-number\">100</span>));\n        }\n        <span class=\"hljs-comment\">// 3. 发出请求</span>\n        SearchResponse response = <span class=\"hljs-literal\">null</span>;\n\n        response = client.search(request, RequestOptions.DEFAULT);\n\n\n        <span class=\"hljs-comment\">// 4. 解析结果</span>\n        <span class=\"hljs-comment\">// 4.1 获取 aggregations</span>\n        Aggregations aggregations = response.getAggregations();\n\n        HashMap&lt;<span class=\"hljs-keyword\">String</span>, List&lt;<span class=\"hljs-keyword\">String</span>&gt;&gt; itemListHashMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">HashMap</span>&lt;&gt;();\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">String</span> item : <span class=\"hljs-type\">items</span>.keySet()) {\n            <span class=\"hljs-comment\">// 4.2 根据名称获取聚合结果</span>\n            Terms brandTerms = aggregations.<span class=\"hljs-keyword\">get</span>(item + <span class=\"hljs-string\">&quot;Agg&quot;</span>);\n            <span class=\"hljs-comment\">// 4.3 获取 buckets 并遍历</span>\n            ArrayList&lt;<span class=\"hljs-keyword\">String</span>&gt; itemList = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">ArrayList</span>&lt;&gt;();\n            <span class=\"hljs-keyword\">for</span> (Terms.Bucket bucket : <span class=\"hljs-type\">brandTerms</span>.getBuckets()) {\n                <span class=\"hljs-comment\">// 获取 key</span>\n                itemList.add(bucket.getKeyAsString());\n            }\n            itemListHashMap.put(item, itemList);\n        }\n        <span class=\"hljs-keyword\">return</span> itemListHashMap;\n    } <span class=\"hljs-keyword\">catch</span> (IOException e) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">RuntimeException</span>(e);\n    }\n}\n</code></pre>\n<h2 id=\"自动补全\">自动补全</h2>\n<p>当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。</p>\n<p>因为需要根据拼音字母来推断，因此要用到拼音分词功能。</p>\n<h3 id=\"拼音分词器\">拼音分词器</h3>\n<p>要实现根据字母做补全，就必须对文档按照拼音分词。在 GitHub 上有 ElasticSearch的拼音分词插件。地址：<a href=\"https://github.com/medcl/elasticsearch-analysis-pinyin\">https://github.com/medcl/elasticsearch-analysis-pinyin</a></p>\n<p>安装方式与 IK 分词器一样，分三步：</p>\n<ol>\n<li>解压</li>\n<li>上传到虚拟机中，ElasticSearch 的 plugin 目录</li>\n<li>重启 ElasticSearch</li>\n<li>测试</li>\n</ol>\n<p>详细安装步骤可以参考 IK 分词器的安装过程。</p>\n<p>测试用法如下：</p>\n<pre><code class=\"hljs language-json\">POST /<span class=\"hljs-title class_\">_analyze</span>\n<span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-string\">&quot;text&quot;</span>: <span class=\"hljs-string\">&quot;如家酒店还不错&quot;</span>,\n  <span class=\"hljs-string\">&quot;analyzer&quot;</span>: <span class=\"hljs-string\">&quot;pinyin&quot;</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>结果如下：</p>\n<pre><code class=\"hljs language-json\">{\n  <span class=\"hljs-string\">&quot;tokens&quot;</span> : [\n    {\n      <span class=\"hljs-string\">&quot;token&quot;</span> : &quot;<span class=\"hljs-type\">ru</span><span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>word<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 0\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>rjjdhbc<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>word<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 0\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>jia<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>word<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 1\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>jiu<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>word<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 2\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>dian<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>word<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 3\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>hai<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>word<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 4\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>bu<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>word<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 5\n    },\n    {\n      &quot;</span>token<span class=\"hljs-string\">&quot; : &quot;</span>cuo<span class=\"hljs-string\">&quot;,\n      &quot;</span>start_offset<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span>end_offset<span class=\"hljs-string\">&quot; : 0,\n      &quot;</span><span class=\"hljs-keyword\">type</span><span class=\"hljs-string\">&quot; : &quot;</span>word<span class=\"hljs-string\">&quot;,\n      &quot;</span>position<span class=\"hljs-string\">&quot; : 6\n    }\n  ]\n}</span>\n</code></pre>\n<h3 id=\"自定义分词器\">自定义分词器</h3>\n<p>默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。</p>\n<p>ElasticSearch 中分词器（analyzer）的组成包含三部分：</p>\n<ul>\n<li>character filters：在 tokenizer 之前对文本进行处理。例如删除字符、替换字符</li>\n<li>tokenizer：将文本按照一定的规则切割成词条（term）。例如 keyword，就是不分词；还有 ik_smart</li>\n<li>tokenizer filter：将 tokenizer 输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等</li>\n</ul>\n<p>声明自定义分词器的语法如下：</p>\n<pre><code class=\"hljs language-json\">PUT /<span class=\"hljs-built_in\">test</span>\n{\n  <span class=\"hljs-string\">&quot;settings&quot;</span>: {\n    <span class=\"hljs-string\">&quot;analysis&quot;</span>: {\n      <span class=\"hljs-string\">&quot;analyzer&quot;</span>: {\n        <span class=\"hljs-string\">&quot;my_analyzer&quot;</span>: {\n          <span class=\"hljs-string\">&quot;tokenizer&quot;</span>: <span class=\"hljs-string\">&quot;ik_max_word&quot;</span>,\n          <span class=\"hljs-string\">&quot;filter&quot;</span>: <span class=\"hljs-string\">&quot;py&quot;</span>\n        }\n      },\n      <span class=\"hljs-string\">&quot;filter&quot;</span>: {\n        <span class=\"hljs-string\">&quot;py&quot;</span>: {\n          <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;pinyin&quot;</span>,\n          <span class=\"hljs-string\">&quot;keep_full_pinyin&quot;</span>: <span class=\"hljs-literal\">false</span>,\n          <span class=\"hljs-string\">&quot;keep_joined_full_pinyin&quot;</span>: <span class=\"hljs-literal\">true</span>,\n          <span class=\"hljs-string\">&quot;keep_original&quot;</span>: <span class=\"hljs-literal\">true</span>,\n          <span class=\"hljs-string\">&quot;limit_first_letter_length&quot;</span>: 16,\n          <span class=\"hljs-string\">&quot;remove_duplicated_term&quot;</span>: <span class=\"hljs-literal\">true</span>,\n          <span class=\"hljs-string\">&quot;none_chinese_pinyin_tokenize&quot;</span>: <span class=\"hljs-literal\">false</span>\n        }\n      }\n    }\n  },\n  <span class=\"hljs-string\">&quot;mappings&quot;</span>: {\n    <span class=\"hljs-string\">&quot;properties&quot;</span>: {\n      <span class=\"hljs-string\">&quot;name&quot;</span>: {\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;text&quot;</span>,\n        <span class=\"hljs-string\">&quot;analyzer&quot;</span>: <span class=\"hljs-string\">&quot;my_analyzer&quot;</span>,\n        <span class=\"hljs-string\">&quot;search_analyzer&quot;</span>: <span class=\"hljs-string\">&quot;ik_smart&quot;</span>\n      }\n    }\n  }\n}\n</code></pre>\n<p>总结：</p>\n<p>如何使用拼音分词器？</p>\n<ul>\n<li><p>下载 pinyin 分词器</p>\n</li>\n<li><p>解压并放到 ElasticSearch 的 plugin 目录</p>\n</li>\n<li><p>重启即可</p>\n</li>\n</ul>\n<p>如何自定义分词器？</p>\n<ul>\n<li>创建索引库时，在 settings 中配置，可以包含三部分：character filter、tokenizer、filter</li>\n</ul>\n<p>拼音分词器注意事项？</p>\n<ul>\n<li>为了避免搜索到同音字，搜索时不要使用拼音分词器</li>\n</ul>\n<h3 id=\"自动补全查询\">自动补全查询</h3>\n<p>ElasticSearch 提供了 <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html\">Completion Suggester</a> 查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：</p>\n<ul>\n<li><p>参与补全查询的字段必须是 completion 类型。</p>\n</li>\n<li><p>字段的内容一般是用来补全的多个词条形成的数组。</p>\n</li>\n</ul>\n<p>比如，一个这样的索引库：</p>\n<pre><code class=\"hljs language-json\">PUT /<span class=\"hljs-title class_\">test2</span>\n<span class=\"hljs-punctuation\">{</span>\n  <span class=\"hljs-string\">&quot;mappings&quot;</span>: <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-string\">&quot;properties&quot;</span>: <span class=\"hljs-punctuation\">{</span>\n      <span class=\"hljs-string\">&quot;title&quot;</span>:<span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;completion&quot;</span>\n      <span class=\"hljs-punctuation\">}</span>\n    <span class=\"hljs-punctuation\">}</span>\n  <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n</code></pre>\n<p>然后插入下面的数据：</p>\n<pre><code class=\"hljs language-json\">POST <span class=\"hljs-regexp\">/test2/</span>_doc\n{\n  <span class=\"hljs-string\">&quot;title&quot;</span>: [<span class=\"hljs-string\">&quot;Sony&quot;</span>, <span class=\"hljs-string\">&quot;WH-1000XM3&quot;</span>]\n}\nPOST <span class=\"hljs-regexp\">/test2/</span>_doc\n{\n  <span class=\"hljs-string\">&quot;title&quot;</span>: [<span class=\"hljs-string\">&quot;SK-II&quot;</span>, <span class=\"hljs-string\">&quot;PITERA&quot;</span>]\n}\nPOST <span class=\"hljs-regexp\">/test2/</span>_doc\n{\n  <span class=\"hljs-string\">&quot;title&quot;</span>: [<span class=\"hljs-string\">&quot;Nintendo&quot;</span>, <span class=\"hljs-string\">&quot;switch&quot;</span>]\n}\n</code></pre>\n<p>查询的 DSL 语句如下：</p>\n<pre><code class=\"hljs language-json\">POST <span class=\"hljs-regexp\">/test2/</span>_search\n{\n  <span class=\"hljs-string\">&quot;suggest&quot;</span>: {\n    <span class=\"hljs-string\">&quot;title_suggest&quot;</span>: {\n      <span class=\"hljs-string\">&quot;text&quot;</span>: <span class=\"hljs-string\">&quot;s&quot;</span>, \n      <span class=\"hljs-string\">&quot;completion&quot;</span>: {\n        <span class=\"hljs-string\">&quot;field&quot;</span>: <span class=\"hljs-string\">&quot;title&quot;</span>, \n        <span class=\"hljs-string\">&quot;skip_duplicates&quot;</span>: <span class=\"hljs-keyword\">true</span>, \n        <span class=\"hljs-string\">&quot;size&quot;</span>: <span class=\"hljs-number\">10</span> \n      }\n    }\n  }\n}\n</code></pre>\n<h3 id=\"实现酒店搜索框自动补全\">实现酒店搜索框自动补全</h3>\n<p>现在，我们的 hotel 索引库还没有设置拼音分词器，需要修改索引库中的配置。但是我们知道索引库是无法修改的，只能删除然后重新创建。</p>\n<p>另外，我们需要添加一个字段，用来做自动补全，将 brand、suggestion、city 等都放进去，作为自动补全的提示。</p>\n<p>因此，总结一下，我们需要做的事情包括：</p>\n<ol>\n<li><p>修改 hotel 索引库结构，设置自定义拼音分词器</p>\n</li>\n<li><p>修改索引库的 name、all 字段，使用自定义分词器</p>\n</li>\n<li><p>索引库添加一个新字段 suggestion，类型为 completion 类型，使用自定义的分词器</p>\n</li>\n<li><p>给 HotelDoc 类添加 suggestion 字段，内容包含 brand、business</p>\n</li>\n<li><p>重新导入数据到 hotel 库</p>\n</li>\n</ol>\n<h4 id=\"修改酒店映射结构\">修改酒店映射结构</h4>\n<p>代码如下：</p>\n<pre><code class=\"hljs language-json\"><span class=\"hljs-string\">//</span> 酒店数据索引库\nPUT <span class=\"hljs-string\">/hotel</span>\n{\n  <span class=\"hljs-string\">&quot;settings&quot;</span>: {\n    <span class=\"hljs-string\">&quot;analysis&quot;</span>: {\n      <span class=\"hljs-string\">&quot;analyzer&quot;</span>: {\n        <span class=\"hljs-string\">&quot;text_anlyzer&quot;</span>: {\n          <span class=\"hljs-string\">&quot;tokenizer&quot;</span>: <span class=\"hljs-string\">&quot;ik_max_word&quot;</span>,\n          <span class=\"hljs-string\">&quot;filter&quot;</span>: <span class=\"hljs-string\">&quot;py&quot;</span>\n        },\n        <span class=\"hljs-string\">&quot;completion_analyzer&quot;</span>: {\n          <span class=\"hljs-string\">&quot;tokenizer&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>,\n          <span class=\"hljs-string\">&quot;filter&quot;</span>: <span class=\"hljs-string\">&quot;py&quot;</span>\n        }\n      },\n      <span class=\"hljs-string\">&quot;filter&quot;</span>: {\n        <span class=\"hljs-string\">&quot;py&quot;</span>: {\n          <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;pinyin&quot;</span>,\n          <span class=\"hljs-string\">&quot;keep_full_pinyin&quot;</span>: <span class=\"hljs-literal\">false</span>,\n          <span class=\"hljs-string\">&quot;keep_joined_full_pinyin&quot;</span>: <span class=\"hljs-literal\">true</span>,\n          <span class=\"hljs-string\">&quot;keep_original&quot;</span>: <span class=\"hljs-literal\">true</span>,\n          <span class=\"hljs-string\">&quot;limit_first_letter_length&quot;</span>: 16,\n          <span class=\"hljs-string\">&quot;remove_duplicated_term&quot;</span>: <span class=\"hljs-literal\">true</span>,\n          <span class=\"hljs-string\">&quot;none_chinese_pinyin_tokenize&quot;</span>: <span class=\"hljs-literal\">false</span>\n        }\n      }\n    }\n  },\n  <span class=\"hljs-string\">&quot;mappings&quot;</span>: {\n    <span class=\"hljs-string\">&quot;properties&quot;</span>: {\n      <span class=\"hljs-string\">&quot;id&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;name&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;text&quot;</span>,\n        <span class=\"hljs-string\">&quot;analyzer&quot;</span>: <span class=\"hljs-string\">&quot;text_anlyzer&quot;</span>,\n        <span class=\"hljs-string\">&quot;search_analyzer&quot;</span>: <span class=\"hljs-string\">&quot;ik_smart&quot;</span>,\n        <span class=\"hljs-string\">&quot;copy_to&quot;</span>: <span class=\"hljs-string\">&quot;all&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;address&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>,\n        <span class=\"hljs-string\">&quot;index&quot;</span>: <span class=\"hljs-literal\">false</span>\n      },\n      <span class=\"hljs-string\">&quot;price&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;integer&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;score&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;integer&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;brand&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>,\n        <span class=\"hljs-string\">&quot;copy_to&quot;</span>: <span class=\"hljs-string\">&quot;all&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;city&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;starName&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;business&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>,\n        <span class=\"hljs-string\">&quot;copy_to&quot;</span>: <span class=\"hljs-string\">&quot;all&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;location&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;geo_point&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;pic&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;keyword&quot;</span>,\n        <span class=\"hljs-string\">&quot;index&quot;</span>: <span class=\"hljs-literal\">false</span>\n      },\n      <span class=\"hljs-string\">&quot;all&quot;</span>:{\n        <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;text&quot;</span>,\n        <span class=\"hljs-string\">&quot;analyzer&quot;</span>: <span class=\"hljs-string\">&quot;text_anlyzer&quot;</span>,\n        <span class=\"hljs-string\">&quot;search_analyzer&quot;</span>: <span class=\"hljs-string\">&quot;ik_smart&quot;</span>\n      },\n      <span class=\"hljs-string\">&quot;suggestion&quot;</span>:{\n          <span class=\"hljs-string\">&quot;type&quot;</span>: <span class=\"hljs-string\">&quot;completion&quot;</span>,\n          <span class=\"hljs-string\">&quot;analyzer&quot;</span>: <span class=\"hljs-string\">&quot;completion_analyzer&quot;</span>\n      }\n    }\n  }\n}\n</code></pre>\n<h4 id=\"修改-hoteldoc-实体-1\">修改 HotelDoc 实体</h4>\n<p>HotelDoc 中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。</p>\n<p>因此我们在 HotelDoc 中添加一个 suggestion 字段，类型为 <code>List&lt;String&gt;</code>，然后将 brand、city、business 等信息放到里面。</p>\n<p>代码如下：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Data</span>\n<span class=\"hljs-meta\">@NoArgsConstructor</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HotelDoc</span> </span>{\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">Long</span> id;\n    <span class=\"hljs-keyword\">private</span> String name;\n    <span class=\"hljs-keyword\">private</span> String address;\n    <span class=\"hljs-keyword\">private</span> Integer price;\n    <span class=\"hljs-keyword\">private</span> Integer score;\n    <span class=\"hljs-keyword\">private</span> String brand;\n    <span class=\"hljs-keyword\">private</span> String city;\n    <span class=\"hljs-keyword\">private</span> String starName;\n    <span class=\"hljs-keyword\">private</span> String business;\n    <span class=\"hljs-keyword\">private</span> String location;\n    <span class=\"hljs-keyword\">private</span> String pic;\n    <span class=\"hljs-keyword\">private</span> Object distance;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-built_in\">Boolean</span> isAD;\n    <span class=\"hljs-keyword\">private</span> List&lt;String&gt; suggestion;\n\n    <span class=\"hljs-keyword\">public</span> HotelDoc(Hotel hotel) {\n        <span class=\"hljs-keyword\">this</span>.id = hotel.getId();\n        <span class=\"hljs-keyword\">this</span>.name = hotel.getName();\n        <span class=\"hljs-keyword\">this</span>.address = hotel.getAddress();\n        <span class=\"hljs-keyword\">this</span>.price = hotel.getPrice();\n        <span class=\"hljs-keyword\">this</span>.score = hotel.getScore();\n        <span class=\"hljs-keyword\">this</span>.brand = hotel.getBrand();\n        <span class=\"hljs-keyword\">this</span>.city = hotel.getCity();\n        <span class=\"hljs-keyword\">this</span>.starName = hotel.getStarName();\n        <span class=\"hljs-keyword\">this</span>.business = hotel.getBusiness();\n        <span class=\"hljs-keyword\">this</span>.location = hotel.getLatitude() + <span class=\"hljs-string\">&quot;, &quot;</span> + hotel.getLongitude();\n        <span class=\"hljs-keyword\">this</span>.pic = hotel.getPic();\n        <span class=\"hljs-comment\">// 组装suggestion</span>\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">this</span>.business.contains(<span class=\"hljs-string\">&quot;/&quot;</span>)) {\n            <span class=\"hljs-comment\">// business有多个值，需要切割</span>\n            String[] arr = <span class=\"hljs-keyword\">this</span>.business.split(<span class=\"hljs-string\">&quot;/&quot;</span>);\n            <span class=\"hljs-comment\">// 添加元素</span>\n            <span class=\"hljs-keyword\">this</span>.suggestion = new ArrayList&lt;&gt;();\n            <span class=\"hljs-keyword\">this</span>.suggestion.add(<span class=\"hljs-keyword\">this</span>.brand);\n            Collections.addAll(<span class=\"hljs-keyword\">this</span>.suggestion, arr);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">this</span>.suggestion = Arrays.asList(<span class=\"hljs-keyword\">this</span>.brand, <span class=\"hljs-keyword\">this</span>.business);\n        }\n    }\n}\n</code></pre>\n<h4 id=\"重新导入并测试\">重新导入并测试</h4>\n<p>重新执行之前编写的导入数据功能 <code>testBulkRequest()</code>，并搜索测试</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match_all&quot;</span>: {}\n  }\n}\n</code></pre>\n<p>可以看到新的酒店数据中包含了 suggestion，接下来测试自动补全功能</p>\n<pre><code class=\"hljs language-json\">GET <span class=\"hljs-regexp\">/hotel/</span>_search\n{\n  <span class=\"hljs-string\">&quot;suggest&quot;</span>: {\n    <span class=\"hljs-string\">&quot;suggestions&quot;</span>: {\n      <span class=\"hljs-string\">&quot;text&quot;</span>: <span class=\"hljs-string\">&quot;sd&quot;</span>,\n      <span class=\"hljs-string\">&quot;completion&quot;</span>: {\n        <span class=\"hljs-string\">&quot;field&quot;</span>: <span class=\"hljs-string\">&quot;suggestion&quot;</span>,\n        <span class=\"hljs-string\">&quot;skip_duplicates&quot;</span>: <span class=\"hljs-keyword\">true</span>, \n        <span class=\"hljs-string\">&quot;size&quot;</span>: <span class=\"hljs-number\">10</span> \n      }\n    }\n  }\n}\n</code></pre>\n<h4 id=\"自动补全查询的-java-api\">自动补全查询的 Java API</h4>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// 1.准备请求</span>\nSearchRequest request = <span class=\"hljs-keyword\">new</span> SearchRequest(<span class=\"hljs-string\">&quot;hotel&quot;</span>);\n<span class=\"hljs-comment\">// 2.请求参数</span>\nrequest.<span class=\"hljs-keyword\">source</span>().suggest(<span class=\"hljs-keyword\">new</span> SuggestBuilder().addSuggestion(\n    <span class=\"hljs-string\">&quot;mySuggestion&quot;</span>,\n    SuggestBuilders\n    .completionSuggestion(<span class=\"hljs-string\">&quot;title&quot;</span>)\n    .prefix(<span class=\"hljs-string\">&quot;h&quot;</span>)\n    .skipDuplicates(<span class=\"hljs-keyword\">true</span>)\n    .<span class=\"hljs-keyword\">size</span>(<span class=\"hljs-number\">10</span>)\n));\n<span class=\"hljs-comment\">// 3.发送请求</span>\nclient.search(request, RequestOptions.<span class=\"hljs-keyword\">DEFAULT</span>);\n</code></pre>\n<p>而自动补全的结果也比较特殊，解析的代码如下：</p>\n<pre><code class=\"hljs language-java\">// <span class=\"hljs-number\">4.</span>处理结果\nSuggest suggest = response.getSuggest();\n// <span class=\"hljs-number\">4.1</span>.根据名称获取补全结果\nCompletionSuggestion suggestion = suggest.getSuggestion(&quot;mySuggestion&quot;);\n// <span class=\"hljs-number\">4.2</span>.获取<span class=\"hljs-keyword\">options</span>并遍历\n<span class=\"hljs-keyword\">for</span> (CompletionSuggestion.Entry.<span class=\"hljs-keyword\">Option</span> <span class=\"hljs-keyword\">option</span> : suggestion.getOptions()) {\n    // <span class=\"hljs-number\">4.3</span>.获取一个<span class=\"hljs-keyword\">option</span>中的<span class=\"hljs-type\">text</span>，也就是补全的词条\n    String <span class=\"hljs-type\">text</span> = <span class=\"hljs-keyword\">option</span>.getText().string();\n    <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-type\">text</span>);\n}\n</code></pre>\n<h4 id=\"实现搜索框自动补全\">实现搜索框自动补全</h4>\n<p>在 <code>cn.itcast.hotel.web</code> 包下的 <code>HotelController</code> 中添加新接口，接收新的请求：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-variable\">@GetMapping</span>(<span class=\"hljs-string\">&quot;suggestion&quot;</span>)\npublic List&lt;String&gt; getSuggestions(<span class=\"hljs-variable\">@RequestParam</span>(<span class=\"hljs-string\">&quot;key&quot;</span>) String prefix) {\n    <span class=\"hljs-selector-tag\">return</span> <span class=\"hljs-selector-tag\">hotelService</span><span class=\"hljs-selector-class\">.getSuggestions</span>(prefix);\n}\n</code></pre>\n<p>在 <code>cn.itcast.hotel.service</code> 包下的 <code>IhotelService</code> 中添加方法：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-function\">List&lt;<span class=\"hljs-type\">String</span>&gt; <span class=\"hljs-title\">getSuggestions</span><span class=\"hljs-params\">(<span class=\"hljs-type\">String</span> prefix)</span></span>;\n</code></pre>\n<p>在 <code>cn.itcast.hotel.service.impl.HotelService</code> 中实现该方法：</p>\n<pre><code class=\"hljs language-java\">@Override\n<span class=\"hljs-keyword\">public</span> List&lt;<span class=\"hljs-keyword\">String</span>&gt; getSuggestions(<span class=\"hljs-keyword\">String</span> prefix) {\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-comment\">// 1.准备请求</span>\n        SearchRequest request = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">SearchRequest</span>(<span class=\"hljs-string\">&quot;hotel&quot;</span>);\n        <span class=\"hljs-comment\">// 2.请求参数</span>\n        request.source().suggest(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">SuggestBuilder</span>().addSuggestion(\n            <span class=\"hljs-string\">&quot;suggestions&quot;</span>,\n            SuggestBuilders\n            .completionSuggestion(<span class=\"hljs-string\">&quot;suggestion&quot;</span>)\n            .prefix(prefix)\n            .skipDuplicates(<span class=\"hljs-literal\">true</span>)\n            .size(<span class=\"hljs-number\">10</span>)\n        ));\n        <span class=\"hljs-comment\">// 3.发送请求</span>\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n        <span class=\"hljs-comment\">// 4.处理结果</span>\n        Suggest suggest = response.getSuggest();\n        <span class=\"hljs-comment\">// 4.1.根据名称获取补全结果</span>\n        CompletionSuggestion suggestion = suggest.getSuggestion(<span class=\"hljs-string\">&quot;suggestions&quot;</span>);\n        <span class=\"hljs-comment\">// 4.2.获取options并遍历</span>\n        ArrayList&lt;<span class=\"hljs-keyword\">String</span>&gt; result = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">ArrayList</span>&lt;&gt;();\n        <span class=\"hljs-keyword\">for</span> (CompletionSuggestion.Entry.Option option : <span class=\"hljs-type\">suggestion</span>.getOptions()) {\n            <span class=\"hljs-comment\">// 4.3.获取一个option中的text，也就是补全的词条</span>\n            <span class=\"hljs-keyword\">String</span> text = option.getText().string();\n            result.add(text);\n        }\n        <span class=\"hljs-keyword\">return</span> result;\n    } <span class=\"hljs-keyword\">catch</span> (IOException e) {\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">RuntimeException</span>(e);\n    }\n}\n</code></pre>\n<h2 id=\"数据同步\">数据同步</h2>\n<p>ElasticSearch 中的酒店数据来自于 MySQL 数据库，因此 MySQL 数据发生改变时，ElasticSearch 也必须跟着改变，这个就是 ElasticSearch 与 MySQL 之间的数据同步。</p>\n<h3 id=\"思路分析\">思路分析</h3>\n<p>常见的数据同步方案有三种：</p>\n<ul>\n<li>同步调用</li>\n<li>异步通知</li>\n<li>监听 binlog</li>\n</ul>\n<h4 id=\"同步调用\">同步调用</h4>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E5%90%8C%E6%AD%A5%E8%B0%83%E7%94%A8.i2rj0d3cpwg.svg\" alt=\"同步调用\"></p>\n<p>基本步骤如下：</p>\n<ul>\n<li>hotel-demo 对外提供接口，用来修改 ElasticSearch 中的数据</li>\n<li>酒店管理服务在完成数据库操作后，直接调用 hotel-demo 提供的接口</li>\n</ul>\n<h4 id=\"异步通知\">异步通知</h4>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E5%BC%82%E6%AD%A5%E9%80%9A%E7%9F%A5.1p2ptlc5nrs0.svg\" alt=\"异步通知\"></p>\n<p>流程如下：</p>\n<ul>\n<li>hotel-admin 对 MySQL 数据库数据完成增、删、改后，发送 MQ 消息</li>\n<li>hotel-demo 监听 MQ，接收到消息后完成 ElasticSearch 数据修改</li>\n</ul>\n<h4 id=\"监听-binlog\">监听 binlog</h4>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E7%9B%91%E5%90%ACbinlog.1n6hcbad4pb4.svg\" alt=\"监听binlog\"></p>\n<p>流程如下：</p>\n<ul>\n<li>给 MySQL 开启 binlog 功能</li>\n<li>MySQL 完成增、删、改操作都会记录在 binlog 中</li>\n<li>hotel-demo 基于 canal 监听 binlog 变化，实时更新 ElasticSearch 中的内容</li>\n</ul>\n<h4 id=\"不同数据同步方案优缺点\">不同数据同步方案优缺点</h4>\n<p>方式一：同步调用</p>\n<ul>\n<li>优点：实现简单，粗暴</li>\n<li>缺点：业务耦合度高</li>\n</ul>\n<p>方式二：异步通知</p>\n<ul>\n<li>优点：低耦合，实现难度一般</li>\n<li>缺点：依赖 MQ 的可靠性</li>\n</ul>\n<p>方式三：监听 binlog</p>\n<ul>\n<li>优点：完全解除服务间耦合</li>\n<li>缺点：开启 binlog 增加数据库负担、实现复杂度高</li>\n</ul>\n<h3 id=\"实现数据同步\">实现数据同步</h3>\n<h4 id=\"基于-mq-的实现思路\">基于 MQ 的实现思路</h4>\n<p>利用提供的 hotel-admin 项目作为酒店管理的微服务。当酒店数据发生增、删、改时，要求对 ElasticSearch 中数据也要完成相同操作。</p>\n<p>步骤：</p>\n<ul>\n<li><p>导入 hotel-admin 项目，启动并测试酒店数据的 CRUD</p>\n</li>\n<li><p>声明 exchange、queue、RoutingKey</p>\n</li>\n<li><p>在 hotel-admin 中的增、删、改业务中完成消息发送</p>\n</li>\n<li><p>在 hotel-demo 中完成消息监听，并更新 ElasticSearch 中数据</p>\n</li>\n<li><p>启动并测试数据同步功能</p>\n</li>\n</ul>\n<h3 id=\"导入-demo\">导入 demo</h3>\n<p>代码链接：<a href=\"https://github.com/Lanqilu/HaloElasticSearch/commit/b9d7c724b44d6ea8e307ac5d54778bba635bd314\">GitHub</a></p>\n<p>运行后，访问 <a href=\"http://localhost:8099\">http://localhost:8099</a></p>\n<h3 id=\"声明交换机、队列\">声明交换机、队列</h3>\n<p>MQ 结构如图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/MQ%E7%BB%93%E6%9E%84.lv1ecla6gvk.svg\" alt=\"MQ结构\"></p>\n<h4 id=\"引入依赖并修改配置文件\">引入依赖并修改配置文件</h4>\n<p>在 hotel-admin、hotel-demo 中引入 rabbitmq 的依赖：</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-comment\">&lt;!--amqp--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">rabbitmq:</span>\n    <span class=\"hljs-attr\">host:</span> <span class=\"hljs-string\">rabbitmq</span>\n    <span class=\"hljs-attr\">port:</span> <span class=\"hljs-number\">5672</span>\n    <span class=\"hljs-attr\">username:</span> <span class=\"hljs-string\">halo</span>\n    <span class=\"hljs-attr\">password:</span> <span class=\"hljs-string\">halo</span>\n    <span class=\"hljs-attr\">virtual-host:</span> <span class=\"hljs-string\">/</span>\n</code></pre>\n<h4 id=\"声明交换机、队列-1\">声明交换机、队列</h4>\n<p>在 hotel-admin 和 hotel-demo 中的 <code>cn.itcast.hotel.constatnts</code> 包下新建一个类 <code>MqConstants</code>：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MqConstants</span> {\n    <span class=\"hljs-comment\">/**\n     * 交换机\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">String</span> HOTEL_EXCHANGE = <span class=\"hljs-string\">&quot;hotel.topic&quot;</span>;\n    <span class=\"hljs-comment\">/**\n     * 监听新增和修改的队列\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">String</span> HOTEL_INSERT_QUEUE = <span class=\"hljs-string\">&quot;hotel.insert.queue&quot;</span>;\n    <span class=\"hljs-comment\">/**\n     * 监听删除的队列\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">String</span> HOTEL_DELETE_QUEUE = <span class=\"hljs-string\">&quot;hotel.delete.queue&quot;</span>;\n    <span class=\"hljs-comment\">/**\n     * 新增或修改的RoutingKey\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">String</span> HOTEL_INSERT_KEY = <span class=\"hljs-string\">&quot;hotel.insert&quot;</span>;\n    <span class=\"hljs-comment\">/**\n     * 删除的RoutingKey\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">String</span> HOTEL_DELETE_KEY = <span class=\"hljs-string\">&quot;hotel.delete&quot;</span>;\n}\n</code></pre>\n<p>在 hotel-demo 中，定义配置类，声明队列、交换机：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Configuration</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MqConfig</span> {\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">TopicExchange</span> <span class=\"hljs-title function_\">topicExchange</span>(<span class=\"hljs-params\"></span>){\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TopicExchange</span>(<span class=\"hljs-title class_\">MqConstants</span>.<span class=\"hljs-property\">HOTEL_EXCHANGE</span>, <span class=\"hljs-literal\">true</span>, <span class=\"hljs-literal\">false</span>);\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">Queue</span> <span class=\"hljs-title function_\">insertQueue</span>(<span class=\"hljs-params\"></span>){\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Queue</span>(<span class=\"hljs-title class_\">MqConstants</span>.<span class=\"hljs-property\">HOTEL_INSERT_QUEUE</span>, <span class=\"hljs-literal\">true</span>);\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">Queue</span> <span class=\"hljs-title function_\">deleteQueue</span>(<span class=\"hljs-params\"></span>){\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Queue</span>(<span class=\"hljs-title class_\">MqConstants</span>.<span class=\"hljs-property\">HOTEL_DELETE_QUEUE</span>, <span class=\"hljs-literal\">true</span>);\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">Binding</span> <span class=\"hljs-title function_\">insertQueueBinding</span>(<span class=\"hljs-params\"></span>){\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">BindingBuilder</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-title function_\">insertQueue</span>()).<span class=\"hljs-title function_\">to</span>(<span class=\"hljs-title function_\">topicExchange</span>()).<span class=\"hljs-title function_\">with</span>(<span class=\"hljs-title class_\">MqConstants</span>.<span class=\"hljs-property\">HOTEL_INSERT_KEY</span>);\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">Binding</span> <span class=\"hljs-title function_\">deleteQueueBinding</span>(<span class=\"hljs-params\"></span>){\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">BindingBuilder</span>.<span class=\"hljs-title function_\">bind</span>(<span class=\"hljs-title function_\">deleteQueue</span>()).<span class=\"hljs-title function_\">to</span>(<span class=\"hljs-title function_\">topicExchange</span>()).<span class=\"hljs-title function_\">with</span>(<span class=\"hljs-title class_\">MqConstants</span>.<span class=\"hljs-property\">HOTEL_DELETE_KEY</span>);\n    }\n}\n</code></pre>\n<h3 id=\"发送-mq-消息\">发送 MQ 消息</h3>\n<p>在 hotel-admin 中的增、删、改业务中分别发送 MQ 消息：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-variable\">@Autowired</span>\nprivate RabbitTemplate rabbitTemplate;\n\n<span class=\"hljs-variable\">@PostMapping</span>\npublic void saveHotel(<span class=\"hljs-variable\">@RequestBody</span> Hotel hotel){\n    <span class=\"hljs-selector-tag\">hotelService</span><span class=\"hljs-selector-class\">.save</span>(hotel);\n    <span class=\"hljs-selector-tag\">rabbitTemplate</span><span class=\"hljs-selector-class\">.convertAndSend</span>(MqConstants.HOTEL_EXCHANGE,MqConstants.HOTEL_INSERT_KEY,hotel.getId());\n}\n\n@<span class=\"hljs-selector-tag\">PutMapping</span>()\n<span class=\"hljs-selector-tag\">public</span> <span class=\"hljs-selector-tag\">void</span> <span class=\"hljs-selector-tag\">updateById</span>(<span class=\"hljs-variable\">@RequestBody</span> Hotel hotel){\n    <span class=\"hljs-selector-tag\">if</span> (hotel.getId() == null) {\n        <span class=\"hljs-selector-tag\">throw</span> <span class=\"hljs-selector-tag\">new</span> <span class=\"hljs-selector-tag\">InvalidParameterException</span>(<span class=\"hljs-string\">&quot;id不能为空&quot;</span>);\n    }\n    <span class=\"hljs-selector-tag\">hotelService</span><span class=\"hljs-selector-class\">.updateById</span>(hotel);\n    <span class=\"hljs-selector-tag\">rabbitTemplate</span><span class=\"hljs-selector-class\">.convertAndSend</span>(MqConstants.HOTEL_EXCHANGE,MqConstants.HOTEL_INSERT_KEY,hotel.getId());\n}\n\n@<span class=\"hljs-selector-tag\">DeleteMapping</span>(<span class=\"hljs-string\">&quot;/{id}&quot;</span>)\n<span class=\"hljs-selector-tag\">public</span> <span class=\"hljs-selector-tag\">void</span> <span class=\"hljs-selector-tag\">deleteById</span>(<span class=\"hljs-variable\">@PathVariable</span>(<span class=\"hljs-string\">&quot;id&quot;</span>) Long id) {\n    <span class=\"hljs-selector-tag\">hotelService</span><span class=\"hljs-selector-class\">.removeById</span>(id);\n    <span class=\"hljs-selector-tag\">rabbitTemplate</span><span class=\"hljs-selector-class\">.convertAndSend</span>(MqConstants.HOTEL_EXCHANGE,MqConstants.HOTEL_DELETE_KEY,id);\n}\n</code></pre>\n<h3 id=\"接收-mq-消息\">接收 MQ 消息</h3>\n<p>hotel-demo 接收到 MQ 消息要做的事情包括：</p>\n<ul>\n<li>新增消息：根据传递的 hotel 的 id 查询 hotel 信息，然后新增一条数据到索引库</li>\n<li>删除消息：根据传递的 hotel 的 id 删除索引库中的一条数据</li>\n</ul>\n<p>首先在 hotel-demo 的 <code>cn.itcast.hotel.service</code> 包下的 <code>IHotelService</code> 中新增新增、删除业务</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deleteById</span><span class=\"hljs-params\">(Long id)</span></span>;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">insertById</span><span class=\"hljs-params\">(Long id)</span></span>;\n</code></pre>\n<p>给 hotel-demo 中的 <code>cn.itcast.hotel.service.impl</code> 包下的 HotelService 中实现业务：</p>\n<pre><code class=\"hljs language-java\">@Override\npublic void delete<span class=\"hljs-constructor\">ById(Long <span class=\"hljs-params\">id</span>)</span> {\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-comment\">// 1.准备Request</span>\n        DeleteRequest request = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">DeleteRequest(<span class=\"hljs-string\">&quot;hotel&quot;</span>, <span class=\"hljs-params\">id</span>.<span class=\"hljs-params\">toString</span>()</span>);\n        <span class=\"hljs-comment\">// 2.发送请求</span>\n        client.delete(request, RequestOptions.DEFAULT);\n    } catch (IOException e) {\n        throw <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">RuntimeException(<span class=\"hljs-params\">e</span>)</span>;\n    }\n}\n\n@Override\npublic void insert<span class=\"hljs-constructor\">ById(Long <span class=\"hljs-params\">id</span>)</span> {\n    <span class=\"hljs-keyword\">try</span> {\n        <span class=\"hljs-comment\">// 0.根据id查询酒店数据</span>\n        Hotel hotel = get<span class=\"hljs-constructor\">ById(<span class=\"hljs-params\">id</span>)</span>;\n        <span class=\"hljs-comment\">// 转换为文档类型</span>\n        HotelDoc hotelDoc = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">HotelDoc(<span class=\"hljs-params\">hotel</span>)</span>;\n\n        <span class=\"hljs-comment\">// 1.准备Request对象</span>\n        IndexRequest request = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">IndexRequest(<span class=\"hljs-string\">&quot;hotel&quot;</span>)</span>.id(hotel.get<span class=\"hljs-constructor\">Id()</span>.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String()</span>);\n        <span class=\"hljs-comment\">// 2.准备Json文档</span>\n        request.source(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">JSON</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">JSONString(<span class=\"hljs-params\">hotelDoc</span>)</span>, XContentType.JSON);\n        <span class=\"hljs-comment\">// 3.发送请求</span>\n        client.index(request, RequestOptions.DEFAULT);\n    } catch (IOException e) {\n        throw <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">RuntimeException(<span class=\"hljs-params\">e</span>)</span>;\n    }\n}\n</code></pre>\n<p>编写监听器，在 hotel-demo 中的 <code>cn.itcast.hotel.mq</code> 包新增一个类：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HotelListener</span> {\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> IHotelService hotelService;\n\n    <span class=\"hljs-comment\">/**\n     * 监听酒店新增或修改的业务\n     * <span class=\"hljs-doctag\">@param</span> id 酒店id\n     */</span>\n    <span class=\"hljs-meta\">@RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE)</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">listenHotelInsertOrUpdate</span><span class=\"hljs-params\">(Long id)</span>{\n        hotelService.insertById(id);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * 监听酒店删除的业务\n     * <span class=\"hljs-doctag\">@param</span> id 酒店id\n     */</span>\n    <span class=\"hljs-meta\">@RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE)</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">listenHotelDelete</span><span class=\"hljs-params\">(Long id)</span>{\n        hotelService.deleteById(id);\n    }\n}\n</code></pre>\n<h2 id=\"elasticsearch-集群\">ElasticSearch 集群</h2>\n<p>单机的 ElasticSearch 做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。</p>\n<ul>\n<li>海量数据存储问题：将索引库从逻辑上拆分为 N 个分片（shard），存储到多个节点</li>\n<li>单点故障问题：将分片数据在不同节点备份（replica）</li>\n</ul>\n<p>ES 集群相关概念:</p>\n<ul>\n<li>集群（cluster）：一组拥有共同的 cluster name 的 节点。</li>\n<li>节点（node)   ：集群中的一个 Elasticearch 实例</li>\n<li>分片（shard）：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中</li>\n</ul>\n<p>解决问题：数据量太大，单点存储量有限的问题。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4pwzs1lq4540.png\" alt=\"image\"></p>\n<p>此处，我们把数据分成 3 片：shard0、shard1、shard2</p>\n<ul>\n<li><p>主分片（Primary shard）：相对于副本分片的定义。</p>\n</li>\n<li><p>副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。</p>\n</li>\n</ul>\n<p>数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！</p>\n<p>为了在高可用和成本间寻求平衡，我们可以这样做：</p>\n<ul>\n<li>首先对数据分片，存储到不同节点</li>\n<li>然后对每个分片进行备份，放到对方节点，完成互相备份</li>\n</ul>\n<p>这样可以大大减少所需要的服务节点数量，如图，我们以 3 分片，每个分片备份一份为例：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3jlk46u66q60.png\" alt=\"image\"></p>\n<p>现在，每个分片都有 1 个备份，存储在 3 个节点：</p>\n<ul>\n<li>node0：保存了分片 0 和 1</li>\n<li>node1：保存了分片 0 和 2</li>\n<li>node2：保存了分片 1 和 2</li>\n</ul>\n<h3 id=\"部署-elasticsearch-集群\">部署 ElasticSearch 集群</h3>\n<p>我们会在单机上利用 docker 容器运行多个 ElasticSearch 实例来模拟 ElasticSearch 集群。不过生产环境推荐大家每一台服务节点仅部署一个 ElasticSearch 的实例。</p>\n<p>部署 ElasticSearch 集群可以直接使用 docker-compose 来完成，但这要求你的 Linux 虚拟机至少有 4G 的内存空间</p>\n<h4 id=\"创建-elasticsearch-集群\">创建 ElasticSearch 集群</h4>\n<p>首先编写一个 docker-compose 文件，内容如下：</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-attribute\">version</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">&#x27;2.2&#x27;</span>\n<span class=\"hljs-attribute\">services</span><span class=\"hljs-punctuation\">:</span>\n  <span class=\"hljs-attribute\">es01</span><span class=\"hljs-punctuation\">:</span>\n    <span class=\"hljs-attribute\">image</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">elasticsearch:7.12.1</span>\n    <span class=\"hljs-attribute\">container_name</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">es01</span>\n    <span class=\"hljs-attribute\">environment</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">node.name=es01</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">cluster.name=es-docker-cluster</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">discovery.seed_hosts=es02,es03</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">cluster.initial_master_nodes=es01,es02,es03</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span>\n    <span class=\"hljs-attribute\">volumes</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">data01:/usr/share/elasticsearch/data</span>\n    <span class=\"hljs-attribute\">ports</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">9200:9200</span>\n    <span class=\"hljs-attribute\">networks</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">elastic</span>\n  <span class=\"hljs-attribute\">es02</span><span class=\"hljs-punctuation\">:</span>\n    <span class=\"hljs-attribute\">image</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">elasticsearch:7.12.1</span>\n    <span class=\"hljs-attribute\">container_name</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">es02</span>\n    <span class=\"hljs-attribute\">environment</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">node.name=es02</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">cluster.name=es-docker-cluster</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">discovery.seed_hosts=es01,es03</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">cluster.initial_master_nodes=es01,es02,es03</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span>\n    <span class=\"hljs-attribute\">volumes</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">data02:/usr/share/elasticsearch/data</span>\n    <span class=\"hljs-attribute\">ports</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">9201:9200</span>\n    <span class=\"hljs-attribute\">networks</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">elastic</span>\n  <span class=\"hljs-attribute\">es03</span><span class=\"hljs-punctuation\">:</span>\n    <span class=\"hljs-attribute\">image</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">elasticsearch:7.12.1</span>\n    <span class=\"hljs-attribute\">container_name</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">es03</span>\n    <span class=\"hljs-attribute\">environment</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">node.name=es03</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">cluster.name=es-docker-cluster</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">discovery.seed_hosts=es01,es02</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">cluster.initial_master_nodes=es01,es02,es03</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">&quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;</span>\n    <span class=\"hljs-attribute\">volumes</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">data03:/usr/share/elasticsearch/data</span>\n    <span class=\"hljs-attribute\">networks</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">elastic</span>\n    <span class=\"hljs-attribute\">ports</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">9202:9200</span>\n<span class=\"hljs-attribute\">volumes</span><span class=\"hljs-punctuation\">:</span>\n  <span class=\"hljs-attribute\">data01</span><span class=\"hljs-punctuation\">:</span>\n    <span class=\"hljs-attribute\">driver</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">local</span>\n  <span class=\"hljs-attribute\">data02</span><span class=\"hljs-punctuation\">:</span>\n    <span class=\"hljs-attribute\">driver</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">local</span>\n  <span class=\"hljs-attribute\">data03</span><span class=\"hljs-punctuation\">:</span>\n    <span class=\"hljs-attribute\">driver</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">local</span>\n\n<span class=\"hljs-attribute\">networks</span><span class=\"hljs-punctuation\">:</span>\n  <span class=\"hljs-attribute\">elastic</span><span class=\"hljs-punctuation\">:</span>\n    <span class=\"hljs-attribute\">driver</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">bridge</span>\n</code></pre>\n<p>ElasticSearch  运行需要修改一些 Linux 系统权限，修改 <code>/etc/sysctl.conf</code> 文件</p>\n<pre><code class=\"hljs language-sh\">vi <span class=\"hljs-regexp\">/etc/</span>sysctl.conf\n</code></pre>\n<p>添加下面的内容：</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-attr\">vm.max_map_count</span>=<span class=\"hljs-number\">262144</span>\n</code></pre>\n<p>然后执行命令，让配置生效：</p>\n<pre><code class=\"hljs language-sh\">sysctl -<span class=\"hljs-selector-tag\">p</span>\n</code></pre>\n<p>通过 docker-compose 启动集群：</p>\n<pre><code class=\"hljs language-sh\"><span class=\"hljs-attribute\">docker-compose up -d</span>\n</code></pre>\n<h4 id=\"集群状态监控\">集群状态监控</h4>\n<p>kibana 可以监控 ElasticSearch  集群，不过新版本需要依赖 ElasticSearch  的 x-pack 功能，配置比较复杂。</p>\n<p>这里推荐使用 cerebro 来监控 ElasticSearch  集群状态，官方网址：<a href=\"https://github.com/lmenezes/cerebro\">https://github.com/lmenezes/cerebro</a></p>\n<p>双击其中的 cerebro.bat 文件即可启动服务。访问 <a href=\"http://localhost:9000\">http://localhost:9000</a> 即可进入管理界面：</p>\n<p>输入你的 ElasticSearch 的任意节点的地址和端口，点击 connect 即可</p>\n<h4 id=\"创建索引库-1\">创建索引库</h4>\n<p>利用 kibana 的 DevTools 创建索引库，在 DevTools 中输入指令：</p>\n<pre><code class=\"hljs language-json\">PUT /test\n{\n  <span class=\"hljs-string\">&quot;settings&quot;</span>: {\n    <span class=\"hljs-string\">&quot;number_of_shards&quot;</span>: <span class=\"hljs-number\">3</span>, <span class=\"hljs-regexp\">//</span> 分片数量\n    <span class=\"hljs-string\">&quot;number_of_replicas&quot;</span>: <span class=\"hljs-number\">1</span> <span class=\"hljs-regexp\">//</span> 副本数量\n  },\n  <span class=\"hljs-string\">&quot;mappings&quot;</span>: {\n    <span class=\"hljs-string\">&quot;properties&quot;</span>: {\n      <span class=\"hljs-regexp\">//</span> mapping映射定义 ...\n    }\n  }\n}\n</code></pre>\n<p>或利用 cerebro 创建索引库</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.29xen9tqfmvw.png\" alt=\"image\"></p>\n<p>查看分片效果，回到首页，即可查看索引库分片效果：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2jn8zaht2280.png\" alt=\"image\"></p>\n<h3 id=\"集群脑裂问题\">集群脑裂问题</h3>\n<h4 id=\"集群职责划分\">集群职责划分</h4>\n<p>ElasticSearch 中集群节点有不同的职责划分：</p>\n<table>\n<thead>\n<tr>\n<th>节点类型</th>\n<th>配置参数</th>\n<th>默认值</th>\n<th>节点职责</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>master  eligible</td>\n<td>node.master</td>\n<td>true</td>\n<td>备选主节点：主节点可以管理和记录集群状态、决定分片在哪个节点、处理创建和删除索引库的请求</td>\n</tr>\n<tr>\n<td>data</td>\n<td>node.data</td>\n<td>true</td>\n<td>数据节点：存储数据、搜索、聚合、CRUD</td>\n</tr>\n<tr>\n<td>ingest</td>\n<td>node.ingest</td>\n<td>true</td>\n<td>数据存储之前的预处理</td>\n</tr>\n<tr>\n<td>coordinating</td>\n<td>上面 3 个参数都为 false 则为 coordinating 节点</td>\n<td>无</td>\n<td>路由请求到其它节点  合并其它节点处理的结果，返回给用户</td>\n</tr>\n</tbody></table>\n<p>默认情况下，集群中的任何一个节点都同时具备上述四种角色。</p>\n<p>但是真实的集群一定要将集群职责分离：</p>\n<ul>\n<li>master 节点：对 CPU 要求高，但是内存要求低</li>\n<li>data 节点：对 CPU 和内存要求都高</li>\n<li>coordinating 节点：对网络带宽、CPU 要求高</li>\n</ul>\n<p>职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。</p>\n<p>一个典型的 ElasticSearch 集群职责划分如图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/ES%E9%9B%86%E7%BE%A4.2rrl7g78cxs0.svg\" alt=\"ES集群\"></p>\n<h4 id=\"脑裂问题\">脑裂问题</h4>\n<p>脑裂是因为集群中的节点失联导致的。</p>\n<p>例如一个集群中，主节点与其它节点失联，</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.6ry0qp2sxiw0.png\" alt=\"image\"></p>\n<p>此时 node2 和 node3 认为 node1 宕机，就会重新选主：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5qon8j1rbak0.png\" alt=\"image\"></p>\n<p>当 node3 当选后，集群继续对外提供服务，node2 和 node3 自成集群，node1 自成集群，两个集群数据不同步，出现数据差异。</p>\n<p>当网络恢复后，因为集群中有两个 master 节点，集群状态的不一致，出现脑裂的情况：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.wmlcqz00rls.png\" alt=\"image\"></p>\n<p>解决脑裂的方案是，要求选票超过 ( eligible节点数量 + 1 ）/ 2 才能当选为主，因此 eligible 节点数量最好是奇数。对应配置项是 discovery.zen.minimum_master_nodes，在 ElasticSearch 7.0 以后，已经成为默认配置，因此一般不会发生脑裂问题</p>\n<p>例如：3 个节点形成的集群，选票必须超过 （3 + 1） / 2 ，也就是 2 票。node3 得到 node2 和 node3 的选票，当选为主。node1 只有自己 1 票，没有当选。集群中依然只有 1 个主节点，没有出现脑裂。</p>\n<h3 id=\"集群分布式存储\">集群分布式存储</h3>\n<p>当新增文档时，应该保存到不同分片，保证数据均衡，那么 coordinating node 如何确定数据该存储到哪个分片呢？</p>\n<h4 id=\"分片存储测试\">分片存储测试</h4>\n<p>在一个节点中加入数据，后可以通过 explain 命令查询</p>\n<pre><code class=\"hljs language-json\">POST <span class=\"hljs-regexp\">/test/</span>_search\n{\n  <span class=\"hljs-string\">&quot;explain&quot;</span>: <span class=\"hljs-keyword\">true</span>,\n  <span class=\"hljs-string\">&quot;query&quot;</span>: {\n    <span class=\"hljs-string\">&quot;match_all&quot;</span>: {}\n  }\n}\n</code></pre>\n<p>发现数据在不同的节点中，形成分片存储</p>\n<h4 id=\"分片存储原理\">分片存储原理</h4>\n<p>ElasticSearch 会通过 hash 算法来计算文档应该存储到哪个分片：<code>shard = hash(_routing) % number_of_shards</code></p>\n<p>说明：</p>\n<ul>\n<li><code>_routing</code> 默认是文档的id</li>\n<li>算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！</li>\n</ul>\n<p>新增文档的流程如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/ES%E9%9B%86%E7%BE%A4.akvhs79fwq0.svg\" alt=\"ES集群\"></p>\n<p>解读：</p>\n<ul>\n<li>新增一个 id=1 的文档</li>\n<li>对 id 做 hash 运算，假如得到的是 2，则应该存储到 P-2</li>\n<li>P-2 的主分片在 node3 节点，将数据路由到 node3</li>\n<li>保存文档</li>\n<li>同步给 P-2 的副本 R-2，在 node2 节点</li>\n<li>返回结果给 coordinating-node 节点</li>\n</ul>\n<h4 id=\"集群分布式查询\">集群分布式查询</h4>\n<p>ElasticSearch 的查询分成两个阶段：</p>\n<ul>\n<li><p>scatter phase：分散阶段，coordinating node 会把请求分发到每一个分片</p>\n</li>\n<li><p>gather phase：聚集阶段，coordinating node 汇总 data node 的搜索结果，并处理为最终结果集返回给用户</p>\n</li>\n</ul>\n<h4 id=\"集群故障转移\">集群故障转移</h4>\n<p>集群的 master 节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。</p>\n<ul>\n<li>假如，node1 发生了故障</li>\n<li>宕机后的第一件事，需要重新选主，例如选中了 node2，</li>\n<li>node2 成为主节点后，会检测集群监控状态，发现：shard-1、shard-0 没有副本节点。因此需要将 node1 上的数据迁移到 node2、node3</li>\n<li>但 node1 恢复，此时 node1 不在是主节点，但数据会重新平衡</li>\n</ul>\n');
INSERT INTO `m_blog` VALUES (13, 1, 'ElasticaSeach 入门', 'ElasticaSeach 入门', '\n## 初识 ElasticSearch\n\n### 了解 ElasticSearch\n\n#### ElasticSearch 的作用\n\nElasticSearch 是一款非常强大的开源搜索引擎，具备非常多强大功能，可以帮助我们从海量数据中快速找到需要的内容\n\n#### ELK 技术栈\n\nElasticSearch 结合 Kibana、Logstash、Beats，也就是 Elastic stack（ELK）。被广泛应用在日志数据分析、实时监控等领域。\n\n#### ElasticSearch 和 Lucene\n\nElasticSearch 底层是基于 Lucene 来实现的。\n\nLucene 是一个 Java 语言的搜索引擎类库，是 Apache 公司的顶级项目，由 DougCutting 于 1999 年研发。\n\nLucene 官网地址：https://lucene.apache.org/ 。\n\nLucene 的优势：易扩展、高性能（基于倒排索引）\n\nLucene 的缺点：只限于 Java 语言开发、学习曲线陡峭、不支持水平扩展\n\nElasticSearch 的发展历史：\n\n- 2004 年 Shay Banon 基于 Lucene 开发了 Compass\n- 2010 年 Shay Banon 重写了 Compass，取名为 ElasticSearch。\n\nElasticSearch 官网地址: https://www.elastic.co/cn/\n\n相比与 Lucene ，ElasticSearch 具备下列优势：\n\n+ 支持分布式，可水平扩展\n+ 提供 Restful 接口，可被任何语言调用\n\n### 倒排索引\n\n倒排索引的概念是基于 MySQL 这样的正向索引而言的。\n\n#### 正向索引\n\n如果是根据 id 查询，那么直接走索引，查询速度非常快。\n\n但如果是基于 title 做模糊查询，只能是逐行扫描数据，流程如下：\n\n1. 用户搜索数据，条件是 title 符合 `\"%手机%\"`\n2. 逐行获取数据，比如 id 为 1 的数据\n3. 判断数据中的 title 是否符合用户搜索条件\n4. 如果符合则放入结果集，不符合则丢弃。回到步骤 1\n\n逐行扫描，也就是全表扫描，随着数据量增加，其查询效率也会越来越低。当数据量达到数百万时，就是一场灾难。\n\n#### 倒排索引\n\n倒排索引中有两个非常重要的概念：\n\n- 文档（Document）：用来搜索的数据，其中的每一条数据就是一个文档。例如一个网页、一个商品信息\n- 词条（Term）：对文档数据或用户搜索数据，利用某种算法分词，得到的具备含义的词语就是词条。例如：我是中国人，就可以分为：我、是、中国人、中国、国人这样的几个词条\n\n创建倒排索引是对正向索引的一种特殊处理，流程如下：\n\n- 将每一个文档的数据利用算法分词，得到一个个词条\n- 创建表，每行数据包括词条、词条所在文档 id、位置等信息\n- 因为词条唯一性，可以给词条创建索引，例如 hash 表结构索引\n\n如图：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5jp2imzxno00.png)\n\n倒排索引的搜索流程如下（以搜索“华为手机”为例）：\n\n1. 用户输入条件 `\"华为手机\"` 进行搜索。\n2. 对用户输入内容分词，得到词条：`华为`、`手机`。\n3. 拿着词条在倒排索引中查找，可以得到包含词条的文档 id：1、2、3。\n4. 拿着文档 id 到正向索引中查找具体文档。\n\n虽然要先查询倒排索引，再查询倒排索引，但是无论是词条、还是文档 id 都建立了索引，查询速度非常快！无需全表扫描。\n\n#### 正向和倒排\n\n那么为什么一个叫做正向索引，一个叫做倒排索引呢？\n\n- 正向索引是最传统的，根据id索引的方式。但根据词条查询时，必须先逐条获取每个文档，然后判断文档中是否包含所需要的词条，是根据文档找词条的过程。\n\n- 倒排索引则相反，是先找到用户要搜索的词条，根据词条得到保护词条的文档的 id，然后根据 id 获取文档。是根据词条找文档的过程。\n\n正向索引\n\n+ 优点：可以给多个字段创建索引、根据索引字段搜索、排序速度非常快\n\n- 缺点：根据非索引字段，或者索引字段中的部分词条查找时，只能全表扫描。\n\n倒排索引：\n\n- 优点：根据词条搜索、模糊搜索时，速度非常快\n- 缺点：只能给词条创建索引，而不是字段、无法根据字段做排序\n\n### ElasticSearch 中的一些概念\n\nElasticSearch 中有很多独有的概念，与 MySQL 中略有差别，但也有相似之处。\n\n#### 文档和字段\n\nElasticSearch 是面向文档（Document）存储的，可以是数据库中的一条商品数据，一个订单信息。文档数据会被序列化为 JSON 格式后存储在 ElasticSearch 中：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.lwpnpfcxvds.png)\n\n而 JSON 文档中往往包含很多的字段（Field），类似于数据库中的列。\n\n#### 索引和映射\n\n索引（Index），就是相同类型的文档的集合。例如：\n\n- 所有用户文档，就可以组织在一起，称为用户的索引；\n- 所有商品的文档，可以组织在一起，称为商品的索引；\n- 所有订单的文档，可以组织在一起，称为订单的索引；\n\n![索引](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/索引.67l5ib0vvgo0.svg)\n\n因此，我们可以把索引当做是数据库中的表。\n\n数据库的表会有约束信息，用来定义表的结构、字段的名称、类型等信息。因此，索引库中就有映射（mapping），是索引中文档的字段约束信息，类似表的结构约束。\n\n#### MySQL 与 ElasticSearch\n\n我们统一的把 MySQL 与 ElasticSearch 的概念做一下对比：\n\n| MySQL  | Elasticsearch | **说明**                                                     |\n| ------ | ------------- | ------------------------------------------------------------ |\n| Table  | Index         | 索引（index），就是文档的集合，类似数据库的表（table）       |\n| Row    | Document      | 文档（Document），就是一条条的数据，类似数据库中的行（Row），文档都是JSON格式 |\n| Column | Field         | 字段（Field），就是 JSON 文档中的字段，类似数据库中的列（Column） |\n| Schema | Mapping       | Mapping（映射）是索引中文档的约束，例如字段类型约束。类似数据库的表结构（Schema） |\n| SQL    | DSL           | DSL是 ElasticSearch 提供的 JSON 风格的请求语句，用来操作 ElasticSearch，实现 CRUD |\n\n- MySQL ：擅长事务类型操作，可以确保数据的安全和一致性\n\n- ElasticSearch：擅长海量数据的搜索、分析、计算\n\n因此在企业中，往往是两者结合使用：\n\n- 对安全性要求较高的写操作，使用 MySQL 实现\n- 对查询性能要求较高的搜索需求，使用 ElasticSearch 实现\n- 两者再基于某种方式，实现数据的同步，保证一致性\n\n![ElasticSearch](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/ElasticSearch.4koj7qwgqge0.svg)\n\n### 安装 ElasticSearch 、Kibana\n\n#### 创建网络\n\n因为我们还需要部署 Kibana 容器，因此需要让 ElasticSearch 和 Kibana 容器互联。这里先创建一个网络：\n\n```sh\ndocker network create halo-es-net\n```\n\n#### 拉取或加载镜像\n\n```sh\ndocker pull elasticsearch:7.14.1\n```\n\n```sh\ndocker pull kibana:7.14.1\n```\n\n#### 运行（单点）\n\n运行 docker 命令，部署单点 ElasticSearch ：\n\n```sh\ndocker run -d \\\n	--name halo-es \\\n    -e \"ES_JAVA_OPTS=-Xms512m -Xmx512m\" \\\n    -e \"discovery.type=single-node\" \\\n    -v es-data:/usr/share/elasticsearch/data \\\n    -v es-plugins:/usr/share/elasticsearch/plugins \\\n    --privileged \\\n    --network halo-es-net \\\n    -p 9200:9200 \\\n    -p 9300:9300 \\\nelasticsearch:7.14.1\n```\n\n命令解释：\n\n- `-e \"cluster.name=es-docker-cluster\"`：设置集群名称\n- `-e \"http.host=0.0.0.0\"`：监听的地址，可以外网访问\n- `-e \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"`：内存大小\n- `-e \"discovery.type=single-node\"`：非集群模式\n- `-v es-data:/usr/share/elasticsearch/data`：挂载逻辑卷，绑定 ElasticSearch 的数据目录\n- `-v es-logs:/usr/share/elasticsearch/logs`：挂载逻辑卷，绑定 ElasticSearch 的日志目录\n- `-v es-plugins:/usr/share/elasticsearch/plugins`：挂载逻辑卷，绑定 ElasticSearch 的插件目录\n- `--privileged`：授予逻辑卷访问权\n- `--network halo-es-net` ：加入一个名为 halo-es-net 的网络中\n- `-p 9200:9200`：端口映射配置\n\n在浏览器中输入：http://halo:9200 即可看到 ElasticSearch 的响应结果：\n\n运行 docker 命令，部署 Kibana\n\n```sh\ndocker run -d \\\n--name halo-kibana \\\n-e ELASTICSEARCH_HOSTS=http://halo-es:9200 \\\n--network halo-es-net \\\n-p 5601:5601  \\\nkibana:7.14.1\n```\n\n- `--network es-net` ：加入一个名为es-net的网络中，与 elasticsearch 在同一个网络中\n- `-e ELASTICSEARCH_HOSTS=http://halo-es:9200\"`：设置 elasticsearch 的地址，因为 kibana 已经与elasticsearch 在一个网络，因此可以用容器名（halo-es）直接访问 elasticsearch\n- `-p 5601:5601`：端口映射配置\n\nkibana 启动一般比较慢，需要多等待一会，可以通过命令查看日志：\n\n```sh\ndocker logs -f kibana\n```\n\n在浏览器输入地址访问：http://halo:5601，即可看到结果\n\n### 安装 IK 分词器\n\nElasticSearch 在创建倒排索引时需要对文档分词；在搜索时，需要对用户输入内容分词。但默认的分词规则对中文处理并不友好。\n\n我们在 Kibana 的 DevTools 中测试：\n\n```json\nPOST /_analyze\n{\n  \"analyzer\": \"standard\",\n  \"text\": \"你好,世界! Hello,World!\"\n}\n```\n\n语法说明：\n\n+ POST：请求方式\n+ /_analyze：请求路径，这里省略了 http://halo:9200，有 kibana 帮我们补充\n+ 请求参数，JSON 风格：`analyzer`：分词器类型，这里是默认的 standard 分词器；`text`：要分词的内容\n\n```json\n{\n  \"tokens\" : [\n    {\n      \"token\" : \"你\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 1,\n      \"type\" : \"<IDEOGRAPHIC>\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"好\",\n      \"start_offset\" : 1,\n      \"end_offset\" : 2,\n      \"type\" : \"<IDEOGRAPHIC>\",\n      \"position\" : 1\n    },\n    {\n      \"token\" : \"世\",\n      \"start_offset\" : 3,\n      \"end_offset\" : 4,\n      \"type\" : \"<IDEOGRAPHIC>\",\n      \"position\" : 2\n    },\n    {\n      \"token\" : \"界\",\n      \"start_offset\" : 4,\n      \"end_offset\" : 5,\n      \"type\" : \"<IDEOGRAPHIC>\",\n      \"position\" : 3\n    },\n    {\n      \"token\" : \"hello\",\n      \"start_offset\" : 7,\n      \"end_offset\" : 12,\n      \"type\" : \"<ALPHANUM>\",\n      \"position\" : 4\n    },\n    {\n      \"token\" : \"world\",\n      \"start_offset\" : 13,\n      \"end_offset\" : 18,\n      \"type\" : \"<ALPHANUM>\",\n      \"position\" : 5\n    }\n  ]\n}\n```\n\n处理中文分词，一般会使用 IK 分词器。https://github.com/medcl/elasticsearch-analysis-ik\n\n#### 在线安装 IK 插件\n\n```sh\n# 进入容器内部\ndocker exec -it elasticsearch /bin/bash\n\n# 在线下载并安装\n./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.14.1/elasticsearch-analysis-ik-7.14.1.zip\n\n#退出\nexit\n#重启容器\ndocker restart elasticsearch\n```\n\n#### 离线安装 IK 插件\n\n查看数据卷目录\n\n安装插件需要知道 elasticsearch 的 plugins 目录位置，而我们用了数据卷挂载，因此需要查看 elasticsearch 的数据卷目录，通过下面命令查看:\n\n```sh\ndocker volume inspect es-plugins\n```\n\n显示结果：\n\n```\n[\n    {\n        \"CreatedAt\": \"2021-09-11T12:50:57+08:00\",\n        \"Driver\": \"local\",\n        \"Labels\": null,\n        \"Mountpoint\": \"/var/lib/docker/volumes/es-plugins/_data\",\n        \"Name\": \"es-plugins\",\n        \"Options\": null,\n        \"Scope\": \"local\"\n    }\n]\n```\n\n说明 plugins 目录被挂载到了：`/var/lib/docker/volumes/es-plugins/_data ` 这个目录中。\n\n将 ik 分词器解压缩，重命名为 ik，上传到 es 容器的插件数据卷中后重启容器\n\n```sh\ndocker restart halo-es\n```\n\n#### 测试分词器\n\nIK 分词器包含两种模式：\n\n* `ik_smart` ：最少切分，粗粒度\n\n* `ik_max_word` ：最细切分，细粒度\n\n```json\nPOST /_analyze\n{\n  \"analyzer\": \"ik_max_word\",\n  \"text\": \"你好,我的世界! Hello,World!\"\n}\n```\n\n结果：\n\n```json\n{\n  \"tokens\" : [\n    {\n      \"token\" : \"你好\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 2,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"我\",\n      \"start_offset\" : 3,\n      \"end_offset\" : 4,\n      \"type\" : \"CN_CHAR\",\n      \"position\" : 1\n    },\n    {\n      \"token\" : \"的\",\n      \"start_offset\" : 4,\n      \"end_offset\" : 5,\n      \"type\" : \"CN_CHAR\",\n      \"position\" : 2\n    },\n    {\n      \"token\" : \"世界\",\n      \"start_offset\" : 5,\n      \"end_offset\" : 7,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 3\n    },\n    {\n      \"token\" : \"hello\",\n      \"start_offset\" : 9,\n      \"end_offset\" : 14,\n      \"type\" : \"ENGLISH\",\n      \"position\" : 4\n    },\n    {\n      \"token\" : \"world\",\n      \"start_offset\" : 15,\n      \"end_offset\" : 20,\n      \"type\" : \"ENGLISH\",\n      \"position\" : 5\n    }\n  ]\n}\n```\n\n#### 扩展和停用词词典\n\n随着互联网的发展，“造词运动”也越发的频繁。出现了很多新的词语，在原有的词汇列表中并不存在。\n\n所以我们的词汇也需要不断的更新，IK 分词器提供了扩展词汇的功能。\n\n打开 IK 分词器 config 目录：\n\n```sh\ncd /var/lib/docker/volumes/es-plugins/_data/ik/config\n```\n\n在 IKAnalyzer.cfg.xml 配置文件内容添加：\n\n```xml\n<!DOCTYPE properties SYSTEM \"http://java.sun.com/dtd/properties.dtd\">\n<properties>\n        <comment>IK Analyzer 扩展配置</comment>\n        <!--用户可以在这里配置自己的扩展字典 -->\n        <entry key=\"ext_dict\">ext.dic</entry>\n         <!--用户可以在这里配置自己的扩展停止词字典-->\n        <entry key=\"ext_stopwords\">stopwort.dic</entry>\n        <!--用户可以在这里配置远程扩展字典 -->\n        <!-- <entry key=\"remote_ext_dict\">words_location</entry> -->\n        <!--用户可以在这里配置远程扩展停止词字典-->\n        <!-- <entry key=\"remote_ext_stopwords\">words_location</entry> -->\n</properties>\n```\n\n新建一个 ext.dic，可以参考 config 目录下复制一个配置文件进行修改\n\n```properties\n我的世界\n```\n\nstopwort.dic 添加\n\n```properties\n的\n```\n\n重启 ElasticSearch \n\n```sh\ndocker restart es\n\n# 查看 日志\ndocker logs -f elasticsearch\n```\n\n日志中已经成功加载 ext.dic 配置文件\n\n测试\n\n```json\nPOST /_analyze\n{\n  \"analyzer\": \"ik_max_word\",\n  \"text\": \"你好,我的世界! Hello,World!\"\n}\n```\n\n```json\n{\n  \"tokens\" : [\n    {\n      \"token\" : \"你好\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 2,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"我的世界\",\n      \"start_offset\" : 3,\n      \"end_offset\" : 7,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 1\n    },\n    {\n      \"token\" : \"世界\",\n      \"start_offset\" : 5,\n      \"end_offset\" : 7,\n      \"type\" : \"CN_WORD\",\n      \"position\" : 2\n    },\n    {\n      \"token\" : \"hello\",\n      \"start_offset\" : 9,\n      \"end_offset\" : 14,\n      \"type\" : \"ENGLISH\",\n      \"position\" : 3\n    },\n    {\n      \"token\" : \"world\",\n      \"start_offset\" : 15,\n      \"end_offset\" : 20,\n      \"type\" : \"ENGLISH\",\n      \"position\" : 4\n    }\n  ]\n}\n```\n\n> 注意当前文件的编码必须是 UTF-8 格式，严禁使用 Windows 记事本编辑\n\n## DSL 索引库操作\n\n索引库就类似数据库表，mapping 映射就类似表的结构。我们要向 es 中存储数据，必须先创建“库”和“表”。\n\n### mapping 映射属性\n\nmapping 是对索引库中文档的约束，常见的mapping属性包括：\n\n- type：字段数据类型，常见的简单类型有：\n  - 字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip 地址）\n  - 数值：long、integer、short、byte、double、float、\n  - 布尔：boolean\n  - 日期：date\n  - 对象：object\n- index：是否创建索引，默认为 true\n- analyzer：使用哪种分词器\n- properties：该字段的子字段\n\n例如下面的 JSON 文档：\n\n```json\n{\n    \"age\": 21,\n    \"weight\": 52.1,\n    \"isMarried\": false,\n    \"info\": \"黑马程序员Java讲师\",\n    \"email\": \"zy@itcast.cn\",\n    \"score\": [99.1, 99.5, 98.9],\n    \"name\": {\n        \"firstName\": \"云\",\n        \"lastName\": \"赵\"\n    }\n}\n```\n\n对应的每个字段映射（mapping）：\n\n- age：类型为 integer；参与搜索，因此需要 index 为 true；无需分词器\n- weight：类型为 float；参与搜索，因此需要 index 为 true；无需分词器\n- isMarried：类型为 boolean；参与搜索，因此需要 index 为 true；无需分词器\n- info：类型为字符串，需要分词，因此是 text；参与搜索，因此需要 index 为 true；分词器可以用 ik_smart\n- email：类型为字符串，但是不需要分词，因此是 keyword；不参与搜索，因此需要 index 为 false；无需分词器\n- score：虽然是数组，但是我们只看元素的类型，类型为 float；参与搜索，因此需要 index 为 true；无需分词器\n- name：类型为 object，需要定义多个子属性\n  - name.firstName：类型为字符串，但是不需要分词，因此是 keyword；参与搜索，因此需要 index 为 true；无需分词器\n  - name.lastName：类型为字符串，但是不需要分词，因此是 keyword；参与搜索，因此需要 index 为 true；无需分词器\n\n### 索引库的 CRUD\n\n这里统一使用 Kibana 编写 DSL 的方式来演示。\n\n#### 创建索引库和映射\n\n基本语法：\n\n+ 请求方式：PUT\n+ 请求路径：/索引库名，可以自定义\n+ 请求参数：mapping 映射\n\n```json\nPUT /索引库名称\n{\n  \"mappings\": {\n    \"properties\": {\n      \"字段名\":{\n        \"type\": \"text\",\n        \"analyzer\": \"ik_smart\"\n      },\n      \"字段名2\":{\n        \"type\": \"keyword\",\n        \"index\": \"false\"\n      },\n      \"字段名3\":{\n        \"properties\": {\n          \"子字段\": {\n            \"type\": \"keyword\"\n          }\n        }\n      },\n      // ...略\n    }\n  }\n}\n```\n\n示例：\n\n```json\nPUT /heima\n{\n  \"mappings\": {\n    \"properties\": {\n      \"info\":{\n        \"type\": \"text\",\n        \"analyzer\": \"ik_smart\"\n      },\n      \"email\":{\n        \"type\": \"keyword\",\n        \"index\": \"falsae\"\n      },\n      \"name\":{\n        \"properties\": {\n          \"firstName\": {\n            \"type\": \"keyword\"\n          }\n        }\n      },\n      // ... 略\n    }\n  }\n}\n```\n\n#### 查询索引库\n\n基本语法：\n\n- 请求方式：GET\n\n- 请求路径：/索引库名\n\n- 请求参数：无\n\n```\nGET /索引库名\n```\n\n#### 删除索引库\n\n语法：\n\n- 请求方式：DELETE\n\n- 请求路径：/索引库名\n\n- 请求参数：无\n\n```\nDELETE /索引库名\n```\n\n#### 修改索引库\n\n倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库一旦创建，无法修改 mapping。\n\n虽然无法修改 mapping 中已有的字段，但是却允许添加新的字段到 mapping 中，因为不会对倒排索引产生影响。\n\n语法说明：\n\n```json\nPUT /索引库名/_mapping\n{\n  \"properties\": {\n    \"新字段名\": {\n      \"type\": \"xxxx\"\n    }\n  }\n}\n```\n\n#### 索引库的 CRUD 小结\n\n- 创建索引库：PUT /索引库名\n- 查询索引库：GET /索引库名\n- 删除索引库：DELETE /索引库名\n- 添加字段：PUT /索引库名/_mapping\n\n## DSL 文档操作\n\n### 新增文档\n\n 语法：\n\n```json\nPOST /索引库名/_doc/文档id\n{\n    \"字段1\": \"值1\",\n    \"字段2\": \"值2\",\n    \"字段3\": {\n        \"子属性1\": \"值3\",\n        \"子属性2\": \"值4\"\n    },\n    // ...\n}\n```\n\n示例：\n\n```json\nPOST /halo/_doc/1\n{\n  \"info\": \"黑马程序员Java讲师\",\n  \"email\": \"zy@itcast.cn\",\n  \"name\": {\n    \"firstName\": \"云\",\n    \"lastName\": \"赵\"\n  }\n}\n```\n\n### 查询文档\n\n根据 rest 风格，新增是 post，查询应该是 get，不过查询一般都需要条件，这里我们把文档 id 带上。\n\n语法：\n\n```\nGET /{索引库名称}/_doc/{id}\n```\n\n通过 kibana 查看数据：\n\n```\nGET /halo/_doc/1\n```\n\n### 删除文档\n\n删除使用 DELETE 请求，同样，需要根据 id 进行删除：\n\n语法：\n\n```\nDELETE /{索引库名}/_doc/id值\n```\n\n示例：\n\n```\nDELETE /halo/_doc/1\n```\n\n### 修改文档\n\n修改有两种方式：\n\n- 全量修改：直接覆盖原来的文档\n- 增量修改：修改文档中的部分字段\n\n#### 全量修改\n\n全量修改是覆盖原来的文档，其本质是：\n\n- 根据指定的 id 删除文档\n- 新增一个相同 id 的文档\n\n> 注意：如果根据 id 删除时，id 不存在，第二步的新增也会执行，也就从修改变成了新增操作了。\n\n语法：\n\n```json\nPUT /{索引库名}/_doc/文档id\n{\n    \"字段1\": \"值1\",\n    \"字段2\": \"值2\",\n    // ... 略\n}\n```\n\n示例：\n\n```json\nPUT /halo/_doc/1\n{\n  \"info\": \"黑马程序员高级Java讲师2\",\n  \"email\": \"zy@itcast.cn\",\n  \"name\": {\n    \"firstName\": \"云\",\n    \"lastName\": \"赵\"\n  }\n}\n```\n\n#### 增量修改\n\n增量修改是只修改指定 id 匹配的文档中的部分字段。\n\n语法：\n\n```json\nPOST /{索引库名}/_update/文档id\n{\n    \"doc\": {\n         \"字段名\": \"新的值\",\n    }\n}\n```\n\n示例：\n\n```\nPOST /halo/_update/1\n{\n  \"doc\": {\n    \"email\": \"ZhaoYun@itcast.cn\"\n  }\n}\n```\n\n### 文档操作总结\n\n- 创建文档：POST /{索引库名}/_doc/文档id   { JSON 文档 }\n- 查询文档：GET /{索引库名}/_doc/文档id\n- 删除文档：DELETE /{索引库名}/_doc/文档id\n- 修改文档：\n  - 全量修改：PUT /{索引库名}/_doc/文档id { JSON 文档 }\n  - 增量修改：POST /{索引库名}/_update/文档id { \"doc\": {字段}}\n\n## Rest Client 索引库操作\n\nElasticSearch 官方提供了各种不同语言的客户端，用来操作 ElasticSearch。这些客户端的本质就是组装 DSL 语句，通过 http 请求发送给 ElasticSearch。官方文档地址：https://www.elastic.co/guide/en/elasticsearch/client/index.html\n\n其中的 Java Rest Client 又包括两种：\n\n- Java Low Level Rest Client\n- Java High Level Rest Client\n\n我们学习的是 Java HighLevel Rest Client 客户端 API\n\n### 创建测试环境\n\n#### 初始化项目\n\n创建数据库，建立数据表\n\n```sql\nCREATE TABLE `tb_hotel`  (\n    `id` bigint(20) NOT NULL COMMENT \'酒店id\',\n    `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT \'酒店名称\',\n    `address` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT \'酒店地址\',\n    `price` int(10) NOT NULL COMMENT \'酒店价格\',\n    `score` int(2) NOT NULL COMMENT \'酒店评分\',\n    `brand` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT \'酒店品牌\',\n    `city` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT \'所在城市\',\n    `star_name` varchar(16) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'酒店星级，1星到5星，1钻到5钻\',\n    `business` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'商圈\',\n    `latitude` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT \'纬度\',\n    `longitude` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT \'经度\',\n    `pic` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT \'酒店图片\',\n    PRIMARY KEY (`id`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n```\n\n导入数据库数据：[链接](https://github.com/Lanqilu/HaloElasticSearch/blob/master/doc/database/tb_hotel.sql)\n\n初始项目代码：[链接](https://github.com/Lanqilu/HaloElasticSearch/commit/d64b305ccf9ca67b8a18bafee3df7163e7dd8246)\n\n#### mapping 映射分析\n\n创建索引库，最关键的是 mapping 映射，而 mapping 映射要考虑的信息包括：\n\n- 字段名\n- 字段数据类型\n- 是否参与搜索\n- 是否需要分词\n- 如果分词，分词器是什么？\n\n其中：\n\n- 字段名、字段数据类型，可以参考数据表结构的名称和类型\n- 是否参与搜索要分析业务来判断，例如图片地址，就无需参与搜索\n- 是否分词呢要看内容，内容如果是一个整体就无需分词，反之则要分词\n- 分词器，我们可以统一使用 ik_max_word\n\n来看下酒店数据的索引库结构：\n\n```json\nPUT /hotel\n{\n  \"mappings\": {\n    \"properties\": {\n      \"id\": {\n        \"type\": \"keyword\"\n      },\n      \"name\":{\n        \"type\": \"text\",\n        \"analyzer\": \"ik_max_word\",\n        \"copy_to\": \"all\"\n      },\n      \"address\":{\n        \"type\": \"keyword\",\n        \"index\": false\n      },\n      \"price\":{\n        \"type\": \"integer\"\n      },\n      \"score\":{\n        \"type\": \"integer\"\n      },\n      \"brand\":{\n        \"type\": \"keyword\",\n        \"copy_to\": \"all\"\n      },\n      \"city\":{\n        \"type\": \"keyword\",\n        \"copy_to\": \"all\"\n      },\n      \"starName\":{\n        \"type\": \"keyword\"\n      },\n      \"business\":{\n        \"type\": \"keyword\"\n      },\n      \"location\":{\n        \"type\": \"geo_point\"\n      },\n      \"pic\":{\n        \"type\": \"keyword\",\n        \"index\": false\n      },\n      \"all\":{\n        \"type\": \"text\",\n        \"analyzer\": \"ik_max_word\"\n      }\n    }\n  }\n}\n```\n\n几个特殊字段说明：\n\n- location：地理坐标，里面包含精度、纬度\n- all：一个组合字段，其目的是将多字段的值 利用 copy_to 合并，提供给用户搜索\n\n ES 中支持两种地理坐标数据类型：\n\n•geo_point：由纬度（latitude）和经度（longitude）确定的一个点。例如：\"32.8752345, 120.2981576\"\n\n•geo_shape：有多个geo_point组成的复杂几何图形。例如一条直线，\"LINESTRING (-77.03653 38.897676, -77.009051 38.889939)\"\n\n字段拷贝可以使用 copy_to 属性将当前字段拷贝到指定字段。示例：\n\n```json\n\"all\": {\n  \"type\": \"text\",\n  \"analyzer\": \"ik_max_word\"\n},\n\"brand\": {\n  \"type\": \"keyword\",\n  \"copy_to\": \"all\"\n}\n```\n\n#### 初始化 RestClient\n\n在 ElasticSearch 提供的 API 中，与 ElasticSearch 一切交互都封装在一个名为 RestHighLevelClient 的类中，必须先完成这个对象的初始化，建立与 ElasticSearch 的连接。\n\n分为三步：\n\n① 引入 ElasticSearch 的 RestHighLevelClient 依赖：\n\n```xml\n<dependency>\n    <groupId>org.elasticsearch.client</groupId>\n    <artifactId>elasticsearch-rest-high-level-client</artifactId>\n</dependency>\n```\n\n② 因为 SpringBoot 默认的 ElasticSearch 版本是 7.6.2，所以我们需要覆盖默认的 ElasticSearch 版本，与 ElasticSearch 版本保持一致\n\n```xml\n<properties>\n    <java.version>1.8</java.version>\n    <elasticsearch.version>7.14.1</elasticsearch.version>\n</properties>\n```\n\n③ 初始化 RestHighLevelClient：\n\n初始化的代码如下：\n\n```java\nRestHighLevelClient client = new RestHighLevelClient(RestClient.builder(HttpHost.create(\"http://halo:9200\")));\n```\n\n这里为了单元测试方便，我们创建一个测试类 HotelIndexTest，然后将初始化的代码编写在 `@BeforeEach` 方法中：\n\n```java\npublic class HotelIndexTest {\n\n    private RestHighLevelClient client;\n\n    @Test\n    void testInit() {\n        System.out.println(\"client = \" + client);\n    }\n\n    @BeforeEach\n    void setUp() {\n        this.client = new RestHighLevelClient(RestClient.builder(HttpHost.create(\"http://halo:9200\")));\n    }\n\n    @AfterEach\n    void tearDown() throws IOException {\n        this.client.close();\n    }\n}\n```\n\n### 创建索引库\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.zlx2xrhd54w.png)\n\n代码分为三步：\n\n1. 创建 Request 对象。因为是创建索引库的操作，因此 Request 是 CreateIndexRequest\n2. 添加请求参数，其实就是 DSL 的 JSON 参数部分。因为 JSON 字符串很长，这里是定义了静态字符串常量 MAPPING_TEMPLATE，让代码看起来更加优雅。\n3. 发送请求，`client.indices()` 方法的返回值是 IndicesClient 类型，封装了所有与索引库操作有关的方法。\n\n在 hotel-demo 中的 HotelIndexTest 测试类中，编写单元测试，实现创建索引：\n\n```java\n@Test\nvoid createHotelIndex() throws IOException {\n    // 1.创建Request对象\n    CreateIndexRequest request = new CreateIndexRequest(\"hotel\");\n    // 2.准备请求的参数：DSL语句\n    request.source(MAPPING_TEMPLATE, XContentType.JSON);\n    // 3.发送请求\n    client.indices().create(request, RequestOptions.DEFAULT);\n}\n```\n\n### 删除索引库\n\n删除索引库的 DSL 语句非常简单：\n\n```json\nDELETE /hotel\n```\n\n与创建索引库相比：\n\n- 请求方式从 PUT 变为 DELTE\n- 请求路径不变\n- 无请求参数\n\n所以代码的差异，注意体现在 Request 对象上。依然是三步走：\n\n- 创建 Request 对象。这次是 DeleteIndexRequest 对象\n- 准备参数。这里是无参\n- 发送请求。改用 delete 方法\n\n在 hotel-demo 中的 HotelIndexTest 测试类中，编写单元测试，实现删除索引：\n\n```java\n@Test\nvoid testDeleteHotelIndex() throws IOException {\n    // 1.创建Request对象\n    DeleteIndexRequest request = new DeleteIndexRequest(\"hotel\");\n    // 2.发送请求\n    client.indices().delete(request, RequestOptions.DEFAULT);\n}\n```\n\n### 判断索引库是否存在\n\n判断索引库是否存在，本质就是查询，对应的DSL是：\n\n```json\nGET /hotel\n```\n\n因此与删除的 Java 代码流程是类似的。依然是三步走：\n\n- 创建 Request 对象。这次是 GetIndexRequest 对象\n- 准备参数。这里是无参\n- 发送请求。改用 exists 方法\n\n```java\n@Test\nvoid testExistsHotelIndex() throws IOException {\n    // 1.创建Request对象\n    GetIndexRequest request = new GetIndexRequest(\"hotel\");\n    // 2.发送请求\n    boolean exists = client.indices().exists(request, RequestOptions.DEFAULT);\n    // 3.输出\n    System.err.println(exists ? \"索引库已经存在！\" : \"索引库不存在！\");\n}\n```\n\n### RestAPI 小结\n\nJavaRestClient 操作 ElasticSearch 的流程基本类似。核心是 `client.indices()` 方法来获取索引库的操作对象。\n\n索引库操作的基本步骤：\n\n- 初始化 RestHighLevelClient\n- 创建 XxxIndexRequest。Xxx 是Create、Get、Delete\n- 准备 DSL（ Create时需要，其它是无参）\n- 发送请求。调用 `RestHighLevelClient#indices().xxx()` 方法，xxx 是  create、exists、delete\n\n## Rest Client 文档操作\n\n去数据库查询酒店数据，导入到 hotel 索引库，实现酒店数据的 CRUD。基本步骤如下：\n\n+ 初始化 JavaRestClient\n+ 利用 JavaRestClient 新增酒店数据\n+ 利用 JavaRestClient 根据id查询酒店数据\n+ 利用 JavaRestClient 删除酒店数据\n+ 利用 JavaRestClient 修改酒店数据\n\n### 初始化 JavaRestClient\n\n为了与索引库操作分离，我们再次参加一个测试类，做两件事情：\n\n- 初始化 RestHighLevelClient，同上\n- 我们的酒店数据在数据库，需要利用 IHotelService 去查询，所以注入这个接口\n\n```java\n@SpringBootTest\npublic class HotelDocumentTest {\n    @Autowired\n    private IHotelService hotelService;\n\n    private RestHighLevelClient client;\n\n    @BeforeEach\n    void setUp() {\n        this.client = new RestHighLevelClient(RestClient.builder(HttpHost.create(\"http://halo:9200\")));\n    }\n\n    @AfterEach\n    void tearDown() throws IOException {\n        this.client.close();\n    }\n}\n```\n\n### 新增文档\n\n我们要将数据库的酒店数据查询出来，写入 ElasticSearch 中。\n\n#### 索引库实体类\n\n数据库查询后的结果是一个 Hotel 类型的对象。结构如下：\n\n```java\n@Data\n@TableName(\"tb_hotel\")\npublic class Hotel {\n    @TableId(type = IdType.INPUT)\n    private Long id;\n    private String name;\n    private String address;\n    private Integer price;\n    private Integer score;\n    private String brand;\n    private String city;\n    private String starName;\n    private String business;\n    private String longitude;\n    private String latitude;\n    private String pic;\n}\n```\n\n与我们的索引库结构存在差异：\n\n- longitude 和 latitude 需要合并为 location\n\n因此，我们需要定义一个新的类型，与索引库结构吻合：\n\n```java\npackage cn.itcast.hotel.pojo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n@Data\n@NoArgsConstructor\npublic class HotelDoc {\n    private Long id;\n    private String name;\n    private String address;\n    private Integer price;\n    private Integer score;\n    private String brand;\n    private String city;\n    private String starName;\n    private String business;\n    private String location;\n    private String pic;\n\n    public HotelDoc(Hotel hotel) {\n        this.id = hotel.getId();\n        this.name = hotel.getName();\n        this.address = hotel.getAddress();\n        this.price = hotel.getPrice();\n        this.score = hotel.getScore();\n        this.brand = hotel.getBrand();\n        this.city = hotel.getCity();\n        this.starName = hotel.getStarName();\n        this.business = hotel.getBusiness();\n        this.location = hotel.getLatitude() + \", \" + hotel.getLongitude();\n        this.pic = hotel.getPic();\n    }\n}\n```\n\n#### 语法说明\n\n新增文档的 DSL 语句如下：\n\n```json\nPOST /{索引库名}/_doc/1\n{\n    \"name\": \"Jack\",\n    \"age\": 21\n}\n```\n\n对应的 Java 代码如下：\n\n```java\n@Test\nvoid testIndexDocument() throws IOException {\n    // 1.创建request对象\n    IndexRequest request = new IndexRequest(\"indexName\").id(\"1\");\n    // 2.准备JSON文档\n    request.source(\"{\\\"name\\\": \\\"Jack\\\", \\\"age\\\": 21}\", XContentType.JSON);\n    // 3.发送请求\n    client.index(request, RequestOptions.DEFAULT);\n}\n```\n\n可以看到与创建索引库类似，同样是三步走：\n\n- 创建 Request 对象\n- 准备请求参数，也就是 DSL 中的 JSON 文档\n- 发送请求\n\n变化的地方在于，这里直接使用 `client.xxx()` 的 API，不再需要 `client.indices()` 了。\n\n#### 完整代码\n\n我们导入酒店数据，基本流程一致，但是需要考虑几点变化：\n\n- 酒店数据来自于数据库，我们需要先查询出来，得到 Hotel 对象\n- Hotel 对象需要转为 HotelDoc对象\n- HotelDoc 需要序列化为 JSON 格式\n\n因此，代码整体步骤如下：\n\n- 根据 id 查询酒店数据 Hotel\n- 将 Hotel 封装为 HotelDoc\n- 将 HotelDoc 序列化为 JSON\n- 创建 IndexRequest，指定索引库名和 id\n- 准备请求参数，也就是 JSON 文档\n- 发送请求\n\n在 hotel-demo 的 HotelDocumentTest 测试类中，编写单元测试：\n\n```java\n@Test\nvoid testAddDocument() throws IOException {\n    // 1.根据id查询酒店数据\n    Hotel hotel = hotelService.getById(61083L);\n    // 2.转换为文档类型\n    HotelDoc hotelDoc = new HotelDoc(hotel);\n    // 3.将HotelDoc转json\n    String json = JSON.toJSONString(hotelDoc);\n\n    // 1.准备Request对象\n    IndexRequest request = new IndexRequest(\"hotel\").id(hotelDoc.getId().toString());\n    // 2.准备Json文档\n    request.source(json, XContentType.JSON);\n    // 3.发送请求\n    client.index(request, RequestOptions.DEFAULT);\n}\n```\n\n### 查询文档\n\n#### 语法说明\n\n查询的 DSL 语句如下：\n\n```json\nGET /hotel/_doc/{id}\n```\n\n非常简单，因此代码大概分两步：\n\n- 准备 Request 对象\n- 发送请求\n\n不过查询的目的是得到结果，解析为 HotelDoc，因此难点是结果的解析。示例代码如下：\n\n```java\n@Test\nvoid testGetDocumentById() throws IOException {\n    // 1.创建request对象\n    GetRequest request = new GetRequest(\"indexName\", \"1\");\n    // 2.发送请求，得到结果\n    GetResponse response = client.get(request, RequestOptions.DEFAULT);\n    // 3.解析结果\n    String json = response.getSourceAsString();\n    System.out.println(json);\n}\n```\n\n可以看到，结果是一个 JSON，其中文档放在一个 `_source` 属性中，因此解析就是拿到 `_source`，反序列化为 Java 对象即可。\n\n与之前类似，也是三步走：\n\n- 准备 Request 对象。这次是查询，所以是 GetRequest\n- 发送请求，得到结果。因为是查询，这里调用 `client.get()` 方法\n- 解析结果，就是对 JSON 做反序列化\n\n#### 完整代码\n\n在 hotel-demo 的 HotelDocumentTest 测试类中，编写单元测试：\n\n```java\n@Test\nvoid testGetDocumentById() throws IOException {\n    // 1.准备Request\n    GetRequest request = new GetRequest(\"hotel\", \"61083\");\n    // 2.发送请求，得到响应\n    GetResponse response = client.get(request, RequestOptions.DEFAULT);\n    // 3.解析响应结果\n    String json = response.getSourceAsString();\n    HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);\n    System.out.println(hotelDoc);\n}\n```\n\n### 修改文档\n\n#### 语法说明\n\n修改我们讲过两种方式：\n\n- 全量修改：本质是先根据id删除，再新增\n- 增量修改：修改文档中的指定字段值\n\n在 RestClient 的 API 中，全量修改与新增的 API 完全一致，判断依据是 ID：\n\n- 如果新增时，ID 已经存在，则修改\n- 如果新增时，ID 不存在，则新增\n\n这里不再赘述，我们主要关注增量修改。\n\n```java\n@Test\nvoid testUpdateDocumentById() throws IOException {\n    // 1.创建request对象\n    UpdateRequest request = new UpdateRequest(\"indexName\", \"1\");\n    // 2.准备参数，每2个参数为一对 key value    \n    request.doc(\"age\", 18, \"name\", \"Rose\");\n    // 3.更新文档\n    client.update(request, RequestOptions.DEFAULT);\n}\n```\n\n与之前类似，也是三步走：\n\n- 准备 Request 对象。这次是修改，所以是 UpdateRequest\n- 准备参数。也就是 JSON 文档，里面包含要修改的字段\n- 更新文档。这里调用 `client.update()` 方法\n\n#### 完整代码\n\n在 hotel-demo 的 HotelDocumentTest 测试类中，编写单元测试：\n\n```java\n@Test\nvoid testUpdateDocument() throws IOException {\n    // 1.准备Request\n    UpdateRequest request = new UpdateRequest(\"hotel\", \"61083\");\n    // 2.准备请求参数\n    request.doc(\n        \"price\", \"952\",\n        \"starName\", \"四钻\"\n    );\n    // 3.发送请求\n    client.update(request, RequestOptions.DEFAULT);\n}\n```\n\n### 删除文档\n\n删除的 DSL 为是这样的：\n\n```json\nDELETE /hotel/_doc/{id}\n```\n\n与查询相比，仅仅是请求方式从 DELETE 变成 GET，可以想象 Java 代码应该依然是三步走：\n\n- 准备 Request 对象，因为是删除，这次是 DeleteRequest 对象。要指定索引库名和 id\n- 准备参数，无参\n- 发送请求。因为是删除，所以是 `client.delete()` 方法\n\n```java\n@Test\nvoid testDeleteDocument() throws IOException {\n    // 1.准备Request\n    DeleteRequest request = new DeleteRequest(\"hotel\", \"61083\");\n    // 2.发送请求\n    client.delete(request, RequestOptions.DEFAULT);\n}\n```\n\n### 批量导入文档\n\n案例需求：利用 BulkRequest 批量将数据库数据导入到索引库中。\n\n步骤如下：\n\n- 利用 mybatis-plus 查询酒店数据\n\n- 将查询到的酒店数据（Hotel）转换为文档类型数据（HotelDoc）\n\n- 利用 JavaRestClient 中的 BulkRequest 批处理，实现批量新增文档\n\n#### 语法说明\n\n批量处理 BulkRequest，其本质就是将多个普通的 CRUD 请求组合在一起发送。\n\n其中提供了一个 add 方法，用来添加其他请求：\n\n- IndexRequest，也就是新增\n- UpdateRequest，也就是修改\n- DeleteRequest，也就是删除\n\n因此 Bulk 中添加了多个 IndexRequest，就是批量新增功能了。示例：\n\n```java\n@Test\nvoid testBulk() throws IOException {\n    // 1.创建Bulk请求\n    BulkRequest request = new BulkRequest();\n    // 2.添加要批量提交的请求：这里添加了两个新增文档的请求\n    request.add(new IndexRequest(\"hotel\")\n                .id(\"101\").source(\"json source\", XContentType.JSON));\n    request.add(new IndexRequest(\"hotel\")\n                .id(\"102\").source(\"json source2\", XContentType.JSON));\n    // 3.发起bulk请求\n    client.bulk(request, RequestOptions.DEFAULT);\n}\n```\n\n其实还是三步走：\n\n- 创建 Request 对象。这里是 BulkRequest\n- 准备参数。批处理的参数，就是其它 Request 对象，这里就是多个 IndexRequest\n- 发起请求。这里是批处理，调用的方法为 `client.bulk()` 方法\n\n我们在导入酒店数据时，将上述代码改造成 for 循环处理即可。\n\n#### 完整代码\n\n在 hotel-demo 的 HotelDocumentTest 测试类中，编写单元测试：\n\n```java\n@Test\nvoid testBulkRequest() throws IOException {\n    // 批量查询酒店数据\n    List<Hotel> hotels = hotelService.list();\n\n    // 1.创建 Request\n    BulkRequest request = new BulkRequest();\n    // 2.准备参数，添加多个新增的 Request\n    for (Hotel hotel : hotels) {\n        // 2.1.转换为文档类型 HotelDoc\n        HotelDoc hotelDoc = new HotelDoc(hotel);\n        // 2.2.创建新增文档的 Request 对象\n        request.add(new IndexRequest(\"hotel\")\n                    .id(hotelDoc.getId().toString())\n                    .source(JSON.toJSONString(hotelDoc), XContentType.JSON));\n    }\n    // 3.发送请求\n    client.bulk(request, RequestOptions.DEFAULT);\n}\n```\n\n测试，批量查询\n\n```\nGET /hotel/_search\n```\n\n### Rest Client 文档操作小结\n\n文档操作的基本步骤：\n\n- 初始化 RestHighLevelClient\n- 创建 XxxRequest。Xxx 是 Index、Get、Update、Delete、Bulk\n- 准备参数（Index、Update、Bulk时需要）\n- 发送请求。调用 `RestHighLevelClient#.xxx()` 方法，xxx 是 index、get、update、delete、bulk\n- 解析结果（Get时需要）\n\n## DSL 查询文档\n\nElasticSearch 的查询依然是基于 JSON 风格的 DSL 来实现的。\n\n### DSL 查询分类\n\nElasticSearch 提供了基于 JSON 的 DSL（[Domain Specific Language](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html)）来定义查询。常见的查询类型包括：\n\n- 查询所有：查询出所有数据，一般测试用。例如：match_all\n\n- 全文检索查询：利用分词器对用户输入内容分词，然后去倒排索引库中匹配。例如：\n  - match_query\n  - multi_match_query\n- 精确查询：根据精确词条值查找数据，一般是查找 keyword、数值、日期、boolean 等类型字段。例如：\n  - ids\n  - range\n  - term\n- 地理（geo）查询：根据经纬度查询。例如：\n  - geo_distance\n  - geo_bounding_box\n- 复合（compound）查询：复合查询可以将上述各种查询条件组合起来，合并查询条件。例如：\n  - bool\n  - function_score\n\n查询的语法基本一致：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"查询类型\": {\n      \"查询条件\": \"条件值\"\n    }\n  }\n}\n```\n\n 我们以查询所有为例，其中：\n\n- 查询类型为 match_all\n- 没有查询条件\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  }\n}\n```\n\n其它查询无非就是查询类型、查询条件的变化。\n\n### 全文检索查询\n\n#### 使用场景\n\n全文检索查询的基本流程如下：\n\n- 对用户搜索的内容做分词，得到词条\n- 根据词条去倒排索引库中匹配，得到文档 id\n- 根据文档 id 找到文档，返回给用户\n\n比较常用的场景包括：\n\n- 商城的输入框搜索\n- 百度输入框搜索\n\n因为是拿着词条去匹配，因此参与搜索的字段也必须是可分词的 text 类型的字段。\n\n#### 基本语法\n\n常见的全文检索查询包括：\n\n- match 查询：单字段查询\n- multi_match 查询：多字段查询，任意一个字段符合条件就算符合查询条件\n\nmatch 查询语法如下：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"match\": {\n      \"FIELD\": \"TEXT\"\n    }\n  }\n}\n```\n\nmulit_match 语法如下：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"multi_match\": {\n      \"query\": \"TEXT\",\n      \"fields\": [\"FIELD1\", \" FIELD12\"]\n    }\n  }\n}\n```\n\n#### 使用示例\n\nmatch 查询示例：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match\": {\n      \"all\": \"如家外滩\"\n    }\n  }\n}\n```\n\nmulti_match 查询示例：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"multi_match\": {\n      \"query\": \"如家外滩\",\n      \"fields\": [\"brand\",\"name\",\"business\"]\n    }\n  }\n}\n```\n\n可以看到，两种查询结果是一样的，为什么？\n\n因为我们将 brand、name、business 值都利用 copy_to 复制到了 all 字段中。因此你根据三个字段搜索，和根据 all 字段搜索效果当然一样了。\n\n但是，搜索字段越多，对查询性能影响越大，因此建议采用 copy_to，然后单字段查询的方式。\n\nmatch 和 multi_match 的区别是什么？\n\n- match：根据一个字段查询\n- multi_match：根据多个字段查询，参与查询字段越多，查询性能越差\n\n### 精准查询\n\n精确查询一般是查找 keyword、数值、日期、boolean 等类型字段。所以不会对搜索条件分词。常见的有：\n\n- term：根据词条精确值查询\n- range：根据值的范围查询\n\n#### term 查询\n\n因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是**不分词**的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。\n\n语法说明：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"term\": {\n      \"FIELD\": {\n        \"value\": \"VALUE\"\n      }\n    }\n  }\n}\n```\n\n示例：\n\n当我搜索的是精确词条时，能正确查询出结果：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"term\": {\n      \"city\": {\n        \"value\": \"上海\"\n      }\n    }\n  }\n}\n```\n\n但是，当我搜索的内容不是词条，而是多个词语形成的短语时，反而搜索不到：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"term\": {\n      \"city\": {\n        \"value\": \"上海杭州\"\n      }\n    }\n  }\n}\n```\n\n#### range 查询\n\n范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。\n\n基本语法：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"range\": {\n      \"FIELD\": {\n        \"gte\": 10,\n        \"lte\": 20\n      }\n    }\n  }\n}\n```\n\n+ gte 代表大于等于，gt 则代表大于\n+ lte 代表小于等于，lt 则代表小于\n\n示例：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"range\": {\n      \"price\": {\n        \"gte\": 1000,\n        \"lte\": 3000\n      }\n    }\n  }\n}\n```\n\n#### 精准查询小结\n\n精确查询常见的有哪些？\n\n- term 查询：根据词条精确匹配，一般搜索 keyword 类型、数值类型、布尔类型、日期类型字段\n- range 查询：根据数值范围查询，可以是数值、日期的范围\n\n### 地理坐标查询\n\n所谓的地理坐标查询，其实就是根据经纬度查询，[官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-queries.html)\n\n常见的使用场景包括：\n\n- 携程：搜索我附近的酒店\n- 滴滴：搜索我附近的出租车\n- 微信：搜索我附近的人\n\n#### 矩形范围查询\n\n矩形范围查询，也就是 geo_bounding_box 查询，查询坐标落在某个矩形范围的所有文档：\n\n查询时，需要指定矩形的**左上**、**右下**两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。\n\n语法如下：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"geo_bounding_box\": {\n      \"FIELD\": {\n        \"top_left\": {\n          \"lat\": 31.1,\n          \"lon\": 121.5\n        },\n        \"bottom_right\": {\n          \"lat\": 30.9,\n          \"lon\": 121.7\n        }\n      }\n    }\n  }\n}\n```\n\n#### 附近查询\n\n附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。\n\n换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：\n\n语法说明：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"geo_distance\": {\n      \"distance\": \"15km\",\n      \"FIELD\": \"31.21,121.5\"\n    }\n  }\n}\n```\n\n我们先搜索陆家嘴附近 15km 的酒店：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"geo_distance\": {\n      \"distance\": \"2km\",\n      \"location\": \"31.21,121.5\"\n    }\n  }\n}\n```\n\n### 复合查询\n\n复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：\n\n- fuction score：算分函数查询，可以控制文档相关性算分，控制文档排名\n- bool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索\n\n#### 相关性算分\n\n当我们利用 match 查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。\n\n例如，我们搜索 \"虹桥如家\"，结果如下：\n\n```json\n[\n  {\n    \"_score\" : 17.850193,\n    \"_source\" : {\n      \"name\" : \"虹桥如家酒店真不错\",\n    }\n  },\n  {\n    \"_score\" : 12.259849,\n    \"_source\" : {\n      \"name\" : \"外滩如家酒店真不错\",\n    }\n  },\n  {\n    \"_score\" : 11.91091,\n    \"_source\" : {\n      \"name\" : \"迪士尼如家酒店真不错\",\n    }\n  }\n]\n```\n\n在 ElasticSearch 中，早期使用的打分算法是 [TF-IDF 算法](https://www.ruanyifeng.com/blog/2013/03/tf-idf.html)，在后来的 5.1 版本升级中，ElasticSearch 将算法改进为 [BM25 算法](https://www.jianshu.com/p/1e498888f505)\n\nTF-IDF 算法有一各缺陷，就是词条频率越高，文档得分也会越高，单个词条对文档影响较大。而 BM25 则会让单个词条的算分有一个上限，曲线更加平滑：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.32gad6dlyzu0.png)\n\n#### 算分函数查询\n\n根据相关度打分是比较合理的需求，但合理的不一定是产品经理需要的。\n\n以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。要想认为控制相关性算分，就需要利用 ElasticSearch 中的 function score 查询了。\n\n语法说明：\n\n![算分函数查询](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/算分函数查询.epggagjz1ts.svg)\n\nfunction score 查询中包含四部分内容：\n\n- 原始查询条件：query 部分，基于这个条件搜索文档，并且基于 BM25 算法给文档打分，原始算分（query score)\n- 过滤条件：filter 部分，符合该条件的文档才会重新算分\n- 算分函数：符合 filter 条件的文档要根据这个函数做运算，得到的函数算分（function score），有四种函数\n  - weight：函数结果是常量\n  - field_value_factor：以文档中的某个字段值作为函数结果\n  - random_score：以随机数作为函数结果\n  - script_score：自定义算分函数算法\n- 运算模式：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括：\n  - multiply：相乘\n  - replace：用 function score 替换 query score\n  - 其它，例如：sum、avg、max、min\n\nfunction score 的运行流程如下：\n\n- 根据原始条件查询搜索文档，并且计算相关性算分，称为原始算分（query score）\n- 根据过滤条件，过滤文档\n- 符合**过滤条件**的文档，基于算分函数运算，得到函数算分（function score）\n- 将原始算分（query score）和函数算分（function score）基于运算模式做运算，得到最终结果，作为相关性算分。\n\n因此，其中的关键点是：\n\n- 过滤条件：决定哪些文档的算分被修改\n- 算分函数：决定函数算分的算法\n- 运算模式：决定最终算分结果\n\n示例\n\n需求：给“如家”这个品牌的酒店排名靠前一些。翻译一下这个需求，转换为之前说的四个要点：\n\n- 原始条件：不确定，可以任意变化\n- 过滤条件：brand = \"如家\"\n- 算分函数：可以简单粗暴，直接给固定的算分结果，weight\n- 运算模式：比如求和\n\n因此最终的 DSL 语句如下：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"function_score\": {\n      \"query\": {\n        \"match\": {\n          \"all\": \"外滩\"\n        }\n      },\n      \"functions\": [\n        {\n          \"filter\": {\n            \"term\": {\n              \"brand\": \"如家\"\n            }\n          },\n          \"weight\": 10\n        }\n      ],\n      \"boost_mode\": \"sum\"\n    }\n  }\n}\n```\n\n#### 布尔查询\n\n布尔查询是一个或多个查询子句的组合，每一个子句就是一个子查询。子查询的组合方式有：\n\n- must：必须匹配每个子查询，类似“与”\n- should：选择性匹配子查询，类似“或”\n- must_not：必须不匹配，**不参与算分**，类似“非”\n- filter：必须匹配，不参与算分\n\n比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤。\n\n每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用 bool 查询了。\n\n需要注意的是，搜索时，参与打分的字段越多，查询的性能也越差。因此这种多条件查询时，建议这样做：\n\n- 搜索框的关键字搜索，是全文检索查询，使用 must 查询，参与算分\n- 其它过滤条件，采用 filter 查询。不参与算分\n\n语法示例：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\n          \"term\": {\n            \"city\": \"上海\"\n          }\n        }\n      ],\n      \"should\": [\n        {\n          \"term\": {\n            \"brand\": \"皇冠假日\"\n          }\n        },\n        {\n          \"term\": {\n            \"brand\": \"华美达\"\n          }\n        }\n      ],\n      \"must_not\": [\n        {\n          \"range\": {\n            \"price\": {\n              \"lte\": 500\n            }\n          }\n        }\n      ],\n      \"filter\": [\n        {\n          \"range\": {\n            \"score\": {\n              \"gte\": 45\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n案例示例：\n\n需求：搜索名字包含“如家”，价格不高于 400，在坐标 31.21,121.5 周围 10km 范围内的酒店。\n\n分析：\n\n- 名称搜索，属于全文检索查询，应该参与算分。放到 must 中\n- 价格不高于 400，用 range 查询，属于过滤条件，不参与算分。放到 must_not 中\n- 周围 10km 范围内，用 geo_distance 查询，属于过滤条件，不参与算分。放到 filter 中\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\n          \"match\": {\n            \"name\": \"如家\"\n          }\n        }\n      ],\n      \"must_not\": [\n        {\n          \"range\": {\n            \"price\": {\n              \"gt\": 400\n            }\n          }\n        }\n      ],\n      \"filter\": [\n        {\n          \"geo_distance\": {\n            \"distance\": \"10km\",\n            \"location\": {\n              \"lat\": 31.21,\n              \"lon\": 121.5\n            }\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\nbool 查询有几种逻辑关系？\n\n- must：必须匹配的条件，可以理解为“与”\n- should：选择性匹配的条件，可以理解为“或”\n- must_not：必须不匹配的条件，不参与打分\n- filter：必须匹配的条件，不参与打分\n\n## DSL 搜索结果处理\n\n搜索的结果可以按照用户指定的方式去处理或展示。\n\n### 排序\n\nElasticSearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索[结果排序](https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html)。可以排序字段类型有：keyword 类型、数值类型、地理坐标类型、日期类型等。\n\n#### 普通字段排序\n\nkeyword、数值、日期类型排序的语法基本一致。\n\n**语法**：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": [\n    {\n      \"FIELD\": \"desc\"  // 排序字段、排序方式ASC、DESC\n    }\n  ]\n}\n```\n\n排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推\n\n**示例**：\n\n需求描述：酒店数据按照用户评价（score）降序排序，评价相同的按照价格（price）升序排序\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": [\n    {\n      \"score\": \"desc\"\n    },\n    {\n      \"price\": \"asc\"\n    }\n  ]\n}\n```\n\n#### 地理坐标排序\n\n地理坐标排序略有不同。\n\n**语法说明**：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": [\n    {\n      \"_geo_distance\" : {\n          \"FIELD\" : \"纬度，经度\", // 文档中geo_point类型的字段名、目标坐标点\n          \"order\" : \"asc\", // 排序方式\n          \"unit\" : \"km\" // 排序的距离单位\n      }\n    }\n  ]\n}\n```\n\n这个查询的含义是：\n\n- 指定一个坐标，作为目标点\n- 计算每一个文档中，指定字段（必须是 geo_point 类型）的坐标到目标点的距离是多少\n- 根据距离排序\n\n**示例：**\n\n需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序\n\n提示：获取经纬度的方式：https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/\n\n假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": [\n    {\n      \"_geo_distance\": {\n        \"location\": {\n          \"lat\": 31.034661,\n          \"lon\": 121.612282\n        },\n        \"order\": \"asc\",\n        \"unit\": \"km\"\n      }\n    }\n  ]\n}\n```\n\n### 分页\n\nElasticSearch 默认情况下只返回 top10 的数据。而如果要查询更多数据就需要修改分页参数了。ElasticSearch中通过修改 from、size 参数来控制要返回的分页结果：\n\n- from：从第几个文档开始\n- size：总共查询几个文档\n\n类似于 MySQL 中的 `limit ?, ?`\n\n#### 基本的分页\n\n分页的基本语法如下：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": [\n    {\n      \"price\": {\n        \"order\": \"asc\"\n      }\n    }\n  ],\n  \"from\": 0,\n  \"size\": 5\n}\n```\n\n#### 深度分页问题\n\n现在，我要查询 990~1000 的数据，查询逻辑要这么写：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"from\": 990, // 分页开始的位置，默认为0\n  \"size\": 10, // 期望获取的文档总数\n  \"sort\": [\n    {\"price\": \"asc\"}\n  ]\n}\n```\n\n这里是查询 990 开始的数据，也就是 第 990~1000 条 数据。\n\n不过，ElasticSearch 内部分页时，必须先查询 0~1000 条，然后截取其中的 990 ~ 1000 的这 10 条：\n\n查询 top 1000，如果 ElasticSearch 是单点模式，这并无太大影响。\n\n但是 ElasticSearch 将来一定是集群，例如我集群有 5 个节点，我要查询 top 1000 的数据，并不是每个节点查询 200 条就可以了。\n\n因为节点 A 的 top 200，在另一个节点可能排到 10000 名以外了。\n\n因此要想获取整个集群的 top 1000，必须先查询出每个节点的 top 1000，汇总结果后，重新排名，重新截取 top 1000。\n\n那如果我要查询 9900~10000 的数据呢？是不是要先查询 top 10000呢？那每个节点都要查询 10000 条？汇总到内存中？\n\n当查询分页深度较大时，汇总数据过多，对内存和 CPU 会产生非常大的压力，因此 ElasticSearch 会禁止 from + size 超过 10000 的请求。\n\n针对深度分页，ElasticSearch 提供了两种解决方案，[官方文档](https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html)：\n\n- search after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。\n- scroll：原理将排序后的文档 id 形成快照，保存在内存。官方已经不推荐使用。\n\n#### 分页小结\n\n分页查询的常见实现方案以及优缺点：\n\n- `from + size`：\n  - 优点：支持随机翻页\n  - 缺点：深度分页问题，默认查询上限（from + size）是 10000\n  - 场景：百度、京东、谷歌、淘宝这样的随机翻页搜索\n- `after search`：\n  - 优点：没有查询上限（单次查询的 size 不超过 10000）\n  - 缺点：只能向后逐页查询，不支持随机翻页\n  - 场景：没有随机翻页需求的搜索，例如手机向下滚动翻页\n\n- `scroll`：\n  - 优点：没有查询上限（单次查询的 size 不超过 10000）\n  - 缺点：会有额外内存消耗，并且搜索结果是非实时的\n  - 场景：海量数据的获取和迁移。从 ES 7.1开始不推荐，建议用 after search 方案。\n\n### 高亮\n\n高亮显示的实现分为两步：\n\n- 给文档中的所有关键字都添加一个标签，例如 `<em>` 标签\n- 页面给 `<em>` 标签编写 CSS 样式\n\n高亮的语法：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match\": {\n      \"FIELD\": \"TEXT\"\n    }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"FIELD\": {\n        \"pre_tags\": \"<em>\",\n        \"post_tags\": \"</em>\"\n      }\n    }\n  }\n}\n```\n\n**注意：**\n\n- 高亮是对关键字高亮，因此搜索条件必须带有关键字，而不能是范围这样的查询。\n- 默认情况下，高亮的字段，必须与搜索指定的字段一致，否则无法高亮\n- 如果要对非搜索字段高亮，则需要添加一个属性： `\"require_field_match\": \"false\"`\n\n示例：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match\": {\n      \"all\": \"如家\"\n    }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"name\": {\n        \"require_field_match\": \"false\"\n      }\n    }\n  }\n}\n```\n\n### 搜索结果处理小结\n\n查询的 DSL 是一个大的 JSON 对象，包含下列属性：\n\n- query：查询条件\n- from 和 size：分页条件\n- sort：排序条件\n- highlight：高亮条件\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match\": {\n      \"name\": \"如家\"\n    }\n  },\n  \"from\": 0, // 分页开始的位置\n  \"size\": 20, // 期望获取的文档总数\n  \"sort\": [ \n    {  \"price\": \"asc\" }, // 普通排序\n    {\n      \"_geo_distance\" : { // 距离排序\n          \"location\" : \"31.040699,121.618075\", \n          \"order\" : \"asc\",\n          \"unit\" : \"km\"\n      }\n    }\n  ],\n  \"highlight\": {\n    \"fields\": { // 高亮字段\n      \"name\": {\n        \"pre_tags\": \"<em>\",  // 用来标记高亮字段的前置标签\n        \"post_tags\": \"</em>\" // 用来标记高亮字段的后置标签\n      }\n    }\n  }\n}\n```\n\n## Rest Client 查询文档\n\n文档的查询同样适用 RestHighLevelClient 对象，基本步骤包括：\n\n- 准备 Request 对象\n- 准备请求参数\n- 发起请求\n- 解析响应\n\n### 快速入门\n\n我们以 match_all 查询为例\n\n#### 发起查询请求\n\n```java\n@Test\nvoid testMatchAll() throws IOException {\n    // 1.准备Request\n    SearchRequest request = new SearchRequest(\"hotel\");\n    // 2.组织DSL参数\n    request.source().query(QueryBuilders.matchAllQuery());\n    // 3.发送请求，得到响应结果\n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n    // ...解析响应结果\n}\n```\n\n代码解读：\n\n- 第一步，创建 `SearchRequest` 对象，指定索引库名\n\n- 第二步，利用 `request.source()` 构建 DSL，DSL 中可以包含查询、分页、排序、高亮等\n  - `query()`：代表查询条件，利用 `QueryBuilders.matchAllQuery()` 构建一个 match_all 查询的 DSL\n- 第三步，利用 `client.search()` 发送请求，得到响应\n\n这里关键的 API 有两个：\n\n+ 一个是 `request.source()`，其中包含了查询、排序、分页、高亮等所有功能。\n+ 另一个是 `QueryBuilders`，其中包含 match、term、function_score、bool 等各种查询：\n\n#### 解析响应\n\nElasticSearch 返回的结果是一个 JSON 字符串，结构包含：\n\n```json\n{\n   \"took\" : 0,\n   \"timed_out\" : false,\n   \"hits\" : {\n    \"total\" : {\n      \"value\" : 2,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : 1.0,\n    \"hits\" : [\n      {\n        \"_index\" : \"heima\",\n        \"_type\" : \"_doc\",\n        \"_id\" : \"1\",\n        \"_score\" : 1.0,\n        \"_source\" : {\n          \"info\" : \"Java讲师\", 	\"name\" : \"赵云\",\n       }\n      },\n      // ...\n    ]\n  }\n}\n```\n\n- `hits`：命中的结果\n  - `total`：总条数，其中的 value 是具体的总条数值\n  - `max_score`：所有结果中得分最高的文档的相关性算分\n  - `hits`：搜索结果的文档数组，其中的每个文档都是一个 JSON 对象\n    - `_source`：文档中的原始数据，也是 JSON 对象\n\n因此，我们解析响应结果，就是逐层解析 JSON 字符串，流程如下：\n\n```java\n@Test\nvoid testMatchAll() throws IOException {\n    // ... 略\n    // 4.解析结果\n    SearchHits searchHits = response.getHits();\n    // 4.1.查询的总条数\n    long total = searchHits.getTotalHits().value;\n    // 4.2.查询的结果数组\n    SearchHit[] hits = searchHits.getHits();\n    for (SearchHit hit : hits) {\n        // 4.3.得到source\n        String json = hit.getSourceAsString();\n        // 4.4.打印\n        System.out.println(json);\n    }\n}\n```\n\n- `SearchHits`：通过 `response.getHits()` 获取，就是 JSON 中的最外层的hits，代表命中的结果\n  - `SearchHits#getTotalHits().value`：获取总条数信息\n  - `SearchHits#getHits()`：获取 SearchHit 数组，也就是文档数组\n    - `SearchHit#getSourceAsString()`：获取文档结果中的_source，也就是原始的 JSON 文档数据\n\n#### 完整代码\n\n```java\n    @Test\n    void testMatchAll() throws IOException {\n        // 1.准备 Request\n        SearchRequest request = new SearchRequest(\"hotel\");\n        // 2.组织 DSL 参数\n        request.source().query(QueryBuilders.matchAllQuery());\n        // 3.发送请求，得到响应结果\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n        // 4.解析结果\n        SearchHits searchHits = response.getHits();\n        // 4.1.查询的总条数\n        long total = searchHits.getTotalHits().value;\n        System.err.println(\"total = \" + total);\n        // 4.2.查询的结果数组\n        SearchHit[] hits = searchHits.getHits();\n        for (SearchHit hit : hits) {\n            // 4.3.得到source\n            String json = hit.getSourceAsString();\n            // 反序列化\n            HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);\n            // 4.4.打印\n            System.out.println(hotelDoc);\n        }\n    }\n```\n\n#### 快速入门小结\n\n查询的基本步骤是：\n\n1. 创建 SearchRequest 对象\n2. 准备 `Request.source()`，也就是 DSL。\n   + QueryBuilders 来构建查询条件\n   + 传入 `Request.source()` 的 `query()` 方法\n3. 发送请求，得到结果\n4. 解析结果（参考 JSON 结果，从外到内，逐层解析）\n\n### match 查询\n\n全文检索的 match 和 multi_match 查询与 match_all 的 API 基本一致。差别是查询条件，也就是 query 的部分。\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  }\n}\n\nGET /hotel/_search\n{\n  \"query\": {\n    \"match\": {\n      \"all\": \"如家\"\n    }\n  }\n}\n\nGET /hotel/_search\n{\n  \"query\": {\n    \"multi_match\": {\n      \"query\": \"如家\",\n      \"fields\": [\"brand\", \"name\"]\n    }\n  }\n}\n```\n\n因此，Java 代码上的差异主要是 `request.source().query()` 中的参数了。同样是利用 QueryBuilders 提供的方法：\n\n```java\n// 单字段查询\nQueryBuilders.matchQuery(\"all\", \"如家\");\n// 多字段查询\nQueryBuilders.multiMatchQuery(\"如家\", \"name\", \"business\");\n```\n\n而结果解析代码则完全一致，可以抽取并共享。\n\n完整代码如下：\n\n```java\n@Test\nvoid testMatch() throws IOException {\n    // 1.准备Request\n    SearchRequest request = new SearchRequest(\"hotel\");\n    // 2.准备DSL\n    request.source().query(QueryBuilders.matchQuery(\"all\", \"如家\"));\n    // 3.发送请求\n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n    // 4.解析响应\n    handleResponse(response);\n}\n```\n\n> IDEA 代码抽取 Ctrl + Alt + M\n\n### 精确查询\n\n精确查询主要是两者：\n\n- term：词条精确匹配\n- range：范围查询\n\n与之前的查询相比，差异同样在查询条件，其它都一样。\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"term\": {\n      \"city\": \"杭州\"\n    }\n  }\n}\nGET /hotel/_search\n{\n  \"query\": {\n    \"range\": {\n      \"price\": { \"gte\": 100, \"lte\": 150 }\n    }\n  }\n}\n```\n\n查询条件构造的 API 如下：\n\n```java\n// 词条查询\nQueryBuilders.termQuery(\"city\", \"杭州\"); \n// 范围查询\nQueryBuilders.rangeQuery(\"price\").gte(100).lte(150);\n```\n\n### 布尔查询\n\n布尔查询是用 must、must_not、filter 等方式组合其它查询，代码示例如下：\n\n```java\n// 创建布尔查询\nBoolQueryBuilder boolQuery = QueryBuilders.boolQuery();\n// 添加must条件\nboolQuery.must(QueryBuilders.termQuery(\"city\", \"杭州\")); \n// 添加filter条件\nboolQuery.filter(QueryBuilders.rangeQuery(\"price\").lte(250));\n```\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"bool\": {\n      \"must\": [\n        {\n          \"term\": { \"city\": \"杭州\" }\n        }\n      ],\n      \"filter\": [\n        {\n          \"range\": {\n            \"price\": { \"lte\": 250 }\n          }\n        }\n      ]\n    }\n  }\n}\n```\n\n可以看到，API 与其它查询的差别同样是在查询条件的构建，QueryBuilders，结果解析等其他代码完全不变。\n\n示例代码：\n\n```java\n@Test\nvoid testBool() throws IOException {\n    // 1.准备Request\n    SearchRequest request = new SearchRequest(\"hotel\");\n    \n    // 2.准备DSL\n    // 2.1.准备BooleanQuery\n    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();\n    // 2.2.添加term\n    boolQuery.must(QueryBuilders.termQuery(\"city\", \"上海\"));\n    // 2.3.添加range\n    boolQuery.filter(QueryBuilders.rangeQuery(\"price\").lte(250));\n    \n    request.source().query(boolQuery);\n    \n    // 3.发送请求\n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n    \n    // 4.解析响应\n    handleResponse(response);\n}\n```\n\n\n\n## Rest Client 搜索结果处理\n\n### 排序与分页\n\n搜索结果的排序和分页是与 query 同级的参数，因此同样是使用 `request.source()` 来设置。\n\n对应的 API 如下：\n\n```java\n// 查询 \nrequest.source().query(QueryBuilders.matchAllQuery());\n// 排序\nrequest.source().sort(\"price\", SortOrder.ASC);\n// 分页\nrequest.source().from(0).size(5);\n```\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"from\": 0,\n  \"size\": 5, \n  \"sort\": [\n    {\n      \"FIELD\": \"desc\"  \n    },\n  ]\n}\n```\n\n代码示例：\n\n```java\n@Test\nvoid testPageAndSort() throws IOException {\n    // 页码，每页大小\n    int page = 1, size = 5;\n    // 1.准备Request\n    SearchRequest request = new SearchRequest(\"hotel\");\n    // 2.准备DSL\n    // 2.1.query\n    request.source().query(QueryBuilders.matchAllQuery());\n    // 2.2.排序 sort\n    request.source().sort(\"price\", SortOrder.ASC);\n    // 2.3.分页 from、size\n    request.source().from((page - 1) * size).size(size);\n    // 3.发送请求\n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n    // 4.解析响应\n    handleResponse(response);\n}\n```\n\n### 高亮\n\n高亮的代码与之前代码差异较大，有两点：\n\n- 查询的 DSL：其中除了查询条件，还需要添加高亮条件，同样是与 query 同级。\n- 结果解析：结果除了要解析 _source 文档数据，还要解析高亮结果\n\n#### 高亮请求构建\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match\": {\n      \"all\": \"如家\"\n    }\n  },\n  \"highlight\": {\n    \"fields\": {\n      \"name\": {\n        \"require_field_match\": \"false\"\n      }\n    }\n  }\n}\n```\n\n高亮请求的构建 API 如下：\n\n```java\nrequest.source().highlighter(new HighlightBuilder().field(\"name\").requireFieldMatch(false));\n```\n\n上述代码省略了查询条件部分，但是大家不要忘了：高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。\n\n示例代码如下：\n\n```java\n@Test\nvoid testHighlight() throws IOException {\n    // 1.准备Request\n    SearchRequest request = new SearchRequest(\"hotel\");\n    // 2.准备DSL\n    // 2.1.query\n    request.source().query(QueryBuilders.matchQuery(\"all\", \"如家\"));\n    // 2.2.高亮\n    request.source().highlighter(new HighlightBuilder().field(\"name\").requireFieldMatch(false));\n    // 3.发送请求\n    SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n    // 4.解析响应\n    handleResponse(response);\n}\n```\n\n#### 高亮结果解析\n\n高亮的结果与查询的文档结果默认是分离的，并不在一起。\n\n```json\n{\n  \"_index\" : \"hotel\",\n  \"_type\" : \"_doc\",\n  \"_id\" : \"339952837\",\n  \"_score\" : 2.8947515,\n  \"_source\" : {\n    \"id\" : 339952837,\n    \"name\" : \"如家酒店(北京良乡西路店)\",\n    \"price\" : 159,\n    \"score\" : 46,\n    \"brand\" : \"如家\",\n    \"city\" : \"北京\",\n    \"location\" : \"39.73167, 116.132482\",\n    \"pic\" : \"t0.jpg\"\n  },\n  \"highlight\" : {\n    \"name\" : [\n      \"<em>如家</em>酒店(北京良乡西路店)\",\n    ]\n  }\n}\n```\n\n因此解析高亮的代码需要额外处理：\n\n```java\n// 获取source\nHotelDoc hotelDoc = JSON.parseObject(hit.getSourceAsString(), HotelDoc.class);\n// 处理高亮\nMap<String, HighlightField> highlightFields = hit.getHighlightFields();\nif (!CollectionUtils.isEmpty(highlightFields)) {\n    // 获取高亮字段结果\n    HighlightField highlightField = highlightFields.get(\"name\");\n    if (highlightField != null) {\n        // 取出高亮结果数组中的第一个，就是酒店名称\n        String name = highlightField.getFragments()[0].string();\n        hotelDoc.setName(name);\n    }\n}\n```\n\n代码解读：\n\n- 第一步：从结果中获取 source。`hit.getSourceAsString()`，这部分是非高亮结果，JSON 字符串。还需要反序列为 HotelDoc 对象\n- 第二步：获取高亮结果。`hit.getHighlightFields()`，返回值是一个 Map，key 是高亮字段名称，值是 HighlightField 对象，代表高亮值\n- 第三步：从 Map 中根据高亮字段名称，获取高亮字段值对象HighlightField\n- 第四步：从HighlightField 中获取 Fragments，并且转为字符串。这部分就是真正的高亮字符串了\n- 第五步：用高亮的结果替换 HotelDoc 中的非高亮结果\n\n## 酒店搜索案例\n\n下面，我们通过酒店搜索案例来实战演练下之前学习的知识。\n\n我们实现四部分功能：\n\n- 酒店搜索和分页\n- 酒店结果过滤\n- 我周边的酒店\n- 酒店竞价排名\n\n启动 hotel-demo 项目，其默认端口是 8089，访问 http://localhost:8090，就能看到项目页面了。\n\n### 酒店搜索和分页\n\n案例需求：实现黑马旅游的酒店搜索功能，完成关键字搜索和分页\n\n#### 需求分析\n\n- 请求方式：POST\n- 请求路径：/hotel/list\n- 请求参数：JSON 对象，包含4个字段：\n  - key：搜索关键字\n  - page：页码\n  - size：每页大小\n  - sortBy：排序，目前暂不实现\n- 返回值：分页查询，需要返回分页结果 PageResult，包含两个属性：\n  - `total`：总条数\n  - `List<HotelDoc>`：当前页的数据\n\n因此，我们实现业务的流程如下：\n\n- 步骤一：定义实体类，接收请求参数的 JSON 对象\n- 步骤二：编写 controller，接收页面的请求\n- 步骤三：编写业务实现，利用 RestHighLevelClient 实现搜索、分页\n\n#### 定义实体类\n\n实体类有两个，一个是前端的请求参数实体，一个是服务端应该返回的响应结果实体。\n\n① 请求参数，前端请求的 JSON 结构如下：\n\n```json\n{\n    \"key\": \"搜索关键字\",\n    \"page\": 1,\n    \"size\": 3,\n    \"sortBy\": \"default\"\n}\n```\n\n因此，我们在 `cn.itcast.hotel.pojo` 包下定义一个实体类：\n\n```java\npackage cn.itcast.hotel.pojo;\n\nimport lombok.Data;\n\n@Data\npublic class RequestParams {\n    private String key;\n    private Integer page;\n    private Integer size;\n    private String sortBy;\n}\n```\n\n② 返回值，分页查询，需要返回分页结果 PageResult，包含两个属性：\n\n- `total` ：总条数\n- `List<HotelDoc>` ：当前页的数据\n\n因此，我们在 `cn.itcast.hotel.pojo` 中定义返回结果：\n\n```java\npackage cn.itcast.hotel.pojo;\n\nimport lombok.Data;\n\nimport java.util.List;\n\n@Data\npublic class PageResult {\n    private Long total;\n    private List<HotelDoc> hotels;\n\n    public PageResult() {\n    }\n\n    public PageResult(Long total, List<HotelDoc> hotels) {\n        this.total = total;\n        this.hotels = hotels;\n    }\n}\n```\n\n#### 定义 controller\n\n定义一个 HotelController，声明查询接口，满足下列要求：\n\n- 请求方式：Post\n- 请求路径：/hotel/list\n- 请求参数：对象，类型为 RequestParam\n- 返回值：PageResult，包含两个属性\n  - `Long total`：总条数\n  - `List<HotelDoc> hotels`：酒店数据\n\n因此，我们在 `cn.itcast.hotel.web` 中定义 HotelController：\n\n```java\n@RestController\n@RequestMapping(\"/hotel\")\npublic class HotelController {\n\n    @Autowired\n    private IHotelService hotelService;\n	// 搜索酒店数据\n    @PostMapping(\"/list\")\n    public PageResult search(@RequestBody RequestParams params){\n        return hotelService.search(params);\n    }\n}\n```\n\n#### 实现搜索业务\n\n我们在 controller 调用了 IHotelService，并没有实现该方法，因此下面我们就在 IHotelService 中定义方法，并且去实现业务逻辑。\n\n① 在 `cn.itcast.hotel.service` 中的 `IHotelService` 接口中定义一个方法：\n\n```java\n/**\n * 根据关键字搜索酒店信息\n * @param params 请求参数对象，包含用户输入的关键字 \n * @return 酒店文档列表\n */\nPageResult search(RequestParams params);\n```\n\n② 实现搜索业务，肯定离不开 RestHighLevelClient，我们需要把它注册到 Spring 中作为一个 Bean。在 `cn.itcast.hotel` 中的 `HotelDemoApplication` 中声明这个 Bean：\n\n```java\n@Bean\npublic RestHighLevelClient client() {\n    return new RestHighLevelClient(RestClient.builder(HttpHost.create(\"http://halo:9200\")));\n}\n```\n\n③ 在 `cn.itcast.hotel.service.impl` 中的 `HotelService` 中实现 search 方法：\n\n```java\n@Autowired\nprivate RestHighLevelClient client;\n\n@Override\npublic PageResult search(RequestParams params) {\n    try {\n        // 1.准备Request\n        SearchRequest request = new SearchRequest(\"hotel\");\n        // 2.准备DSL\n        // 2.1.query\n        String key = params.getKey();\n        if (key == null || \"\".equals(key)) {\n            request.source().query(QueryBuilders.matchAllQuery());\n        } else {\n            request.source().query(QueryBuilders.matchQuery(\"all\", key));\n        }\n\n        // 2.2.分页\n        int page = params.getPage();\n        int size = params.getSize();\n        request.source().from((page - 1) * size).size(size);\n\n        // 3.发送请求\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n        // 4.解析响应\n        return handleResponse(response);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n\n// 结果解析\nprivate PageResult handleResponse(SearchResponse response) {\n    // 4.解析响应\n    SearchHits searchHits = response.getHits();\n    // 4.1.获取总条数\n    long total = searchHits.getTotalHits().value;\n    // 4.2.文档数组\n    SearchHit[] hits = searchHits.getHits();\n    // 4.3.遍历\n    List<HotelDoc> hotels = new ArrayList<>();\n    for (SearchHit hit : hits) {\n        // 获取文档source\n        String json = hit.getSourceAsString();\n        // 反序列化\n        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);\n        // 放入集合\n        hotels.add(hotelDoc);\n    }\n    // 4.4.封装返回\n    return new PageResult(total, hotels);\n}\n```\n\n### 酒店结果过滤\n\n需求：添加品牌、城市、星级、价格等过滤功能\n\n#### 需求分析\n\n包含的过滤条件有：\n\n- brand：品牌值\n- city：城市\n- minPrice~maxPrice：价格范围\n- starName：星级\n\n我们需要做两件事情：\n\n- 修改请求参数的对象 RequestParams，接收上述参数\n- 修改业务逻辑，在搜索条件之外，添加一些过滤条件\n\n#### 修改实体类\n\n修改在 `cn.itcast.hotel.pojo` 包下的实体类 RequestParams：\n\n```java\n@Data\npublic class RequestParams {\n    private String key;\n    private Integer page;\n    private Integer size;\n    private String sortBy;\n    // 下面是新增的过滤条件参数\n    private String city;\n    private String brand;\n    private String starName;\n    private Integer minPrice;\n    private Integer maxPrice;\n}\n```\n\n#### 修改搜索业务\n\n在 HotelService 的 search 方法中，只有一个地方需要修改：`requet.source().query( ... )` 其中的查询条件。\n\n在之前的业务中，只有 match 查询，根据关键字搜索，现在要添加条件过滤，包括：\n\n- 品牌过滤：是 keyword 类型，用 term 查询\n- 星级过滤：是 keyword 类型，用 term 查询\n- 价格过滤：是数值类型，用 range 查询\n- 城市过滤：是 keyword 类型，用 term 查询\n\n多个查询条件组合，肯定是 boolean 查询来组合：\n\n- 关键字搜索放到 must 中，参与算分\n- 其它过滤条件放到 filter 中，不参与算分\n\n因为条件构建的逻辑比较复杂，这里封装为一个函数，getBoolQueryBuilder 的代码如下：\n\n```java\nprivate BoolQueryBuilder getBoolQueryBuilder(RequestParams params) {\n    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();\n    String key = params.getKey();\n    if (key == null || \"\".equals(key)) {\n        boolQuery.must(QueryBuilders.matchAllQuery());\n    } else {\n        boolQuery.must(QueryBuilders.matchQuery(\"all\", key));\n    }\n    // 条件过滤\n    // 城市条件\n    if (params.getCity() != null && !params.getCity().equals(\"\")) {\n        boolQuery.filter(QueryBuilders.termQuery(\"city\", params.getCity()));\n    }\n    // 品牌条件\n    if (params.getBrand() != null && !params.getBrand().equals(\"\")) {\n        boolQuery.filter(QueryBuilders.termQuery(\"brand\", params.getBrand()));\n    }\n    // 星级\n    if (params.getStarName() != null && !params.getStarName().equals(\"\")) {\n        boolQuery.filter(QueryBuilders.termQuery(\"starName\", params.getStarName()));\n    }\n    // 价格\n    if (params.getMinPrice() != null && params.getMaxPrice() != null) {\n        boolQuery.filter(QueryBuilders.rangeQuery(\"price\")\n                         .gte(params.getMinPrice()).lte(params.getMaxPrice()));\n    }\n    return boolQuery;\n}\n```\n\n### 我周边的酒店\n\n需求：我附近的酒店\n\n#### 需求分析\n\n在酒店列表页的右侧，有一个小地图，点击地图的定位按钮，地图会找到你所在的位置，并且，在前端会发起查询请求，将你的坐标发送到服务端。\n\n我们要做的事情就是基于这个 location 坐标，然后按照距离对周围酒店排序。实现思路如下：\n\n- 修改 RequestParams 参数，接收 location 字段\n- 修改 search 方法业务逻辑，如果 location 有值，添加根据 geo_distance 排序的功能\n\n#### 修改实体类\n\n修改在 `cn.itcast.hotel.pojo` 包下的实体类 RequestParams：\n\n```java\npackage cn.itcast.hotel.pojo;\n\nimport lombok.Data;\n\n@Data\npublic class RequestParams {\n    private String key;\n    private Integer page;\n    private Integer size;\n    private String sortBy;\n    private String city;\n    private String brand;\n    private String starName;\n    private Integer minPrice;\n    private Integer maxPrice;\n    // 我当前的地理坐标\n    private String location;\n}\n```\n\n#### 距离排序 API\n\n我们以前学习过排序功能，包括两种：\n\n- 普通字段排序\n- 地理坐标排序\n\n我们只讲了普通字段排序对应的 Java 写法。地理坐标排序只学过 DSL 语法，如下：\n\n```json\nGET /indexName/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  },\n  \"sort\": [\n    {\n      \"price\": \"asc\"  \n    },\n    {\n      \"_geo_distance\" : {\n          \"FIELD\" : \"纬度，经度\",\n          \"order\" : \"asc\",\n          \"unit\" : \"km\"\n      }\n    }\n  ]\n}\n```\n\n对应 Java 代码\n\n```java\n// 价格排序\nrequest.source().sort(\"price\", SortOrder.ASC);\n// 距离排序\nrequest.source().sort(SortBuilders.geoDistanceSort(\"location\", new GeoPoint(\"31.21, 121.5\"))\n                      .order(SortOrder.ASC).unit(DistanceUnit.KILOMETERS));\n```\n\n#### 添加距离排序\n\n在 `cn.itcast.hotel.service.impl` 的 `HotelService` 的 `search` 方法中，添加一个排序功能：\n\n```java\n@Override\npublic PageResult search(RequestParams params) {\n    try {\n        // 1.准备Request\n        SearchRequest request = new SearchRequest(\"hotel\");\n        // 2.准备DSL\n        // 2.1.query\n        // 构建 boolQuery\n        BoolQueryBuilder boolQuery = getBoolQueryBuilder(params);\n        request.source().query(boolQuery);\n\n        // 2.2.分页\n        int page = params.getPage();\n        int size = params.getSize();\n        request.source().from((page - 1) * size).size(size);\n\n        // 排序\n        String location = params.getLocation();\n        if (location != null && !location.equals(\"\")) {\n            request.source().sort(SortBuilders\n                                  .geoDistanceSort(\"location\", new GeoPoint(location))\n                                  .order(SortOrder.ASC)\n                                  .unit(DistanceUnit.KILOMETERS));\n        }\n\n        // 3.发送请求\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n        // 4.解析响应\n        return handleResponse(response);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n\n#### 排序距离显示\n\n排序完成后，页面还要获取我附近每个酒店的具体**距离**值，这个值在响应结果中是独立的：\n\n因此，我们在结果解析阶段，除了解析 source 部分以外，还要得到 sort 部分，也就是排序的距离，然后放到响应结果中。\n\n我们要做两件事：\n\n- 修改 HotelDoc，添加排序距离字段，用于页面显示\n- 修改 HotelService 类中的 handleResponse 方法，添加对 sort 值的获取\n\n① 修改HotelDoc类，添加距离字段\n\n```java\npackage cn.itcast.hotel.pojo;\n\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\n\n@Data\n@NoArgsConstructor\npublic class HotelDoc {\n    private Long id;\n    private String name;\n    private String address;\n    private Integer price;\n    private Integer score;\n    private String brand;\n    private String city;\n    private String starName;\n    private String business;\n    private String location;\n    private String pic;\n    // 排序时的 距离值\n    private Object distance;\n\n    public HotelDoc(Hotel hotel) {\n        this.id = hotel.getId();\n        this.name = hotel.getName();\n        this.address = hotel.getAddress();\n        this.price = hotel.getPrice();\n        this.score = hotel.getScore();\n        this.brand = hotel.getBrand();\n        this.city = hotel.getCity();\n        this.starName = hotel.getStarName();\n        this.business = hotel.getBusiness();\n        this.location = hotel.getLatitude() + \", \" + hotel.getLongitude();\n        this.pic = hotel.getPic();\n    }\n}\n```\n\n② 修改 HotelService 中的 handleResponse 方法\n\n```java\n// 结果解析\nprivate PageResult handleResponse(SearchResponse response) {\n    // 4.解析响应\n    SearchHits searchHits = response.getHits();\n    // 4.1.获取总条数\n    long total = searchHits.getTotalHits().value;\n    // 4.2.文档数组\n    SearchHit[] hits = searchHits.getHits();\n    // 4.3.遍历\n    List<HotelDoc> hotels = new ArrayList<>();\n    for (SearchHit hit : hits) {\n        // 获取文档source\n        String json = hit.getSourceAsString();\n        // 反序列化\n        HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);\n        // 获取排序值 - location\n        Object[] sortValues = hit.getSortValues();\n        if (sortValues.length > 0) {\n            Object sortValue = sortValues[0];\n            hotelDoc.setDistance(sortValue);\n        }\n\n        // 放入集合\n        hotels.add(hotelDoc);\n    }\n    // 4.4.封装返回\n    return new PageResult(total, hotels);\n}\n```\n\n### 酒店竞价排名\n\n需求：让指定的酒店在搜索结果中排名置顶\n\n#### 需求分析\n\n要让指定酒店在搜索结果中排名置顶，页面会给指定的酒店添加**广告**标记。\n\n我们之前学习过的 function_score 查询可以影响算分，算分高了，自然排名也就高了。而 function_score 包含 3 个要素：\n\n- 过滤条件：哪些文档要加分\n- 算分函数：如何计算 function score\n- 加权方式：function score 与 query score 如何运算\n\n这里的需求是：让**指定酒店**排名靠前。因此我们需要给这些酒店添加一个标记，这样在过滤条件中就可以根据这个标记来判断，是否要提高算分。\n\n比如，我们给酒店添加一个字段：isAD，Boolean 类型：\n\n- true：是广告\n- false：不是广告\n\n这样 function_score 包含 3 个要素就很好确定了：\n\n- 过滤条件：判断 isAD 是否为 true\n- 算分函数：我们可以用最简单暴力的 weight，固定加权值\n- 加权方式：可以用默认的相乘，大大提高算分\n\n因此，业务的实现步骤包括：\n\n1. 给 HotelDoc 类添加 isAD 字段，Boolean 类型\n\n2. 挑选几个你喜欢的酒店，给它的文档数据添加 isAD 字段，值为 true\n\n3. 修改 search方法，添加 function score 功能，给 isAD 值为 true 的酒店增加权重\n\n#### 修改 HotelDoc 实体\n\n给 `cn.itcast.hotel.pojo` 包下的 HotelDoc 类添加 isAD 字段：\n\n```java\n@Data\n@NoArgsConstructor\npublic class HotelDoc {\n    private Long id;\n    private String name;\n    private String address;\n    private Integer price;\n    private Integer score;\n    private String brand;\n    private String city;\n    private String starName;\n    private String business;\n    private String location;\n    private String pic;\n    // 排序时的距离值\n    private Object distance;\n    private Boolean isAD;\n\n    public HotelDoc(Hotel hotel) {\n        this.id = hotel.getId();\n        this.name = hotel.getName();\n        this.address = hotel.getAddress();\n        this.price = hotel.getPrice();\n        this.score = hotel.getScore();\n        this.brand = hotel.getBrand();\n        this.city = hotel.getCity();\n        this.starName = hotel.getStarName();\n        this.business = hotel.getBusiness();\n        this.location = hotel.getLatitude() + \", \" + hotel.getLongitude();\n        this.pic = hotel.getPic();\n    }\n}\n```\n\n#### 添加广告标记\n\n用 DSL 添加酒店广告标记\n\n```java\nPOST /hotel/_update/36934\n{\n  \"doc\": {\n    \"isAD\": true\n  }\n}\n```\n\n#### 添加算分函数查询\n\n接下来我们就要修改查询条件了。之前是用的 boolean 查询，现在要改成 function_socre 查询。\n\nfunction_score 查询结构如下：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"function_score\": {\n      \"query\": {\n        \"match\": {\n          \"name\": \"外滩\"\n        }\n      },\n      \"functions\": [ \n        {\n          \"filter\": {\n            \"term\": {\n              \"brand\": \"如家\"\n            }\n          },\n          \"weight\": 5\n        }\n      ]\n    }\n  }\n}\n```\n\n对应的 JavaAPI 如下\n\n```java\nFunctionScoreQueryBuilder functionScoreQueryBuilder = \n    QueryBuilders.functionScoreQuery(\n        QueryBuilders.matchQuery(\"name\", \"外滩\"),\n        new FunctionScoreQueryBuilder.FilterFunctionBuilder[]{\n            new FunctionScoreQueryBuilder.FilterFunctionBuilder(\n                QueryBuilders.termQuery(\"brand\", \"如家\"), \n                ScoreFunctionBuilders.weightFactorFunction(5)\n            )\n        }\n	);\nsourceBuilder.query(functionScoreQueryBuilder);\n```\n\n我们可以将之前写的 boolean 查询作为**原始查询**条件放到 query 中，接下来就是添加过滤条件、算分函数、加权模式了。所以原来的代码依然可以沿用。\n\n修改 `cn.itcast.hotel.service.impl` 包下的 `HotelService` 类中的 `getQueryBuilder` 方法，添加算分函数查询：\n\n```java\nprivate FunctionScoreQueryBuilder getQueryBuilder(RequestParams params) {\n    BoolQueryBuilder boolQuery = QueryBuilders.boolQuery();\n    String key = params.getKey();\n    if (key == null || \"\".equals(key)) {\n        boolQuery.must(QueryBuilders.matchAllQuery());\n    } else {\n        boolQuery.must(QueryBuilders.matchQuery(\"all\", key));\n    }\n    // 条件过滤\n    // 城市条件\n    if (params.getCity() != null && !params.getCity().equals(\"\")) {\n        boolQuery.filter(QueryBuilders.termQuery(\"city\", params.getCity()));\n    }\n    // 品牌条件\n    if (params.getBrand() != null && !params.getBrand().equals(\"\")) {\n        boolQuery.filter(QueryBuilders.termQuery(\"brand\", params.getBrand()));\n    }\n    // 星级\n    if (params.getStarName() != null && !params.getStarName().equals(\"\")) {\n        boolQuery.filter(QueryBuilders.termQuery(\"starName\", params.getStarName()));\n    }\n    // 价格\n    if (params.getMinPrice() != null && params.getMaxPrice() != null) {\n        boolQuery.filter(QueryBuilders.rangeQuery(\"price\")\n                         .gte(params.getMinPrice()).lte(params.getMaxPrice()));\n    }\n\n    // 算分控制\n    FunctionScoreQueryBuilder functionScoreQueryBuilder =\n        QueryBuilders.functionScoreQuery(\n        // 原始查询，相关性算分\n        boolQuery,\n        // function score\n        new FunctionScoreQueryBuilder.FilterFunctionBuilder[]{\n            // 一个 function score 元素\n            new FunctionScoreQueryBuilder.FilterFunctionBuilder(\n                // 过滤条件\n                QueryBuilders.termQuery(\"isAD\", true),\n                // 算分函数\n                ScoreFunctionBuilders.weightFactorFunction(10)\n            )\n        });\n\n    return functionScoreQueryBuilder;\n}\n```\n\n## 数据聚合\n\n[聚合](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html)（aggregation） 可以让我们极其方便的实现对数据的统计、分析、运算。例如：\n\n- 什么品牌的手机最受欢迎？\n- 这些手机的平均价格、最高价格、最低价格？\n- 这些手机每月的销售情况如何？\n\n实现这些统计功能的比数据库的 SQL 要方便的多，而且查询速度非常快，可以实现近实时搜索效果。\n\n### 聚合的种类\n\n聚合常见的有三类：\n\n- 桶（Bucket）聚合：用来对文档做分组\n  - TermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组\n  - Date Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组\n\n- 度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等\n  - Avg：求平均值\n  - Max：求最大值\n  - Min：求最小值\n  - Stats：同时求 max、min、avg、sum 等\n- 管道（pipeline）聚合：其它聚合的结果为基础做聚合\n\n> **注意：**参加聚合的字段必须是 keyword、日期、数值、布尔类型\n\n### DSL 实现聚合\n\n现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。\n\n此时可以根据酒店品牌的名称做聚合，也就是 Bucket 聚合。\n\n#### Bucket 聚合语法\n\n语法如下：\n\n```json\nGET /hotel/_search\n{\n  \"size\": 0,  // 设置 size 为 0，结果中不包含文档，只包含聚合结果\n  \"aggs\": { // 定义聚合\n    \"brandAgg\": { //给聚合起个名字\n      \"terms\": { // 聚合的类型，按照品牌值聚合，所以选择term\n        \"field\": \"brand\", // 参与聚合的字段\n        \"size\": 5 // 希望获取的聚合结果数量\n      }\n    }\n  }\n}\n```\n\n结果如下：\n\n```json\n{\n  \"took\" : 36,\n  \"timed_out\" : false,\n  \"_shards\" : {\n    \"total\" : 1,\n    \"successful\" : 1,\n    \"skipped\" : 0,\n    \"failed\" : 0\n  },\n  \"hits\" : {\n    \"total\" : {\n      \"value\" : 201,\n      \"relation\" : \"eq\"\n    },\n    \"max_score\" : null,\n    \"hits\" : [ ]\n  },\n  \"aggregations\" : {\n    \"brandAgg\" : {\n      \"doc_count_error_upper_bound\" : 0,\n      \"sum_other_doc_count\" : 96,\n      \"buckets\" : [\n        {\n          \"key\" : \"7天酒店\",\n          \"doc_count\" : 30\n        },\n        {\n          \"key\" : \"如家\",\n          \"doc_count\" : 30\n        },\n        {\n          \"key\" : \"皇冠假日\",\n          \"doc_count\" : 17\n        },\n        {\n          \"key\" : \"速8\",\n          \"doc_count\" : 15\n        },\n        {\n          \"key\" : \"万怡\",\n          \"doc_count\" : 13\n        }\n      ]\n    }\n  }\n}\n```\n\n#### 聚合结果排序\n\n默认情况下，Bucket 聚合会统计 Bucket 内的文档数量，记为 `_count`，并且按照 `_count` 降序排序。\n\n我们可以指定 order 属性，自定义聚合的排序方式：\n\n```json\nGET /hotel/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"brandAgg\": {\n      \"terms\": {\n        \"field\": \"brand\",\n        \"order\": {\n          \"_count\": \"asc\" // 按照 _count 升序排列\n        }, \n        \"size\": 5\n      }\n    }\n  }\n}\n```\n\n#### 限定聚合范围\n\n默认情况下，Bucket 聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。\n\n我们可以限定要聚合的文档范围，只要添加 query 条件即可：\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"range\": {\n      \"price\": {\n        \"lte\": 200 // 只对200元以下的文档聚合\n      }\n    }\n  }, \n  \"size\": 0,\n  \"aggs\": {\n    \"brandAgg\": {\n      \"terms\": {\n        \"field\": \"brand\",\n        \"size\": 5\n      }\n    }\n  }\n}\n```\n\n#### Metric 聚合语法\n\n现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的 min、max、avg 等值。\n\n这就要用到 Metric 聚合了，例如 stats 聚合：就可以获取 min、max、avg 等结果。\n\n语法如下：\n\n```json\nGET /hotel/_search\n{\n  \"size\": 0, \n  \"aggs\": {\n    \"brandAgg\": { \n      \"terms\": { \n        \"field\": \"brand\", \n        \"size\": 5\n      },\n      \"aggs\": { // 是brands聚合的子聚合，也就是分组后对每组分别计算\n        \"score_stats\": { // 聚合名称\n          \"stats\": { // 聚合类型，这里stats可以计算min、max、avg等\n            \"field\": \"score\" // 聚合字段，这里是score\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n这次的 score_stats 聚合是在 brandAgg 的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。\n\n另外，我们还可以给聚合结果做个排序：\n\n```json\nGET /hotel/_search\n{\n  \"size\": 0,\n  \"aggs\": {\n    \"brandAgg\": {\n      \"terms\": {\n        \"field\": \"brand\",\n        \"size\": 5,\n        \"order\": {\n          \"scoreAgg.avg\": \"desc\"\n        }\n      },\n      \"aggs\": {\n        \"scoreAgg\": {\n          \"stats\": {\n            \"field\": \"score\"\n          }\n        }\n      }\n    }\n  }\n}\n```\n\n#### DSL 实现聚合小结\n\naggs 代表聚合，与 query 同级，此时 query 的作用是？\n\n- 限定聚合的的文档范围\n\n聚合必须的三要素：\n\n- 聚合名称\n- 聚合类型\n- 聚合字段\n\n聚合可配置属性有：\n\n- size：指定聚合结果数量\n- order：指定聚合结果排序方式\n- field：指定聚合字段\n\n### Rest Client 实现聚合\n\n#### API 语法\n\n聚合条件与 query 条件同级别，因此需要使用 `request.source()` 来指定聚合条件。\n\n聚合条件的语法：\n\n```java\nrequest.source().size(0);\nrequest.source().aggregation(\n    AggregationBuilders\n    .terms(\"brand_agg\")\n    .field(\"brand\")\n    .size(20)\n);\n```\n\n聚合的结果也与查询结果不同，API 也比较特殊。不过同样是 JSON 逐层解析：\n\n```java\n// 4. 解析结果\n// 4.1 获取 aggregations\nAggregations aggregations = response.getAggregations();\n// 4.2 根据名称获取聚合结果\nTerms brandTerms = aggregations.get(\"brandAgg\");\n// 4.3 获取 buckets 并遍历\nfor (Terms.Bucket bucket : brandTerms.getBuckets()) {\n    // 获取 key\n    String key = bucket.getKeyAsString();\n    System.out.println(key);\n}\n```\n\n#### 业务需求\n\n需求：搜索页面的品牌、城市等信息不应该是在页面写死，而是通过聚合索引库中的酒店数据得来的\n\n分析：目前，页面的城市列表、星级列表、品牌列表都是写死的，并不会随着搜索结果的变化而变化。但是用户搜索条件改变时，搜索结果会跟着变化。\n\n例如：用户搜索“东方明珠”，那搜索的酒店肯定是在上海东方明珠附近，因此，城市只能是上海，此时城市列表中就不应该显示北京、深圳、杭州这些信息了。也就是说，搜索结果中包含哪些城市，页面就应该列出哪些城市；搜索结果中包含哪些品牌，页面就应该列出哪些品牌。\n\n如何得知搜索结果中包含哪些品牌？如何得知搜索结果中包含哪些城市？\n\n使用聚合功能，利用 Bucket 聚合，对搜索结果中的文档基于品牌分组、基于城市分组，就能得知包含哪些品牌、哪些城市了。\n\n因为是对搜索结果聚合，因此聚合是限定范围的聚合，也就是说聚合的限定条件跟搜索文档的条件一致。\n\n返回结果是一个 Map 结构：\n\n- key 是字符串，城市、星级、品牌、价格\n- value 是集合，例如多个城市的名称\n\n#### 业务实现\n\n在 `cn.itcast.hotel.web` 包的 `HotelController` 中添加一个方法，遵循下面的要求：\n\n- 请求方式：`POST`\n- 请求路径：`/hotel/filters`\n- 请求参数：`RequestParams`，与搜索文档的参数一致\n- 返回值类型：`Map<String, List<String>>`\n\n代码：\n\n```java\n@PostMapping(\"filters\")\npublic Map<String, List<String>> getFilters(@RequestBody RequestParams params){\n    return hotelService.getFilters(params);\n}\n```\n\n这里调用了 IHotelService 中的 getFilters 方法，尚未实现。\n\n在 `cn.itcast.hotel.service.IHotelService` 中定义新方法：\n\n```java\nMap<String, List<String>> filters(RequestParams params);\n```\n\n在 `cn.itcast.hotel.service.impl.HotelService` 中实现该方法：\n\n```java\n@Override\npublic Map<String, List<String>> getFilters(RequestParams params) {\n    try {\n        // 1. 准备 request\n        SearchRequest request = new SearchRequest(\"hotel\");\n\n        // 2. 准备 DSL\n        // query\n        FunctionScoreQueryBuilder query = getQueryBuilder(params);\n        request.source().highlighter(new HighlightBuilder().field(\"name\").requireFieldMatch(false));\n        request.source().query(query);\n        // 2.1 设置 size = 0\n        request.source().size(0);\n        // 2.2 聚合\n        HashMap<String, String> items = new HashMap<>();\n        items.put(\"brand\", \"品牌\");\n        items.put(\"city\", \"城市\");\n        items.put(\"starName\", \"星级\");\n        for (String item : items.keySet()) {\n            request.source().aggregation(AggregationBuilders\n                                         .terms(item + \"Agg\")\n                                         .field(item)\n                                         .size(100));\n        }\n        // 3. 发出请求\n        SearchResponse response = null;\n\n        response = client.search(request, RequestOptions.DEFAULT);\n\n\n        // 4. 解析结果\n        // 4.1 获取 aggregations\n        Aggregations aggregations = response.getAggregations();\n\n        HashMap<String, List<String>> itemListHashMap = new HashMap<>();\n\n        for (String item : items.keySet()) {\n            // 4.2 根据名称获取聚合结果\n            Terms brandTerms = aggregations.get(item + \"Agg\");\n            // 4.3 获取 buckets 并遍历\n            ArrayList<String> itemList = new ArrayList<>();\n            for (Terms.Bucket bucket : brandTerms.getBuckets()) {\n                // 获取 key\n                itemList.add(bucket.getKeyAsString());\n            }\n            itemListHashMap.put(item, itemList);\n        }\n        return itemListHashMap;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n\n## 自动补全\n\n当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项，这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。\n\n因为需要根据拼音字母来推断，因此要用到拼音分词功能。\n\n### 拼音分词器\n\n要实现根据字母做补全，就必须对文档按照拼音分词。在 GitHub 上有 ElasticSearch的拼音分词插件。地址：https://github.com/medcl/elasticsearch-analysis-pinyin\n\n安装方式与 IK 分词器一样，分三步：\n\n1. 解压\n2. 上传到虚拟机中，ElasticSearch 的 plugin 目录\n3. 重启 ElasticSearch\n4. 测试\n\n详细安装步骤可以参考 IK 分词器的安装过程。\n\n测试用法如下：\n\n```json\nPOST /_analyze\n{\n  \"text\": \"如家酒店还不错\",\n  \"analyzer\": \"pinyin\"\n}\n```\n\n结果如下：\n\n```json\n{\n  \"tokens\" : [\n    {\n      \"token\" : \"ru\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 0,\n      \"type\" : \"word\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"rjjdhbc\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 0,\n      \"type\" : \"word\",\n      \"position\" : 0\n    },\n    {\n      \"token\" : \"jia\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 0,\n      \"type\" : \"word\",\n      \"position\" : 1\n    },\n    {\n      \"token\" : \"jiu\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 0,\n      \"type\" : \"word\",\n      \"position\" : 2\n    },\n    {\n      \"token\" : \"dian\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 0,\n      \"type\" : \"word\",\n      \"position\" : 3\n    },\n    {\n      \"token\" : \"hai\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 0,\n      \"type\" : \"word\",\n      \"position\" : 4\n    },\n    {\n      \"token\" : \"bu\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 0,\n      \"type\" : \"word\",\n      \"position\" : 5\n    },\n    {\n      \"token\" : \"cuo\",\n      \"start_offset\" : 0,\n      \"end_offset\" : 0,\n      \"type\" : \"word\",\n      \"position\" : 6\n    }\n  ]\n}\n```\n\n### 自定义分词器\n\n默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。\n\nElasticSearch 中分词器（analyzer）的组成包含三部分：\n\n- character filters：在 tokenizer 之前对文本进行处理。例如删除字符、替换字符\n- tokenizer：将文本按照一定的规则切割成词条（term）。例如 keyword，就是不分词；还有 ik_smart\n- tokenizer filter：将 tokenizer 输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等\n\n声明自定义分词器的语法如下：\n\n```json\nPUT /test\n{\n  \"settings\": {\n    \"analysis\": {\n      \"analyzer\": {\n        \"my_analyzer\": {\n          \"tokenizer\": \"ik_max_word\",\n          \"filter\": \"py\"\n        }\n      },\n      \"filter\": {\n        \"py\": {\n          \"type\": \"pinyin\",\n          \"keep_full_pinyin\": false,\n          \"keep_joined_full_pinyin\": true,\n          \"keep_original\": true,\n          \"limit_first_letter_length\": 16,\n          \"remove_duplicated_term\": true,\n          \"none_chinese_pinyin_tokenize\": false\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"name\": {\n        \"type\": \"text\",\n        \"analyzer\": \"my_analyzer\",\n        \"search_analyzer\": \"ik_smart\"\n      }\n    }\n  }\n}\n```\n\n总结：\n\n如何使用拼音分词器？\n\n- 下载 pinyin 分词器\n\n- 解压并放到 ElasticSearch 的 plugin 目录\n\n- 重启即可\n\n如何自定义分词器？\n\n- 创建索引库时，在 settings 中配置，可以包含三部分：character filter、tokenizer、filter\n\n\n拼音分词器注意事项？\n\n- 为了避免搜索到同音字，搜索时不要使用拼音分词器\n\n### 自动补全查询\n\nElasticSearch 提供了 [Completion Suggester](https://www.elastic.co/guide/en/elasticsearch/reference/7.6/search-suggesters.html) 查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：\n\n- 参与补全查询的字段必须是 completion 类型。\n\n- 字段的内容一般是用来补全的多个词条形成的数组。\n\n比如，一个这样的索引库：\n\n```json\nPUT /test2\n{\n  \"mappings\": {\n    \"properties\": {\n      \"title\":{\n        \"type\": \"completion\"\n      }\n    }\n  }\n}\n```\n\n然后插入下面的数据：\n\n```json\nPOST /test2/_doc\n{\n  \"title\": [\"Sony\", \"WH-1000XM3\"]\n}\nPOST /test2/_doc\n{\n  \"title\": [\"SK-II\", \"PITERA\"]\n}\nPOST /test2/_doc\n{\n  \"title\": [\"Nintendo\", \"switch\"]\n}\n```\n\n查询的 DSL 语句如下：\n\n```json\nPOST /test2/_search\n{\n  \"suggest\": {\n    \"title_suggest\": {\n      \"text\": \"s\", \n      \"completion\": {\n        \"field\": \"title\", \n        \"skip_duplicates\": true, \n        \"size\": 10 \n      }\n    }\n  }\n}\n```\n\n### 实现酒店搜索框自动补全\n\n现在，我们的 hotel 索引库还没有设置拼音分词器，需要修改索引库中的配置。但是我们知道索引库是无法修改的，只能删除然后重新创建。\n\n另外，我们需要添加一个字段，用来做自动补全，将 brand、suggestion、city 等都放进去，作为自动补全的提示。\n\n因此，总结一下，我们需要做的事情包括：\n\n1. 修改 hotel 索引库结构，设置自定义拼音分词器\n\n2. 修改索引库的 name、all 字段，使用自定义分词器\n\n3. 索引库添加一个新字段 suggestion，类型为 completion 类型，使用自定义的分词器\n\n4. 给 HotelDoc 类添加 suggestion 字段，内容包含 brand、business\n\n5. 重新导入数据到 hotel 库\n\n#### 修改酒店映射结构\n\n代码如下：\n\n```json\n// 酒店数据索引库\nPUT /hotel\n{\n  \"settings\": {\n    \"analysis\": {\n      \"analyzer\": {\n        \"text_anlyzer\": {\n          \"tokenizer\": \"ik_max_word\",\n          \"filter\": \"py\"\n        },\n        \"completion_analyzer\": {\n          \"tokenizer\": \"keyword\",\n          \"filter\": \"py\"\n        }\n      },\n      \"filter\": {\n        \"py\": {\n          \"type\": \"pinyin\",\n          \"keep_full_pinyin\": false,\n          \"keep_joined_full_pinyin\": true,\n          \"keep_original\": true,\n          \"limit_first_letter_length\": 16,\n          \"remove_duplicated_term\": true,\n          \"none_chinese_pinyin_tokenize\": false\n        }\n      }\n    }\n  },\n  \"mappings\": {\n    \"properties\": {\n      \"id\":{\n        \"type\": \"keyword\"\n      },\n      \"name\":{\n        \"type\": \"text\",\n        \"analyzer\": \"text_anlyzer\",\n        \"search_analyzer\": \"ik_smart\",\n        \"copy_to\": \"all\"\n      },\n      \"address\":{\n        \"type\": \"keyword\",\n        \"index\": false\n      },\n      \"price\":{\n        \"type\": \"integer\"\n      },\n      \"score\":{\n        \"type\": \"integer\"\n      },\n      \"brand\":{\n        \"type\": \"keyword\",\n        \"copy_to\": \"all\"\n      },\n      \"city\":{\n        \"type\": \"keyword\"\n      },\n      \"starName\":{\n        \"type\": \"keyword\"\n      },\n      \"business\":{\n        \"type\": \"keyword\",\n        \"copy_to\": \"all\"\n      },\n      \"location\":{\n        \"type\": \"geo_point\"\n      },\n      \"pic\":{\n        \"type\": \"keyword\",\n        \"index\": false\n      },\n      \"all\":{\n        \"type\": \"text\",\n        \"analyzer\": \"text_anlyzer\",\n        \"search_analyzer\": \"ik_smart\"\n      },\n      \"suggestion\":{\n          \"type\": \"completion\",\n          \"analyzer\": \"completion_analyzer\"\n      }\n    }\n  }\n}\n```\n\n#### 修改 HotelDoc 实体\n\nHotelDoc 中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。\n\n因此我们在 HotelDoc 中添加一个 suggestion 字段，类型为 `List<String>`，然后将 brand、city、business 等信息放到里面。\n\n代码如下：\n\n```java\n@Data\n@NoArgsConstructor\npublic class HotelDoc {\n    private Long id;\n    private String name;\n    private String address;\n    private Integer price;\n    private Integer score;\n    private String brand;\n    private String city;\n    private String starName;\n    private String business;\n    private String location;\n    private String pic;\n    private Object distance;\n    private Boolean isAD;\n    private List<String> suggestion;\n\n    public HotelDoc(Hotel hotel) {\n        this.id = hotel.getId();\n        this.name = hotel.getName();\n        this.address = hotel.getAddress();\n        this.price = hotel.getPrice();\n        this.score = hotel.getScore();\n        this.brand = hotel.getBrand();\n        this.city = hotel.getCity();\n        this.starName = hotel.getStarName();\n        this.business = hotel.getBusiness();\n        this.location = hotel.getLatitude() + \", \" + hotel.getLongitude();\n        this.pic = hotel.getPic();\n        // 组装suggestion\n        if (this.business.contains(\"/\")) {\n            // business有多个值，需要切割\n            String[] arr = this.business.split(\"/\");\n            // 添加元素\n            this.suggestion = new ArrayList<>();\n            this.suggestion.add(this.brand);\n            Collections.addAll(this.suggestion, arr);\n        } else {\n            this.suggestion = Arrays.asList(this.brand, this.business);\n        }\n    }\n}\n```\n\n#### 重新导入并测试\n\n重新执行之前编写的导入数据功能 `testBulkRequest()`，并搜索测试\n\n```json\nGET /hotel/_search\n{\n  \"query\": {\n    \"match_all\": {}\n  }\n}\n```\n\n可以看到新的酒店数据中包含了 suggestion，接下来测试自动补全功能\n\n```json\nGET /hotel/_search\n{\n  \"suggest\": {\n    \"suggestions\": {\n      \"text\": \"sd\",\n      \"completion\": {\n        \"field\": \"suggestion\",\n        \"skip_duplicates\": true, \n        \"size\": 10 \n      }\n    }\n  }\n}\n```\n\n#### 自动补全查询的 Java API\n\n```java\n// 1.准备请求\nSearchRequest request = new SearchRequest(\"hotel\");\n// 2.请求参数\nrequest.source().suggest(new SuggestBuilder().addSuggestion(\n    \"mySuggestion\",\n    SuggestBuilders\n    .completionSuggestion(\"title\")\n    .prefix(\"h\")\n    .skipDuplicates(true)\n    .size(10)\n));\n// 3.发送请求\nclient.search(request, RequestOptions.DEFAULT);\n```\n\n而自动补全的结果也比较特殊，解析的代码如下：\n\n```java\n// 4.处理结果\nSuggest suggest = response.getSuggest();\n// 4.1.根据名称获取补全结果\nCompletionSuggestion suggestion = suggest.getSuggestion(\"mySuggestion\");\n// 4.2.获取options并遍历\nfor (CompletionSuggestion.Entry.Option option : suggestion.getOptions()) {\n    // 4.3.获取一个option中的text，也就是补全的词条\n    String text = option.getText().string();\n    System.out.println(text);\n}\n```\n\n#### 实现搜索框自动补全\n\n在 `cn.itcast.hotel.web` 包下的 `HotelController` 中添加新接口，接收新的请求：\n\n```java\n@GetMapping(\"suggestion\")\npublic List<String> getSuggestions(@RequestParam(\"key\") String prefix) {\n    return hotelService.getSuggestions(prefix);\n}\n```\n\n在 `cn.itcast.hotel.service` 包下的 `IhotelService` 中添加方法：\n\n```java\nList<String> getSuggestions(String prefix);\n```\n\n在 `cn.itcast.hotel.service.impl.HotelService` 中实现该方法：\n\n```java\n@Override\npublic List<String> getSuggestions(String prefix) {\n    try {\n        // 1.准备请求\n        SearchRequest request = new SearchRequest(\"hotel\");\n        // 2.请求参数\n        request.source().suggest(new SuggestBuilder().addSuggestion(\n            \"suggestions\",\n            SuggestBuilders\n            .completionSuggestion(\"suggestion\")\n            .prefix(prefix)\n            .skipDuplicates(true)\n            .size(10)\n        ));\n        // 3.发送请求\n        SearchResponse response = client.search(request, RequestOptions.DEFAULT);\n        // 4.处理结果\n        Suggest suggest = response.getSuggest();\n        // 4.1.根据名称获取补全结果\n        CompletionSuggestion suggestion = suggest.getSuggestion(\"suggestions\");\n        // 4.2.获取options并遍历\n        ArrayList<String> result = new ArrayList<>();\n        for (CompletionSuggestion.Entry.Option option : suggestion.getOptions()) {\n            // 4.3.获取一个option中的text，也就是补全的词条\n            String text = option.getText().string();\n            result.add(text);\n        }\n        return result;\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n\n## 数据同步\n\nElasticSearch 中的酒店数据来自于 MySQL 数据库，因此 MySQL 数据发生改变时，ElasticSearch 也必须跟着改变，这个就是 ElasticSearch 与 MySQL 之间的数据同步。\n\n### 思路分析\n\n常见的数据同步方案有三种：\n\n- 同步调用\n- 异步通知\n- 监听 binlog\n\n#### 同步调用\n\n![同步调用](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/同步调用.i2rj0d3cpwg.svg)\n\n基本步骤如下：\n\n- hotel-demo 对外提供接口，用来修改 ElasticSearch 中的数据\n- 酒店管理服务在完成数据库操作后，直接调用 hotel-demo 提供的接口\n\n#### 异步通知\n\n![异步通知](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/异步通知.1p2ptlc5nrs0.svg)\n\n流程如下：\n\n- hotel-admin 对 MySQL 数据库数据完成增、删、改后，发送 MQ 消息\n- hotel-demo 监听 MQ，接收到消息后完成 ElasticSearch 数据修改\n\n#### 监听 binlog\n\n![监听binlog](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/监听binlog.1n6hcbad4pb4.svg)\n\n流程如下：\n\n- 给 MySQL 开启 binlog 功能\n- MySQL 完成增、删、改操作都会记录在 binlog 中\n- hotel-demo 基于 canal 监听 binlog 变化，实时更新 ElasticSearch 中的内容\n\n#### 不同数据同步方案优缺点\n\n方式一：同步调用\n\n- 优点：实现简单，粗暴\n- 缺点：业务耦合度高\n\n方式二：异步通知\n\n- 优点：低耦合，实现难度一般\n- 缺点：依赖 MQ 的可靠性\n\n方式三：监听 binlog\n\n- 优点：完全解除服务间耦合\n- 缺点：开启 binlog 增加数据库负担、实现复杂度高\n\n### 实现数据同步\n\n#### 基于 MQ 的实现思路\n\n利用提供的 hotel-admin 项目作为酒店管理的微服务。当酒店数据发生增、删、改时，要求对 ElasticSearch 中数据也要完成相同操作。\n\n步骤：\n\n- 导入 hotel-admin 项目，启动并测试酒店数据的 CRUD\n\n- 声明 exchange、queue、RoutingKey\n\n- 在 hotel-admin 中的增、删、改业务中完成消息发送\n\n- 在 hotel-demo 中完成消息监听，并更新 ElasticSearch 中数据\n\n- 启动并测试数据同步功能\n\n### 导入 demo\n\n代码链接：[GitHub](https://github.com/Lanqilu/HaloElasticSearch/commit/b9d7c724b44d6ea8e307ac5d54778bba635bd314)\n\n运行后，访问 http://localhost:8099\n\n### 声明交换机、队列\n\nMQ 结构如图：\n\n![MQ结构](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/MQ结构.lv1ecla6gvk.svg)\n\n#### 引入依赖并修改配置文件 \n\n在 hotel-admin、hotel-demo 中引入 rabbitmq 的依赖：\n\n```xml\n<!--amqp-->\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n```\n\n```yaml\nspring:\n  rabbitmq:\n    host: rabbitmq\n    port: 5672\n    username: halo\n    password: halo\n    virtual-host: /\n```\n\n#### 声明交换机、队列\n\n在 hotel-admin 和 hotel-demo 中的 `cn.itcast.hotel.constatnts` 包下新建一个类 `MqConstants`：\n\n```java\npublic class MqConstants {\n    /**\n     * 交换机\n     */\n    public final static String HOTEL_EXCHANGE = \"hotel.topic\";\n    /**\n     * 监听新增和修改的队列\n     */\n    public final static String HOTEL_INSERT_QUEUE = \"hotel.insert.queue\";\n    /**\n     * 监听删除的队列\n     */\n    public final static String HOTEL_DELETE_QUEUE = \"hotel.delete.queue\";\n    /**\n     * 新增或修改的RoutingKey\n     */\n    public final static String HOTEL_INSERT_KEY = \"hotel.insert\";\n    /**\n     * 删除的RoutingKey\n     */\n    public final static String HOTEL_DELETE_KEY = \"hotel.delete\";\n}\n```\n\n在 hotel-demo 中，定义配置类，声明队列、交换机：\n\n```java\n@Configuration\npublic class MqConfig {\n    @Bean\n    public TopicExchange topicExchange(){\n        return new TopicExchange(MqConstants.HOTEL_EXCHANGE, true, false);\n    }\n\n    @Bean\n    public Queue insertQueue(){\n        return new Queue(MqConstants.HOTEL_INSERT_QUEUE, true);\n    }\n\n    @Bean\n    public Queue deleteQueue(){\n        return new Queue(MqConstants.HOTEL_DELETE_QUEUE, true);\n    }\n\n    @Bean\n    public Binding insertQueueBinding(){\n        return BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY);\n    }\n\n    @Bean\n    public Binding deleteQueueBinding(){\n        return BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY);\n    }\n}\n```\n\n### 发送 MQ 消息\n\n在 hotel-admin 中的增、删、改业务中分别发送 MQ 消息：\n\n```java\n@Autowired\nprivate RabbitTemplate rabbitTemplate;\n\n@PostMapping\npublic void saveHotel(@RequestBody Hotel hotel){\n    hotelService.save(hotel);\n    rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE,MqConstants.HOTEL_INSERT_KEY,hotel.getId());\n}\n\n@PutMapping()\npublic void updateById(@RequestBody Hotel hotel){\n    if (hotel.getId() == null) {\n        throw new InvalidParameterException(\"id不能为空\");\n    }\n    hotelService.updateById(hotel);\n    rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE,MqConstants.HOTEL_INSERT_KEY,hotel.getId());\n}\n\n@DeleteMapping(\"/{id}\")\npublic void deleteById(@PathVariable(\"id\") Long id) {\n    hotelService.removeById(id);\n    rabbitTemplate.convertAndSend(MqConstants.HOTEL_EXCHANGE,MqConstants.HOTEL_DELETE_KEY,id);\n}\n```\n\n### 接收 MQ 消息\n\nhotel-demo 接收到 MQ 消息要做的事情包括：\n\n- 新增消息：根据传递的 hotel 的 id 查询 hotel 信息，然后新增一条数据到索引库\n- 删除消息：根据传递的 hotel 的 id 删除索引库中的一条数据\n\n首先在 hotel-demo 的 `cn.itcast.hotel.service` 包下的 `IHotelService` 中新增新增、删除业务\n\n```java\nvoid deleteById(Long id);\n\nvoid insertById(Long id);\n```\n\n给 hotel-demo 中的 `cn.itcast.hotel.service.impl` 包下的 HotelService 中实现业务：\n\n```java\n@Override\npublic void deleteById(Long id) {\n    try {\n        // 1.准备Request\n        DeleteRequest request = new DeleteRequest(\"hotel\", id.toString());\n        // 2.发送请求\n        client.delete(request, RequestOptions.DEFAULT);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n\n@Override\npublic void insertById(Long id) {\n    try {\n        // 0.根据id查询酒店数据\n        Hotel hotel = getById(id);\n        // 转换为文档类型\n        HotelDoc hotelDoc = new HotelDoc(hotel);\n\n        // 1.准备Request对象\n        IndexRequest request = new IndexRequest(\"hotel\").id(hotel.getId().toString());\n        // 2.准备Json文档\n        request.source(JSON.toJSONString(hotelDoc), XContentType.JSON);\n        // 3.发送请求\n        client.index(request, RequestOptions.DEFAULT);\n    } catch (IOException e) {\n        throw new RuntimeException(e);\n    }\n}\n```\n\n编写监听器，在 hotel-demo 中的 `cn.itcast.hotel.mq` 包新增一个类：\n\n```java\n@Component\npublic class HotelListener {\n\n    @Autowired\n    private IHotelService hotelService;\n\n    /**\n     * 监听酒店新增或修改的业务\n     * @param id 酒店id\n     */\n    @RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE)\n    public void listenHotelInsertOrUpdate(Long id){\n        hotelService.insertById(id);\n    }\n\n    /**\n     * 监听酒店删除的业务\n     * @param id 酒店id\n     */\n    @RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE)\n    public void listenHotelDelete(Long id){\n        hotelService.deleteById(id);\n    }\n}\n```\n\n## ElasticSearch 集群\n\n单机的 ElasticSearch 做数据存储，必然面临两个问题：海量数据存储问题、单点故障问题。\n\n- 海量数据存储问题：将索引库从逻辑上拆分为 N 个分片（shard），存储到多个节点\n- 单点故障问题：将分片数据在不同节点备份（replica）\n\nES 集群相关概念:\n\n* 集群（cluster）：一组拥有共同的 cluster name 的 节点。\n* 节点（node)   ：集群中的一个 Elasticearch 实例\n* 分片（shard）：索引可以被拆分为不同的部分进行存储，称为分片。在集群环境下，一个索引的不同分片可以拆分到不同的节点中\n\n解决问题：数据量太大，单点存储量有限的问题。\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4pwzs1lq4540.png)\n\n此处，我们把数据分成 3 片：shard0、shard1、shard2\n\n* 主分片（Primary shard）：相对于副本分片的定义。\n\n* 副本分片（Replica shard）每个主分片可以有一个或者多个副本，数据和主分片一样。\n\n数据备份可以保证高可用，但是每个分片备份一份，所需要的节点数量就会翻一倍，成本实在是太高了！\n\n为了在高可用和成本间寻求平衡，我们可以这样做：\n\n- 首先对数据分片，存储到不同节点\n- 然后对每个分片进行备份，放到对方节点，完成互相备份\n\n这样可以大大减少所需要的服务节点数量，如图，我们以 3 分片，每个分片备份一份为例：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3jlk46u66q60.png)\n\n现在，每个分片都有 1 个备份，存储在 3 个节点：\n\n- node0：保存了分片 0 和 1\n- node1：保存了分片 0 和 2\n- node2：保存了分片 1 和 2\n\n### 部署 ElasticSearch 集群\n\n我们会在单机上利用 docker 容器运行多个 ElasticSearch 实例来模拟 ElasticSearch 集群。不过生产环境推荐大家每一台服务节点仅部署一个 ElasticSearch 的实例。\n\n部署 ElasticSearch 集群可以直接使用 docker-compose 来完成，但这要求你的 Linux 虚拟机至少有 4G 的内存空间\n\n#### 创建 ElasticSearch 集群\n\n首先编写一个 docker-compose 文件，内容如下：\n\n```sh\nversion: \'2.2\'\nservices:\n  es01:\n    image: elasticsearch:7.12.1\n    container_name: es01\n    environment:\n      - node.name=es01\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es02,es03\n      - cluster.initial_master_nodes=es01,es02,es03\n      - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\n    volumes:\n      - data01:/usr/share/elasticsearch/data\n    ports:\n      - 9200:9200\n    networks:\n      - elastic\n  es02:\n    image: elasticsearch:7.12.1\n    container_name: es02\n    environment:\n      - node.name=es02\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es01,es03\n      - cluster.initial_master_nodes=es01,es02,es03\n      - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\n    volumes:\n      - data02:/usr/share/elasticsearch/data\n    ports:\n      - 9201:9200\n    networks:\n      - elastic\n  es03:\n    image: elasticsearch:7.12.1\n    container_name: es03\n    environment:\n      - node.name=es03\n      - cluster.name=es-docker-cluster\n      - discovery.seed_hosts=es01,es02\n      - cluster.initial_master_nodes=es01,es02,es03\n      - \"ES_JAVA_OPTS=-Xms512m -Xmx512m\"\n    volumes:\n      - data03:/usr/share/elasticsearch/data\n    networks:\n      - elastic\n    ports:\n      - 9202:9200\nvolumes:\n  data01:\n    driver: local\n  data02:\n    driver: local\n  data03:\n    driver: local\n\nnetworks:\n  elastic:\n    driver: bridge\n```\n\nElasticSearch  运行需要修改一些 Linux 系统权限，修改 `/etc/sysctl.conf` 文件\n\n```sh\nvi /etc/sysctl.conf\n```\n\n添加下面的内容：\n\n```sh\nvm.max_map_count=262144\n```\n\n然后执行命令，让配置生效：\n\n```sh\nsysctl -p\n```\n\n通过 docker-compose 启动集群：\n\n```sh\ndocker-compose up -d\n```\n\n#### 集群状态监控\n\nkibana 可以监控 ElasticSearch  集群，不过新版本需要依赖 ElasticSearch  的 x-pack 功能，配置比较复杂。\n\n这里推荐使用 cerebro 来监控 ElasticSearch  集群状态，官方网址：https://github.com/lmenezes/cerebro\n\n双击其中的 cerebro.bat 文件即可启动服务。访问 http://localhost:9000 即可进入管理界面：\n\n输入你的 ElasticSearch 的任意节点的地址和端口，点击 connect 即可\n\n#### 创建索引库\n\n利用 kibana 的 DevTools 创建索引库，在 DevTools 中输入指令：\n\n```json\nPUT /test\n{\n  \"settings\": {\n    \"number_of_shards\": 3, // 分片数量\n    \"number_of_replicas\": 1 // 副本数量\n  },\n  \"mappings\": {\n    \"properties\": {\n      // mapping映射定义 ...\n    }\n  }\n}\n```\n\n或利用 cerebro 创建索引库\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.29xen9tqfmvw.png)\n\n查看分片效果，回到首页，即可查看索引库分片效果：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2jn8zaht2280.png)\n\n### 集群脑裂问题\n\n#### 集群职责划分\n\nElasticSearch 中集群节点有不同的职责划分：\n\n| 节点类型         | 配置参数                                       | 默认值 | 节点职责                                                     |\n| ---------------- | ---------------------------------------------- | ------ | ------------------------------------------------------------ |\n| master  eligible | node.master                                    | true   | 备选主节点：主节点可以管理和记录集群状态、决定分片在哪个节点、处理创建和删除索引库的请求 |\n| data             | node.data                                      | true   | 数据节点：存储数据、搜索、聚合、CRUD                         |\n| ingest           | node.ingest                                    | true   | 数据存储之前的预处理                                         |\n| coordinating     | 上面 3 个参数都为 false 则为 coordinating 节点 | 无     | 路由请求到其它节点  合并其它节点处理的结果，返回给用户       |\n\n默认情况下，集群中的任何一个节点都同时具备上述四种角色。\n\n但是真实的集群一定要将集群职责分离：\n\n- master 节点：对 CPU 要求高，但是内存要求低\n- data 节点：对 CPU 和内存要求都高\n- coordinating 节点：对网络带宽、CPU 要求高\n\n职责分离可以让我们根据不同节点的需求分配不同的硬件去部署。而且避免业务之间的互相干扰。\n\n一个典型的 ElasticSearch 集群职责划分如图：\n\n![ES集群](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/ES集群.2rrl7g78cxs0.svg)\n\n#### 脑裂问题\n\n脑裂是因为集群中的节点失联导致的。\n\n例如一个集群中，主节点与其它节点失联，\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.6ry0qp2sxiw0.png)\n\n此时 node2 和 node3 认为 node1 宕机，就会重新选主：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5qon8j1rbak0.png)\n\n当 node3 当选后，集群继续对外提供服务，node2 和 node3 自成集群，node1 自成集群，两个集群数据不同步，出现数据差异。\n\n当网络恢复后，因为集群中有两个 master 节点，集群状态的不一致，出现脑裂的情况：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.wmlcqz00rls.png)\n\n解决脑裂的方案是，要求选票超过 ( eligible节点数量 + 1 ）/ 2 才能当选为主，因此 eligible 节点数量最好是奇数。对应配置项是 discovery.zen.minimum_master_nodes，在 ElasticSearch 7.0 以后，已经成为默认配置，因此一般不会发生脑裂问题\n\n例如：3 个节点形成的集群，选票必须超过 （3 + 1） / 2 ，也就是 2 票。node3 得到 node2 和 node3 的选票，当选为主。node1 只有自己 1 票，没有当选。集群中依然只有 1 个主节点，没有出现脑裂。\n\n### 集群分布式存储\n\n当新增文档时，应该保存到不同分片，保证数据均衡，那么 coordinating node 如何确定数据该存储到哪个分片呢？\n\n#### 分片存储测试\n\n在一个节点中加入数据，后可以通过 explain 命令查询\n\n```json\nPOST /test/_search\n{\n  \"explain\": true,\n  \"query\": {\n    \"match_all\": {}\n  }\n}\n```\n\n发现数据在不同的节点中，形成分片存储\n\n#### 分片存储原理\n\nElasticSearch 会通过 hash 算法来计算文档应该存储到哪个分片：`shard = hash(_routing) % number_of_shards`\n\n说明：\n\n- `_routing` 默认是文档的id\n- 算法与分片数量有关，因此索引库一旦创建，分片数量不能修改！\n\n新增文档的流程如下：\n\n![ES集群](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/ES集群.akvhs79fwq0.svg)\n\n解读：\n\n- 新增一个 id=1 的文档\n- 对 id 做 hash 运算，假如得到的是 2，则应该存储到 P-2\n- P-2 的主分片在 node3 节点，将数据路由到 node3\n- 保存文档\n- 同步给 P-2 的副本 R-2，在 node2 节点\n- 返回结果给 coordinating-node 节点\n\n#### 集群分布式查询\n\nElasticSearch 的查询分成两个阶段：\n\n- scatter phase：分散阶段，coordinating node 会把请求分发到每一个分片\n\n- gather phase：聚集阶段，coordinating node 汇总 data node 的搜索结果，并处理为最终结果集返回给用户\n\n#### 集群故障转移\n\n集群的 master 节点会监控集群中的节点状态，如果发现有节点宕机，会立即将宕机节点的分片数据迁移到其它节点，确保数据安全，这个叫做故障转移。\n\n+ 假如，node1 发生了故障\n+ 宕机后的第一件事，需要重新选主，例如选中了 node2，\n+ node2 成为主节点后，会检测集群监控状态，发现：shard-1、shard-0 没有副本节点。因此需要将 node1 上的数据迁移到 node2、node3\n+ 但 node1 恢复，此时 node1 不在是主节点，但数据会重新平衡\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '2021-09-26 12:22:18', 1, 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/macos.6z1mshl4twk0.svg', 5, '2021-09-26 12:22:18', NULL, NULL, NULL, 1, 1, 0, NULL, 0, NULL);
INSERT INTO `m_blog` VALUES (15, 1, '微服务入门', '微服务入门', '## 认识微服务\n\n### 单体架构与分布式架构\n\n单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。优点是架构简单、部署成本低，但耦合度高（维护困难、升级困难）\n\n分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。降低了服务耦合，有利于服务升级和拓展，但服务调用关系错综复杂\n\n分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：\n\n- 服务拆分的粒度如何界定？\n- 服务之间如何调用？\n- 服务的调用关系如何管理？\n\n人们需要制定一套行之有效的标准来约束分布式架构。\n\n### 微服务\n\n微服务的架构特征：\n\n- 单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责\n- 自治：团队独立、技术独立、数据独立，独立部署和交付\n- 面向服务：服务提供统一标准的接口，与语言和技术无关\n- 隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题\n\n微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。\n\n因此，可以认为微服务是一种经过良好架构设计的分布式架构方案 。\n\n但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。\n\n其中在 Java 领域最引人注目的就是 Spring Cloud 提供的方案了。\n\n### Spring Cloud\n\nSpring Cloud 是目前国内使用最广泛的微服务框架。官网地址：https://spring.io/projects/spring-cloud。\n\nSpring Cloud 集成了各种微服务功能组件，并基于 Spring Boot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。\n\n其中常见的组件包括：\n\n![微服务组件](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/微服务组件.8239z8cveb0.svg)\n\n另外，Spring Cloud 底层是依赖于 Spring Boot 的，并且有版本的兼容关系，如下：\n\n![SpringBoot与SpringCloud](https://pic.imgdb.cn/item/6133818144eaada739d722b1.jpg)\n\n### 认识微服务小结\n\n- 单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统\n- 分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝\n- 微服务：一种良好的分布式架构方案\n  - 优点：拆分粒度更小、服务更独立、耦合度更低\n  - 缺点：架构非常复杂，运维、监控、部署难度提高\n- Spring Cloud 是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件\n\n## 服务拆分和远程调用\n\n### 服务拆分原则\n\n微服务拆分时的几个原则：\n\n- 不同微服务，不要重复开发相同业务\n- 微服务数据独立，不要访问其它微服务的数据库\n- 微服务可以将自己的业务暴露为接口，供其它微服务调用\n\n### 服务拆分示例\n\n以 spring-cloud-demo 为例，其结构如下：\n\n```\nspring-cloud-demo\n ├── order-service\n └── user-service\n```\n\nspring-cloud-demo：父工程，管理依赖\n\n- order-service：订单微服务，负责订单相关业务\n- user-service：用户微服务，负责用户相关业务\n\n要求：\n\n- 订单微服务和用户微服务都必须有各自的数据库，相互独立\n- 订单服务和用户服务都对外暴露 Restful 的接口\n- 订单服务如果需要查询用户信息，只能调用用户服务的 Restful 接口，不能查询用户数据库\n\n初始项目代码：[链接](https://github.com/Lanqilu/HaloSpringCloud/releases/tag/v0.1)\n\n### 实现远程调用案例\n\n#### 案例需求\n\n修改 order-service 中的根据 id 查询订单业务，要求在查询订单的同时，根据订单中包含的 userId 查询出用户信息，一起返回。\n\n因此，我们需要在 order-service 中向 user-service 发起一个 http 的请求，调用 `http://localhost:8081/user/{userId}` 这个接口。\n\n大概的步骤是这样的：\n\n- 注册一个 RestTemplate 的实例到 Spring 容器\n- 修改 order-service 服务中的 OrderService 类中的 queryOrderById 方法，根据 Order 对象中的 userId 查询 User\n- 将查询的 User 填充到 Order 对象，一起返回\n\n#### 注册 RestTemplate\n\n首先，我们在 order-service 服务中的 OrderApplication 启动类中，注册 RestTemplate 实例：\n\n```java\npackage cn.itcast.order;\n\nimport org.mybatis.spring.annotation.MapperScan;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.web.client.RestTemplate;\n\n@MapperScan(\"cn.itcast.order.mapper\")\n@SpringBootApplication\npublic class OrderApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(OrderApplication.class, args);\n    }\n\n    @Bean\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n}\n```\n\n#### 实现远程调用\n\n修改 order-service 服务中的 cn.itcast.order.service 包下的 OrderService 类中的 queryOrderById 方法：\n\n```java\n@Autowired\nprivate RestTemplate restTemplate;\n\npublic Order queryOrderById(Long orderId) {\n    // 1.查询订单\n    Order order = orderMapper.findById(orderId);\n    // 2. 利用 RestTemplate 发起 http 请求，查询用户\n    String url = \"http://localhost:8081/user/\" + order.getUserId();\n    User user = restTemplate.getForObject(url, User.class);\n    // 3. 封装 user 到 Order\n    order.setUser(user);\n    // 4.返回\n    return order;\n}\n```\n\n代码：[链接](https://github.com/Lanqilu/HaloSpringCloud/tree/44482f1ec6618da6ee5805fbbdc5c0c2464725bb)\n\n### 提供者与消费者\n\n在服务调用关系中，会有两个不同的角色：\n\n+ 服务提供者：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）\n+ 服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）\n\n但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。如果服务 A 调用了服务 B，而服务 B 又调用了服务 C，服务 B 的角色是什么？\n\n- 对于 A 调用 B 的业务而言：A 是服务消费者，B 是服务提供者\n- 对于 B 调用 C 的业务而言：B 是服务消费者，C 是服务提供者\n\n因此，服务 B 既可以是服务提供者，也可以是服务消费者。\n\n## Eureka 注册中心\n\n以上实例存在的问题：\n\n- order-service 在发起远程调用的时候，该如何得知 user-service 实例的 ip 地址和端口？\n- 有多个 user-service 实例地址，order-service 调用时该如何选择？\n- order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？\n\n### Eureka 的结构和作用\n\n![Eureka的作用](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Eureka的作用.mzzzu1u538w.svg)\n\n问题1：order-service 如何得知 user-service 实例地址？获取地址信息的流程如下：\n\n- user-service 服务实例启动后，将自己的信息注册到 eureka-server（Eureka 服务端）。这个叫服务注册\n- eureka-server 保存服务名称到服务实例地址列表的映射关系\n- order-service 根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取\n\n问题2：order-service 如何从多个 user-service 实例中选择具体的实例？\n\n- order-service 从实例列表中利用负载均衡算法选中一个实例地址\n- 向该实例地址发起远程调用\n\n问题3：order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？\n\n- user-service 会每隔一段时间（默认 30 秒）向 eureka-server 发起请求，报告自己状态，称为心跳\n- 当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除\n- order-service 拉取服务时，就能将故障实例排除了\n\n在 Eureka 架构中，微服务角色有两类：\n\n+ EurekaServer：服务端，注册中心。记录服务信息、心跳监控\n+ EurekaClient：客户端\n  + Provider：服务提供者，例如案例中的 user-service。注册自己的信息到 EurekaServer、每隔 30 秒向 EurekaServer 发送心跳\n  + Consumer：服务消费者，例如案例中的 order-service 根据服务名称从 EurekaServer 拉取服务列表基于服务列表做负载均衡，选中一个微服务后发起远程调用\n\n> 注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此 eureka 将服务注册、服务发现等功能统一封装到了eureka-client 端\n\neureka 服务注册分为以下步骤：\n\n+ 搭建注册中心：搭建 EurekaServer\n+ 服务注册：将 user-service、order-service 都注册到 eureka\n+ 服务发现：在 order-service 中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用\n\n### 搭建 eureka-server\n\n首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务\n\n创建 eureka-server 服务，在 spring-cloud-demo 父工程下，创建 eureka-server Maven 子模块\n\n引入 eureka 依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>\n</dependency>\n```\n\n#### 编写启动类\n\n给 eureka-server 服务编写一个启动类，一定要添加一个 `@EnableEurekaServer` 注解，开启 eureka 的注册中心功能：\n\n```java\npackage cn.itcast.eureka;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;\n\n@SpringBootApplication\n@EnableEurekaServer\npublic class EurekaApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(EurekaApplication.class, args);\n    }\n}\n```\n\n#### 编写配置文件\n\n编写一个 application.yml 文件，内容如下：\n\n```yaml\nserver:\n  port: 10086 # 服务端口\nspring:\n  application:\n    name: eureka-server # 服务名称 必须\neureka:\n  client:\n    service-url: # eureka 的地址信息\n      defaultZone: http://127.0.0.1:10086/eureka\n```\n\n#### 启动服务\n\n启动微服务，然后在浏览器访问：http://127.0.0.1:10086\n\n看到下面结果应该是成功了：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3fxbktup2b40.png)\n\n代码：[链接](https://github.com/Lanqilu/HaloSpringCloud/tree/6485893c857e8407573b163f91fd7b6b7cfd4cfe)\n\n### Eureka 服务注册\n\n下面，我们将 user-service 注册到 eureka-server 中去\n\n#### 引入依赖\n\n在 user-service 的 pom 文件中，引入下面的 eureka-client 依赖：\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n</dependency>\n```\n\n#### 修改配置文件\n\n在 user-service 中，修改 application.yml 文件，添加服务名称、eureka 地址：\n\n```yaml\nspring:\n  application:\n    name: user-service\neureka:\n  client:\n    service-url:\n      defaultZone: http://127.0.0.1:10086/eureka\n```\n\n用同样的方法可以注册 order-service\n\n#### 启动多个 user-service 实例\n\n为了演示一个服务有多个实例的场景，我们添加一个 SpringBoot 的启动配置，再启动一个 user-service。\n\n首先，复制原来的 user-service 启动配置：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.1oxav2o4lv7k.png)\n\n然后，在弹出的窗口中，填写信息：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.acb3rk5x180.png)\n\n启动两个 user-service 实例后，查看 eureka-server 管理页面：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4tnhuetb1yc0.png)\n\n### Eureka 服务发现\n\n下面，我们将 order-service 的逻辑修改：向 eureka-server 拉取 user-service 的信息，实现服务发现。\n\n#### 引入依赖和修改配置文件\n\n之前说过，服务发现、服务注册统一都封装在 eureka-client 依赖，因此这一步与服务注册时一致。\n\n#### 服务拉取和负载均衡\n\n去 eureka-server 中拉取 user-service 服务的实例列表，并且实现负载均衡。\n\n在 order-service 的 OrderApplication 中，给 RestTemplate 这个 Bean 添加一个 `@LoadBalanced` 注解：\n\n```java\n/**\n * 创建 RestTemplate 并注入容器\n */\n@Bean\n@LoadBalanced\npublic RestTemplate restTemplate(){\n    return new RestTemplate();\n}\n```\n\n修改 order-service 服务中的 cn.itcast.order.service 包下的 OrderService 类中的queryOrderById 方法。修改访问的 url 路径，用服务名代替 ip、端口：\n\n```java\npublic Order queryOrderById(Long orderId) {\n    // 1.查询订单\n    Order order = orderMapper.findById(orderId);\n    // 2. 利用 RestTemplate 发起 http 请求，查询用户\n    String url = \"http://user-service/user/\" + order.getUserId();\n    User user = restTemplate.getForObject(url, User.class);\n    // 3. 封装 user 到 Order\n    order.setUser(user);\n    // 4.返回\n    return order;\n}\n```\n\nspring 会自动帮助我们从 eureka-server 端，根据 userservice 这个服务名称，获取实例列表，而后完成负载均衡（默认轮询）。\n\n### Eureka 注册中心小结\n\n1. 搭建 EurekaServer\n   + 引入 eureka-server 依赖\n   + 添加 `@EnableEurekaServer` 注解\n   + 在 application.yml 中配置 eureka 地址\n2. 服务注册\n   + 引入 eureka-client 依赖\n   + 在 application.yml 中配置 eureka 地址\n3. 服务发现\n   + 引入 eureka-client 依赖\n   + 在 application.yml 中配置 eureka 地址\n   + 给 RestTemplate 添加 `@LoadBalanced` 注解\n   + 用服务提供者的服务名称远程调用\n\n## Ribbon 负载均衡\n\n上一节中，我们添加了 @LoadBalanced 注解，即可实现负载均衡功能，这是什么原理呢？\n\n### 负载均衡原理\n\nSpring Cloud 底层其实是利用了一个名为 Ribbon 的组件，来实现负载均衡功能的。\n\n![Ribbon负载均衡流程](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Ribbon负载均衡流程.2mk0jmuwdoq0.svg)\n\n### 源码跟踪\n\n为什么我们只输入了 service 名称就可以访问了呢？之前还要获取 ip 和端口。\n\n显然有人帮我们根据 service 名称，获取到了服务实例的 ip 和端口。它就是 `LoadBalancerInterceptor`，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。\n\n我们进行源码跟踪：\n\n#### LoadBalancerIntercepor\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5mxujbposco0.png)\n\n可以看到这里的 intercept 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：\n\n- `request.getURI()`：获取请求 url，本例中就是 http://user-service/user/8\n- `originalUri.getHost()`：获取 uri 路径的主机名，其实就是服务 id，`user-service`\n- `this.loadBalancer.execute()`：处理服务 id，和用户请求。\n\n这里的 `this.loadBalancer` 是 `LoadBalancerClient` 类型，我们继续跟入。\n\n#### LoadBalancerClient\n\n继续跟入 execute 方法：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.66vjvvg0xn40.png)\n\n代码是这样的：\n\n- `getLoadBalancer(serviceId)`：根据服务 id 获取 ILoadBalancer，而 ILoadBalancer 会拿着服务 id 去 eureka 中获取服务列表并保存起来。\n- `getServer(loadBalancer)`：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8081端口的服务\n\n#### 负载均衡策略 IRule\n\n在刚才的代码中，可以看到获取服务使通过一个 `getServer` 方法来做负载均衡:\n\n我们继续跟入：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3vkjab3blgm0.png)\n\n继续跟踪源码 chooseServer 方法，发现调用父类中 BaseLoadBalancer 一段代码：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4ks2tojsyxe0.png)\n\n我们看看这个 rule 是谁：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2jcbindlmai0.png)\n\n默认是使用轮询，到这里，整个负载均衡的流程我们就清楚了。\n\n#### 负载均衡原理源码分析小结\n\nSpring Cloud Ribbon 的底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。基本流程如下：\n\n- 拦截我们的 RestTemplate 请求 http://userservice/user/1\n- RibbonLoadBalancerClient 会从请求 url 中获取服务名称，也就是 user-service\n- DynamicServerListLoadBalancer 根据 user-service 到 eureka 拉取服务列表\n- eureka 返回列表，localhost:8081、localhost:8082\n- IRule 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081\n- RibbonLoadBalancerClient 修改请求地址，用 localhost:8081 替代 userservice，得到 http://localhost:8081/user/1，发起真实请求\n\n### 负载均衡策略\n\n负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.61x1c4fc6pg0.png)\n\n常见的不同规则的含义如下：\n\n1. RoundRobinRule：  简单轮询服务列表来选择服务器。它是 Ribbon 默认的负载均衡规则。\n2. AvailabilityFilteringRule：对以下两种服务器进行忽略\n   + 在默认情况下，这台服务器如果 3 次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续 30 秒，如果再次连接失败，短路的持续时间就会几何级地增加。\n   +  并发数过高的服务器。如果一个服务器的并发连接数过高，配置了 AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的`<clientName>.<clientConfigNameSpace>.ActiveConnectionsLimit `属性进行配置。\n3. WeightedResponseTimeRule：为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。\n4. ZoneAvoidanceRule：以区域可用的服务器为基础进行服务器的选择。使用 Zone 对服务器进行分类，这个 Zone 可以理解为一个机房、一个机架等。而后再对 Zone 内的多个服务做轮询。\n5. BestAvailableRule：忽略那些短路的服务器，并选择并发数较低的服务器。\n6. RandomRule：随机选择一个可用的服务器。\n7. RetryRule：  重试机制的选择逻辑\n\n默认的实现就是 ZoneAvoidanceRule，是一种轮询方案\n\n#### 自定义负载均衡策略\n\n通过定义 IRule 实现可以修改负载均衡规则，有两种方式：\n\n代码方式：在 order-service 中的 OrderApplication 类（或配置类）中，定义一个新的 IRule：\n\n```java\n@Bean\npublic IRule randomRule(){\n    return new RandomRule();\n}\n```\n\n配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：\n\n```yaml\nuser-service: # 给某个微服务配置负载均衡规则，这里是user-service服务\n  ribbon:\n    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule # 负载均衡规则 \n```\n\n代码方式针对全局，配置文件方式可以对某个服务进行配置\n\n一般用默认的负载均衡规则，不做修改。\n\n#### 饥饿加载\n\nRibbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，请求时间会很长。\n\n而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：\n\n```yaml\nribbon:\n  eager-load: \n    enabled: true # 开启饥饿加载\n    clients: user-service # 指定对 user-service 这个服务进行加载\n```\n\n### Ribbon 负载均衡小结\n\n1. Ribbon 负载均衡规则：\n   + 规则接口是 IRule\n   + 默认实现是 ZoneAvoidanceRule，根据 zone 选择服务列表，然后轮询\n2. 负载均衡自定义方式：\n   + 代码方式：配置灵活，但修改时需要重新打包发布\n   + 配置方式：直观，方便，无需重新打包发布，但是无法做全局配置\n3. 饥饿加载\n   + 开启饥饿加载，配置文件\n   + 指定饥饿加载的微服务名称，多个 clients 使用 yaml 列表\n\n## Nacos 注册中心\n\n### 认识和安装 Nacos\n\n[Nacos](https://nacos.io/) 是阿里巴巴的产品，现在是 [SpringCloud](https://spring.io/projects/spring-cloud) 中的一个组件。相比 [Eureka](https://github.com/Netflix/eureka) 功能更加丰富，在国内受欢迎程度较高。\n\nDocker 安装：[官网](https://nacos.io/zh-cn/docs/quick-start-docker.html)\n\n### 服务注册到 Nacos\n\nNacos 是 Spring Cloud Alibaba 的组件，而 Spring Cloud Alibaba 也遵循 Spring Cloud 中定义的服务注册、服务发现规范。因此使用 Nacos 和使用 Eureka 对于微服务来说，并没有太大区别。其主要差异在于：依赖不同、服务地址不同。\n\n#### 引入 Nacos 依赖\n\n在 spring-cloud-demo 父工程的 pom 文件中的 `<dependencyManagement>` 中引入 Spring Cloud Alibaba 的依赖：\n\n```xml\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-alibaba-dependencies</artifactId>\n    <version>2.2.6.RELEASE</version>\n    <type>pom</type>\n    <scope>import</scope>\n</dependency>\n```\n\n然后在 user-service 和 order-service 中的 pom 文件中引入 nacos-discovery 依赖：\n\n```xml\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n\n> 注意：不要忘了注释掉 eureka 的依赖。\n\n#### 配置 Nacos 地址\n\n在 user-service 和 order-service 的 application.yml 中添加 nacos 地址：\n\n```yaml\nspring:\n  cloud:\n    nacos:\n      server-addr: n:8848\n```\n\n> 这里使用的是远程服务器的地址\n\n#### 启动项目\n\n启动 user-service 和 order-service 浏览器输入 http://halo:8848/nacos/ 账号密码默认都为 nacos，项目成功可以看到服务列表中的服务。  \n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.6jgz8xeif3g0.png)\n\n### 服务分级存储模型\n\n一个**服务**可以有多个**实例**，例如我们的 user-service，可以有:\n\n- 127.0.0.1:8081\n- 127.0.0.1:8082\n- 127.0.0.1:8083\n\n假如这些实例分布于全国各地的不同机房，例如：\n\n- 127.0.0.1:8081，在上海机房\n- 127.0.0.1:8082，在上海机房\n- 127.0.0.1:8083，在杭州机房\n\nNacos 就将同一机房内的实例划分为一个**集群**。\n\n也就是说，user-service 是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2mxp9c1ugiw0.png)\n\n微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：杭州机房内的 order-service 应该优先访问同机房的 user-service。\n\n#### 给 user-service 配置集群\n\n修改 user-service 的 application.yml 文件，添加集群配置：\n\n```yaml\nspring:\n  cloud:\n    nacos:\n      server-addr: halo:8848\n      discovery:\n        cluster-name: HZ # 集群名称\n```\n\n重启两个 user-service 实例后，我们再次复制一个 user-service 启动配置，添加属性：\n\n```sh\n-Dserver.port=8083 -Dspring.cloud.nacos.discovery.cluster-name=SH\n```\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.1piv5isgkpb4.png)\n\n我们可以在 Nacos 控制台看到下面结果：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3pz2tkuveru0.png)\n\n#### 同集群优先的负载均衡\n\n默认的 `ZoneAvoidanceRule` 并不能实现根据同集群优先来实现负载均衡。\n\n因此 Nacos 中提供了一个 `NacosRule` 的实现，可以优先从同集群中挑选实例。\n\n首先给 order-service 配置集群信息，方法同上一节\n\n修改 order-service 的 application.yml 文件，添加集群配置：\n\n```yaml\nspring:\n  cloud:\n    nacos:\n      server-addr: halo:8848\n      discovery:\n        cluster-name: HZ # 集群名称\n```\n\n修改负载均衡规则。修改 order-service 的 application.yml 文件，修改负载均衡规则：\n\n```yaml\nuser-service:\n  ribbon:\n    NFLoadBalancerRuleClassName: com.alibaba.cloud.nacos.ribbon.NacosRule # 负载均衡规则\n```\n\n本地集群中采用随机\n\nNacos Rule 负载均衡策略\n\n1. 优先选择同集群服务实例列表\n2. 本地集群找不到提供者，才去其它集群寻找，并且会报警告\n3. 确定了可用实例列表后，再采用随机负载均衡挑选实例\n\n### 权重配置\n\n实际部署中会出现这样的场景：服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。\n\n但默认情况下 Nacos Rule 是同集群内随机挑选，不会考虑机器的性能问题。\n\n因此，Nacos 提供了权重配置来控制访问频率，权重越大则访问频率越高。\n\n在 Nacos 控制台，找到 user-service 的实例列表，点击编辑，即可修改权重：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5bywq83lkh00.png)\n\n> 注意：如果权重修改为 0，则该实例永远不会被访问\n\n### 环境隔离\n\nNacos 提供了 namespace 来实现环境隔离功能。\n\n- Nacos 中可以有多个 namespace\n- namespace 下可以有 group、service 等\n- 不同 namespace 之间相互隔离，例如不同 namespace 的服务互相不可见\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.33r23m595e00.png)\n\n#### 创建 namespace\n\n默认情况下，所有 service、data、group 都在同一个 namespace，名为 public：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3ebpxcypny00.png)\n\n我们可以点击页面新增按钮，添加一个 namespace\n\n#### 给微服务配置 namespace\n\n给微服务配置 namespace 只能通过修改配置来实现。\n\n例如，修改 order-service 的 application.yml 文件：\n\n```yaml\nspring:\n  cloud:\n    nacos:\n      server-addr: halo:8848\n      discovery:\n        cluster-name: HZ\n        namespace: 45e30304-1b64-4c21-8c83-22309949af10 # 命名空间，填ID\n```\n\n重启 order-service 后，访问控制台，可以看到下面的结果：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.7fljcch1djg0.png)\n\n此时访问 order-service，因为 namespace 不同，会导致找不到 user-service，控制台会报错：\n\n```\n09-09 22:11:49:886 ERROR 4100 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet]    : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed; nested exception is java.lang.IllegalStateException: No instances available for user-service] with root cause\n```\n\n## Nacos 与 Eureka 的异同\n\n### Nacos 服务实例类型\n\nNacos 的服务实例分为两种类型：\n\n- 临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。\n- 非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。\n\n配置一个服务实例为永久实例：\n\n```yaml\nspring:\n  cloud:\n    nacos:\n      discovery:\n        ephemeral: false # 设置为非临时实例\n```\n\n### Nacos 注册中心原理\n\nNacos 和 Eureka 整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：\n\n![Nacos注册中心原理](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Nacos注册中心原理.vsk7w614iqo.svg)\n\n### Nacos 与 Eureka 的共同点\n\n- 都支持服务注册和服务拉取\n- 都支持服务提供者心跳方式做健康检测\n\n### Nacos 与 Eureka 的区别\n\n- Nacos 支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式\n- 临时实例心跳不正常会被剔除，非临时实例则不会被剔除\n- Nacos 支持服务列表变更的消息推送模式，服务列表更新更及时\n- Nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 模式；Eureka采用 AP 方式\n\n## Nacos 配置管理\n\nNacos 除了可以做注册中心，也可以做配置管理来使用。\n\n### 统一配置管理\n\n当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。\n\nNacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。\n\n#### 在 Nacos 中添加配置文件\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.1k2q3p4hypa8.png)\n\n然后在弹出的表单中，填写配置信息：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.26dw95t2zibk.png)\n\n> 注意：项目的核心配置，需要热更新的配置才有放到 Nacos 管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。\n\n#### 从微服务拉取配置\n\n微服务要拉取 Nacos 中管理的配置，并且与本地的 application.yml 配置合并，才能完成项目启动。\n\n但如果尚未读取 application.yml，又如何得知 Nacos 地址呢？\n\n因此 Spring 引入了一种新的配置文件：bootstrap.yaml 文件，会在 application.yml 之前被读取，流程如下：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.50gh2h1avrw0.png)\n\n① 引入 nacos-config 依赖\n\n首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：\n\n```xml\n<!--nacos配置管理依赖-->\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>\n</dependency>\n```\n\n② 添加 bootstrap.yaml\n\n然后，在 user-service 中添加一个 bootstrap.yaml 文件，内容如下：\n\n```yaml\nspring:\n  application:\n    name: user-service # 服务名称\n  profiles:\n    active: dev # 开发环境，这里是 dev \n  cloud:\n    nacos:\n      server-addr: halo:8848 # Nacos地址\n      config:\n        file-extension: yaml # 文件后缀名\n```\n\n这里会根据 `spring.cloud.nacos.server-addr` 获取 Nacos 地址，再根据 `${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}` 作为文件 id，来读取配置。\n\n本例中，就是去读取 `user-service-dev.yaml`：\n\n③ 读取 Nacos 配置\n\n在 user-service 中的 `UserController` 中添加业务逻辑，读取 `pattern.dateformat` 配置：\n\n```java\n@Value(\"${pattern.dateformat}\")\nprivate String dateformat;\n\n@GetMapping(\"now\")\npublic String now() {\n    return LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));\n}\n```\n\n### 配置热更新\n\n我们最终的目的，是修改 Nacos 中的配置后，微服务中无需重启即可让配置生效，也就是配置热更新。\n\n要实现配置热更新，可以使用两种方式：\n\n#### 方式一\n\n在 `@Value` 注入的变量所在类上添加注解 `@RefreshScope`：\n\n```java\n@Slf4j\n@RestController\n@RequestMapping(\"/user\")\n@RefreshScope\npublic class UserController {\n    @Value(\"${pattern.dateformat}\")\n    private String dateformat;\n    \n    // 略\n}\n```\n\n#### 方式二\n\n使用 `@ConfigurationProperties` 注解代替 `@Value` 注解。\n\n在 user-service 服务中，添加一个类，读取 `patterrn.dateformat` 属性：\n\n```java\npackage cn.itcast.user.config;\n\nimport lombok.Data;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\nimport org.springframework.stereotype.Component;\n\n@Component\n@Data\n@ConfigurationProperties(prefix = \"pattern\")\npublic class PatternProperties {\n    private String dateformat;\n}\n```\n\n在 `UserController` 中使用这个类代替 `@Value`：\n\n```java\n@Autowired\nprivate PatternProperties properties;\n\n@GetMapping(\"now\")\npublic String now() {\n    return LocalDateTime.now().format(DateTimeFormatter.ofPattern(properties.getDateformat()));\n}\n```\n\n### 配置共享\n\n其实微服务启动时，会去 Nacos 读取多个配置文件，例如：\n\n- `[spring.application.name]-[spring.profiles.active].yaml`，例如：user-service-dev.yaml\n\n- `[spring.application.name].yaml`，例如：user-service.yaml\n\n而 `[spring.application.name].yaml` 不包含环境，因此可以被多个环境共享。\n\n下面我们通过案例来测试配置共享\n\n#### 添加一个环境共享配置\n\n在 Nacos 中添加一个 user-service.yaml 文件：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4j1r0ype41k0.png)\n\n#### 在 user-service 中读取共享配置\n\n在 user-service 服务中，修改 `PatternProperties` 类，读取新添加的属性：\n\n```java\n@Data\n@Component\n@ConfigurationProperties(prefix = \"pattern\")\npublic class PatternProperties {\n    private String dateformat;\n    private String envShareValue;\n}\n```\n\n在 user-service 服务中，修改 `UserController`，添加一个方法：\n\n```java\n@Autowired\nprivate PatternProperties properties;\n\n@GetMapping(\"prop\")\npublic PatternProperties prop(){\n    return properties;\n}\n```\n\n#### 不同的 profile 下测试\n\n运行两个 UserApplication，使用不同的 profile。修改 UserApplication2 这个启动项，改变其 profile 值：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5fmr356kyr80.png)\n\n这样，UserApplication（8081） 使用的 profile 是 dev，UserApplication2（8082） 使用的 profile 是 test。\n\n启动 UserApplication 和 UserApplication2\n\n可以看出来，不管是 dev，还是 test 环境，都读取到了envSharedValue 这个属性的值。\n\n#### 配置共享的优先级\n\n当 Nacos、服务本地同时出现相同属性时，优先级有高低之分，优先级从高到低依次是：\n\n+ 服务名-[profile].yaml\n+ 服务名.yaml\n+ 本地配置\n\n## 搭建 Nacos 集群\n\n计划的集群结构：\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3v4vof6qfki0.png)\n\n三个 nacos 节点的地址：\n\n| 节点   | ip   | port |\n| ------ | ---- | ---- |\n| nacos1 | halo | 8845 |\n| nacos2 | halo | 8846 |\n| nacos3 | halo | 8847 |\n\n搭建集群的基本步骤：\n\n- 搭建数据库，初始化数据库表结构\n- 下载 Nacos 安装包\n- 配置 Nacos\n- 启动 Nacos 集群\n- Nginx 反向代理\n\n### 初始化数据库\n\nNacos 默认数据存储在内嵌数据库 Derby 中，不属于生产可用的数据库。\n\n这里我们以单点的数据库为例来讲解。\n\n首先新建一个数据库，命名为 nacos，而后导入下面的 SQL：\n\n```sql\nCREATE TABLE `config_info` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'id\',\n  `data_id` varchar(255) NOT NULL COMMENT \'data_id\',\n  `group_id` varchar(255) DEFAULT NULL,\n  `content` longtext NOT NULL COMMENT \'content\',\n  `md5` varchar(32) DEFAULT NULL COMMENT \'md5\',\n  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'创建时间\',\n  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'修改时间\',\n  `src_user` text COMMENT \'source user\',\n  `src_ip` varchar(50) DEFAULT NULL COMMENT \'source ip\',\n  `app_name` varchar(128) DEFAULT NULL,\n  `tenant_id` varchar(128) DEFAULT \'\' COMMENT \'租户字段\',\n  `c_desc` varchar(256) DEFAULT NULL,\n  `c_use` varchar(64) DEFAULT NULL,\n  `effect` varchar(64) DEFAULT NULL,\n  `type` varchar(64) DEFAULT NULL,\n  `c_schema` text,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_configinfo_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'config_info\';\n\n/******************************************/\n/*   数据库全名 = nacos_config   */\n/*   表名称 = config_info_aggr   */\n/******************************************/\nCREATE TABLE `config_info_aggr` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'id\',\n  `data_id` varchar(255) NOT NULL COMMENT \'data_id\',\n  `group_id` varchar(255) NOT NULL COMMENT \'group_id\',\n  `datum_id` varchar(255) NOT NULL COMMENT \'datum_id\',\n  `content` longtext NOT NULL COMMENT \'内容\',\n  `gmt_modified` datetime NOT NULL COMMENT \'修改时间\',\n  `app_name` varchar(128) DEFAULT NULL,\n  `tenant_id` varchar(128) DEFAULT \'\' COMMENT \'租户字段\',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`data_id`,`group_id`,`tenant_id`,`datum_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'增加租户字段\';\n\n\n/******************************************/\n/*   数据库全名 = nacos_config   */\n/*   表名称 = config_info_beta   */\n/******************************************/\nCREATE TABLE `config_info_beta` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'id\',\n  `data_id` varchar(255) NOT NULL COMMENT \'data_id\',\n  `group_id` varchar(128) NOT NULL COMMENT \'group_id\',\n  `app_name` varchar(128) DEFAULT NULL COMMENT \'app_name\',\n  `content` longtext NOT NULL COMMENT \'content\',\n  `beta_ips` varchar(1024) DEFAULT NULL COMMENT \'betaIps\',\n  `md5` varchar(32) DEFAULT NULL COMMENT \'md5\',\n  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'创建时间\',\n  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'修改时间\',\n  `src_user` text COMMENT \'source user\',\n  `src_ip` varchar(50) DEFAULT NULL COMMENT \'source ip\',\n  `tenant_id` varchar(128) DEFAULT \'\' COMMENT \'租户字段\',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_configinfobeta_datagrouptenant` (`data_id`,`group_id`,`tenant_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'config_info_beta\';\n\n/******************************************/\n/*   数据库全名 = nacos_config   */\n/*   表名称 = config_info_tag   */\n/******************************************/\nCREATE TABLE `config_info_tag` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'id\',\n  `data_id` varchar(255) NOT NULL COMMENT \'data_id\',\n  `group_id` varchar(128) NOT NULL COMMENT \'group_id\',\n  `tenant_id` varchar(128) DEFAULT \'\' COMMENT \'tenant_id\',\n  `tag_id` varchar(128) NOT NULL COMMENT \'tag_id\',\n  `app_name` varchar(128) DEFAULT NULL COMMENT \'app_name\',\n  `content` longtext NOT NULL COMMENT \'content\',\n  `md5` varchar(32) DEFAULT NULL COMMENT \'md5\',\n  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'创建时间\',\n  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'修改时间\',\n  `src_user` text COMMENT \'source user\',\n  `src_ip` varchar(50) DEFAULT NULL COMMENT \'source ip\',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`data_id`,`group_id`,`tenant_id`,`tag_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'config_info_tag\';\n\n/******************************************/\n/*   数据库全名 = nacos_config   */\n/*   表名称 = config_tags_relation   */\n/******************************************/\nCREATE TABLE `config_tags_relation` (\n  `id` bigint(20) NOT NULL COMMENT \'id\',\n  `tag_name` varchar(128) NOT NULL COMMENT \'tag_name\',\n  `tag_type` varchar(64) DEFAULT NULL COMMENT \'tag_type\',\n  `data_id` varchar(255) NOT NULL COMMENT \'data_id\',\n  `group_id` varchar(128) NOT NULL COMMENT \'group_id\',\n  `tenant_id` varchar(128) DEFAULT \'\' COMMENT \'tenant_id\',\n  `nid` bigint(20) NOT NULL AUTO_INCREMENT,\n  PRIMARY KEY (`nid`),\n  UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),\n  KEY `idx_tenant_id` (`tenant_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'config_tag_relation\';\n\n/******************************************/\n/*   数据库全名 = nacos_config   */\n/*   表名称 = group_capacity   */\n/******************************************/\nCREATE TABLE `group_capacity` (\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT \'主键ID\',\n  `group_id` varchar(128) NOT NULL DEFAULT \'\' COMMENT \'Group ID，空字符表示整个集群\',\n  `quota` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'配额，0表示使用默认值\',\n  `usage` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'使用量\',\n  `max_size` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'单个配置大小上限，单位为字节，0表示使用默认值\',\n  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'聚合子配置最大个数，，0表示使用默认值\',\n  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值\',\n  `max_history_count` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'最大变更历史数量\',\n  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'创建时间\',\n  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'修改时间\',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_group_id` (`group_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'集群、各Group容量信息表\';\n\n/******************************************/\n/*   数据库全名 = nacos_config   */\n/*   表名称 = his_config_info   */\n/******************************************/\nCREATE TABLE `his_config_info` (\n  `id` bigint(64) unsigned NOT NULL,\n  `nid` bigint(20) unsigned NOT NULL AUTO_INCREMENT,\n  `data_id` varchar(255) NOT NULL,\n  `group_id` varchar(128) NOT NULL,\n  `app_name` varchar(128) DEFAULT NULL COMMENT \'app_name\',\n  `content` longtext NOT NULL,\n  `md5` varchar(32) DEFAULT NULL,\n  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP,\n  `src_user` text,\n  `src_ip` varchar(50) DEFAULT NULL,\n  `op_type` char(10) DEFAULT NULL,\n  `tenant_id` varchar(128) DEFAULT \'\' COMMENT \'租户字段\',\n  PRIMARY KEY (`nid`),\n  KEY `idx_gmt_create` (`gmt_create`),\n  KEY `idx_gmt_modified` (`gmt_modified`),\n  KEY `idx_did` (`data_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'多租户改造\';\n\n\n/******************************************/\n/*   数据库全名 = nacos_config   */\n/*   表名称 = tenant_capacity   */\n/******************************************/\nCREATE TABLE `tenant_capacity` (\n  `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT \'主键ID\',\n  `tenant_id` varchar(128) NOT NULL DEFAULT \'\' COMMENT \'Tenant ID\',\n  `quota` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'配额，0表示使用默认值\',\n  `usage` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'使用量\',\n  `max_size` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'单个配置大小上限，单位为字节，0表示使用默认值\',\n  `max_aggr_count` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'聚合子配置最大个数\',\n  `max_aggr_size` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'单个聚合数据的子配置大小上限，单位为字节，0表示使用默认值\',\n  `max_history_count` int(10) unsigned NOT NULL DEFAULT \'0\' COMMENT \'最大变更历史数量\',\n  `gmt_create` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'创建时间\',\n  `gmt_modified` datetime NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT \'修改时间\',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_tenant_id` (`tenant_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'租户容量信息表\';\n\n\nCREATE TABLE `tenant_info` (\n  `id` bigint(20) NOT NULL AUTO_INCREMENT COMMENT \'id\',\n  `kp` varchar(128) NOT NULL COMMENT \'kp\',\n  `tenant_id` varchar(128) default \'\' COMMENT \'tenant_id\',\n  `tenant_name` varchar(128) default \'\' COMMENT \'tenant_name\',\n  `tenant_desc` varchar(256) DEFAULT NULL COMMENT \'tenant_desc\',\n  `create_source` varchar(32) DEFAULT NULL COMMENT \'create_source\',\n  `gmt_create` bigint(20) NOT NULL COMMENT \'创建时间\',\n  `gmt_modified` bigint(20) NOT NULL COMMENT \'修改时间\',\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),\n  KEY `idx_tenant_id` (`tenant_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=\'tenant_info\';\n\nCREATE TABLE `users` (\n	`username` varchar(50) NOT NULL PRIMARY KEY,\n	`password` varchar(500) NOT NULL,\n	`enabled` boolean NOT NULL\n);\n\nCREATE TABLE `roles` (\n	`username` varchar(50) NOT NULL,\n	`role` varchar(50) NOT NULL,\n	UNIQUE INDEX `idx_user_role` (`username` ASC, `role` ASC) USING BTREE\n);\n\nCREATE TABLE `permissions` (\n    `role` varchar(50) NOT NULL,\n    `resource` varchar(255) NOT NULL,\n    `action` varchar(8) NOT NULL,\n    UNIQUE INDEX `uk_role_permission` (`role`,`resource`,`action`) USING BTREE\n);\n\nINSERT INTO users (username, password, enabled) VALUES (\'nacos\', \'$2a$10$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu\', TRUE);\n\nINSERT INTO roles (username, role) VALUES (\'nacos\', \'ROLE_ADMIN\');\n```\n\n### 下载 Nacos\n\nNacos 在 GitHub 上有下载地址：https://github.com/alibaba/nacos/tags，可以选择任意版本下载。\n\n本例中才用 1.4.1 版本\n\n### 配置 Nacos\n\n将这个包解压到任意非中文目录下\n\n- bin：启动脚本\n- conf：配置文件\n\n进入 Nacos 的 conf 目录，修改配置文件 cluster.conf.example，重命名为 cluster.conf\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5nlh9ki5w2s0.png)\n\n然后添加内容：\n\n```\n127.0.0.1:8845\n127.0.0.1.8846\n127.0.0.1.8847\n```\n\n然后修改 application.properties 文件，添加数据库配置\n\n```\nspring.datasource.platform=mysql\n\ndb.num=1\n\ndb.url.0=jdbc:mysql://halo:3306/nacos?characterEncoding=utf8&connectTimeout=1000&socketTimeout=3000&autoReconnect=true&useUnicode=true&useSSL=false&serverTimezone=UTC\ndb.user.0=root\ndb.password.0=mogu2018\n```\n\n### 启动 Nacos\n\n将 nacos 文件夹复制三份，分别命名为：nacos1、nacos2、nacos3\n\n然后分别修改三个文件夹中的 application.properties，\n\nnacos1:\n\n```properties\nserver.port=8845\n```\n\nnacos2:\n\n```properties\nserver.port=8846\n```\n\nnacos3:\n\n```properties\nserver.port=8847\n```\n\n然后分别启动三个 nacos 节点：\n\n```\nstartup.cmd\n```\n\n### Nginx 反向代理\n\n修改 conf/nginx.conf 文件，配置如下：\n\n```\nupstream nacos-cluster {\n    server 127.0.0.1:8845;\n	server 127.0.0.1:8846;\n	server 127.0.0.1:8847;\n}\n\nserver {\n    listen       80;\n    server_name  localhost;\n\n    location /nacos {\n        proxy_pass http://nacos-cluster;\n    }\n}\n```\n\n而后在浏览器访问：http://localhost/nacos 即可。\n\n代码中 application.yml 文件配置如下：\n\n```yaml\nspring:\n  cloud:\n    nacos:\n      server-addr: localhost:80 # Nacos地址\n```\n\n- 实际部署时，需要给做反向代理的 Nginx 服务器设置一个域名，这样后续如果有服务器迁移 Nacos 的客户端也无需更改配置。\n\n- Nacos 的各个节点应该部署到多个不同服务器，做好容灾和隔离\n\n## Feign 远程调用\n\n先来看我们以前利用 RestTemplate 发起远程调用的代码：\n\n```java\n// 2. 利用 RestTemplate 发起 http 请求，查询用户\nString url = \"http://user-service/user/\" + order.getUserId();\nUser user = restTemplate.getForObject(url, User.class);\n```\n\n存在下面的问题：\n\n+ 代码可读性差，编程体验不统一\n+ 参数复杂 URL 难以维护\n\nFeign 是一个声明式的 http 客户端，官方地址：https://github.com/OpenFeign/feign\n\n其作用就是帮助我们优雅的实现 http 请求的发送，解决上面提到的问题。\n\n### Feign 替代 RestTemplate\n\nFeign 的使用步骤如下：\n\n#### 引入依赖\n\n我们在 order-service 服务的 pom 文件中引入 feign 的依赖：\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n\n#### 添加注解\n\n在 order-service 的启动类添加 `@EnableFeignClients` 注解开启 Feign 的功能：\n\n```java\n@EnableFeignClients\n@MapperScan(\"cn.itcast.order.mapper\")\n@SpringBootApplication\npublic class OrderApplication {\n    public static void main(String[] args) {\n        SpringApplication.run(OrderApplication.class, args);\n    }\n}\n```\n\n#### 编写 Feign 的客户端\n\n在 order-service 中新建一个接口，内容如下：\n\n```java\npackage cn.itcast.order.clients;\n\nimport cn.itcast.order.pojo.User;\nimport org.springframework.cloud.openfeign.FeignClient;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\n\n@FeignClient(\"user-service\")\npublic interface UserClient {\n    @GetMapping(\"/user/{id}\")\n    User findById(@PathVariable(\"id\") Long id);\n}\n```\n\n这个客户端主要是基于 SpringMVC 的注解来声明远程调用的信息，比如：\n\n- 服务名称：user-service\n- 请求方式：GET\n- 请求路径：/user/{id}\n- 请求参数：Long id\n- 返回值类型：User\n\n这样，Feign 就可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。\n\n#### 测试\n\n修改 order-service 中的 `OrderService` 类中的 `queryOrderById` 方法，使用 Feign 客户端代替 RestTemplate：\n\n```java\n@Service\npublic class OrderService {\n\n    @Autowired\n    private OrderMapper orderMapper;\n\n    @Autowired\n    private UserClient userClient;\n\n    public Order queryOrderById(Long orderId) {\n        // 1.查询订单\n        Order order = orderMapper.findById(orderId);\n        // 2. 使用 Feign 进行远程调用\n        User user = userClient.findById(order.getUserId());\n        // 3. 封装 user 到 Order\n        order.setUser(user);\n        // 4.返回\n        return order;\n    }\n}\n```\n\n#### Feign 替代 RestTemplate 小结\n\n使用 Feign 的步骤：\n\n1. 引入依赖\n2. 添加 `@EnableFeignClients` 注解\n3. 编写 FeignClient 接口\n4. 使用 FeignClient 中定义的方法代替 RestTemplate\n\n### Feign 的自定义配置\n\nFeign 可以支持很多的自定义配置，如下表所示：\n\n| 类型                  | 作用             | 说明                                                        |\n| --------------------- | ---------------- | ----------------------------------------------------------- |\n| `feign.Logger.Level`  | 修改日志级别     | 包含四种不同的级别：NONE、BASIC、HEADERS、FULL              |\n| `feign.codec.Decoder` | 响应结果的解析器 | http 远程调用的结果做解析，例如解析 JSON 字符串为 Java 对象 |\n| `feign.codec.Encoder` | 请求参数编码     | 将请求参数编码，便于通过 http 请求发送                      |\n| `feign.Contract`      | 支持的注解格式   | 默认是 SpringMVC 的注解                                     |\n| `feign.Retryer`       | 失败重试机制     | 请求失败的重试机制，默认是没有，不过会使用Ribbon 的重试     |\n\n一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的 `@Bean` 覆盖默认Bean 即可。\n\n下面以日志为例来演示如何自定义配置。\n\n#### 配置文件方式\n\n基于配置文件修改 Feign 的日志级别可以针对单个服务：\n\n```yaml\nfeign:  \n  client:\n    config: \n      userservice: # 针对某个微服务的配置\n        loggerLevel: FULL # 日志级别 \n```\n\n也可以针对所有服务：\n\n```yaml\nfeign:  \n  client:\n    config: \n      default: # 这里用 default 就是全局配置，如果是写服务名称，则是针对某个微服务的配置\n        loggerLevel: FULL # 日志级别 \n```\n\n而日志的级别分为四种：\n\n- NONE：不记录任何日志信息，这是默认值。\n- BASIC：仅记录请求的方法，URL 以及响应状态码和执行时间\n- HEADERS：在 BASIC 的基础上，额外记录了请求和响应的头信息\n- FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。\n\n#### Java 代码方式\n\n也可以基于 Java 代码来修改日志级别，先声明一个类，然后声明一个 `Logger.Level` 的对象：\n\n```java\npublic class DefaultFeignConfiguration  {\n    @Bean\n    public Logger.Level feignLogLevel(){\n        return Logger.Level.BASIC; // 日志级别为BASIC\n    }\n}\n```\n\n如果要全局生效，将其放到启动类的 `@EnableFeignClients` 这个注解中：\n\n```java\n@EnableFeignClients(defaultConfiguration = DefaultFeignConfiguration .class) \n```\n\n如果是局部生效，则把它放到对应的 `@FeignClient` 这个注解中：\n\n```java\n@FeignClient(value = \"user-service\", configuration = DefaultFeignConfiguration .class)\n```\n\n### Feign 使用优化\n\nFeign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现包括：\n\n+ URLConnection：默认实现，不支持连接池\n+ Apache HttpClient ：支持连接池\n+ OKHttp：支持连接池\n\n因此提高 Feign 的性能主要手段就是使用连接池代替默认的 URLConnection。\n\n这里我们用 Apache 的 HttpClient 来演示。\n\n#### 引入依赖\n\n在 order-service 的 pom 文件中引入 Apache 的 HttpClient 依赖：\n\n```xml\n<!--httpClient的依赖 -->\n<dependency>\n    <groupId>io.github.openfeign</groupId>\n    <artifactId>feign-httpclient</artifactId>\n</dependency>\n```\n\n#### 配置连接池\n\n在 order-service 的 application.yml 中添加配置：\n\n```yaml\nfeign:\n  client:\n    config:\n      default: # default 全局的配置\n        loggerLevel: BASIC # 日志级别，BASIC 就是基本的请求和响应信息\n  httpclient:\n    enabled: true # 开启 feign 对 HttpClient 的支持\n    max-connections: 200 # 最大的连接数\n    max-connections-per-route: 50 # 每个路径的最大连接数\n```\n\n#### Feign 的优化小结\n\n1. 日志级别尽量用 basic\n2. 使用 HttpClient（或 OKHttp ）代替 URLConnection\n   + 引入 feign-httpclient 依赖\n   + 配置文件开启 httpclient 功能，设置连接池参数\n\n## Feign 的最佳实践\n\n所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。\n\n仔细观察可以发现，Feign 的客户端与服务提供者的 controller 代码非常相似\n\nFeign客户端：\n\n```java\n@GetMapping(\"/user/{id}\")\nUser findById(@PathVariable(\"id\") Long id);\n```\n\nUserController：\n\n```java\n@GetMapping(\"/{id}\")\npublic User queryById(@PathVariable(\"id\") Long id) {\n    return userService.queryById(id);\n}\n```\n\n有没有一种办法简化这种重复的代码编写呢？\n\n### 继承方式\n\n一样的代码可以通过继承来共享：\n\n1. 定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明。\n2. Feign 客户端和 Controller 都集成改接口\n\n优点：简单、实现了代码共享\n\n缺点：\n\n+ 服务提供方、服务消费方紧耦合\n+ 参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解\n\n### 抽取方式\n\n将 Feign 的 Client 抽取为独立模块，并且把接口有关的 POJO、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。\n\n例如，将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。\n\n### 基于抽取的最佳实践实现\n\n#### 抽取\n\n首先创建一个 module，命名为 feign-api\n\n在 feign-api 中然后引入 feign 的 starter 依赖\n\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n\n然后，order-service 中编写的 UserClient、User、DefaultFeignConfiguration 都剪切到 feign-api项目中\n\n#### 使用 feign-api\n\n在 order-service 的 pom 文件中中引入 feign-api 的依赖：\n\n```xml\n<dependency>\n    <groupId>cn.itcast.demo</groupId>\n    <artifactId>feign-api</artifactId>\n    <version>1.0</version>\n</dependency>\n```\n\n修改 order-service 中的所有与上述三个组件有关的导包部分，改成导入 feign-api 中的包\n\n#### 解决扫描包问题\n\norder-service 的 `@EnableFeignClients` 注解是在 cn.itcast.order 包下，不在同一个包，无法扫描到 UserClient。\n\n方式一，指定 Feign 应该扫描的包：\n\n```java\n@EnableFeignClients(basePackages = \"cn.itcast.feign.clients\")\n```\n\n方式二，指定需要加载的 Client 接口：\n\n```java\n@EnableFeignClients(clients = {UserClient.class})\n```\n\n## Gateway 服务网关\n\nSpring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。\n\n### 为什么需要网关\n\nGateway 网关是我们服务的守门神，所有微服务的统一入口。\n\n网关的核心功能特性：\n\n- 请求路由\n- 权限控制\n- 限流\n\n权限控制：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。\n\n路由和负载均衡：一切请求都必须先经过 Gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。\n\n限流：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。\n\n在 Spring Cloud 中网关的实现包括两种：Gateway、Zuul\n\nZuul 是基于 Servlet 的实现，属于阻塞式编程。而 Spring Cloud Gateway 则是基于 Spring 5 中提供的 WebFlux，属于响应式编程的实现，具备更好的性能。\n\n### Gateway 快速入门\n\n下面，我们就演示下网关的基本路由功能。基本步骤如下：\n\n1. 创建 Maven 工程 gateway，引入网关依赖\n2. 编写启动类\n3. 编写基础配置和路由规则\n4. 启动网关服务进行测试\n\n#### 创建 Gateway 服务并引入依赖\n\n创建 gateway 服务，引入一下依赖：\n\n```xml\n<!--网关-->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-gateway</artifactId>\n</dependency>\n<!--nacos服务发现依赖-->\n<dependency>\n    <groupId>com.alibaba.cloud</groupId>\n    <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>\n</dependency>\n```\n\n#### 编写启动类\n\n```java\npackage cn.itcast.gateway;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@SpringBootApplication\npublic class GatewayApplication {\n\n	public static void main(String[] args) {\n		SpringApplication.run(GatewayApplication.class, args);\n	}\n}\n```\n\n#### 编写基础配置和路由规则\n\n创建 application.yml 文件，内容如下：\n\n```yaml\nserver:\n  port: 10010 # 网关端口\nspring:\n  application:\n    name: gateway # 服务名称\n  cloud:\n    nacos:\n      server-addr: halo:8848 # nacos地址\n    gateway:\n      routes: # 网关路由配置\n        - id: user-service-gateway # 路由id，自定义，只要唯一即可\n          # uri: http://127.0.0.1:8081 # 路由的目标地址 http就是固定地址\n          uri: lb://user-service # 路由的目标地址 lb就是负载均衡，后面跟服务名称\n          predicates: # 路由断言，也就是判断请求是否符合路由规则的条件\n            - Path=/user/** # 这个是按照路径匹配，只要以/user/开头就符合要求\n```\n\n我们将符合 `Path` 规则的一切请求，都代理到 `uri` 参数指定的地址。\n\n本例中，我们将 `/user/**`开头的请求，代理到 `lb://user-service`，lb 是负载均衡，根据服务名拉取服务列表，实现负载均衡。\n\n#### 启动测试\n\n启动网关，访问 http://localhost:10010/user/1 时，符合`/user/**`规则，请求转发到 uri：http://userservice/user/1，得到了结果\n\n#### 网关路由的流程图\n\n![Gateway网关路由的流程图](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Gateway网关路由的流程图.6onddfdjlr00.svg)\n\n#### Gateway 快速入门小结\n\n网关搭建步骤：\n\n1. 创建项目，引入 nacos 服务发现和 gateway 依赖\n\n2. 配置 application.yml，包括服务基本信息、nacos 地址、路由\n\n路由配置包括：\n\n1. 路由 id：路由的唯一标示\n\n2. 路由目标（uri）：路由的目标地址，http 代表固定地址，lb 代表根据服务名负载均衡\n\n3. 路由断言（predicates）：判断路由的规则，\n\n4. 路由过滤器（filters）：对请求或响应做处理\n\n### 断言工厂\n\n我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件\n\n例如 `Path=/user/**` 是按照路径匹配，这个规则是由 `org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory` 类来处理的，像这样的断言工厂在 Spring Cloud Gateway 还有十几个：\n\n| 名称       | 说明                            | 示例                                                         |\n| ---------- | ------------------------------- | ------------------------------------------------------------ |\n| After      | 是某个时间点后的请求            | `-  After=2037-01-20T17:42:47.789-07:00[America/Denver]`     |\n| Before     | 是某个时间点之前的请求          | `-  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]`     |\n| Between    | 是某两个时间点之前的请求        | `-  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver]` |\n| Cookie     | 请求必须包含某些 cookie         | `- Cookie=chocolate, ch.p`                                   |\n| Header     | 请求必须包含某些 header         | `- Header=X-Request-Id, \\d+`                                 |\n| Host       | 请求必须是访问某个 host（域名） | `-  Host=**.somehost.org,**.anotherhost.org`                 |\n| Method     | 请求方式必须是指定方式          | `- Method=GET,POST`                                          |\n| Path       | 请求路径必须符合指定规则        | `- Path=/red/{segment},/blue/**`                             |\n| Query      | 请求参数必须包含指定参数        | `- Query=name, Jack` 或者 `-  Query=name`                    |\n| RemoteAddr | 请求者的 ip 必须是指定范围      | `- RemoteAddr=192.168.1.1/24`                                |\n| Weight     | 权重处理                        |                                                              |\n\n详情查阅：[官方文档](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories)\n\n### 过滤器工厂\n\nGateway Filter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：\n\n![过滤器工厂](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/过滤器工厂.2sw963vwfry0.svg)\n\n#### 路由过滤器的种类\n\nSpring 提供了 31 种不同的路由过滤器工厂。例如：\n\n| 名称                   | 说明                         |\n| ---------------------- | ---------------------------- |\n| `AddRequestHeader`     | 给当前请求添加一个请求头     |\n| `RemoveRequestHeader`  | 移除请求中的一个请求头       |\n| `AddResponseHeader`    | 给响应结果中添加一个响应头   |\n| `RemoveResponseHeader` | 从响应结果中移除有一个响应头 |\n| `RequestRateLimiter`   | 限制请求的流量               |\n\n详情查阅：[官方文档](https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories)\n\n#### 请求头过滤器\n\n下面我们以 `AddRequestHeader` 为例来讲解。\n\n需求：给所有进入 user-service 的请求添加一个请求头：Truth=Halo\n\n只需要修改 gateway 服务的 application.yml 文件，添加路由过滤即可：\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: user-service \n        uri: lb://userservice \n        predicates: \n        - Path=/user/** \n        filters: # 过滤器\n        - AddRequestHeader=Truth, Halo # 添加请求头\n```\n\n当前过滤器写在 user-service 路由下，因此仅仅对访问 user-service 的请求有效。\n\n#### 默认过滤器\n\n如果要对所有的路由都生效，则可以将过滤器工厂写到 default 下。格式如下：\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      routes:\n      - id: user-service \n        uri: lb://userservice \n        predicates: \n        - Path=/user/**\n      default-filters: # 默认过滤项\n      - AddRequestHeader=Truth, Halo\n```\n\n#### 过滤器工厂总结\n\n过滤器的作用是什么？\n\n+ 对路由的请求或响应做加工处理，比如添加请求头\n+ 配置在路由下的过滤器只对当前路由的请求生效\n\ndefaultFilters 的作用是什么？\n\n+ 对所有路由都生效的过滤器\n\n### 全局过滤器\n\n上一节学习的过滤器，网关提供了 31 种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。\n\n#### 全局过滤器作用\n\n全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与 GatewayFilter 的作用一样。\n\n两者的区别在于： \n\n+ GatewayFilter 通过配置定义，处理逻辑是固定的；\n+ GlobalFilter 的逻辑需要自己写代码实现。\n\n定义方式是实现 GlobalFilter 接口。\n\n```java\npublic interface GlobalFilter {\n    /**\n     *  处理当前请求，有必要的话通过{@link GatewayFilterChain}将请求交给下一个过滤器处理\n     *\n     * @param exchange 请求上下文，里面可以获取Request、Response等信息\n     * @param chain 用来把请求委托给下一个过滤器 \n     * @return {@code Mono<Void>} 返回标示当前过滤器业务结束\n     */\n    Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain);\n}\n```\n\n在 filter 中编写自定义逻辑，可以实现下列功能：\n\n- 登录状态判断\n- 权限校验\n- 请求限流等\n\n#### 自定义全局过滤器\n\n需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：\n\n- 参数中是否有 authorization，\n\n- authorization 参数值是否为 admin\n\n如果同时满足则放行，否则拦截\n\n实现，在 gateway 中定义一个过滤器：\n\n```java\n@Order(-1)\n@Component\npublic class AuthorizeFilter implements GlobalFilter {\n    @Override\n    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {\n        // 1. 获取请求参数\n        ServerHttpRequest request = exchange.getRequest();\n        MultiValueMap<String, String> queryParams = request.getQueryParams();\n        // 2. 获取参数中的 authorization\n        String auth = queryParams.getFirst(\"authorization\");\n        // 3. 判断参数值是否等于 admin\n        if (\"admin\".equals(auth)) {\n            // 放行\n            return chain.filter(exchange);\n        }\n        // 拦截\n        // 设置状态码\n        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);\n        // 拦截请求\n        return exchange.getResponse().setComplete();\n    }\n}\n```\n\n`@Order(-1)` 用于指定过滤器顺序，值越小优先级越高\n\n重启网关，访问 http://localhost:10010/user/1?authorization=admin\n\n#### 过滤器执行顺序\n\n请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter\n\n请求路由后，会将当前路由过滤器和 DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：\n\n![过滤器执行顺序](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/过滤器执行顺序.4mfcqien0h60.svg)\n\n排序的规则是什么呢？\n\n- 首先，每一个过滤器都必须指定一个 int 类型的 order 值，order 值越小，优先级越高，执行顺序越靠前。\n- GlobalFilter 通过实现 Ordered 接口，或者添加 `@Order` 注解来指定 order 值，由我们自己指定。路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从 1 递增。\n- 当过滤器的 order 值一样时，会按照 defaultFilter、路由过滤器、GlobalFilter 的顺序执行。\n\n详细内容，可以查看源码：\n\n+ `org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()` 方法是先加载 defaultFilters，然后再加载某个 route 的 filters，然后合并。\n+ `org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()` 方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链\n\n### 跨域问题\n\n#### 什么是跨域问题\n\n跨域：域名不一致就是跨域，主要包括：\n\n- 域名不同： www.taobao.com 和 www.taobao.org 和 www.jd.com 和 miaosha.jd.com\n\n- 域名相同，端口不同：localhost:8080 和 localhost8081\n\n跨域问题：浏览器禁止请求的发起者与服务端发生跨域 Ajax 请求，请求被浏览器拦截的问题\n\nCORS 解决方案，参考资料：https://www.ruanyifeng.com/blog/2016/04/cors.html\n\n#### 解决跨域问题\n\n在 gateway 服务的 application.yml 文件中，添加下面的配置：\n\n```yaml\nspring:\n  cloud:\n    gateway:\n      # .\n      globalcors: # 全局的跨域处理\n        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题\n        corsConfigurations:\n          \'[/**]\':\n            allowedOrigins: # 允许哪些网站的跨域请求 \n              - \"http://localhost:8090\"\n            allowedMethods: # 允许的跨域ajax的请求方式\n              - \"GET\"\n              - \"POST\"\n              - \"DELETE\"\n              - \"PUT\"\n              - \"OPTIONS\"\n            allowedHeaders: \"*\" # 允许在请求中携带的头信息\n            allowCredentials: true # 是否允许携带cookie\n            maxAge: 360000 # 这次跨域检测的有效期\n```\n\n\n\n\n\n\n\n\n\n', '2021-10-17 06:37:27', 1, 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/macos.6z1mshl4twk0.svg', 2, '2021-10-14 11:20:50', NULL, NULL, NULL, 1, 1, 0, NULL, 0, '<h2 id=\"认识微服务\">认识微服务</h2>\n<h3 id=\"单体架构与分布式架构\">单体架构与分布式架构</h3>\n<p>单体架构：将业务的所有功能集中在一个项目中开发，打成一个包部署。优点是架构简单、部署成本低，但耦合度高（维护困难、升级困难）</p>\n<p>分布式架构：根据业务功能对系统做拆分，每个业务功能模块作为独立项目开发，称为一个服务。降低了服务耦合，有利于服务升级和拓展，但服务调用关系错综复杂</p>\n<p>分布式架构虽然降低了服务耦合，但是服务拆分时也有很多问题需要思考：</p>\n<ul>\n<li>服务拆分的粒度如何界定？</li>\n<li>服务之间如何调用？</li>\n<li>服务的调用关系如何管理？</li>\n</ul>\n<p>人们需要制定一套行之有效的标准来约束分布式架构。</p>\n<h3 id=\"微服务\">微服务</h3>\n<p>微服务的架构特征：</p>\n<ul>\n<li>单一职责：微服务拆分粒度更小，每一个服务都对应唯一的业务能力，做到单一职责</li>\n<li>自治：团队独立、技术独立、数据独立，独立部署和交付</li>\n<li>面向服务：服务提供统一标准的接口，与语言和技术无关</li>\n<li>隔离性强：服务调用做好隔离、容错、降级，避免出现级联问题</li>\n</ul>\n<p>微服务的上述特性其实是在给分布式架构制定一个标准，进一步降低服务之间的耦合度，提供服务的独立性和灵活性。做到高内聚，低耦合。</p>\n<p>因此，可以认为微服务是一种经过良好架构设计的分布式架构方案 。</p>\n<p>但方案该怎么落地？选用什么样的技术栈？全球的互联网公司都在积极尝试自己的微服务落地方案。</p>\n<p>其中在 Java 领域最引人注目的就是 Spring Cloud 提供的方案了。</p>\n<h3 id=\"spring-cloud\">Spring Cloud</h3>\n<p>Spring Cloud 是目前国内使用最广泛的微服务框架。官网地址：<a href=\"https://spring.io/projects/spring-cloud%E3%80%82\">https://spring.io/projects/spring-cloud。</a></p>\n<p>Spring Cloud 集成了各种微服务功能组件，并基于 Spring Boot 实现了这些组件的自动装配，从而提供了良好的开箱即用体验。</p>\n<p>其中常见的组件包括：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E7%BB%84%E4%BB%B6.8239z8cveb0.svg\" alt=\"微服务组件\"></p>\n<p>另外，Spring Cloud 底层是依赖于 Spring Boot 的，并且有版本的兼容关系，如下：</p>\n<p><img src=\"https://pic.imgdb.cn/item/6133818144eaada739d722b1.jpg\" alt=\"SpringBoot与SpringCloud\"></p>\n<h3 id=\"认识微服务小结\">认识微服务小结</h3>\n<ul>\n<li>单体架构：简单方便，高度耦合，扩展性差，适合小型项目。例如：学生管理系统</li>\n<li>分布式架构：松耦合，扩展性好，但架构复杂，难度大。适合大型互联网项目，例如：京东、淘宝</li>\n<li>微服务：一种良好的分布式架构方案<ul>\n<li>优点：拆分粒度更小、服务更独立、耦合度更低</li>\n<li>缺点：架构非常复杂，运维、监控、部署难度提高</li>\n</ul>\n</li>\n<li>Spring Cloud 是微服务架构的一站式解决方案，集成了各种优秀微服务功能组件</li>\n</ul>\n<h2 id=\"服务拆分和远程调用\">服务拆分和远程调用</h2>\n<h3 id=\"服务拆分原则\">服务拆分原则</h3>\n<p>微服务拆分时的几个原则：</p>\n<ul>\n<li>不同微服务，不要重复开发相同业务</li>\n<li>微服务数据独立，不要访问其它微服务的数据库</li>\n<li>微服务可以将自己的业务暴露为接口，供其它微服务调用</li>\n</ul>\n<h3 id=\"服务拆分示例\">服务拆分示例</h3>\n<p>以 spring-cloud-demo 为例，其结构如下：</p>\n<pre><code>spring-<span class=\"hljs-keyword\">cloud-demo\n</span> ├── <span class=\"hljs-keyword\">order-service\n</span> └── user-service\n</code></pre>\n<p>spring-cloud-demo：父工程，管理依赖</p>\n<ul>\n<li>order-service：订单微服务，负责订单相关业务</li>\n<li>user-service：用户微服务，负责用户相关业务</li>\n</ul>\n<p>要求：</p>\n<ul>\n<li>订单微服务和用户微服务都必须有各自的数据库，相互独立</li>\n<li>订单服务和用户服务都对外暴露 Restful 的接口</li>\n<li>订单服务如果需要查询用户信息，只能调用用户服务的 Restful 接口，不能查询用户数据库</li>\n</ul>\n<p>初始项目代码：<a href=\"https://github.com/Lanqilu/HaloSpringCloud/releases/tag/v0.1\">链接</a></p>\n<h3 id=\"实现远程调用案例\">实现远程调用案例</h3>\n<h4 id=\"案例需求\">案例需求</h4>\n<p>修改 order-service 中的根据 id 查询订单业务，要求在查询订单的同时，根据订单中包含的 userId 查询出用户信息，一起返回。</p>\n<p>因此，我们需要在 order-service 中向 user-service 发起一个 http 的请求，调用 <code>http://localhost:8081/user/{userId}</code> 这个接口。</p>\n<p>大概的步骤是这样的：</p>\n<ul>\n<li>注册一个 RestTemplate 的实例到 Spring 容器</li>\n<li>修改 order-service 服务中的 OrderService 类中的 queryOrderById 方法，根据 Order 对象中的 userId 查询 User</li>\n<li>将查询的 User 填充到 Order 对象，一起返回</li>\n</ul>\n<h4 id=\"注册-resttemplate\">注册 RestTemplate</h4>\n<p>首先，我们在 order-service 服务中的 OrderApplication 启动类中，注册 RestTemplate 实例：</p>\n<pre><code class=\"hljs language-java\">package cn.<span class=\"hljs-property\">itcast</span>.<span class=\"hljs-property\">order</span>;\n\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">mybatis</span>.<span class=\"hljs-property\">spring</span>.<span class=\"hljs-property\">annotation</span>.<span class=\"hljs-property\">MapperScan</span>;\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">springframework</span>.<span class=\"hljs-property\">boot</span>.<span class=\"hljs-property\">SpringApplication</span>;\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">springframework</span>.<span class=\"hljs-property\">boot</span>.<span class=\"hljs-property\">autoconfigure</span>.<span class=\"hljs-property\">SpringBootApplication</span>;\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">springframework</span>.<span class=\"hljs-property\">context</span>.<span class=\"hljs-property\">annotation</span>.<span class=\"hljs-property\">Bean</span>;\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">springframework</span>.<span class=\"hljs-property\">web</span>.<span class=\"hljs-property\">client</span>.<span class=\"hljs-property\">RestTemplate</span>;\n\n<span class=\"hljs-meta\">@MapperScan</span>(<span class=\"hljs-string\">&quot;cn.itcast.order.mapper&quot;</span>)\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OrderApplication</span> {\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-title class_\">SpringApplication</span>.<span class=\"hljs-title function_\">run</span>(<span class=\"hljs-title class_\">OrderApplication</span>.<span class=\"hljs-property\">class</span>, args);\n    }\n\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">RestTemplate</span> <span class=\"hljs-title function_\">restTemplate</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RestTemplate</span>();\n    }\n}\n</code></pre>\n<h4 id=\"实现远程调用\">实现远程调用</h4>\n<p>修改 order-service 服务中的 cn.itcast.order.service 包下的 OrderService 类中的 queryOrderById 方法：</p>\n<pre><code class=\"hljs language-java\">@Autowired\nprivate RestTemplate restTemplate;\n\n<span class=\"hljs-built_in\">public</span> <span class=\"hljs-keyword\">Order</span> queryOrderById(Long orderId) {\n    // <span class=\"hljs-number\">1.</span>查询订单\n    <span class=\"hljs-keyword\">Order</span> <span class=\"hljs-keyword\">order</span> = orderMapper.findById(orderId);\n    // <span class=\"hljs-number\">2.</span> 利用 RestTemplate 发起 http 请求，查询用户\n    String url = &quot;http://localhost:8081/user/&quot; + <span class=\"hljs-keyword\">order</span>.getUserId();\n    <span class=\"hljs-keyword\">User</span> <span class=\"hljs-keyword\">user</span> = restTemplate.getForObject(url, <span class=\"hljs-keyword\">User</span>.<span class=\"hljs-keyword\">class</span>);\n    // <span class=\"hljs-number\">3.</span> 封装 <span class=\"hljs-keyword\">user</span> 到 <span class=\"hljs-keyword\">Order</span>\n    <span class=\"hljs-keyword\">order</span>.setUser(<span class=\"hljs-keyword\">user</span>);\n    // <span class=\"hljs-number\">4.</span>返回\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">order</span>;\n}\n</code></pre>\n<p>代码：<a href=\"https://github.com/Lanqilu/HaloSpringCloud/tree/44482f1ec6618da6ee5805fbbdc5c0c2464725bb\">链接</a></p>\n<h3 id=\"提供者与消费者\">提供者与消费者</h3>\n<p>在服务调用关系中，会有两个不同的角色：</p>\n<ul>\n<li>服务提供者：一次业务中，被其它微服务调用的服务。（提供接口给其它微服务）</li>\n<li>服务消费者：一次业务中，调用其它微服务的服务。（调用其它微服务提供的接口）</li>\n</ul>\n<p>但是，服务提供者与服务消费者的角色并不是绝对的，而是相对于业务而言。如果服务 A 调用了服务 B，而服务 B 又调用了服务 C，服务 B 的角色是什么？</p>\n<ul>\n<li>对于 A 调用 B 的业务而言：A 是服务消费者，B 是服务提供者</li>\n<li>对于 B 调用 C 的业务而言：B 是服务消费者，C 是服务提供者</li>\n</ul>\n<p>因此，服务 B 既可以是服务提供者，也可以是服务消费者。</p>\n<h2 id=\"eureka-注册中心\">Eureka 注册中心</h2>\n<p>以上实例存在的问题：</p>\n<ul>\n<li>order-service 在发起远程调用的时候，该如何得知 user-service 实例的 ip 地址和端口？</li>\n<li>有多个 user-service 实例地址，order-service 调用时该如何选择？</li>\n<li>order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</li>\n</ul>\n<h3 id=\"eureka-的结构和作用\">Eureka 的结构和作用</h3>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Eureka%E7%9A%84%E4%BD%9C%E7%94%A8.mzzzu1u538w.svg\" alt=\"Eureka的作用\"></p>\n<p>问题1：order-service 如何得知 user-service 实例地址？获取地址信息的流程如下：</p>\n<ul>\n<li>user-service 服务实例启动后，将自己的信息注册到 eureka-server（Eureka 服务端）。这个叫服务注册</li>\n<li>eureka-server 保存服务名称到服务实例地址列表的映射关系</li>\n<li>order-service 根据服务名称，拉取实例地址列表。这个叫服务发现或服务拉取</li>\n</ul>\n<p>问题2：order-service 如何从多个 user-service 实例中选择具体的实例？</p>\n<ul>\n<li>order-service 从实例列表中利用负载均衡算法选中一个实例地址</li>\n<li>向该实例地址发起远程调用</li>\n</ul>\n<p>问题3：order-service 如何得知某个 user-service 实例是否依然健康，是不是已经宕机？</p>\n<ul>\n<li>user-service 会每隔一段时间（默认 30 秒）向 eureka-server 发起请求，报告自己状态，称为心跳</li>\n<li>当超过一定时间没有发送心跳时，eureka-server 会认为微服务实例故障，将该实例从服务列表中剔除</li>\n<li>order-service 拉取服务时，就能将故障实例排除了</li>\n</ul>\n<p>在 Eureka 架构中，微服务角色有两类：</p>\n<ul>\n<li>EurekaServer：服务端，注册中心。记录服务信息、心跳监控</li>\n<li>EurekaClient：客户端<ul>\n<li>Provider：服务提供者，例如案例中的 user-service。注册自己的信息到 EurekaServer、每隔 30 秒向 EurekaServer 发送心跳</li>\n<li>Consumer：服务消费者，例如案例中的 order-service 根据服务名称从 EurekaServer 拉取服务列表基于服务列表做负载均衡，选中一个微服务后发起远程调用</li>\n</ul>\n</li>\n</ul>\n<blockquote>\n<p>注意：一个微服务，既可以是服务提供者，又可以是服务消费者，因此 eureka 将服务注册、服务发现等功能统一封装到了eureka-client 端</p>\n</blockquote>\n<p>eureka 服务注册分为以下步骤：</p>\n<ul>\n<li>搭建注册中心：搭建 EurekaServer</li>\n<li>服务注册：将 user-service、order-service 都注册到 eureka</li>\n<li>服务发现：在 order-service 中完成服务拉取，然后通过负载均衡挑选一个服务，实现远程调用</li>\n</ul>\n<h3 id=\"搭建-eureka-server\">搭建 eureka-server</h3>\n<p>首先大家注册中心服务端：eureka-server，这必须是一个独立的微服务</p>\n<p>创建 eureka-server 服务，在 spring-cloud-demo 父工程下，创建 eureka-server Maven 子模块</p>\n<p>引入 eureka 依赖</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<h4 id=\"编写启动类\">编写启动类</h4>\n<p>给 eureka-server 服务编写一个启动类，一定要添加一个 <code>@EnableEurekaServer</code> 注解，开启 eureka 的注册中心功能：</p>\n<pre><code class=\"hljs language-java\">package cn.<span class=\"hljs-property\">itcast</span>.<span class=\"hljs-property\">eureka</span>;\n\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">springframework</span>.<span class=\"hljs-property\">boot</span>.<span class=\"hljs-property\">SpringApplication</span>;\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">springframework</span>.<span class=\"hljs-property\">boot</span>.<span class=\"hljs-property\">autoconfigure</span>.<span class=\"hljs-property\">SpringBootApplication</span>;\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">springframework</span>.<span class=\"hljs-property\">cloud</span>.<span class=\"hljs-property\">netflix</span>.<span class=\"hljs-property\">eureka</span>.<span class=\"hljs-property\">server</span>.<span class=\"hljs-property\">EnableEurekaServer</span>;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-meta\">@EnableEurekaServer</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EurekaApplication</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-title class_\">SpringApplication</span>.<span class=\"hljs-title function_\">run</span>(<span class=\"hljs-title class_\">EurekaApplication</span>.<span class=\"hljs-property\">class</span>, args);\n    }\n}\n</code></pre>\n<h4 id=\"编写配置文件\">编写配置文件</h4>\n<p>编写一个 application.yml 文件，内容如下：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-symbol\">server:</span>\n<span class=\"hljs-symbol\">  port:</span> <span class=\"hljs-number\">10086</span> <span class=\"hljs-meta\"># 服务端口</span>\n<span class=\"hljs-symbol\">spring:</span>\n<span class=\"hljs-symbol\">  application:</span>\n<span class=\"hljs-symbol\">    name:</span> eureka-server <span class=\"hljs-meta\"># 服务名称 必须</span>\n<span class=\"hljs-symbol\">eureka:</span>\n<span class=\"hljs-symbol\">  client:</span>\n    service-url: <span class=\"hljs-meta\"># eureka 的地址信息</span>\n<span class=\"hljs-symbol\">      defaultZone:</span> http:<span class=\"hljs-comment\">//127.0.0.1:10086/eureka</span>\n</code></pre>\n<h4 id=\"启动服务\">启动服务</h4>\n<p>启动微服务，然后在浏览器访问：<a href=\"http://127.0.0.1:10086\">http://127.0.0.1:10086</a></p>\n<p>看到下面结果应该是成功了：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3fxbktup2b40.png\" alt=\"image\"></p>\n<p>代码：<a href=\"https://github.com/Lanqilu/HaloSpringCloud/tree/6485893c857e8407573b163f91fd7b6b7cfd4cfe\">链接</a></p>\n<h3 id=\"eureka-服务注册\">Eureka 服务注册</h3>\n<p>下面，我们将 user-service 注册到 eureka-server 中去</p>\n<h4 id=\"引入依赖\">引入依赖</h4>\n<p>在 user-service 的 pom 文件中，引入下面的 eureka-client 依赖：</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<h4 id=\"修改配置文件\">修改配置文件</h4>\n<p>在 user-service 中，修改 application.yml 文件，添加服务名称、eureka 地址：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-symbol\">spring:</span>\n<span class=\"hljs-symbol\">  application:</span>\n<span class=\"hljs-symbol\">    name:</span> user-service\n<span class=\"hljs-symbol\">eureka:</span>\n<span class=\"hljs-symbol\">  client:</span>\n    service-url:\n<span class=\"hljs-symbol\">      defaultZone:</span> http:<span class=\"hljs-comment\">//127.0.0.1:10086/eureka</span>\n</code></pre>\n<p>用同样的方法可以注册 order-service</p>\n<h4 id=\"启动多个-user-service-实例\">启动多个 user-service 实例</h4>\n<p>为了演示一个服务有多个实例的场景，我们添加一个 SpringBoot 的启动配置，再启动一个 user-service。</p>\n<p>首先，复制原来的 user-service 启动配置：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.1oxav2o4lv7k.png\" alt=\"image\"></p>\n<p>然后，在弹出的窗口中，填写信息：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.acb3rk5x180.png\" alt=\"image\"></p>\n<p>启动两个 user-service 实例后，查看 eureka-server 管理页面：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4tnhuetb1yc0.png\" alt=\"image\"></p>\n<h3 id=\"eureka-服务发现\">Eureka 服务发现</h3>\n<p>下面，我们将 order-service 的逻辑修改：向 eureka-server 拉取 user-service 的信息，实现服务发现。</p>\n<h4 id=\"引入依赖和修改配置文件\">引入依赖和修改配置文件</h4>\n<p>之前说过，服务发现、服务注册统一都封装在 eureka-client 依赖，因此这一步与服务注册时一致。</p>\n<h4 id=\"服务拉取和负载均衡\">服务拉取和负载均衡</h4>\n<p>去 eureka-server 中拉取 user-service 服务的实例列表，并且实现负载均衡。</p>\n<p>在 order-service 的 OrderApplication 中，给 RestTemplate 这个 Bean 添加一个 <code>@LoadBalanced</code> 注解：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">/**\n * 创建 RestTemplate 并注入容器\n */</span>\n<span class=\"hljs-variable\">@Bean</span>\n<span class=\"hljs-variable\">@LoadBalanced</span>\npublic RestTemplate restTemplate(){\n    <span class=\"hljs-selector-tag\">return</span> <span class=\"hljs-selector-tag\">new</span> <span class=\"hljs-selector-tag\">RestTemplate</span>();\n}\n</code></pre>\n<p>修改 order-service 服务中的 cn.itcast.order.service 包下的 OrderService 类中的queryOrderById 方法。修改访问的 url 路径，用服务名代替 ip、端口：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-built_in\">public</span> <span class=\"hljs-keyword\">Order</span> queryOrderById(Long orderId) {\n    // <span class=\"hljs-number\">1.</span>查询订单\n    <span class=\"hljs-keyword\">Order</span> <span class=\"hljs-keyword\">order</span> = orderMapper.findById(orderId);\n    // <span class=\"hljs-number\">2.</span> 利用 RestTemplate 发起 http 请求，查询用户\n    String url = &quot;http://user-service/user/&quot; + <span class=\"hljs-keyword\">order</span>.getUserId();\n    <span class=\"hljs-keyword\">User</span> <span class=\"hljs-keyword\">user</span> = restTemplate.getForObject(url, <span class=\"hljs-keyword\">User</span>.<span class=\"hljs-keyword\">class</span>);\n    // <span class=\"hljs-number\">3.</span> 封装 <span class=\"hljs-keyword\">user</span> 到 <span class=\"hljs-keyword\">Order</span>\n    <span class=\"hljs-keyword\">order</span>.setUser(<span class=\"hljs-keyword\">user</span>);\n    // <span class=\"hljs-number\">4.</span>返回\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">order</span>;\n}\n</code></pre>\n<p>spring 会自动帮助我们从 eureka-server 端，根据 userservice 这个服务名称，获取实例列表，而后完成负载均衡（默认轮询）。</p>\n<h3 id=\"eureka-注册中心小结\">Eureka 注册中心小结</h3>\n<ol>\n<li>搭建 EurekaServer<ul>\n<li>引入 eureka-server 依赖</li>\n<li>添加 <code>@EnableEurekaServer</code> 注解</li>\n<li>在 application.yml 中配置 eureka 地址</li>\n</ul>\n</li>\n<li>服务注册<ul>\n<li>引入 eureka-client 依赖</li>\n<li>在 application.yml 中配置 eureka 地址</li>\n</ul>\n</li>\n<li>服务发现<ul>\n<li>引入 eureka-client 依赖</li>\n<li>在 application.yml 中配置 eureka 地址</li>\n<li>给 RestTemplate 添加 <code>@LoadBalanced</code> 注解</li>\n<li>用服务提供者的服务名称远程调用</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"ribbon-负载均衡\">Ribbon 负载均衡</h2>\n<p>上一节中，我们添加了 @LoadBalanced 注解，即可实现负载均衡功能，这是什么原理呢？</p>\n<h3 id=\"负载均衡原理\">负载均衡原理</h3>\n<p>Spring Cloud 底层其实是利用了一个名为 Ribbon 的组件，来实现负载均衡功能的。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E6%B5%81%E7%A8%8B.2mk0jmuwdoq0.svg\" alt=\"Ribbon负载均衡流程\"></p>\n<h3 id=\"源码跟踪\">源码跟踪</h3>\n<p>为什么我们只输入了 service 名称就可以访问了呢？之前还要获取 ip 和端口。</p>\n<p>显然有人帮我们根据 service 名称，获取到了服务实例的 ip 和端口。它就是 <code>LoadBalancerInterceptor</code>，这个类会在对 RestTemplate 的请求进行拦截，然后从 Eureka 根据服务 id 获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务 id。</p>\n<p>我们进行源码跟踪：</p>\n<h4 id=\"loadbalancerintercepor\">LoadBalancerIntercepor</h4>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5mxujbposco0.png\" alt=\"image\"></p>\n<p>可以看到这里的 intercept 方法，拦截了用户的 HttpRequest 请求，然后做了几件事：</p>\n<ul>\n<li><code>request.getURI()</code>：获取请求 url，本例中就是 <a href=\"http://user-service/user/8\">http://user-service/user/8</a></li>\n<li><code>originalUri.getHost()</code>：获取 uri 路径的主机名，其实就是服务 id，<code>user-service</code></li>\n<li><code>this.loadBalancer.execute()</code>：处理服务 id，和用户请求。</li>\n</ul>\n<p>这里的 <code>this.loadBalancer</code> 是 <code>LoadBalancerClient</code> 类型，我们继续跟入。</p>\n<h4 id=\"loadbalancerclient\">LoadBalancerClient</h4>\n<p>继续跟入 execute 方法：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.66vjvvg0xn40.png\" alt=\"image\"></p>\n<p>代码是这样的：</p>\n<ul>\n<li><code>getLoadBalancer(serviceId)</code>：根据服务 id 获取 ILoadBalancer，而 ILoadBalancer 会拿着服务 id 去 eureka 中获取服务列表并保存起来。</li>\n<li><code>getServer(loadBalancer)</code>：利用内置的负载均衡算法，从服务列表中选择一个。本例中，可以看到获取了8081端口的服务</li>\n</ul>\n<h4 id=\"负载均衡策略-irule\">负载均衡策略 IRule</h4>\n<p>在刚才的代码中，可以看到获取服务使通过一个 <code>getServer</code> 方法来做负载均衡:</p>\n<p>我们继续跟入：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3vkjab3blgm0.png\" alt=\"image\"></p>\n<p>继续跟踪源码 chooseServer 方法，发现调用父类中 BaseLoadBalancer 一段代码：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4ks2tojsyxe0.png\" alt=\"image\"></p>\n<p>我们看看这个 rule 是谁：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2jcbindlmai0.png\" alt=\"image\"></p>\n<p>默认是使用轮询，到这里，整个负载均衡的流程我们就清楚了。</p>\n<h4 id=\"负载均衡原理源码分析小结\">负载均衡原理源码分析小结</h4>\n<p>Spring Cloud Ribbon 的底层采用了一个拦截器，拦截了 RestTemplate 发出的请求，对地址做了修改。基本流程如下：</p>\n<ul>\n<li>拦截我们的 RestTemplate 请求 <a href=\"http://userservice/user/1\">http://userservice/user/1</a></li>\n<li>RibbonLoadBalancerClient 会从请求 url 中获取服务名称，也就是 user-service</li>\n<li>DynamicServerListLoadBalancer 根据 user-service 到 eureka 拉取服务列表</li>\n<li>eureka 返回列表，localhost:8081、localhost:8082</li>\n<li>IRule 利用内置负载均衡规则，从列表中选择一个，例如 localhost:8081</li>\n<li>RibbonLoadBalancerClient 修改请求地址，用 localhost:8081 替代 userservice，得到 <a href=\"http://localhost:8081/user/1%EF%BC%8C%E5%8F%91%E8%B5%B7%E7%9C%9F%E5%AE%9E%E8%AF%B7%E6%B1%82\">http://localhost:8081/user/1，发起真实请求</a></li>\n</ul>\n<h3 id=\"负载均衡策略\">负载均衡策略</h3>\n<p>负载均衡的规则都定义在 IRule 接口中，而 IRule 有很多不同的实现类：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.61x1c4fc6pg0.png\" alt=\"image\"></p>\n<p>常见的不同规则的含义如下：</p>\n<ol>\n<li>RoundRobinRule：  简单轮询服务列表来选择服务器。它是 Ribbon 默认的负载均衡规则。</li>\n<li>AvailabilityFilteringRule：对以下两种服务器进行忽略<ul>\n<li>在默认情况下，这台服务器如果 3 次连接失败，这台服务器就会被设置为“短路”状态。短路状态将持续 30 秒，如果再次连接失败，短路的持续时间就会几何级地增加。</li>\n<li> 并发数过高的服务器。如果一个服务器的并发连接数过高，配置了 AvailabilityFilteringRule 规则的客户端也会将其忽略。并发连接数的上限，可以由客户端的<code>&lt;clientName&gt;.&lt;clientConfigNameSpace&gt;.ActiveConnectionsLimit </code>属性进行配置。</li>\n</ul>\n</li>\n<li>WeightedResponseTimeRule：为每一个服务器赋予一个权重值。服务器响应时间越长，这个服务器的权重就越小。这个规则会随机选择服务器，这个权重值会影响服务器的选择。</li>\n<li>ZoneAvoidanceRule：以区域可用的服务器为基础进行服务器的选择。使用 Zone 对服务器进行分类，这个 Zone 可以理解为一个机房、一个机架等。而后再对 Zone 内的多个服务做轮询。</li>\n<li>BestAvailableRule：忽略那些短路的服务器，并选择并发数较低的服务器。</li>\n<li>RandomRule：随机选择一个可用的服务器。</li>\n<li>RetryRule：  重试机制的选择逻辑</li>\n</ol>\n<p>默认的实现就是 ZoneAvoidanceRule，是一种轮询方案</p>\n<h4 id=\"自定义负载均衡策略\">自定义负载均衡策略</h4>\n<p>通过定义 IRule 实现可以修改负载均衡规则，有两种方式：</p>\n<p>代码方式：在 order-service 中的 OrderApplication 类（或配置类）中，定义一个新的 IRule：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Bean</span>\n<span class=\"hljs-keyword\">public</span> IRule <span class=\"hljs-title function_\">randomRule</span>(<span class=\"hljs-params\"></span>){\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">RandomRule</span>();\n}\n</code></pre>\n<p>配置文件方式：在 order-service 的 application.yml 文件中，添加新的配置也可以修改规则：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">user-service:</span> <span class=\"hljs-comment\"># 给某个微服务配置负载均衡规则，这里是user-service服务</span>\n  <span class=\"hljs-attr\">ribbon:</span>\n    <span class=\"hljs-attr\">NFLoadBalancerRuleClassName:</span> <span class=\"hljs-string\">com.netflix.loadbalancer.RandomRule</span> <span class=\"hljs-comment\"># 负载均衡规则 </span>\n</code></pre>\n<p>代码方式针对全局，配置文件方式可以对某个服务进行配置</p>\n<p>一般用默认的负载均衡规则，不做修改。</p>\n<h4 id=\"饥饿加载\">饥饿加载</h4>\n<p>Ribbon 默认是采用懒加载，即第一次访问时才会去创建 LoadBalanceClient，请求时间会很长。</p>\n<p>而饥饿加载则会在项目启动时创建，降低第一次访问的耗时，通过下面配置开启饥饿加载：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">ribbon:</span>\n  <span class=\"hljs-attr\">eager-load:</span> \n    <span class=\"hljs-attr\">enabled:</span> <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\"># 开启饥饿加载</span>\n    <span class=\"hljs-attr\">clients:</span> <span class=\"hljs-string\">user-service</span> <span class=\"hljs-comment\"># 指定对 user-service 这个服务进行加载</span>\n</code></pre>\n<h3 id=\"ribbon-负载均衡小结\">Ribbon 负载均衡小结</h3>\n<ol>\n<li>Ribbon 负载均衡规则：<ul>\n<li>规则接口是 IRule</li>\n<li>默认实现是 ZoneAvoidanceRule，根据 zone 选择服务列表，然后轮询</li>\n</ul>\n</li>\n<li>负载均衡自定义方式：<ul>\n<li>代码方式：配置灵活，但修改时需要重新打包发布</li>\n<li>配置方式：直观，方便，无需重新打包发布，但是无法做全局配置</li>\n</ul>\n</li>\n<li>饥饿加载<ul>\n<li>开启饥饿加载，配置文件</li>\n<li>指定饥饿加载的微服务名称，多个 clients 使用 yaml 列表</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"nacos-注册中心\">Nacos 注册中心</h2>\n<h3 id=\"认识和安装-nacos\">认识和安装 Nacos</h3>\n<p><a href=\"https://nacos.io/\">Nacos</a> 是阿里巴巴的产品，现在是 <a href=\"https://spring.io/projects/spring-cloud\">SpringCloud</a> 中的一个组件。相比 <a href=\"https://github.com/Netflix/eureka\">Eureka</a> 功能更加丰富，在国内受欢迎程度较高。</p>\n<p>Docker 安装：<a href=\"https://nacos.io/zh-cn/docs/quick-start-docker.html\">官网</a></p>\n<h3 id=\"服务注册到-nacos\">服务注册到 Nacos</h3>\n<p>Nacos 是 Spring Cloud Alibaba 的组件，而 Spring Cloud Alibaba 也遵循 Spring Cloud 中定义的服务注册、服务发现规范。因此使用 Nacos 和使用 Eureka 对于微服务来说，并没有太大区别。其主要差异在于：依赖不同、服务地址不同。</p>\n<h4 id=\"引入-nacos-依赖\">引入 Nacos 依赖</h4>\n<p>在 spring-cloud-demo 父工程的 pom 文件中的 <code>&lt;dependencyManagement&gt;</code> 中引入 Spring Cloud Alibaba 的依赖：</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>2.2.6.RELEASE<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">type</span>&gt;</span>pom<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">type</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">scope</span>&gt;</span>import<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">scope</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>然后在 user-service 和 order-service 中的 pom 文件中引入 nacos-discovery 依赖：</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<blockquote>\n<p>注意：不要忘了注释掉 eureka 的依赖。</p>\n</blockquote>\n<h4 id=\"配置-nacos-地址\">配置 Nacos 地址</h4>\n<p>在 user-service 和 order-service 的 application.yml 中添加 nacos 地址：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attribute\">spring</span><span class=\"hljs-punctuation\">:</span>\n  <span class=\"hljs-attribute\">cloud</span><span class=\"hljs-punctuation\">:</span>\n    <span class=\"hljs-attribute\">nacos</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-attribute\">server-addr</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">n:8848</span>\n</code></pre>\n<blockquote>\n<p>这里使用的是远程服务器的地址</p>\n</blockquote>\n<h4 id=\"启动项目\">启动项目</h4>\n<p>启动 user-service 和 order-service 浏览器输入 <a href=\"http://halo:8848/nacos/\">http://halo:8848/nacos/</a> 账号密码默认都为 nacos，项目成功可以看到服务列表中的服务。  </p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.6jgz8xeif3g0.png\" alt=\"image\"></p>\n<h3 id=\"服务分级存储模型\">服务分级存储模型</h3>\n<p>一个<strong>服务</strong>可以有多个<strong>实例</strong>，例如我们的 user-service，可以有:</p>\n<ul>\n<li>127.0.0.1:8081</li>\n<li>127.0.0.1:8082</li>\n<li>127.0.0.1:8083</li>\n</ul>\n<p>假如这些实例分布于全国各地的不同机房，例如：</p>\n<ul>\n<li>127.0.0.1:8081，在上海机房</li>\n<li>127.0.0.1:8082，在上海机房</li>\n<li>127.0.0.1:8083，在杭州机房</li>\n</ul>\n<p>Nacos 就将同一机房内的实例划分为一个<strong>集群</strong>。</p>\n<p>也就是说，user-service 是服务，一个服务可以包含多个集群，如杭州、上海，每个集群下可以有多个实例，形成分级模型，如图：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.2mxp9c1ugiw0.png\" alt=\"image\"></p>\n<p>微服务互相访问时，应该尽可能访问同集群实例，因为本地访问速度更快。当本集群内不可用时，才访问其它集群。例如：杭州机房内的 order-service 应该优先访问同机房的 user-service。</p>\n<h4 id=\"给-user-service-配置集群\">给 user-service 配置集群</h4>\n<p>修改 user-service 的 application.yml 文件，添加集群配置：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">cloud:</span>\n    <span class=\"hljs-attr\">nacos:</span>\n      <span class=\"hljs-attr\">server-addr:</span> <span class=\"hljs-string\">halo:8848</span>\n      <span class=\"hljs-attr\">discovery:</span>\n        <span class=\"hljs-attr\">cluster-name:</span> <span class=\"hljs-string\">HZ</span> <span class=\"hljs-comment\"># 集群名称</span>\n</code></pre>\n<p>重启两个 user-service 实例后，我们再次复制一个 user-service 启动配置，添加属性：</p>\n<pre><code class=\"hljs language-sh\">-Dserver.<span class=\"hljs-attribute\">port</span>=8083 -Dspring.cloud.nacos.discovery.<span class=\"hljs-attribute\">cluster-name</span>=SH\n</code></pre>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.1piv5isgkpb4.png\" alt=\"image\"></p>\n<p>我们可以在 Nacos 控制台看到下面结果：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3pz2tkuveru0.png\" alt=\"image\"></p>\n<h4 id=\"同集群优先的负载均衡\">同集群优先的负载均衡</h4>\n<p>默认的 <code>ZoneAvoidanceRule</code> 并不能实现根据同集群优先来实现负载均衡。</p>\n<p>因此 Nacos 中提供了一个 <code>NacosRule</code> 的实现，可以优先从同集群中挑选实例。</p>\n<p>首先给 order-service 配置集群信息，方法同上一节</p>\n<p>修改 order-service 的 application.yml 文件，添加集群配置：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">cloud:</span>\n    <span class=\"hljs-attr\">nacos:</span>\n      <span class=\"hljs-attr\">server-addr:</span> <span class=\"hljs-string\">halo:8848</span>\n      <span class=\"hljs-attr\">discovery:</span>\n        <span class=\"hljs-attr\">cluster-name:</span> <span class=\"hljs-string\">HZ</span> <span class=\"hljs-comment\"># 集群名称</span>\n</code></pre>\n<p>修改负载均衡规则。修改 order-service 的 application.yml 文件，修改负载均衡规则：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">user-service:</span>\n  <span class=\"hljs-attr\">ribbon:</span>\n    <span class=\"hljs-attr\">NFLoadBalancerRuleClassName:</span> <span class=\"hljs-string\">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class=\"hljs-comment\"># 负载均衡规则</span>\n</code></pre>\n<p>本地集群中采用随机</p>\n<p>Nacos Rule 负载均衡策略</p>\n<ol>\n<li>优先选择同集群服务实例列表</li>\n<li>本地集群找不到提供者，才去其它集群寻找，并且会报警告</li>\n<li>确定了可用实例列表后，再采用随机负载均衡挑选实例</li>\n</ol>\n<h3 id=\"权重配置\">权重配置</h3>\n<p>实际部署中会出现这样的场景：服务器设备性能有差异，部分实例所在机器性能较好，另一些较差，我们希望性能好的机器承担更多的用户请求。</p>\n<p>但默认情况下 Nacos Rule 是同集群内随机挑选，不会考虑机器的性能问题。</p>\n<p>因此，Nacos 提供了权重配置来控制访问频率，权重越大则访问频率越高。</p>\n<p>在 Nacos 控制台，找到 user-service 的实例列表，点击编辑，即可修改权重：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5bywq83lkh00.png\" alt=\"image\"></p>\n<blockquote>\n<p>注意：如果权重修改为 0，则该实例永远不会被访问</p>\n</blockquote>\n<h3 id=\"环境隔离\">环境隔离</h3>\n<p>Nacos 提供了 namespace 来实现环境隔离功能。</p>\n<ul>\n<li>Nacos 中可以有多个 namespace</li>\n<li>namespace 下可以有 group、service 等</li>\n<li>不同 namespace 之间相互隔离，例如不同 namespace 的服务互相不可见</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.33r23m595e00.png\" alt=\"image\"></p>\n<h4 id=\"创建-namespace\">创建 namespace</h4>\n<p>默认情况下，所有 service、data、group 都在同一个 namespace，名为 public：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3ebpxcypny00.png\" alt=\"image\"></p>\n<p>我们可以点击页面新增按钮，添加一个 namespace</p>\n<h4 id=\"给微服务配置-namespace\">给微服务配置 namespace</h4>\n<p>给微服务配置 namespace 只能通过修改配置来实现。</p>\n<p>例如，修改 order-service 的 application.yml 文件：</p>\n<pre><code class=\"hljs language-yaml\">spring:\n  cloud:\n    nacos:\n      server-addr: halo:<span class=\"hljs-number\">8848</span>\n      discovery:\n        cluster-name: HZ\n        namespace: <span class=\"hljs-number\">45e30304</span>-<span class=\"hljs-number\">1b64</span>-4c21-8c83-22309949af10 # 命名空间，填ID\n</code></pre>\n<p>重启 order-service 后，访问控制台，可以看到下面的结果：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.7fljcch1djg0.png\" alt=\"image\"></p>\n<p>此时访问 order-service，因为 namespace 不同，会导致找不到 user-service，控制台会报错：</p>\n<pre><code><span class=\"hljs-number\">09</span>-<span class=\"hljs-number\">09</span> <span class=\"hljs-number\">22</span>:<span class=\"hljs-number\">11</span>:<span class=\"hljs-number\">49</span>:<span class=\"hljs-number\">886</span> ERROR <span class=\"hljs-number\">4100</span> --- <span class=\"hljs-selector-attr\">[nio-8080-exec-1]</span> o<span class=\"hljs-selector-class\">.a</span><span class=\"hljs-selector-class\">.c</span><span class=\"hljs-selector-class\">.c</span><span class=\"hljs-selector-class\">.C</span>.<span class=\"hljs-selector-attr\">[.[.[/]</span>.<span class=\"hljs-selector-attr\">[dispatcherServlet]</span>    : Servlet<span class=\"hljs-selector-class\">.service</span>() <span class=\"hljs-keyword\">for</span> servlet <span class=\"hljs-selector-attr\">[dispatcherServlet]</span> <span class=\"hljs-keyword\">in</span> context with path <span class=\"hljs-selector-attr\">[]</span> threw exception <span class=\"hljs-selector-attr\">[Request processing failed; nested exception is java.lang.IllegalStateException: No instances available for user-service]</span> with root cause\n</code></pre>\n<h2 id=\"nacos-与-eureka-的异同\">Nacos 与 Eureka 的异同</h2>\n<h3 id=\"nacos-服务实例类型\">Nacos 服务实例类型</h3>\n<p>Nacos 的服务实例分为两种类型：</p>\n<ul>\n<li>临时实例：如果实例宕机超过一定时间，会从服务列表剔除，默认的类型。</li>\n<li>非临时实例：如果实例宕机，不会从服务列表剔除，也可以叫永久实例。</li>\n</ul>\n<p>配置一个服务实例为永久实例：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">cloud:</span>\n    <span class=\"hljs-attr\">nacos:</span>\n      <span class=\"hljs-attr\">discovery:</span>\n        <span class=\"hljs-attr\">ephemeral:</span> <span class=\"hljs-literal\">false</span> <span class=\"hljs-comment\"># 设置为非临时实例</span>\n</code></pre>\n<h3 id=\"nacos-注册中心原理\">Nacos 注册中心原理</h3>\n<p>Nacos 和 Eureka 整体结构类似，服务注册、服务拉取、心跳等待，但是也存在一些差异：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Nacos%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83%E5%8E%9F%E7%90%86.vsk7w614iqo.svg\" alt=\"Nacos注册中心原理\"></p>\n<h3 id=\"nacos-与-eureka-的共同点\">Nacos 与 Eureka 的共同点</h3>\n<ul>\n<li>都支持服务注册和服务拉取</li>\n<li>都支持服务提供者心跳方式做健康检测</li>\n</ul>\n<h3 id=\"nacos-与-eureka-的区别\">Nacos 与 Eureka 的区别</h3>\n<ul>\n<li>Nacos 支持服务端主动检测提供者状态：临时实例采用心跳模式，非临时实例采用主动检测模式</li>\n<li>临时实例心跳不正常会被剔除，非临时实例则不会被剔除</li>\n<li>Nacos 支持服务列表变更的消息推送模式，服务列表更新更及时</li>\n<li>Nacos 集群默认采用 AP 方式，当集群中存在非临时实例时，采用 CP 模式；Eureka采用 AP 方式</li>\n</ul>\n<h2 id=\"nacos-配置管理\">Nacos 配置管理</h2>\n<p>Nacos 除了可以做注册中心，也可以做配置管理来使用。</p>\n<h3 id=\"统一配置管理\">统一配置管理</h3>\n<p>当微服务部署的实例越来越多，达到数十、数百时，逐个修改微服务配置就会让人抓狂，而且很容易出错。我们需要一种统一配置管理方案，可以集中管理所有实例的配置。</p>\n<p>Nacos 一方面可以将配置集中管理，另一方可以在配置变更时，及时通知微服务，实现配置的热更新。</p>\n<h4 id=\"在-nacos-中添加配置文件\">在 Nacos 中添加配置文件</h4>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.1k2q3p4hypa8.png\" alt=\"image\"></p>\n<p>然后在弹出的表单中，填写配置信息：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.26dw95t2zibk.png\" alt=\"image\"></p>\n<blockquote>\n<p>注意：项目的核心配置，需要热更新的配置才有放到 Nacos 管理的必要。基本不会变更的一些配置还是保存在微服务本地比较好。</p>\n</blockquote>\n<h4 id=\"从微服务拉取配置\">从微服务拉取配置</h4>\n<p>微服务要拉取 Nacos 中管理的配置，并且与本地的 application.yml 配置合并，才能完成项目启动。</p>\n<p>但如果尚未读取 application.yml，又如何得知 Nacos 地址呢？</p>\n<p>因此 Spring 引入了一种新的配置文件：bootstrap.yaml 文件，会在 application.yml 之前被读取，流程如下：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.50gh2h1avrw0.png\" alt=\"image\"></p>\n<p>① 引入 nacos-config 依赖</p>\n<p>首先，在 user-service 服务中，引入 nacos-config 的客户端依赖：</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-comment\">&lt;!--nacos配置管理依赖--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>② 添加 bootstrap.yaml</p>\n<p>然后，在 user-service 中添加一个 bootstrap.yaml 文件，内容如下：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">application:</span>\n    <span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">user-service</span> <span class=\"hljs-comment\"># 服务名称</span>\n  <span class=\"hljs-attr\">profiles:</span>\n    <span class=\"hljs-attr\">active:</span> <span class=\"hljs-string\">dev</span> <span class=\"hljs-comment\"># 开发环境，这里是 dev </span>\n  <span class=\"hljs-attr\">cloud:</span>\n    <span class=\"hljs-attr\">nacos:</span>\n      <span class=\"hljs-attr\">server-addr:</span> <span class=\"hljs-string\">halo:8848</span> <span class=\"hljs-comment\"># Nacos地址</span>\n      <span class=\"hljs-attr\">config:</span>\n        <span class=\"hljs-attr\">file-extension:</span> <span class=\"hljs-string\">yaml</span> <span class=\"hljs-comment\"># 文件后缀名</span>\n</code></pre>\n<p>这里会根据 <code>spring.cloud.nacos.server-addr</code> 获取 Nacos 地址，再根据 <code>${spring.application.name}-${spring.profiles.active}.${spring.cloud.nacos.config.file-extension}</code> 作为文件 id，来读取配置。</p>\n<p>本例中，就是去读取 <code>user-service-dev.yaml</code>：</p>\n<p>③ 读取 Nacos 配置</p>\n<p>在 user-service 中的 <code>UserController</code> 中添加业务逻辑，读取 <code>pattern.dateformat</code> 配置：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Value(<span class=\"hljs-string\">&quot;<span class=\"hljs-subst\">${pattern.dateformat}</span>&quot;</span>)</span>\n<span class=\"hljs-keyword\">private</span> String dateformat;\n\n<span class=\"hljs-meta\">@GetMapping(<span class=\"hljs-string\">&quot;now&quot;</span>)</span>\n<span class=\"hljs-keyword\">public</span> String now() {\n    <span class=\"hljs-keyword\">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));\n}\n</code></pre>\n<h3 id=\"配置热更新\">配置热更新</h3>\n<p>我们最终的目的，是修改 Nacos 中的配置后，微服务中无需重启即可让配置生效，也就是配置热更新。</p>\n<p>要实现配置热更新，可以使用两种方式：</p>\n<h4 id=\"方式一\">方式一</h4>\n<p>在 <code>@Value</code> 注入的变量所在类上添加注解 <code>@RefreshScope</code>：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-variable\">@Slf4j</span>\n<span class=\"hljs-variable\">@RestController</span>\n<span class=\"hljs-variable\">@RequestMapping</span>(<span class=\"hljs-string\">&quot;/user&quot;</span>)\n<span class=\"hljs-variable\">@RefreshScope</span>\npublic class UserController {\n    <span class=\"hljs-variable\">@Value</span>(<span class=\"hljs-string\">&quot;${pattern.dateformat}&quot;</span>)\n    private String dateformat;\n    \n    <span class=\"hljs-comment\">// 略</span>\n}\n</code></pre>\n<h4 id=\"方式二\">方式二</h4>\n<p>使用 <code>@ConfigurationProperties</code> 注解代替 <code>@Value</code> 注解。</p>\n<p>在 user-service 服务中，添加一个类，读取 <code>patterrn.dateformat</code> 属性：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">package</span> cn.itcast.user.config;\n\n<span class=\"hljs-keyword\">import</span> lombok.Data;\n<span class=\"hljs-keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Component;\n\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-meta\">@Data</span>\n<span class=\"hljs-meta\">@ConfigurationProperties(prefix = <span class=\"hljs-string\">&quot;pattern&quot;</span>)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PatternProperties</span> </span>{\n    <span class=\"hljs-keyword\">private</span> String dateformat;\n}\n</code></pre>\n<p>在 <code>UserController</code> 中使用这个类代替 <code>@Value</code>：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Autowired</span>\n<span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">PatternProperties</span> properties;\n\n<span class=\"hljs-meta\">@GetMapping</span>(<span class=\"hljs-string\">&quot;now&quot;</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">String</span> <span class=\"hljs-title function_\">now</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">LocalDateTime</span>.<span class=\"hljs-title function_\">now</span>().<span class=\"hljs-title function_\">format</span>(<span class=\"hljs-title class_\">DateTimeFormatter</span>.<span class=\"hljs-title function_\">ofPattern</span>(properties.<span class=\"hljs-title function_\">getDateformat</span>()));\n}\n</code></pre>\n<h3 id=\"配置共享\">配置共享</h3>\n<p>其实微服务启动时，会去 Nacos 读取多个配置文件，例如：</p>\n<ul>\n<li><p><code>[spring.application.name]-[spring.profiles.active].yaml</code>，例如：user-service-dev.yaml</p>\n</li>\n<li><p><code>[spring.application.name].yaml</code>，例如：user-service.yaml</p>\n</li>\n</ul>\n<p>而 <code>[spring.application.name].yaml</code> 不包含环境，因此可以被多个环境共享。</p>\n<p>下面我们通过案例来测试配置共享</p>\n<h4 id=\"添加一个环境共享配置\">添加一个环境共享配置</h4>\n<p>在 Nacos 中添加一个 user-service.yaml 文件：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.4j1r0ype41k0.png\" alt=\"image\"></p>\n<h4 id=\"在-user-service-中读取共享配置\">在 user-service 中读取共享配置</h4>\n<p>在 user-service 服务中，修改 <code>PatternProperties</code> 类，读取新添加的属性：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-variable\">@Data</span>\n<span class=\"hljs-variable\">@Component</span>\n<span class=\"hljs-variable\">@ConfigurationProperties</span>(prefix = <span class=\"hljs-string\">&quot;pattern&quot;</span>)\npublic class PatternProperties {\n    <span class=\"hljs-selector-tag\">private</span> <span class=\"hljs-selector-tag\">String</span> <span class=\"hljs-selector-tag\">dateformat</span>;\n    <span class=\"hljs-selector-tag\">private</span> <span class=\"hljs-selector-tag\">String</span> <span class=\"hljs-selector-tag\">envShareValue</span>;\n}\n</code></pre>\n<p>在 user-service 服务中，修改 <code>UserController</code>，添加一个方法：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Autowired</span>\n<span class=\"hljs-keyword\">private</span> PatternProperties properties;\n\n<span class=\"hljs-meta\">@GetMapping(<span class=\"hljs-string\">&quot;prop&quot;</span>)</span>\n<span class=\"hljs-keyword\">public</span> PatternProperties prop(){\n    <span class=\"hljs-keyword\">return</span> properties;\n}\n</code></pre>\n<h4 id=\"不同的-profile-下测试\">不同的 profile 下测试</h4>\n<p>运行两个 UserApplication，使用不同的 profile。修改 UserApplication2 这个启动项，改变其 profile 值：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5fmr356kyr80.png\" alt=\"image\"></p>\n<p>这样，UserApplication（8081） 使用的 profile 是 dev，UserApplication2（8082） 使用的 profile 是 test。</p>\n<p>启动 UserApplication 和 UserApplication2</p>\n<p>可以看出来，不管是 dev，还是 test 环境，都读取到了envSharedValue 这个属性的值。</p>\n<h4 id=\"配置共享的优先级\">配置共享的优先级</h4>\n<p>当 Nacos、服务本地同时出现相同属性时，优先级有高低之分，优先级从高到低依次是：</p>\n<ul>\n<li>服务名-[profile].yaml</li>\n<li>服务名.yaml</li>\n<li>本地配置</li>\n</ul>\n<h2 id=\"搭建-nacos-集群\">搭建 Nacos 集群</h2>\n<p>计划的集群结构：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.3v4vof6qfki0.png\" alt=\"image\"></p>\n<p>三个 nacos 节点的地址：</p>\n<table>\n<thead>\n<tr>\n<th>节点</th>\n<th>ip</th>\n<th>port</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>nacos1</td>\n<td>halo</td>\n<td>8845</td>\n</tr>\n<tr>\n<td>nacos2</td>\n<td>halo</td>\n<td>8846</td>\n</tr>\n<tr>\n<td>nacos3</td>\n<td>halo</td>\n<td>8847</td>\n</tr>\n</tbody></table>\n<p>搭建集群的基本步骤：</p>\n<ul>\n<li>搭建数据库，初始化数据库表结构</li>\n<li>下载 Nacos 安装包</li>\n<li>配置 Nacos</li>\n<li>启动 Nacos 集群</li>\n<li>Nginx 反向代理</li>\n</ul>\n<h3 id=\"初始化数据库\">初始化数据库</h3>\n<p>Nacos 默认数据存储在内嵌数据库 Derby 中，不属于生产可用的数据库。</p>\n<p>这里我们以单点的数据库为例来讲解。</p>\n<p>首先新建一个数据库，命名为 nacos，而后导入下面的 SQL：</p>\n<pre><code class=\"hljs language-sql\">CREATE TABLE `config_info` (\n  `id` bigint(<span class=\"hljs-number\">20</span>) <span class=\"hljs-literal\">NOT</span> NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,\n  `dat<span class=\"hljs-built_in\">a_id</span>` varchar(<span class=\"hljs-number\">255</span>) <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;dat<span class=\"hljs-built_in\">a_id</span>&#x27;,\n  `group_id` varchar(<span class=\"hljs-number\">255</span>) DEFAULT NULL,\n  `content` longtext <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;content&#x27;,\n  `md5` varchar(<span class=\"hljs-number\">32</span>) DEFAULT NULL COMMENT &#x27;md5&#x27;,\n  `gmt_create` datetime <span class=\"hljs-literal\">NOT</span> NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,\n  `gmt_modified` datetime <span class=\"hljs-literal\">NOT</span> NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,\n  `src_user` text COMMENT &#x27;source user&#x27;,\n  `src_ip` varchar(<span class=\"hljs-number\">50</span>) DEFAULT NULL COMMENT &#x27;source ip&#x27;,\n  `app_name` varchar(<span class=\"hljs-number\">128</span>) DEFAULT NULL,\n  `tenant_id` varchar(<span class=\"hljs-number\">128</span>) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,\n  `c_desc` varchar(<span class=\"hljs-number\">256</span>) DEFAULT NULL,\n  `c_use` varchar(<span class=\"hljs-number\">64</span>) DEFAULT NULL,\n  `effect` varchar(<span class=\"hljs-number\">64</span>) DEFAULT NULL,\n  `type` varchar(<span class=\"hljs-number\">64</span>) DEFAULT NULL,\n  `c_schema` text,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_configinfo_datagrouptenant` (`dat<span class=\"hljs-built_in\">a_id</span>`,`group_id`,`tenant_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info&#x27;<span class=\"hljs-comment\">;</span>\n\n<span class=\"hljs-comment\">/******************************************/</span>\n<span class=\"hljs-comment\">/*   数据库全名 = nacos_config   */</span>\n<span class=\"hljs-comment\">/*   表名称 = config_info_aggr   */</span>\n<span class=\"hljs-comment\">/******************************************/</span>\nCREATE TABLE `config_info_aggr` (\n  `id` bigint(<span class=\"hljs-number\">20</span>) <span class=\"hljs-literal\">NOT</span> NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,\n  `dat<span class=\"hljs-built_in\">a_id</span>` varchar(<span class=\"hljs-number\">255</span>) <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;dat<span class=\"hljs-built_in\">a_id</span>&#x27;,\n  `group_id` varchar(<span class=\"hljs-number\">255</span>) <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;group_id&#x27;,\n  `datum_id` varchar(<span class=\"hljs-number\">255</span>) <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;datum_id&#x27;,\n  `content` longtext <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;内容&#x27;,\n  `gmt_modified` datetime <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;修改时间&#x27;,\n  `app_name` varchar(<span class=\"hljs-number\">128</span>) DEFAULT NULL,\n  `tenant_id` varchar(<span class=\"hljs-number\">128</span>) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_configinfoaggr_datagrouptenantdatum` (`dat<span class=\"hljs-built_in\">a_id</span>`,`group_id`,`tenant_id`,`datum_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;增加租户字段&#x27;<span class=\"hljs-comment\">;</span>\n\n\n<span class=\"hljs-comment\">/******************************************/</span>\n<span class=\"hljs-comment\">/*   数据库全名 = nacos_config   */</span>\n<span class=\"hljs-comment\">/*   表名称 = config_info_beta   */</span>\n<span class=\"hljs-comment\">/******************************************/</span>\nCREATE TABLE `config_info_beta` (\n  `id` bigint(<span class=\"hljs-number\">20</span>) <span class=\"hljs-literal\">NOT</span> NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,\n  `dat<span class=\"hljs-built_in\">a_id</span>` varchar(<span class=\"hljs-number\">255</span>) <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;dat<span class=\"hljs-built_in\">a_id</span>&#x27;,\n  `group_id` varchar(<span class=\"hljs-number\">128</span>) <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;group_id&#x27;,\n  `app_name` varchar(<span class=\"hljs-number\">128</span>) DEFAULT NULL COMMENT &#x27;app_name&#x27;,\n  `content` longtext <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;content&#x27;,\n  `bet<span class=\"hljs-built_in\">a_ips</span>` varchar(<span class=\"hljs-number\">1024</span>) DEFAULT NULL COMMENT &#x27;betaIps&#x27;,\n  `md5` varchar(<span class=\"hljs-number\">32</span>) DEFAULT NULL COMMENT &#x27;md5&#x27;,\n  `gmt_create` datetime <span class=\"hljs-literal\">NOT</span> NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,\n  `gmt_modified` datetime <span class=\"hljs-literal\">NOT</span> NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,\n  `src_user` text COMMENT &#x27;source user&#x27;,\n  `src_ip` varchar(<span class=\"hljs-number\">50</span>) DEFAULT NULL COMMENT &#x27;source ip&#x27;,\n  `tenant_id` varchar(<span class=\"hljs-number\">128</span>) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_configinfobet<span class=\"hljs-built_in\">a_datagrouptenant</span>` (`dat<span class=\"hljs-built_in\">a_id</span>`,`group_id`,`tenant_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info_beta&#x27;<span class=\"hljs-comment\">;</span>\n\n<span class=\"hljs-comment\">/******************************************/</span>\n<span class=\"hljs-comment\">/*   数据库全名 = nacos_config   */</span>\n<span class=\"hljs-comment\">/*   表名称 = config_info_tag   */</span>\n<span class=\"hljs-comment\">/******************************************/</span>\nCREATE TABLE `config_info_tag` (\n  `id` bigint(<span class=\"hljs-number\">20</span>) <span class=\"hljs-literal\">NOT</span> NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,\n  `dat<span class=\"hljs-built_in\">a_id</span>` varchar(<span class=\"hljs-number\">255</span>) <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;dat<span class=\"hljs-built_in\">a_id</span>&#x27;,\n  `group_id` varchar(<span class=\"hljs-number\">128</span>) <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;group_id&#x27;,\n  `tenant_id` varchar(<span class=\"hljs-number\">128</span>) DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,\n  `tag_id` varchar(<span class=\"hljs-number\">128</span>) <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;tag_id&#x27;,\n  `app_name` varchar(<span class=\"hljs-number\">128</span>) DEFAULT NULL COMMENT &#x27;app_name&#x27;,\n  `content` longtext <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;content&#x27;,\n  `md5` varchar(<span class=\"hljs-number\">32</span>) DEFAULT NULL COMMENT &#x27;md5&#x27;,\n  `gmt_create` datetime <span class=\"hljs-literal\">NOT</span> NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,\n  `gmt_modified` datetime <span class=\"hljs-literal\">NOT</span> NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,\n  `src_user` text COMMENT &#x27;source user&#x27;,\n  `src_ip` varchar(<span class=\"hljs-number\">50</span>) DEFAULT NULL COMMENT &#x27;source ip&#x27;,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_configinfotag_datagrouptenanttag` (`dat<span class=\"hljs-built_in\">a_id</span>`,`group_id`,`tenant_id`,`tag_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_info_tag&#x27;<span class=\"hljs-comment\">;</span>\n\n<span class=\"hljs-comment\">/******************************************/</span>\n<span class=\"hljs-comment\">/*   数据库全名 = nacos_config   */</span>\n<span class=\"hljs-comment\">/*   表名称 = config_tags_relation   */</span>\n<span class=\"hljs-comment\">/******************************************/</span>\nCREATE TABLE `config_tags_relation` (\n  `id` bigint(<span class=\"hljs-number\">20</span>) <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;id&#x27;,\n  `tag_name` varchar(<span class=\"hljs-number\">128</span>) <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;tag_name&#x27;,\n  `tag_type` varchar(<span class=\"hljs-number\">64</span>) DEFAULT NULL COMMENT &#x27;tag_type&#x27;,\n  `dat<span class=\"hljs-built_in\">a_id</span>` varchar(<span class=\"hljs-number\">255</span>) <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;dat<span class=\"hljs-built_in\">a_id</span>&#x27;,\n  `group_id` varchar(<span class=\"hljs-number\">128</span>) <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;group_id&#x27;,\n  `tenant_id` varchar(<span class=\"hljs-number\">128</span>) DEFAULT &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,\n  `nid` bigint(<span class=\"hljs-number\">20</span>) <span class=\"hljs-literal\">NOT</span> NULL AUTO_INCREMENT,\n  PRIMARY KEY (`nid`),\n  UNIQUE KEY `uk_configtagrelation_configidtag` (`id`,`tag_name`,`tag_type`),\n  KEY `idx_tenant_id` (`tenant_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;config_tag_relation&#x27;<span class=\"hljs-comment\">;</span>\n\n<span class=\"hljs-comment\">/******************************************/</span>\n<span class=\"hljs-comment\">/*   数据库全名 = nacos_config   */</span>\n<span class=\"hljs-comment\">/*   表名称 = group_capacity   */</span>\n<span class=\"hljs-comment\">/******************************************/</span>\nCREATE TABLE `group_capacity` (\n  `id` bigint(<span class=\"hljs-number\">20</span>) unsigned <span class=\"hljs-literal\">NOT</span> NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,\n  `group_id` varchar(<span class=\"hljs-number\">128</span>) <span class=\"hljs-literal\">NOT</span> NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Group ID，空字符表示整个集群&#x27;,\n  `quota` int(<span class=\"hljs-number\">10</span>) unsigned <span class=\"hljs-literal\">NOT</span> NULL DEFAULT &#x27;<span class=\"hljs-number\">0</span>&#x27; COMMENT &#x27;配额，<span class=\"hljs-number\">0</span>表示使用默认值&#x27;,\n  `usage` int(<span class=\"hljs-number\">10</span>) unsigned <span class=\"hljs-literal\">NOT</span> NULL DEFAULT &#x27;<span class=\"hljs-number\">0</span>&#x27; COMMENT &#x27;使用量&#x27;,\n  `max_size` int(<span class=\"hljs-number\">10</span>) unsigned <span class=\"hljs-literal\">NOT</span> NULL DEFAULT &#x27;<span class=\"hljs-number\">0</span>&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，<span class=\"hljs-number\">0</span>表示使用默认值&#x27;,\n  `max_aggr_count` int(<span class=\"hljs-number\">10</span>) unsigned <span class=\"hljs-literal\">NOT</span> NULL DEFAULT &#x27;<span class=\"hljs-number\">0</span>&#x27; COMMENT &#x27;聚合子配置最大个数，，<span class=\"hljs-number\">0</span>表示使用默认值&#x27;,\n  `max_aggr_size` int(<span class=\"hljs-number\">10</span>) unsigned <span class=\"hljs-literal\">NOT</span> NULL DEFAULT &#x27;<span class=\"hljs-number\">0</span>&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，<span class=\"hljs-number\">0</span>表示使用默认值&#x27;,\n  `max_history_count` int(<span class=\"hljs-number\">10</span>) unsigned <span class=\"hljs-literal\">NOT</span> NULL DEFAULT &#x27;<span class=\"hljs-number\">0</span>&#x27; COMMENT &#x27;最大变更历史数量&#x27;,\n  `gmt_create` datetime <span class=\"hljs-literal\">NOT</span> NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,\n  `gmt_modified` datetime <span class=\"hljs-literal\">NOT</span> NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_group_id` (`group_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;集群、各Group容量信息表&#x27;<span class=\"hljs-comment\">;</span>\n\n<span class=\"hljs-comment\">/******************************************/</span>\n<span class=\"hljs-comment\">/*   数据库全名 = nacos_config   */</span>\n<span class=\"hljs-comment\">/*   表名称 = his_config_info   */</span>\n<span class=\"hljs-comment\">/******************************************/</span>\nCREATE TABLE `his_config_info` (\n  `id` bigint(<span class=\"hljs-number\">64</span>) unsigned <span class=\"hljs-literal\">NOT</span> NULL,\n  `nid` bigint(<span class=\"hljs-number\">20</span>) unsigned <span class=\"hljs-literal\">NOT</span> NULL AUTO_INCREMENT,\n  `dat<span class=\"hljs-built_in\">a_id</span>` varchar(<span class=\"hljs-number\">255</span>) <span class=\"hljs-literal\">NOT</span> NULL,\n  `group_id` varchar(<span class=\"hljs-number\">128</span>) <span class=\"hljs-literal\">NOT</span> NULL,\n  `app_name` varchar(<span class=\"hljs-number\">128</span>) DEFAULT NULL COMMENT &#x27;app_name&#x27;,\n  `content` longtext <span class=\"hljs-literal\">NOT</span> NULL,\n  `md5` varchar(<span class=\"hljs-number\">32</span>) DEFAULT NULL,\n  `gmt_create` datetime <span class=\"hljs-literal\">NOT</span> NULL DEFAULT CURRENT_TIMESTAMP,\n  `gmt_modified` datetime <span class=\"hljs-literal\">NOT</span> NULL DEFAULT CURRENT_TIMESTAMP,\n  `src_user` text,\n  `src_ip` varchar(<span class=\"hljs-number\">50</span>) DEFAULT NULL,\n  `op_type` char(<span class=\"hljs-number\">10</span>) DEFAULT NULL,\n  `tenant_id` varchar(<span class=\"hljs-number\">128</span>) DEFAULT &#x27;&#x27; COMMENT &#x27;租户字段&#x27;,\n  PRIMARY KEY (`nid`),\n  KEY `idx_gmt_create` (`gmt_create`),\n  KEY `idx_gmt_modified` (`gmt_modified`),\n  KEY `idx_did` (`dat<span class=\"hljs-built_in\">a_id</span>`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;多租户改造&#x27;<span class=\"hljs-comment\">;</span>\n\n\n<span class=\"hljs-comment\">/******************************************/</span>\n<span class=\"hljs-comment\">/*   数据库全名 = nacos_config   */</span>\n<span class=\"hljs-comment\">/*   表名称 = tenant_capacity   */</span>\n<span class=\"hljs-comment\">/******************************************/</span>\nCREATE TABLE `tenant_capacity` (\n  `id` bigint(<span class=\"hljs-number\">20</span>) unsigned <span class=\"hljs-literal\">NOT</span> NULL AUTO_INCREMENT COMMENT &#x27;主键ID&#x27;,\n  `tenant_id` varchar(<span class=\"hljs-number\">128</span>) <span class=\"hljs-literal\">NOT</span> NULL DEFAULT &#x27;&#x27; COMMENT &#x27;Tenant ID&#x27;,\n  `quota` int(<span class=\"hljs-number\">10</span>) unsigned <span class=\"hljs-literal\">NOT</span> NULL DEFAULT &#x27;<span class=\"hljs-number\">0</span>&#x27; COMMENT &#x27;配额，<span class=\"hljs-number\">0</span>表示使用默认值&#x27;,\n  `usage` int(<span class=\"hljs-number\">10</span>) unsigned <span class=\"hljs-literal\">NOT</span> NULL DEFAULT &#x27;<span class=\"hljs-number\">0</span>&#x27; COMMENT &#x27;使用量&#x27;,\n  `max_size` int(<span class=\"hljs-number\">10</span>) unsigned <span class=\"hljs-literal\">NOT</span> NULL DEFAULT &#x27;<span class=\"hljs-number\">0</span>&#x27; COMMENT &#x27;单个配置大小上限，单位为字节，<span class=\"hljs-number\">0</span>表示使用默认值&#x27;,\n  `max_aggr_count` int(<span class=\"hljs-number\">10</span>) unsigned <span class=\"hljs-literal\">NOT</span> NULL DEFAULT &#x27;<span class=\"hljs-number\">0</span>&#x27; COMMENT &#x27;聚合子配置最大个数&#x27;,\n  `max_aggr_size` int(<span class=\"hljs-number\">10</span>) unsigned <span class=\"hljs-literal\">NOT</span> NULL DEFAULT &#x27;<span class=\"hljs-number\">0</span>&#x27; COMMENT &#x27;单个聚合数据的子配置大小上限，单位为字节，<span class=\"hljs-number\">0</span>表示使用默认值&#x27;,\n  `max_history_count` int(<span class=\"hljs-number\">10</span>) unsigned <span class=\"hljs-literal\">NOT</span> NULL DEFAULT &#x27;<span class=\"hljs-number\">0</span>&#x27; COMMENT &#x27;最大变更历史数量&#x27;,\n  `gmt_create` datetime <span class=\"hljs-literal\">NOT</span> NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;创建时间&#x27;,\n  `gmt_modified` datetime <span class=\"hljs-literal\">NOT</span> NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#x27;修改时间&#x27;,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_tenant_id` (`tenant_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;租户容量信息表&#x27;<span class=\"hljs-comment\">;</span>\n\n\nCREATE TABLE `tenant_info` (\n  `id` bigint(<span class=\"hljs-number\">20</span>) <span class=\"hljs-literal\">NOT</span> NULL AUTO_INCREMENT COMMENT &#x27;id&#x27;,\n  `kp` varchar(<span class=\"hljs-number\">128</span>) <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;kp&#x27;,\n  `tenant_id` varchar(<span class=\"hljs-number\">128</span>) default &#x27;&#x27; COMMENT &#x27;tenant_id&#x27;,\n  `tenant_name` varchar(<span class=\"hljs-number\">128</span>) default &#x27;&#x27; COMMENT &#x27;tenant_name&#x27;,\n  `tenant_desc` varchar(<span class=\"hljs-number\">256</span>) DEFAULT NULL COMMENT &#x27;tenant_desc&#x27;,\n  `create_source` varchar(<span class=\"hljs-number\">32</span>) DEFAULT NULL COMMENT &#x27;create_source&#x27;,\n  `gmt_create` bigint(<span class=\"hljs-number\">20</span>) <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;创建时间&#x27;,\n  `gmt_modified` bigint(<span class=\"hljs-number\">20</span>) <span class=\"hljs-literal\">NOT</span> NULL COMMENT &#x27;修改时间&#x27;,\n  PRIMARY KEY (`id`),\n  UNIQUE KEY `uk_tenant_info_kptenantid` (`kp`,`tenant_id`),\n  KEY `idx_tenant_id` (`tenant_id`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin COMMENT=&#x27;tenant_info&#x27;<span class=\"hljs-comment\">;</span>\n\nCREATE TABLE `users` (\n    `username` varchar(<span class=\"hljs-number\">50</span>) <span class=\"hljs-literal\">NOT</span> NULL PRIMARY KEY,\n    `password` varchar(<span class=\"hljs-number\">500</span>) <span class=\"hljs-literal\">NOT</span> NULL,\n    `enabled` boolean <span class=\"hljs-literal\">NOT</span> NULL\n)<span class=\"hljs-comment\">;</span>\n\nCREATE TABLE `roles` (\n    `username` varchar(<span class=\"hljs-number\">50</span>) <span class=\"hljs-literal\">NOT</span> NULL,\n    `role` varchar(<span class=\"hljs-number\">50</span>) <span class=\"hljs-literal\">NOT</span> NULL,\n    UNIQUE INDEX `idx_user_role` (`username` ASC, `role` ASC) USING BTREE\n)<span class=\"hljs-comment\">;</span>\n\nCREATE TABLE `permissions` (\n    `role` varchar(<span class=\"hljs-number\">50</span>) <span class=\"hljs-literal\">NOT</span> NULL,\n    `resource` varchar(<span class=\"hljs-number\">255</span>) <span class=\"hljs-literal\">NOT</span> NULL,\n    `action` varchar(<span class=\"hljs-number\">8</span>) <span class=\"hljs-literal\">NOT</span> NULL,\n    UNIQUE INDEX `uk_role_permission` (`role`,`resource`,`action`) USING BTREE\n)<span class=\"hljs-comment\">;</span>\n\nINSERT INTO users (username, password, enabled) VALUES (&#x27;nacos&#x27;, &#x27;$<span class=\"hljs-number\">2</span>a$<span class=\"hljs-number\">10</span>$EuWPZHzz32dJN7jexM34MOeYirDdFAZm2kuWj7VEOJhhZkDrxfvUu&#x27;, <span class=\"hljs-literal\">TRUE</span>)<span class=\"hljs-comment\">;</span>\n\nINSERT INTO roles (username, role) VALUES (&#x27;nacos&#x27;, &#x27;ROLE_ADMIN&#x27;)<span class=\"hljs-comment\">;</span>\n</code></pre>\n<h3 id=\"下载-nacos\">下载 Nacos</h3>\n<p>Nacos 在 GitHub 上有下载地址：<a href=\"https://github.com/alibaba/nacos/tags%EF%BC%8C%E5%8F%AF%E4%BB%A5%E9%80%89%E6%8B%A9%E4%BB%BB%E6%84%8F%E7%89%88%E6%9C%AC%E4%B8%8B%E8%BD%BD%E3%80%82\">https://github.com/alibaba/nacos/tags，可以选择任意版本下载。</a></p>\n<p>本例中才用 1.4.1 版本</p>\n<h3 id=\"配置-nacos\">配置 Nacos</h3>\n<p>将这个包解压到任意非中文目录下</p>\n<ul>\n<li>bin：启动脚本</li>\n<li>conf：配置文件</li>\n</ul>\n<p>进入 Nacos 的 conf 目录，修改配置文件 cluster.conf.example，重命名为 cluster.conf</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/image.5nlh9ki5w2s0.png\" alt=\"image\"></p>\n<p>然后添加内容：</p>\n<pre><code><span class=\"hljs-number\">127.0.0.1:8845</span>\n<span class=\"hljs-number\">127.0.0.1</span>.<span class=\"hljs-number\">8846</span>\n<span class=\"hljs-number\">127.0.0.1</span>.<span class=\"hljs-number\">8847</span>\n</code></pre>\n<p>然后修改 application.properties 文件，添加数据库配置</p>\n<pre><code><span class=\"hljs-attr\">spring.datasource.platform</span>=mysql\n\n<span class=\"hljs-attr\">db.num</span>=<span class=\"hljs-number\">1</span>\n\n<span class=\"hljs-attr\">db.url.0</span>=jdbc:mysql://halo:<span class=\"hljs-number\">3306</span>/nacos?characterEncoding=utf8&amp;connectTimeout=<span class=\"hljs-number\">1000</span>&amp;socketTimeout=<span class=\"hljs-number\">3000</span>&amp;autoReconnect=<span class=\"hljs-literal\">true</span>&amp;useUnicode=<span class=\"hljs-literal\">true</span>&amp;useSSL=<span class=\"hljs-literal\">false</span>&amp;serverTimezone=UTC\n<span class=\"hljs-attr\">db.user.0</span>=root\n<span class=\"hljs-attr\">db.password.0</span>=mogu2018\n</code></pre>\n<h3 id=\"启动-nacos\">启动 Nacos</h3>\n<p>将 nacos 文件夹复制三份，分别命名为：nacos1、nacos2、nacos3</p>\n<p>然后分别修改三个文件夹中的 application.properties，</p>\n<p>nacos1:</p>\n<pre><code class=\"hljs language-properties\"><span class=\"hljs-title\">server</span>.<span class=\"hljs-keyword\">port</span>=8845\n</code></pre>\n<p>nacos2:</p>\n<pre><code class=\"hljs language-properties\"><span class=\"hljs-title\">server</span>.<span class=\"hljs-keyword\">port</span>=8846\n</code></pre>\n<p>nacos3:</p>\n<pre><code class=\"hljs language-properties\"><span class=\"hljs-title\">server</span>.<span class=\"hljs-keyword\">port</span>=8847\n</code></pre>\n<p>然后分别启动三个 nacos 节点：</p>\n<pre><code>startup.<span class=\"hljs-built_in\">cmd</span>\n</code></pre>\n<h3 id=\"nginx-反向代理\">Nginx 反向代理</h3>\n<p>修改 conf/nginx.conf 文件，配置如下：</p>\n<pre><code><span class=\"hljs-section\">upstream</span> nacos-cluster {\n    <span class=\"hljs-attribute\">server</span> <span class=\"hljs-number\">127.0.0.1:8845</span>;\n    <span class=\"hljs-attribute\">server</span> <span class=\"hljs-number\">127.0.0.1:8846</span>;\n    <span class=\"hljs-attribute\">server</span> <span class=\"hljs-number\">127.0.0.1:8847</span>;\n}\n\n<span class=\"hljs-section\">server</span> {\n    <span class=\"hljs-attribute\">listen</span>       <span class=\"hljs-number\">80</span>;\n    <span class=\"hljs-attribute\">server_name</span>  localhost;\n\n    <span class=\"hljs-section\">location</span> /nacos {\n        <span class=\"hljs-attribute\">proxy_pass</span> http://nacos-cluster;\n    }\n}\n</code></pre>\n<p>而后在浏览器访问：<a href=\"http://localhost/nacos\">http://localhost/nacos</a> 即可。</p>\n<p>代码中 application.yml 文件配置如下：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-attr\">cloud:</span>\n    <span class=\"hljs-attr\">nacos:</span>\n      <span class=\"hljs-attr\">server-addr:</span> <span class=\"hljs-string\">localhost:80</span> <span class=\"hljs-comment\"># Nacos地址</span>\n</code></pre>\n<ul>\n<li><p>实际部署时，需要给做反向代理的 Nginx 服务器设置一个域名，这样后续如果有服务器迁移 Nacos 的客户端也无需更改配置。</p>\n</li>\n<li><p>Nacos 的各个节点应该部署到多个不同服务器，做好容灾和隔离</p>\n</li>\n</ul>\n<h2 id=\"feign-远程调用\">Feign 远程调用</h2>\n<p>先来看我们以前利用 RestTemplate 发起远程调用的代码：</p>\n<pre><code class=\"hljs language-java\">// <span class=\"hljs-number\">2.</span> 利用 RestTemplate 发起 http 请求，查询用户\nString url = &quot;http://user-service/user/&quot; + <span class=\"hljs-keyword\">order</span>.getUserId();\n<span class=\"hljs-keyword\">User</span> <span class=\"hljs-keyword\">user</span> = restTemplate.getForObject(url, <span class=\"hljs-keyword\">User</span>.<span class=\"hljs-keyword\">class</span>);\n</code></pre>\n<p>存在下面的问题：</p>\n<ul>\n<li>代码可读性差，编程体验不统一</li>\n<li>参数复杂 URL 难以维护</li>\n</ul>\n<p>Feign 是一个声明式的 http 客户端，官方地址：<a href=\"https://github.com/OpenFeign/feign\">https://github.com/OpenFeign/feign</a></p>\n<p>其作用就是帮助我们优雅的实现 http 请求的发送，解决上面提到的问题。</p>\n<h3 id=\"feign-替代-resttemplate\">Feign 替代 RestTemplate</h3>\n<p>Feign 的使用步骤如下：</p>\n<h4 id=\"引入依赖-1\">引入依赖</h4>\n<p>我们在 order-service 服务的 pom 文件中引入 feign 的依赖：</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<h4 id=\"添加注解\">添加注解</h4>\n<p>在 order-service 的启动类添加 <code>@EnableFeignClients</code> 注解开启 Feign 的功能：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-variable\">@EnableFeignClients</span>\n<span class=\"hljs-variable\">@MapperScan</span>(<span class=\"hljs-string\">&quot;cn.itcast.order.mapper&quot;</span>)\n<span class=\"hljs-variable\">@SpringBootApplication</span>\npublic class OrderApplication {\n    <span class=\"hljs-selector-tag\">public</span> <span class=\"hljs-selector-tag\">static</span> <span class=\"hljs-selector-tag\">void</span> <span class=\"hljs-selector-tag\">main</span>(String[] args) {\n        <span class=\"hljs-selector-tag\">SpringApplication</span><span class=\"hljs-selector-class\">.run</span>(OrderApplication.class, args);\n    }\n}\n</code></pre>\n<h4 id=\"编写-feign-的客户端\">编写 Feign 的客户端</h4>\n<p>在 order-service 中新建一个接口，内容如下：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">package</span> cn.itcast.order.clients;\n\n<span class=\"hljs-keyword\">import</span> cn.itcast.order.pojo.User;\n<span class=\"hljs-keyword\">import</span> org.springframework.cloud.openfeign.FeignClient;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.<span class=\"hljs-keyword\">annotation</span>.GetMapping;\n<span class=\"hljs-keyword\">import</span> org.springframework.web.bind.<span class=\"hljs-keyword\">annotation</span>.PathVariable;\n\n<span class=\"hljs-meta\">@FeignClient(<span class=\"hljs-string\">&quot;user-service&quot;</span>)</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">UserClient</span> </span>{\n    <span class=\"hljs-meta\">@GetMapping(<span class=\"hljs-string\">&quot;/user/{id}&quot;</span>)</span>\n    User findById(<span class=\"hljs-meta\">@PathVariable(<span class=\"hljs-string\">&quot;id&quot;</span>)</span> <span class=\"hljs-built_in\">Long</span> id);\n}\n</code></pre>\n<p>这个客户端主要是基于 SpringMVC 的注解来声明远程调用的信息，比如：</p>\n<ul>\n<li>服务名称：user-service</li>\n<li>请求方式：GET</li>\n<li>请求路径：/user/{id}</li>\n<li>请求参数：Long id</li>\n<li>返回值类型：User</li>\n</ul>\n<p>这样，Feign 就可以帮助我们发送 http 请求，无需自己使用 RestTemplate 来发送了。</p>\n<h4 id=\"测试\">测试</h4>\n<p>修改 order-service 中的 <code>OrderService</code> 类中的 <code>queryOrderById</code> 方法，使用 Feign 客户端代替 RestTemplate：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Service</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OrderService</span> {\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> OrderMapper orderMapper;\n\n    <span class=\"hljs-meta\">@Autowired</span>\n    <span class=\"hljs-keyword\">private</span> UserClient userClient;\n\n    <span class=\"hljs-keyword\">public</span> Order <span class=\"hljs-title function_\">queryOrderById</span><span class=\"hljs-params\">(Long orderId)</span> {\n        <span class=\"hljs-comment\">// 1.查询订单</span>\n        <span class=\"hljs-type\">Order</span> <span class=\"hljs-variable\">order</span> <span class=\"hljs-operator\">=</span> orderMapper.findById(orderId);\n        <span class=\"hljs-comment\">// 2. 使用 Feign 进行远程调用</span>\n        <span class=\"hljs-type\">User</span> <span class=\"hljs-variable\">user</span> <span class=\"hljs-operator\">=</span> userClient.findById(order.getUserId());\n        <span class=\"hljs-comment\">// 3. 封装 user 到 Order</span>\n        order.setUser(user);\n        <span class=\"hljs-comment\">// 4.返回</span>\n        <span class=\"hljs-keyword\">return</span> order;\n    }\n}\n</code></pre>\n<h4 id=\"feign-替代-resttemplate-小结\">Feign 替代 RestTemplate 小结</h4>\n<p>使用 Feign 的步骤：</p>\n<ol>\n<li>引入依赖</li>\n<li>添加 <code>@EnableFeignClients</code> 注解</li>\n<li>编写 FeignClient 接口</li>\n<li>使用 FeignClient 中定义的方法代替 RestTemplate</li>\n</ol>\n<h3 id=\"feign-的自定义配置\">Feign 的自定义配置</h3>\n<p>Feign 可以支持很多的自定义配置，如下表所示：</p>\n<table>\n<thead>\n<tr>\n<th>类型</th>\n<th>作用</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>feign.Logger.Level</code></td>\n<td>修改日志级别</td>\n<td>包含四种不同的级别：NONE、BASIC、HEADERS、FULL</td>\n</tr>\n<tr>\n<td><code>feign.codec.Decoder</code></td>\n<td>响应结果的解析器</td>\n<td>http 远程调用的结果做解析，例如解析 JSON 字符串为 Java 对象</td>\n</tr>\n<tr>\n<td><code>feign.codec.Encoder</code></td>\n<td>请求参数编码</td>\n<td>将请求参数编码，便于通过 http 请求发送</td>\n</tr>\n<tr>\n<td><code>feign.Contract</code></td>\n<td>支持的注解格式</td>\n<td>默认是 SpringMVC 的注解</td>\n</tr>\n<tr>\n<td><code>feign.Retryer</code></td>\n<td>失败重试机制</td>\n<td>请求失败的重试机制，默认是没有，不过会使用Ribbon 的重试</td>\n</tr>\n</tbody></table>\n<p>一般情况下，默认值就能满足我们使用，如果要自定义时，只需要创建自定义的 <code>@Bean</code> 覆盖默认Bean 即可。</p>\n<p>下面以日志为例来演示如何自定义配置。</p>\n<h4 id=\"配置文件方式\">配置文件方式</h4>\n<p>基于配置文件修改 Feign 的日志级别可以针对单个服务：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-symbol\">feign:</span>  \n<span class=\"hljs-symbol\">  client:</span>\n<span class=\"hljs-symbol\">    config:</span> \n<span class=\"hljs-symbol\">      userservice:</span> <span class=\"hljs-meta\"># 针对某个微服务的配置</span>\n<span class=\"hljs-symbol\">        loggerLevel:</span> FULL <span class=\"hljs-meta\"># 日志级别 </span>\n</code></pre>\n<p>也可以针对所有服务：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-symbol\">feign:</span>  \n<span class=\"hljs-symbol\">  client:</span>\n<span class=\"hljs-symbol\">    config:</span> \n<span class=\"hljs-symbol\">      default:</span> <span class=\"hljs-meta\"># 这里用 default 就是全局配置，如果是写服务名称，则是针对某个微服务的配置</span>\n<span class=\"hljs-symbol\">        loggerLevel:</span> FULL <span class=\"hljs-meta\"># 日志级别 </span>\n</code></pre>\n<p>而日志的级别分为四种：</p>\n<ul>\n<li>NONE：不记录任何日志信息，这是默认值。</li>\n<li>BASIC：仅记录请求的方法，URL 以及响应状态码和执行时间</li>\n<li>HEADERS：在 BASIC 的基础上，额外记录了请求和响应的头信息</li>\n<li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li>\n</ul>\n<h4 id=\"java-代码方式\">Java 代码方式</h4>\n<p>也可以基于 Java 代码来修改日志级别，先声明一个类，然后声明一个 <code>Logger.Level</code> 的对象：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DefaultFeignConfiguration</span>  {\n    <span class=\"hljs-meta\">@Bean</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">Logger</span>.<span class=\"hljs-property\">Level</span> <span class=\"hljs-title function_\">feignLogLevel</span>(<span class=\"hljs-params\"></span>){\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Logger</span>.<span class=\"hljs-property\">Level</span>.<span class=\"hljs-property\">BASIC</span>; <span class=\"hljs-comment\">// 日志级别为BASIC</span>\n    }\n}\n</code></pre>\n<p>如果要全局生效，将其放到启动类的 <code>@EnableFeignClients</code> 这个注解中：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@EnableFeignClients(<span class=\"hljs-params\">defaultConfiguration = DefaultFeignConfiguration .<span class=\"hljs-keyword\">class</span></span>) </span>\n</code></pre>\n<p>如果是局部生效，则把它放到对应的 <code>@FeignClient</code> 这个注解中：</p>\n<pre><code class=\"hljs language-java\">@<span class=\"hljs-constructor\">FeignClient(<span class=\"hljs-params\">value</span> = <span class=\"hljs-string\">&quot;user-service&quot;</span>, <span class=\"hljs-params\">configuration</span> = DefaultFeignConfiguration .<span class=\"hljs-params\">class</span>)</span>\n</code></pre>\n<h3 id=\"feign-使用优化\">Feign 使用优化</h3>\n<p>Feign 底层发起 http 请求，依赖于其它的框架。其底层客户端实现包括：</p>\n<ul>\n<li>URLConnection：默认实现，不支持连接池</li>\n<li>Apache HttpClient ：支持连接池</li>\n<li>OKHttp：支持连接池</li>\n</ul>\n<p>因此提高 Feign 的性能主要手段就是使用连接池代替默认的 URLConnection。</p>\n<p>这里我们用 Apache 的 HttpClient 来演示。</p>\n<h4 id=\"引入依赖-2\">引入依赖</h4>\n<p>在 order-service 的 pom 文件中引入 Apache 的 HttpClient 依赖：</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-comment\">&lt;!--httpClient的依赖 --&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.github.openfeign<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>feign-httpclient<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<h4 id=\"配置连接池\">配置连接池</h4>\n<p>在 order-service 的 application.yml 中添加配置：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attr\">feign:</span>\n  <span class=\"hljs-attr\">client:</span>\n    <span class=\"hljs-attr\">config:</span>\n      <span class=\"hljs-attr\">default:</span> <span class=\"hljs-comment\"># default 全局的配置</span>\n        <span class=\"hljs-attr\">loggerLevel:</span> <span class=\"hljs-string\">BASIC</span> <span class=\"hljs-comment\"># 日志级别，BASIC 就是基本的请求和响应信息</span>\n  <span class=\"hljs-attr\">httpclient:</span>\n    <span class=\"hljs-attr\">enabled:</span> <span class=\"hljs-literal\">true</span> <span class=\"hljs-comment\"># 开启 feign 对 HttpClient 的支持</span>\n    <span class=\"hljs-attr\">max-connections:</span> <span class=\"hljs-number\">200</span> <span class=\"hljs-comment\"># 最大的连接数</span>\n    <span class=\"hljs-attr\">max-connections-per-route:</span> <span class=\"hljs-number\">50</span> <span class=\"hljs-comment\"># 每个路径的最大连接数</span>\n</code></pre>\n<h4 id=\"feign-的优化小结\">Feign 的优化小结</h4>\n<ol>\n<li>日志级别尽量用 basic</li>\n<li>使用 HttpClient（或 OKHttp ）代替 URLConnection<ul>\n<li>引入 feign-httpclient 依赖</li>\n<li>配置文件开启 httpclient 功能，设置连接池参数</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"feign-的最佳实践\">Feign 的最佳实践</h2>\n<p>所谓最近实践，就是使用过程中总结的经验，最好的一种使用方式。</p>\n<p>仔细观察可以发现，Feign 的客户端与服务提供者的 controller 代码非常相似</p>\n<p>Feign客户端：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-variable\">@GetMapping</span>(<span class=\"hljs-string\">&quot;/user/{id}&quot;</span>)\nUser findById(<span class=\"hljs-variable\">@PathVariable</span>(<span class=\"hljs-string\">&quot;id&quot;</span>) Long id);\n</code></pre>\n<p>UserController：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-variable\">@GetMapping</span>(<span class=\"hljs-string\">&quot;/{id}&quot;</span>)\npublic User queryById(<span class=\"hljs-variable\">@PathVariable</span>(<span class=\"hljs-string\">&quot;id&quot;</span>) Long id) {\n    <span class=\"hljs-selector-tag\">return</span> <span class=\"hljs-selector-tag\">userService</span><span class=\"hljs-selector-class\">.queryById</span>(id);\n}\n</code></pre>\n<p>有没有一种办法简化这种重复的代码编写呢？</p>\n<h3 id=\"继承方式\">继承方式</h3>\n<p>一样的代码可以通过继承来共享：</p>\n<ol>\n<li>定义一个 API 接口，利用定义方法，并基于 SpringMVC 注解做声明。</li>\n<li>Feign 客户端和 Controller 都集成改接口</li>\n</ol>\n<p>优点：简单、实现了代码共享</p>\n<p>缺点：</p>\n<ul>\n<li>服务提供方、服务消费方紧耦合</li>\n<li>参数列表中的注解映射并不会继承，因此 Controller 中必须再次声明方法、参数列表、注解</li>\n</ul>\n<h3 id=\"抽取方式\">抽取方式</h3>\n<p>将 Feign 的 Client 抽取为独立模块，并且把接口有关的 POJO、默认的 Feign 配置都放到这个模块中，提供给所有消费者使用。</p>\n<p>例如，将 UserClient、User、Feign 的默认配置都抽取到一个 feign-api 包中，所有微服务引用该依赖包，即可直接使用。</p>\n<h3 id=\"基于抽取的最佳实践实现\">基于抽取的最佳实践实现</h3>\n<h4 id=\"抽取\">抽取</h4>\n<p>首先创建一个 module，命名为 feign-api</p>\n<p>在 feign-api 中然后引入 feign 的 starter 依赖</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>然后，order-service 中编写的 UserClient、User、DefaultFeignConfiguration 都剪切到 feign-api项目中</p>\n<h4 id=\"使用-feign-api\">使用 feign-api</h4>\n<p>在 order-service 的 pom 文件中中引入 feign-api 的依赖：</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>cn.itcast.demo<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>feign-api<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>1.0<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<p>修改 order-service 中的所有与上述三个组件有关的导包部分，改成导入 feign-api 中的包</p>\n<h4 id=\"解决扫描包问题\">解决扫描包问题</h4>\n<p>order-service 的 <code>@EnableFeignClients</code> 注解是在 cn.itcast.order 包下，不在同一个包，无法扫描到 UserClient。</p>\n<p>方式一，指定 Feign 应该扫描的包：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@EnableFeignClients(basePackages = <span class=\"hljs-string\">&quot;cn.itcast.feign.clients&quot;</span>)</span>\n</code></pre>\n<p>方式二，指定需要加载的 Client 接口：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@EnableFeignClients(<span class=\"hljs-params\">clients = {UserClient.<span class=\"hljs-keyword\">class</span>}</span>)</span>\n</code></pre>\n<h2 id=\"gateway-服务网关\">Gateway 服务网关</h2>\n<p>Spring Cloud Gateway 是 Spring Cloud 的一个全新项目，该项目是基于 Spring 5.0，Spring Boot 2.0 和 Project Reactor 等响应式编程和事件流技术开发的网关，它旨在为微服务架构提供一种简单有效的统一的 API 路由管理方式。</p>\n<h3 id=\"为什么需要网关\">为什么需要网关</h3>\n<p>Gateway 网关是我们服务的守门神，所有微服务的统一入口。</p>\n<p>网关的核心功能特性：</p>\n<ul>\n<li>请求路由</li>\n<li>权限控制</li>\n<li>限流</li>\n</ul>\n<p>权限控制：网关作为微服务入口，需要校验用户是是否有请求资格，如果没有则进行拦截。</p>\n<p>路由和负载均衡：一切请求都必须先经过 Gateway，但网关不处理业务，而是根据某种规则，把请求转发到某个微服务，这个过程叫做路由。当然路由的目标服务有多个时，还需要做负载均衡。</p>\n<p>限流：当请求流量过高时，在网关中按照下流的微服务能够接受的速度来放行请求，避免服务压力过大。</p>\n<p>在 Spring Cloud 中网关的实现包括两种：Gateway、Zuul</p>\n<p>Zuul 是基于 Servlet 的实现，属于阻塞式编程。而 Spring Cloud Gateway 则是基于 Spring 5 中提供的 WebFlux，属于响应式编程的实现，具备更好的性能。</p>\n<h3 id=\"gateway-快速入门\">Gateway 快速入门</h3>\n<p>下面，我们就演示下网关的基本路由功能。基本步骤如下：</p>\n<ol>\n<li>创建 Maven 工程 gateway，引入网关依赖</li>\n<li>编写启动类</li>\n<li>编写基础配置和路由规则</li>\n<li>启动网关服务进行测试</li>\n</ol>\n<h4 id=\"创建-gateway-服务并引入依赖\">创建 Gateway 服务并引入依赖</h4>\n<p>创建 gateway 服务，引入一下依赖：</p>\n<pre><code class=\"hljs language-xml\"><span class=\"hljs-comment\">&lt;!--网关--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n<span class=\"hljs-comment\">&lt;!--nacos服务发现依赖--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.cloud<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<h4 id=\"编写启动类-1\">编写启动类</h4>\n<pre><code class=\"hljs language-java\">package cn.<span class=\"hljs-property\">itcast</span>.<span class=\"hljs-property\">gateway</span>;\n\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">springframework</span>.<span class=\"hljs-property\">boot</span>.<span class=\"hljs-property\">SpringApplication</span>;\n<span class=\"hljs-keyword\">import</span> org.<span class=\"hljs-property\">springframework</span>.<span class=\"hljs-property\">boot</span>.<span class=\"hljs-property\">autoconfigure</span>.<span class=\"hljs-property\">SpringBootApplication</span>;\n\n<span class=\"hljs-meta\">@SpringBootApplication</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">GatewayApplication</span> {\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-title class_\">SpringApplication</span>.<span class=\"hljs-title function_\">run</span>(<span class=\"hljs-title class_\">GatewayApplication</span>.<span class=\"hljs-property\">class</span>, args);\n    }\n}\n</code></pre>\n<h4 id=\"编写基础配置和路由规则\">编写基础配置和路由规则</h4>\n<p>创建 application.yml 文件，内容如下：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-symbol\">server:</span>\n<span class=\"hljs-symbol\">  port:</span> <span class=\"hljs-number\">10010</span> <span class=\"hljs-meta\"># 网关端口</span>\n<span class=\"hljs-symbol\">spring:</span>\n<span class=\"hljs-symbol\">  application:</span>\n<span class=\"hljs-symbol\">    name:</span> gateway <span class=\"hljs-meta\"># 服务名称</span>\n<span class=\"hljs-symbol\">  cloud:</span>\n<span class=\"hljs-symbol\">    nacos:</span>\n      server-addr: halo:<span class=\"hljs-number\">8848</span> <span class=\"hljs-meta\"># nacos地址</span>\n<span class=\"hljs-symbol\">    gateway:</span>\n<span class=\"hljs-symbol\">      routes:</span> <span class=\"hljs-meta\"># 网关路由配置</span>\n        - id: user-service-gateway <span class=\"hljs-meta\"># 路由id，自定义，只要唯一即可</span>\n          <span class=\"hljs-meta\"># uri: http:<span class=\"hljs-comment\">//127.0.0.1:8081 # 路由的目标地址 http就是固定地址</span></span>\n<span class=\"hljs-symbol\">          uri:</span> lb:<span class=\"hljs-comment\">//user-service # 路由的目标地址 lb就是负载均衡，后面跟服务名称</span>\n<span class=\"hljs-symbol\">          predicates:</span> <span class=\"hljs-meta\"># 路由断言，也就是判断请求是否符合路由规则的条件</span>\n            - P<span class=\"hljs-attr\">ath</span><span class=\"hljs-operator\">=</span><span class=\"hljs-keyword\">/user/</span>** <span class=\"hljs-meta\"># 这个是按照路径匹配，只要以/user/开头就符合要求</span>\n</code></pre>\n<p>我们将符合 <code>Path</code> 规则的一切请求，都代理到 <code>uri</code> 参数指定的地址。</p>\n<p>本例中，我们将 <code>/user/**</code>开头的请求，代理到 <code>lb://user-service</code>，lb 是负载均衡，根据服务名拉取服务列表，实现负载均衡。</p>\n<h4 id=\"启动测试\">启动测试</h4>\n<p>启动网关，访问 <a href=\"http://localhost:10010/user/1\">http://localhost:10010/user/1</a> 时，符合<code>/user/**</code>规则，请求转发到 uri：<a href=\"http://userservice/user/1%EF%BC%8C%E5%BE%97%E5%88%B0%E4%BA%86%E7%BB%93%E6%9E%9C\">http://userservice/user/1，得到了结果</a></p>\n<h4 id=\"网关路由的流程图\">网关路由的流程图</h4>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/Gateway%E7%BD%91%E5%85%B3%E8%B7%AF%E7%94%B1%E7%9A%84%E6%B5%81%E7%A8%8B%E5%9B%BE.6onddfdjlr00.svg\" alt=\"Gateway网关路由的流程图\"></p>\n<h4 id=\"gateway-快速入门小结\">Gateway 快速入门小结</h4>\n<p>网关搭建步骤：</p>\n<ol>\n<li><p>创建项目，引入 nacos 服务发现和 gateway 依赖</p>\n</li>\n<li><p>配置 application.yml，包括服务基本信息、nacos 地址、路由</p>\n</li>\n</ol>\n<p>路由配置包括：</p>\n<ol>\n<li><p>路由 id：路由的唯一标示</p>\n</li>\n<li><p>路由目标（uri）：路由的目标地址，http 代表固定地址，lb 代表根据服务名负载均衡</p>\n</li>\n<li><p>路由断言（predicates）：判断路由的规则，</p>\n</li>\n<li><p>路由过滤器（filters）：对请求或响应做处理</p>\n</li>\n</ol>\n<h3 id=\"断言工厂\">断言工厂</h3>\n<p>我们在配置文件中写的断言规则只是字符串，这些字符串会被 Predicate Factory 读取并处理，转变为路由判断的条件</p>\n<p>例如 <code>Path=/user/**</code> 是按照路径匹配，这个规则是由 <code>org.springframework.cloud.gateway.handler.predicate.PathRoutePredicateFactory</code> 类来处理的，像这样的断言工厂在 Spring Cloud Gateway 还有十几个：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n<th>示例</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>After</td>\n<td>是某个时间点后的请求</td>\n<td><code>-  After=2037-01-20T17:42:47.789-07:00[America/Denver]</code></td>\n</tr>\n<tr>\n<td>Before</td>\n<td>是某个时间点之前的请求</td>\n<td><code>-  Before=2031-04-13T15:14:47.433+08:00[Asia/Shanghai]</code></td>\n</tr>\n<tr>\n<td>Between</td>\n<td>是某两个时间点之前的请求</td>\n<td><code>-  Between=2037-01-20T17:42:47.789-07:00[America/Denver],  2037-01-21T17:42:47.789-07:00[America/Denver]</code></td>\n</tr>\n<tr>\n<td>Cookie</td>\n<td>请求必须包含某些 cookie</td>\n<td><code>- Cookie=chocolate, ch.p</code></td>\n</tr>\n<tr>\n<td>Header</td>\n<td>请求必须包含某些 header</td>\n<td><code>- Header=X-Request-Id, \\d+</code></td>\n</tr>\n<tr>\n<td>Host</td>\n<td>请求必须是访问某个 host（域名）</td>\n<td><code>-  Host=**.somehost.org,**.anotherhost.org</code></td>\n</tr>\n<tr>\n<td>Method</td>\n<td>请求方式必须是指定方式</td>\n<td><code>- Method=GET,POST</code></td>\n</tr>\n<tr>\n<td>Path</td>\n<td>请求路径必须符合指定规则</td>\n<td><code>- Path=/red/{segment},/blue/**</code></td>\n</tr>\n<tr>\n<td>Query</td>\n<td>请求参数必须包含指定参数</td>\n<td><code>- Query=name, Jack</code> 或者 <code>-  Query=name</code></td>\n</tr>\n<tr>\n<td>RemoteAddr</td>\n<td>请求者的 ip 必须是指定范围</td>\n<td><code>- RemoteAddr=192.168.1.1/24</code></td>\n</tr>\n<tr>\n<td>Weight</td>\n<td>权重处理</td>\n<td></td>\n</tr>\n</tbody></table>\n<p>详情查阅：<a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories\">官方文档</a></p>\n<h3 id=\"过滤器工厂\">过滤器工厂</h3>\n<p>Gateway Filter 是网关中提供的一种过滤器，可以对进入网关的请求和微服务返回的响应做处理：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E8%BF%87%E6%BB%A4%E5%99%A8%E5%B7%A5%E5%8E%82.2sw963vwfry0.svg\" alt=\"过滤器工厂\"></p>\n<h4 id=\"路由过滤器的种类\">路由过滤器的种类</h4>\n<p>Spring 提供了 31 种不同的路由过滤器工厂。例如：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td><code>AddRequestHeader</code></td>\n<td>给当前请求添加一个请求头</td>\n</tr>\n<tr>\n<td><code>RemoveRequestHeader</code></td>\n<td>移除请求中的一个请求头</td>\n</tr>\n<tr>\n<td><code>AddResponseHeader</code></td>\n<td>给响应结果中添加一个响应头</td>\n</tr>\n<tr>\n<td><code>RemoveResponseHeader</code></td>\n<td>从响应结果中移除有一个响应头</td>\n</tr>\n<tr>\n<td><code>RequestRateLimiter</code></td>\n<td>限制请求的流量</td>\n</tr>\n</tbody></table>\n<p>详情查阅：<a href=\"https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories\">官方文档</a></p>\n<h4 id=\"请求头过滤器\">请求头过滤器</h4>\n<p>下面我们以 <code>AddRequestHeader</code> 为例来讲解。</p>\n<p>需求：给所有进入 user-service 的请求添加一个请求头：Truth=Halo</p>\n<p>只需要修改 gateway 服务的 application.yml 文件，添加路由过滤即可：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-symbol\">spring:</span>\n<span class=\"hljs-symbol\">  cloud:</span>\n<span class=\"hljs-symbol\">    gateway:</span>\n<span class=\"hljs-symbol\">      routes:</span>\n      - id: user-service \n<span class=\"hljs-symbol\">        uri:</span> lb:<span class=\"hljs-comment\">//userservice </span>\n<span class=\"hljs-symbol\">        predicates:</span> \n        - P<span class=\"hljs-attr\">ath</span><span class=\"hljs-operator\">=</span><span class=\"hljs-keyword\">/user/</span>** \n<span class=\"hljs-symbol\">        filters:</span> <span class=\"hljs-meta\"># 过滤器</span>\n        - AddRequestH<span class=\"hljs-attr\">eader</span><span class=\"hljs-operator\">=</span>Truth, Halo <span class=\"hljs-meta\"># 添加请求头</span>\n</code></pre>\n<p>当前过滤器写在 user-service 路由下，因此仅仅对访问 user-service 的请求有效。</p>\n<h4 id=\"默认过滤器\">默认过滤器</h4>\n<p>如果要对所有的路由都生效，则可以将过滤器工厂写到 default 下。格式如下：</p>\n<pre><code class=\"hljs language-yaml\"><span class=\"hljs-attribute\">spring</span><span class=\"hljs-punctuation\">:</span>\n  <span class=\"hljs-attribute\">cloud</span><span class=\"hljs-punctuation\">:</span>\n    <span class=\"hljs-attribute\">gateway</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-attribute\">routes</span><span class=\"hljs-punctuation\">:</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">id: user-service </span>\n        <span class=\"hljs-attribute\">uri</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\">lb://userservice </span>\n        <span class=\"hljs-attribute\">predicates</span><span class=\"hljs-punctuation\">: </span>\n        <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">Path=/user/**</span>\n      <span class=\"hljs-attribute\">default-filters</span><span class=\"hljs-punctuation\">:</span> <span class=\"hljs-string\"># 默认过滤项</span>\n      <span class=\"hljs-bullet\">-</span> <span class=\"hljs-string\">AddRequestHeader=Truth, Halo</span>\n</code></pre>\n<h4 id=\"过滤器工厂总结\">过滤器工厂总结</h4>\n<p>过滤器的作用是什么？</p>\n<ul>\n<li>对路由的请求或响应做加工处理，比如添加请求头</li>\n<li>配置在路由下的过滤器只对当前路由的请求生效</li>\n</ul>\n<p>defaultFilters 的作用是什么？</p>\n<ul>\n<li>对所有路由都生效的过滤器</li>\n</ul>\n<h3 id=\"全局过滤器\">全局过滤器</h3>\n<p>上一节学习的过滤器，网关提供了 31 种，但每一种过滤器的作用都是固定的。如果我们希望拦截请求，做自己的业务逻辑则没办法实现。</p>\n<h4 id=\"全局过滤器作用\">全局过滤器作用</h4>\n<p>全局过滤器的作用也是处理一切进入网关的请求和微服务响应，与 GatewayFilter 的作用一样。</p>\n<p>两者的区别在于： </p>\n<ul>\n<li>GatewayFilter 通过配置定义，处理逻辑是固定的；</li>\n<li>GlobalFilter 的逻辑需要自己写代码实现。</li>\n</ul>\n<p>定义方式是实现 GlobalFilter 接口。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">interface</span> <span class=\"hljs-title\">GlobalFilter</span> </span>{\n    <span class=\"hljs-comment\">/**\n     *  处理当前请求，有必要的话通过{<span class=\"hljs-doctag\">@link</span> GatewayFilterChain}将请求交给下一个过滤器处理\n     *\n     * <span class=\"hljs-doctag\">@param</span> exchange 请求上下文，里面可以获取Request、Response等信息\n     * <span class=\"hljs-doctag\">@param</span> chain 用来把请求委托给下一个过滤器 \n     * <span class=\"hljs-doctag\">@return</span> {<span class=\"hljs-doctag\">@code</span> Mono&lt;Void&gt;} 返回标示当前过滤器业务结束\n     */</span>\n    Mono&lt;<span class=\"hljs-keyword\">Void</span>&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain);\n}\n</code></pre>\n<p>在 filter 中编写自定义逻辑，可以实现下列功能：</p>\n<ul>\n<li>登录状态判断</li>\n<li>权限校验</li>\n<li>请求限流等</li>\n</ul>\n<h4 id=\"自定义全局过滤器\">自定义全局过滤器</h4>\n<p>需求：定义全局过滤器，拦截请求，判断请求的参数是否满足下面条件：</p>\n<ul>\n<li><p>参数中是否有 authorization，</p>\n</li>\n<li><p>authorization 参数值是否为 admin</p>\n</li>\n</ul>\n<p>如果同时满足则放行，否则拦截</p>\n<p>实现，在 gateway 中定义一个过滤器：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-meta\">@Order</span>(-<span class=\"hljs-number\">1</span>)\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AuthorizeFilter</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">GlobalFilter</span> {\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">Mono</span>&lt;<span class=\"hljs-title class_\">Void</span>&gt; <span class=\"hljs-title function_\">filter</span>(<span class=\"hljs-params\">ServerWebExchange exchange, GatewayFilterChain chain</span>) {\n        <span class=\"hljs-comment\">// 1. 获取请求参数</span>\n        <span class=\"hljs-title class_\">ServerHttpRequest</span> request = exchange.<span class=\"hljs-title function_\">getRequest</span>();\n        <span class=\"hljs-title class_\">MultiValueMap</span>&lt;<span class=\"hljs-title class_\">String</span>, <span class=\"hljs-title class_\">String</span>&gt; queryParams = request.<span class=\"hljs-title function_\">getQueryParams</span>();\n        <span class=\"hljs-comment\">// 2. 获取参数中的 authorization</span>\n        <span class=\"hljs-title class_\">String</span> auth = queryParams.<span class=\"hljs-title function_\">getFirst</span>(<span class=\"hljs-string\">&quot;authorization&quot;</span>);\n        <span class=\"hljs-comment\">// 3. 判断参数值是否等于 admin</span>\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">&quot;admin&quot;</span>.<span class=\"hljs-title function_\">equals</span>(auth)) {\n            <span class=\"hljs-comment\">// 放行</span>\n            <span class=\"hljs-keyword\">return</span> chain.<span class=\"hljs-title function_\">filter</span>(exchange);\n        }\n        <span class=\"hljs-comment\">// 拦截</span>\n        <span class=\"hljs-comment\">// 设置状态码</span>\n        exchange.<span class=\"hljs-title function_\">getResponse</span>().<span class=\"hljs-title function_\">setStatusCode</span>(<span class=\"hljs-title class_\">HttpStatus</span>.<span class=\"hljs-property\">UNAUTHORIZED</span>);\n        <span class=\"hljs-comment\">// 拦截请求</span>\n        <span class=\"hljs-keyword\">return</span> exchange.<span class=\"hljs-title function_\">getResponse</span>().<span class=\"hljs-title function_\">setComplete</span>();\n    }\n}\n</code></pre>\n<p><code>@Order(-1)</code> 用于指定过滤器顺序，值越小优先级越高</p>\n<p>重启网关，访问 <a href=\"http://localhost:10010/user/1?authorization=admin\">http://localhost:10010/user/1?authorization=admin</a></p>\n<h4 id=\"过滤器执行顺序\">过滤器执行顺序</h4>\n<p>请求进入网关会碰到三类过滤器：当前路由的过滤器、DefaultFilter、GlobalFilter</p>\n<p>请求路由后，会将当前路由过滤器和 DefaultFilter、GlobalFilter，合并到一个过滤器链（集合）中，排序后依次执行每个过滤器：</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/%E8%BF%87%E6%BB%A4%E5%99%A8%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F.4mfcqien0h60.svg\" alt=\"过滤器执行顺序\"></p>\n<p>排序的规则是什么呢？</p>\n<ul>\n<li>首先，每一个过滤器都必须指定一个 int 类型的 order 值，order 值越小，优先级越高，执行顺序越靠前。</li>\n<li>GlobalFilter 通过实现 Ordered 接口，或者添加 <code>@Order</code> 注解来指定 order 值，由我们自己指定。路由过滤器和 defaultFilter 的 order 由 Spring 指定，默认是按照声明顺序从 1 递增。</li>\n<li>当过滤器的 order 值一样时，会按照 defaultFilter、路由过滤器、GlobalFilter 的顺序执行。</li>\n</ul>\n<p>详细内容，可以查看源码：</p>\n<ul>\n<li><code>org.springframework.cloud.gateway.route.RouteDefinitionRouteLocator#getFilters()</code> 方法是先加载 defaultFilters，然后再加载某个 route 的 filters，然后合并。</li>\n<li><code>org.springframework.cloud.gateway.handler.FilteringWebHandler#handle()</code> 方法会加载全局过滤器，与前面的过滤器合并后根据order排序，组织过滤器链</li>\n</ul>\n<h3 id=\"跨域问题\">跨域问题</h3>\n<h4 id=\"什么是跨域问题\">什么是跨域问题</h4>\n<p>跨域：域名不一致就是跨域，主要包括：</p>\n<ul>\n<li><p>域名不同： <a href=\"http://www.taobao.com\">www.taobao.com</a> 和 <a href=\"http://www.taobao.org\">www.taobao.org</a> 和 <a href=\"http://www.jd.com\">www.jd.com</a> 和 miaosha.jd.com</p>\n</li>\n<li><p>域名相同，端口不同：localhost:8080 和 localhost8081</p>\n</li>\n</ul>\n<p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域 Ajax 请求，请求被浏览器拦截的问题</p>\n<p>CORS 解决方案，参考资料：<a href=\"https://www.ruanyifeng.com/blog/2016/04/cors.html\">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>\n<h4 id=\"解决跨域问题\">解决跨域问题</h4>\n<p>在 gateway 服务的 application.yml 文件中，添加下面的配置：</p>\n<pre><code class=\"hljs language-yaml\">spring:\n  cloud:\n    gateway:\n      # .\n      globalcors: # 全局的跨域处理\n        add-to-simple-url-handler-mapping: true # 解决options请求被拦截问题\n        corsConfigurations:\n          &#x27;<span class=\"hljs-string\">[/**]</span>&#x27;:\n            allowedOrigins: # 允许哪些网站的跨域请求 \n              - <span class=\"hljs-string\">&quot;http://localhost:8090&quot;</span>\n            allowedMethods: # 允许的跨域ajax的请求方式\n              - <span class=\"hljs-string\">&quot;<span class=\"hljs-keyword\">GET</span>&quot;</span>\n              - <span class=\"hljs-string\">&quot;<span class=\"hljs-keyword\">POST</span>&quot;</span>\n              - <span class=\"hljs-string\">&quot;<span class=\"hljs-keyword\">DELETE</span>&quot;</span>\n              - <span class=\"hljs-string\">&quot;<span class=\"hljs-keyword\">PUT</span>&quot;</span>\n              - <span class=\"hljs-string\">&quot;<span class=\"hljs-keyword\">OPTIONS</span>&quot;</span>\n            allowedHeaders: <span class=\"hljs-string\">&quot;*&quot;</span> # 允许在请求中携带的头信息\n            allowCredentials: true # 是否允许携带cookie\n            maxAge: <span class=\"hljs-number\">360000</span> # 这次跨域检测的有效期\n</code></pre>\n');
INSERT INTO `m_blog` VALUES (18, 11, '2021年10月12日21点19分', '2021年10月12日21点19分', '2021年10月12日21点19分', '2021-10-12 21:19:36', 1, 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/macos.6z1mshl4twk0.svg', 0, '2021-10-12 21:19:36', NULL, NULL, NULL, 1, 1, 0, NULL, 0, NULL);
INSERT INTO `m_blog` VALUES (19, 11, '2021年10月12日21点19分1111111', '2021年10月12日21点19分', '2021年10月12日21点19分', '2021-10-12 21:19:36', 1, 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/macos.6z1mshl4twk0.svg', 0, '2021-10-12 21:21:02', NULL, NULL, NULL, 1, 1, 0, NULL, 0, NULL);
INSERT INTO `m_blog` VALUES (20, 11, '2021年10月12日21点19分5555', '2021年10月12日21点19分', '2021年10月12日21点19分', '2021-10-12 21:19:36', 1, 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/macos.6z1mshl4twk0.svg', 0, '2021-10-12 23:53:08', NULL, NULL, NULL, 1, 1, 0, NULL, 0, NULL);
INSERT INTO `m_blog` VALUES (25, 1, '1111', '1111', '# 1\n1111\n## 11', '2021-10-14 11:13:16', 1, 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/macos.6z1mshl4twk0.svg', 0, '2021-10-14 11:13:16', NULL, NULL, NULL, 1, 1, 0, NULL, 0, '<h1 id=\"1\">1</h1>\n<p>1111</p>\n<h2 id=\"11\">11</h2>\n');
INSERT INTO `m_blog` VALUES (26, 1, '部署程序', '部署', '### 关闭之前的 Java 程序\n\n```\nps -ef | grep xxx.jar\n```\n\n查看进程\n\n```\nkill -9 $pid\n```\n\n### 运行程序\n\n```\nnohup java -jar xxxx > nohup.log &\n```\n\nnohup 表示不挂断运行，&表示以后台方式运行。', '2021-11-11 04:50:32', 1, 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/macos.6z1mshl4twk0.svg', 2, '2021-10-14 11:20:26', NULL, NULL, NULL, 1, 1, 0, NULL, 0, '<h3 id=\"关闭之前的-java-程序\">关闭之前的 Java 程序</h3>\n<pre><code><span class=\"hljs-keyword\">ps</span> -ef | <span class=\"hljs-keyword\">grep</span> xxx.jar\n</code></pre>\n<p>查看进程</p>\n<pre><code><span class=\"hljs-built_in\">kill</span> -9 <span class=\"hljs-variable\">$pid</span>\n</code></pre>\n<h3 id=\"运行程序\">运行程序</h3>\n<pre><code>nohup java -jar xxxx &gt; nohup.<span class=\"hljs-built_in\">log</span> <span class=\"hljs-meta\">&amp;</span>\n</code></pre>\n<p>nohup 表示不挂断运行，&amp;表示以后台方式运行。</p>\n');
INSERT INTO `m_blog` VALUES (27, 1, 'Java 集合', '1111', '了解有关 Java 集合类库的基本知识，以及对典型用法的重点介绍\n\n参考资料:\n\n+ 《On Java 8》\n+ [Java 集合框架](https://www.pdai.tech/md/java/collection/java-collection-all.html)\n\n---\n\n如果一个程序只包含固定数量的且其生命期都是已知的对象，那么这是一个非常简单程序。\n\n通常，程序总是根据运行时才知道的某些条件去创建新对象。在此之前，不会知道所需对象的数量，甚至不知道确切的类型。为解决这个普遍的编程问题，需要在任意时刻和任意位创建任意数量的对象。所以，就不能依靠创建命名的引用来持有每一个对象：\n\n```java\nMyType aReference;\n```\n\n因为你不知道实际上会需要多少这样的引用。\n\n大多数语言都提供某种方法来解决这个基本问题。Java 有多种方式进行对象的引用。例如前面曾经学习过的数组，它是编译器支持的类型。数组是保存一组对象的最有效的方式，如果你想保存一组基本类型数据，也推荐使用这种方式。但是数组具有固定的尺寸而在更一般的情况中，你在写程序时并不知道将需要多少个对象，或者是否需要更复杂的方式来存储对象，因此数组尺寸固定这一限制显得过于受限了。\n\nJava 实用类库还提供了一套相当完整的容器类来解决这个问题，其中基本的类型是 List、Set、 Queue 和 Map。这些对象类型也称为集合类，集合提供了完善的方法来保存对象，你可以使用这些工具来解决数量惊人的问题。\n\n集合还有其他一些特性。例如，Set 对于每个值都只保存一个对象，Map 是允许你将某些对象与其他一些对象关联起来的关联数组，Java 集合类都可以自动地调整自己的尺寸。因此，与数组不同，在编程时，你可以将任意数量的对象放置到集合中，并且不需要担心集合应该设置为多大。\n\n即使在 Java 中没有直接的关键字支持，集合类仍旧是可以显著增强你的编程能力的基本工具。\n\n## Java 容器\n\n容器，就是可以容纳其他 Java 对象的对象。Java Collections Framework (JCF) 为 Java 开发者提供了通用的容器，其始于 JDK 1.2，优点是：\n\n+ 降低编程难度\n+ 提高程序性能\n+ 提高 API 间的互操作性\n+ 降低学习难度\n+ 降低设计和实现相关 API 的难度\n+ 增加程序的重用性\n\nJava 容器里只能放对象，对于基本类型（int、long、float、double等），需要将其包装成对应的对象类型后（Integer、Long、Float、Double等）才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。\n\n容器主要包括 Collection 和 Map 两种\n\n+ Collection 存储着对象的集合，\n+ Map 存储着键值对（两个对象）的映射表。\n\n![image](https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-f@master/image.5y8i5yfb0n00.png)\n\n其中 Set、List、Queue 实现自 Collection 接口\n\nSet：\n\n+ TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 $O(1)$，TreeSet 则为 $O(\\log N)$。\n+ HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。\n+ LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。\n\nList：\n\n+ ArrayList：基于动态数组实现，支持随机访问。\n+ Vector：和 ArrayList 类似，但它是线程安全的。\n+ LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。\n\nQueue：\n\n+ LinkedList：可以用它来实现双向队列。\n+ PriorityQueue：基于堆结构实现，可以用它来实现优先队列。\n\nMap：\n\n+ TreeMap：基于红黑树实现。\n+ HashMap：基于哈希表实现。\n+ HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。\n+ LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。\n\n## 泛型和类型安全的集合\n\n使用 Java 5 之前的集合的一个主要问题就是编译器允许你向集合中插入不正确的类型。\n\n例如，考虑一个 Apple 对象的集合，我们使用最基本最可靠的集合 ArrayList。现在，你可以把 ArrayList 当作“可以自动扩充自身尺寸的数组”来看待。使用 ArrayList 相当简单：\n\n+ 创建一个实例，用 `add()` 插入对象；\n+ 然后用 `get()` 访问这些对象，此时需要使用索引，就像数组一样，但是不需要方括号。\n+ ArrayList 还有一个  `size()` 方法，使你可以知道已经有多少元素添加了进来，从而不会不小心因索引越界而引发错误。\n\n在本例中，Apple 和 Orange 都放置在了集合中，然后将它们取出。正常情况下，Java 编译器会报告警告信息，因为这个示例没有使用泛型。在这里，我们使用特定的注解来抑制了警告信息。注解以“@”符号开头，可以接受参数，这里的 `@SuppressWarnings` 注解及其参数表示只抑制“unchecked”类型的警告信息：\n\n```java\nclass Apple {\n  private static long counter;\n  private final long id = counter++;\n  public long id() { return id; }\n}\n\nclass Orange {}\n\npublic class ApplesAndOrangesWithoutGenerics {\n  @SuppressWarnings(\"unchecked\")\n  public static void main(String[] args) {\n    ArrayList apples = new ArrayList();\n    for(int i = 0; i < 3; i++)\n      apples.add(new Apple());\n    // No problem adding an Orange to apples:\n    apples.add(new Orange());\n    for(Object apple : apples) {\n      ((Apple) apple).id();\n      // Orange is detected only at run time\n    }\n  }\n}\n```\n\nApple 和 Orange 是截然不同的，它们除了都是 Object 之外没有任何共同点\n\n> 如果一个类没有显式地声明继承自哪个类，那么它就自动继承自 Object\n\n因为 ArrayList 保存的是 Object ，所以不仅可以通过 ArrayList 的 `add()` 方法将 Apple 对象放入这个集合，而且可以放入 Orange 对象，这无论在编译期还是运行时都不会有问题。\n\n当使用 ArrayList 的 `get()` 方法来取出你认为是 Apple 的对象时，得到的只是 Object 引用，必须将其转型为 Apple。然后需要将整个表达式用括号括起来，以便在调用 Apple 的 `id()` 方法之前，强制执行转型。否则，将会产生语法错误。\n\n在运行时，当尝试将 Orange 对象转为 Apple 时，会出现输出中显示的错误。\n\n```\n___[ Error Output ]___\nException in thread \"main\"\njava.lang.ClassCastException: Orange cannot be cast to Apple at \nApplesAndOrangesWithoutGenerics.main(ApplesAndOrangesWithoutGenerics.java:23)\n```\n\nJava 泛型来创建类可能很复杂。但是，使用预先定义的泛型类却相当简单。\n\n例如，要定义一个用于保存 Apple 对象的 ArrayList，只需要使用 `ArrayList<Apple>` 来代替 ArrayList。尖括号括起来的是类型参数（可能会有多个），它指定了这个集合实例可以保存的类型。\n\n通过使用泛型，就可以在编译期防止将错误类型的对象放置到集合中。下面还是这个示例，但是使用了泛型：\n\n```java\n// collections/ApplesAndOrangesWithGenerics.java\nimport java.util.*;\n\npublic class ApplesAndOrangesWithGenerics {\n  public static void main(String[] args) {\n    ArrayList<Apple> apples = new ArrayList<>();\n    for(int i = 0; i < 3; i++)\n      apples.add(new Apple());\n    // Compile-time error:\n    // apples.add(new Orange());\n    for(Apple apple : apples) {\n      System.out.println(apple.id());\n    }\n  }\n}\n/* Output:\n0\n1\n2\n*/\n```\n\n在 `apples` 定义的右侧，可以看到 `new ArrayList<>()` 。这有时被称为“菱形语法”（diamond syntax）。\n\n在 Java 7 之前，必须要在两端都进行类型声明，如下所示：\n\n```java\nArrayList<Apple> apples = new ArrayList<Apple>();\n```\n\n随着类型变得越来越复杂，这种重复产生的代码非常混乱且难以阅读。程序员发现所有类型信息都可以从左侧获得，因此，编译器没有理由强迫右侧再重复这些。虽然类型推断（type inference）只是个很小的请求，Java 语言团队仍然欣然接受并进行了改进。\n\n有了 ArrayList 声明中的类型指定，编译器会阻止将 Orange 放入 apples，因此，这会成为一个编译期错误而不是运行时错误。\n\n使用泛型，从 List 中获取元素不需要强制类型转换。因为 List 知道它持有什么类型，因此当调用 `get()` 时，它会替你执行转型。因此，使用泛型，你不仅知道编译器将检查放入集合的对象类型，而且在使用集合中的对象时也可以获得更清晰的语法。\n\n当指定了某个类型为泛型参数时，并不仅限于只能将确切类型的对象放入集合中。向上转型也可以像作用于其他类型一样作用于泛型：\n\n```java\n// collections/GenericsAndUpcasting.java\nimport java.util.*;\n\nclass GrannySmith extends Apple {}\nclass Gala extends Apple {}\nclass Fuji extends Apple {}\nclass Braeburn extends Apple {}\n\npublic class GenericsAndUpcasting {\n  public static void main(String[] args) {\n    ArrayList<Apple> apples = new ArrayList<>();\n    apples.add(new GrannySmith());\n    apples.add(new Gala());\n    apples.add(new Fuji());\n    apples.add(new Braeburn());\n    for(Apple apple : apples)\n      System.out.println(apple);\n  }\n}\n/* Output:\nGrannySmith@15db9742\nGala@6d06d69c\nFuji@7852e922\nBraeburn@4e25154f\n*/\n```\n\n因此，可以将 Apple 的子类型添加到被指定为保存 Apple 对象的集合中。\n\n程序的输出是从 Object 默认的 `toString()` 方法产生的，该方法打印类名，后边跟着对象的散列码的无符号十六进制表示（这个散列码是通过 `hashCode()` 方法产生的）。\n\n## 集合类的基本介绍\n\nJava 集合类库采用“持有对象”（holding objects）的思想，并将其分为两个不同的概念——集合和映射，表示为类库的基本接口：\n\n集合（Collection）：一个独立元素的序列，这些元素都服从一条或多条规则。\n\n+ List 必须以插入的顺序保存元素\n+ Set 不能包含重复元素\n+ Queue 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）\n\n映射（Map） ： 一组成对的“键值对”对象，允许使用键来查找值。Map 是强大的编程工具。\n\n+ ArrayList 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 \n+ Map 允许我们使用一个对象来查找另一个对象，它也被称作关联数组（associative array），因为它将对象和其它对象关联在一起\n+ Map 也被称作字典（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。 \n\n在理想情况下，我们编写的大部分代码都在与这些接口打交道，并且在创建的时候就需要指定，所使用的精确类型，并且也只能在创建时指定。因此，可以像下面这样创建一个 List ：\n\n```java\nList<Apple> apples = new ArrayList<>();\n```\n\n请注意， ArrayList 已经被向上转型为了 List。使用接口的目的是，如果想要改变具体实现，只需在创建时修改它就行了，就像下面这样：\n\n```java\nList<Apple> apples = new LinkedList<>();\n```\n\n因此，应该创建一个具体类的对象，将其向上转型为对应的接口，然后在其余代码中都是用这个接口。\n\n但这种方式并非总是有效，因为某些具体类有额外的功能。例如， LinkedList 具有 List 接口中未包含的额外方法，而 TreeMap 也具有在 Map 接口中未包含的方法。如果需要使用这些方法，就不能将它们向上转型为更通用的接口。\n\nCollection 接口概括了序列的概念（序列是指一种存放一组对象的方式）。下面是个简单的示例，用 Integer 对象填充了一个 Collection （这里用 ArrayList 表示），然后打印集合中的每个元素：\n\n```java\n// collections/SimpleCollection.java\nimport java.util.*;\n\npublic class SimpleCollection {\n  public static void main(String[] args) {\n    Collection<Integer> c = new ArrayList<>();\n    for(int i = 0; i < 10; i++)\n      c.add(i); // Autoboxing\n    for(Integer i : c)\n      System.out.print(i + \", \");\n  }\n}\n/* Output:\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n*/\n```\n\n这个例子仅使用了 Collection 中的方法（即 `add()` ），所以使用任何继承自 Collection 的类的对象都可以正常工作。但是 `ArrayList` 是最基本的序列类型。\n\n`add()` 方法的名称就表明它是在 Collection 中添加一个新元素。\n\n但是，文档中非常详细地叙述到 `add()` “要确保这个 Collection 包含指定的元素。”\n\n+ 这是因为考虑到了 Set 的含义，因为在 Set 中，只有当元素不存在时才会添加元素。\n+ 在使用 `ArrayList` ，或任何其他类型的 List 时，`add()` 总是表示“把它放进去”，因为 List 不关心是否存在重复元素。\n\n可以使用 for-in 语法来遍历所有的 Collection，就像这里所展示的那样。后面还将学习到一个更灵活的概念，迭代器。\n\n### 添加元素组\n\n在 java.util 包中的 Arrays 和 Collections 类中都有很多实用的方法，可以在一个 Collection 中添加一组元素。\n\n+ `Arrays.asList()` 方法接受一个数组或是逗号分隔的元素列表（使用可变参数），并将其转换为 List 对象。 \n+ `Collections.addAll()` 方法接受一个 Collection 对象，以及一个数组或是一个逗号分隔的列表，将其中元素添加到 Collection 中。\n\n下边的示例展示了这两个方法，以及更通用的 、所有 Collection 类型都包含的`addAll()` 方法：\n\n```java\npublic class AddingGroups {\n  public static void main(String[] args) {\n    Collection<Integer> collection = new ArrayList<>(Arrays.asList(1, 2, 3, 4, 5));\n    Integer[] moreInts = { 6, 7, 8, 9, 10 };\n    collection.addAll(Arrays.asList(moreInts));\n    // Runs significantly faster, but you can\'t construct a Collection this way:\n    Collections.addAll(collection, 11, 12, 13, 14, 15);\n    Collections.addAll(collection, moreInts);\n    // Produces a list \"backed by\" an array:\n    List<Integer> list = Arrays.asList(16, 17, 18, 19, 20);\n    list.set(1, 99); // OK; 修改指定索引的元素值\n    // list.add(21); // Runtime error; 数组的大小不能调整\n  }\n}\n```\n\nCollection 的构造器可以接受另一个 Collection，用它来将自身初始化。因此，可以使用 `Arrays.asList()` 来为这个构造器产生输入。但是， `Collections.addAll()` 运行得更快，而且很容易构建一个不包含元素的 Collection，然后调用 `Collections.addAll()` ，因此这是首选方式。\n\n`collection.addAll()` 方法只能接受另一个 Collection 作为参数，因此它没有 `Arrays.asList()` 或 `Collections.addAll()` 灵活。这两个方法都使用可变参数列表。\n\n也可以直接使用 `Arrays.asList()` 的输出作为一个 List ，但是这里的底层实现是数组，没法调整大小。如果尝试在这个 List 上调用 `add()` 或 `remove()`，由于这两个方法会尝试修改数组大小，所以会在运行时得到“Unsupported Operation（不支持的操作）”错误：\n\n```java\nclass Snow {}\nclass Powder extends Snow {}\nclass Light extends Powder {}\nclass Heavy extends Powder {}\nclass Crusty extends Snow {}\nclass Slush extends Snow {}\n\npublic class AsListInference {\n  public static void main(String[] args) {\n    List<Snow> snow1 = Arrays.asList(\n      new Crusty(), new Slush(), new Powder());\n    //- snow1.add(new Heavy()); // Exception\n\n    List<Snow> snow2 = Arrays.asList(\n      new Light(), new Heavy());\n    //- snow2.add(new Slush()); // Exception\n\n    List<Snow> snow3 = new ArrayList<>();\n    Collections.addAll(snow3,\n      new Light(), new Heavy(), new Powder());\n    snow3.add(new Crusty());\n\n    // Hint with explicit type argument specification:\n    List<Snow> snow4 = Arrays.<Snow>asList(\n       new Light(), new Heavy(), new Slush());\n    //- snow4.add(new Powder()); // Exception\n  }\n}\n```\n\n在 snow4 中，注意 `Arrays.asList()` 中间的“暗示”（即 `<Snow>` ），告诉编译器 `Arrays.asList()` 生成的结果 **List* 类型的实际目标类型是什么。这称为显式类型参数说明（explicit type argument specification）。\n\n### 集合的打印\n\n必须使用 `Arrays.toString()` 来生成数组的可打印形式。但是打印集合无需任何帮助。下面是一个例子，这个例子中也介绍了基本的Java集合：\n\n```java\n// collections/PrintingCollections.java\n// Collections print themselves automatically\nimport java.util.*;\n\npublic class PrintingCollections {\n  static Collection fill(Collection<String> collection) {\n    collection.add(\"rat\");\n    collection.add(\"cat\");\n    collection.add(\"dog\");\n    collection.add(\"dog\");\n    return collection;\n  }\n  static Map fill(Map<String, String> map) {\n    map.put(\"rat\", \"Fuzzy\");\n    map.put(\"cat\", \"Rags\");\n    map.put(\"dog\", \"Bosco\");\n    map.put(\"dog\", \"Spot\");\n    return map;\n  }\n  public static void main(String[] args) {\n    System.out.println(fill(new ArrayList<>()));\n    System.out.println(fill(new LinkedList<>()));\n    System.out.println(fill(new HashSet<>()));\n    System.out.println(fill(new TreeSet<>()));\n    System.out.println(fill(new LinkedHashSet<>()));\n    System.out.println(fill(new HashMap<>()));\n    System.out.println(fill(new TreeMap<>()));\n    System.out.println(fill(new LinkedHashMap<>()));\n  }\n}\n/* Output:\n[rat, cat, dog, dog]\n[rat, cat, dog, dog]\n[rat, cat, dog]\n[cat, dog, rat]\n[rat, cat, dog]\n{rat=Fuzzy, cat=Rags, dog=Spot}\n{cat=Rags, dog=Spot, rat=Fuzzy}\n{rat=Fuzzy, cat=Rags, dog=Spot}\n*/\n```\n\n这显示了Java集合库中的两个主要类型。它们的区别在于集合中的每个“槽”（slot）保存的元素个数。 **Collection** 类型在每个槽中只能保存一个元素。此类集合包括： **List** ，它以特定的顺序保存一组元素； **Set** ，其中元素不允许重复； **Queue** ，只能在集合一端插入对象，并从另一端移除对象（就本例而言，这只是查看序列的另一种方式，因此并没有显示它）。 **Map** 在每个槽中存放了两个元素，即键和与之关联的值。\n\n默认的打印行为，使用集合提供的 `toString()` 方法即可生成可读性很好的结果。 **Collection** 打印出的内容用方括号括住，每个元素由逗号分隔。 **Map** 则由大括号括住，每个键和值用等号连接（键在左侧，值在右侧）。\n\n第一个 `fill()` 方法适用于所有类型的 **Collection** ，这些类型都实现了 `add()` 方法以添加新元素。\n\n**ArrayList** 和 **LinkedList** 都是 **List** 的类型，从输出中可以看出，它们都按插入顺序保存元素。两者之间的区别不仅在于执行某些类型的操作时的性能，而且 **LinkedList** 包含的操作多于 **ArrayList** 。本章后面将对这些内容进行更全面的探讨。\n\n**HashSet** ， **TreeSet** 和 **LinkedHashSet** 是 **Set** 的类型。从输出中可以看到， **Set** 仅保存每个相同项中的一个，并且不同的 **Set** 实现存储元素的方式也不同。 **HashSet** 使用相当复杂的方法存储元素。现在只需要知道，这种技术是检索元素的最快方法，因此，存储顺序看上去没有什么意义（通常只关心某事物是否是 **Set** 的成员，而存储顺序并不重要）。如果存储顺序很重要，则可以使用 **TreeSet** ，它将按比较结果的升序保存对象）或 **LinkedHashSet** ，它按照被添加的先后顺序保存对象。\n\n**Map** （也称为关联数组）使用键来查找对象，就像一个简单的数据库。所关联的对象称为值。 假设有一个 **Map** 将美国州名与它们的首府联系在一起，如果想要俄亥俄州（Ohio）的首府，可以用“Ohio”作为键来查找，几乎就像使用数组下标一样。正是由于这种行为，对于每个键， **Map** 只存储一次。\n\n`Map.put(key, value)` 添加一个所想要添加的值并将它与一个键（用来查找值）相关联。 `Map.get(key)` 生成与该键相关联的值。上面的示例仅添加键值对，并没有执行查找。这将在稍后展示。\n\n请注意，这里没有指定（或考虑） **Map** 的大小，因为它会自动调整大小。 此外， **Map** 还知道如何打印自己，它会显示相关联的键和值。\n\n本例使用了 **Map** 的三种基本风格： **HashMap** ， **TreeMap** 和 **LinkedHashMap** 。\n\n键和值保存在 **HashMap** 中的顺序不是插入顺序，因为 **HashMap** 实现使用了非常快速的算法来控制顺序。 **TreeMap** 通过比较结果的升序来保存键， **LinkedHashMap** 在保持 **HashMap** 查找速度的同时按键的插入顺序保存键。\n\n## 列表 List\n\n**List**承诺将元素保存在特定的序列中。 **List** 接口在 **Collection** 的基础上添加了许多方法，允许在 **List** 的中间插入和删除元素。\n\n有两种类型的 **List** ：\n\n- 基本的 **ArrayList** ，擅长随机访问元素，但在 **List** 中间插入和删除元素时速度较慢。\n- **LinkedList** ，它通过代价较低的在 **List** 中间进行的插入和删除操作，提供了优化的顺序访问。 **LinkedList** 对于随机访问来说相对较慢，但它具有比 **ArrayList** 更大的特征集。\n\nTODO 特征集？2020年10月12日\n\n下面的示例导入 **typeinfo.pets** ，超前使用了类型信息一章中的类库。这个类库包含了 **Pet** 类层次结构，以及用于随机生成 **Pet** 对象的一些工具类。此时不需要了解完整的详细信息，只需要知道两点：\n\n1. 有一个 **Pet** 类，以及 **Pet** 的各种子类型。\n2. 静态的 `Pets.arrayList()` 方法返回一个填充了随机选取的 **Pet** 对象的 **ArrayList**：\n\n```Java\n// collections/ListFeatures.java\nimport typeinfo.pets.*;\nimport java.util.*;\n\npublic class ListFeatures {\n  public static void main(String[] args) {\n    Random rand = new Random(47);\n    List<Pet> pets = Pets.list(7);\n    System.out.println(\"1: \" + pets);\n    Hamster h = new Hamster();\n    pets.add(h); // Automatically resizes\n    System.out.println(\"2: \" + pets);\n    System.out.println(\"3: \" + pets.contains(h));\n    pets.remove(h); // Remove by object\n    Pet p = pets.get(2);\n    System.out.println(\"4: \" +  p + \" \" + pets.indexOf(p));\n    Pet cymric = new Cymric();\n    System.out.println(\"5: \" + pets.indexOf(cymric));\n    System.out.println(\"6: \" + pets.remove(cymric));\n    // Must be the exact object:\n    System.out.println(\"7: \" + pets.remove(p));\n    System.out.println(\"8: \" + pets);\n    pets.add(3, new Mouse()); // Insert at an index\n    System.out.println(\"9: \" + pets);\n    List<Pet> sub = pets.subList(1, 4);\n    System.out.println(\"subList: \" + sub);\n    System.out.println(\"10: \" + pets.containsAll(sub));\n    Collections.sort(sub); // In-place sort\n    System.out.println(\"sorted subList: \" + sub);\n    // Order is not important in containsAll():\n    System.out.println(\"11: \" + pets.containsAll(sub));\n    Collections.shuffle(sub, rand); // Mix it up\n    System.out.println(\"shuffled subList: \" + sub);\n    System.out.println(\"12: \" + pets.containsAll(sub));\n    List<Pet> copy = new ArrayList<>(pets);\n    sub = Arrays.asList(pets.get(1), pets.get(4));\n    System.out.println(\"sub: \" + sub);\n    copy.retainAll(sub);\n    System.out.println(\"13: \" + copy);\n    copy = new ArrayList<>(pets); // Get a fresh copy\n    copy.remove(2); // Remove by index\n    System.out.println(\"14: \" + copy);\n    copy.removeAll(sub); // Only removes exact objects\n    System.out.println(\"15: \" + copy);\n    copy.set(1, new Mouse()); // Replace an element\n    System.out.println(\"16: \" + copy);\n    copy.addAll(2, sub); // Insert a list in the middle\n    System.out.println(\"17: \" + copy);\n    System.out.println(\"18: \" + pets.isEmpty());\n    pets.clear(); // Remove all elements\n    System.out.println(\"19: \" + pets);\n    System.out.println(\"20: \" + pets.isEmpty());\n    pets.addAll(Pets.list(4));\n    System.out.println(\"21: \" + pets);\n    Object[] o = pets.toArray();\n    System.out.println(\"22: \" + o[3]);\n    Pet[] pa = pets.toArray(new Pet[0]);\n    System.out.println(\"23: \" + pa[3].id());\n  }\n}\n/* Output:\n1: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug]\n2: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Hamster]\n3: true\n4: Cymric 2\n5: -1\n6: false\n7: true\n8: [Rat, Manx, Mutt, Pug, Cymric, Pug]\n9: [Rat, Manx, Mutt, Mouse, Pug, Cymric, Pug]\nsubList: [Manx, Mutt, Mouse]\n10: true\nsorted subList: [Manx, Mouse, Mutt]\n11: true\nshuffled subList: [Mouse, Manx, Mutt]\n12: true\nsub: [Mouse, Pug]\n13: [Mouse, Pug]\n14: [Rat, Mouse, Mutt, Pug, Cymric, Pug]\n15: [Rat, Mutt, Cymric, Pug]\n16: [Rat, Mouse, Cymric, Pug]\n17: [Rat, Mouse, Mouse, Pug, Cymric, Pug]\n18: false\n19: []\n20: true\n21: [Manx, Cymric, Rat, EgyptianMau]\n22: EgyptianMau\n23: 14\n*/\n```\n\n打印行都编了号，因此可从输出追溯到源代码。 第 1 行输出展示了原始的由 **Pet** 组成的 **List** 。 与数组不同， **List** 可以在创建后添加或删除元素，并自行调整大小。这正是它的重要价值：一种可修改的序列。在第 2 行输出中可以看到添加一个 **Hamster** 的结果，该对象将被追加到列表的末尾。\n\n可以使用 `contains()` 方法确定对象是否在列表中。如果要删除一个对象，可以将该对象的引用传递给 `remove()` 方法。同样，如果有一个对象的引用，可以使用 `indexOf()` 在 **List** 中找到该对象所在位置的下标号，如第 4 行输出所示中所示。\n\n当确定元素是否是属于某个 **List** ，寻找某个元素的索引，以及通过引用从 **List** 中删除元素时，都会用到 `equals()` 方法（根类 **Object** 的一个方法）。每个 **Pet** 被定义为一个唯一的对象，所以即使列表中已经有两个 **Cymrics** ，如果再创建一个新的 **Cymric** 对象并将其传递给 `indexOf()` 方法，结果仍为 **-1** （表示未找到），并且尝试调用 `remove()` 方法来删除这个对象将返回 **false** 。对于其他类， `equals()` 的定义可能有所不同。例如，如果两个 **String** 的内容相同，则这两个 **String** 相等。因此，为了防止出现意外，请务必注意 **List** 行为会根据 `equals()` 行为而发生变化。\n\n第 7、8 行输出展示了删除与 **List** 中的对象完全匹配的对象是成功的。\n\n可以在 **List** 的中间插入一个元素，就像在第 9 行输出和它之前的代码那样。但这会带来一个问题：对于 **LinkedList** ，在列表中间插入和删除都是廉价操作（在本例中，除了对列表中间进行的真正的随机访问），但对于 **ArrayList** ，这可是代价高昂的操作。这是否意味着永远不应该在 **ArrayList** 的中间插入元素，并最好是转换为 **LinkedList** ？不，它只是意味着你应该意识到这个问题，如果你开始在某个 **ArrayList** 中间执行很多插入操作，并且程序开始变慢，那么你应该看看你的 **List** 实现有可能就是罪魁祸首（发现此类瓶颈的最佳方式是使用分析器 profiler）。优化是一个很棘手的问题，最好的策略就是置之不顾，直到发现必须要去担心它了（尽管去理解这些问题总是一个很好的主意）。\n\n`subList()` 方法可以轻松地从更大的列表中创建切片，当将切片结果传递给原来这个较大的列表的 `containsAll()` 方法时，很自然地会得到 **true**。请注意，顺序并不重要，在第 11、12 行输出中可以看到，在 **sub** 上调用直观命名的 `Collections.sort()` 和 `Collections.shuffle()` 方法，不会影响 `containsAll()` 的结果。 `subList()` 所产生的列表的幕后支持就是原始列表。因此，对所返回列表的更改都将会反映在原始列表中，反之亦然。\n\n`retainAll()` 方法实际上是一个“集合交集”操作，在本例中，它保留了同时在 **copy** 和 **sub** 中的所有元素。请再次注意，所产生的结果行为依赖于 `equals()` 方法。\n\n第 14 行输出展示了使用索引号来删除元素的结果，与通过对象引用来删除元素相比，它显得更加直观，因为在使用索引时，不必担心 `equals()` 的行为。\n\n`removeAll()` 方法也是基于 `equals()` 方法运行的。 顾名思义，它会从 **List** 中删除在参数 **List** 中的所有元素。\n\n`set()` 方法的命名显得很不合时宜，因为它与 **Set** 类存在潜在的冲突。在这里使用“replace”可能更适合，因为它的功能是用第二个参数替换索引处的元素（第一个参数）。\n\n第 17 行输出表明，对于 **List** ，有一个重载的 `addAll()` 方法可以将新列表插入到原始列表的中间位置，而不是仅能用 **Collection** 的 `addAll()` 方法将其追加到列表的末尾。\n\n第 18 - 20 行输出展示了 `isEmpty()` 和 `clear()` 方法的效果。\n\n第 22、23 行输出展示了如何使用 `toArray()` 方法将任意的 **Collection** 转换为数组。这是一个重载方法，其无参版本返回一个 **Object** 数组，但是如果将目标类型的数组传递给这个重载版本，那么它会生成一个指定类型的数组（假设它通过了类型检查）。如果参数数组太小而无法容纳 **List** 中的所有元素（就像本例一样），则 `toArray()` 会创建一个具有合适尺寸的新数组。 **Pet** 对象有一个 `id()` 方法，可以在所产生的数组中的对象上调用这个方法。\n\n## 迭代器Iterators\n\n在任何集合中，都必须有某种方式可以插入元素并再次获取它们。毕竟，保存事物是集合最基本的工作。对于 **List** ， `add()` 是插入元素的一种方式， `get()` 是获取元素的一种方式。\n\n如果从更高层次的角度考虑，会发现这里有个缺点：要使用集合，必须对集合的确切类型编程。这一开始可能看起来不是很糟糕，但是考虑下面的情况：如果原本是对 **List** 编码的，但是后来发现如果能够将相同的代码应用于 **Set** 会更方便，此时应该怎么做？或者假设想从一开始就编写一段通用代码，它不知道或不关心它正在使用什么类型的集合，因此它可以用于不同类型的集合，那么如何才能不重写代码就可以应用于不同类型的集合？\n\n迭代器（也是一种设计模式）的概念实现了这种抽象。迭代器是一个对象，它在一个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底层结构。另外，迭代器通常被称为轻量级对象（lightweight object）：创建它的代价小。因此，经常可以看到一些对迭代器有些奇怪的约束。例如，Java 的 **Iterator** 只能单向移动。这个 **Iterator** 只能用来：\n\n1. 使用 `iterator()` 方法要求集合返回一个 **Iterator**。 **Iterator** 将准备好返回序列中的第一个元素。\n2. 使用 `next()` 方法获得序列中的下一个元素。\n3. 使用 `hasNext()` 方法检查序列中是否还有元素。\n4. 使用 `remove()` 方法将迭代器最近返回的那个元素删除。\n\n为了观察它的工作方式，这里再次使用 **Pet** 工具：\n\n```java\n// collections/SimpleIteration.java\nimport typeinfo.pets.*;\nimport java.util.*;\n\npublic class SimpleIteration {\n  public static void main(String[] args) {\n    List<Pet> pets = Pets.list(12);\n    Iterator<Pet> it = pets.iterator();\n    while(it.hasNext()) {\n      Pet p = it.next();\n      System.out.print(p.id() + \":\" + p + \" \");\n    }\n    System.out.println();\n    // A simpler approach, when possible:\n    for(Pet p : pets)\n      System.out.print(p.id() + \":\" + p + \" \");\n    System.out.println();\n    // An Iterator can also remove elements:\n    it = pets.iterator();\n    for(int i = 0; i < 6; i++) {\n      it.next();\n      it.remove();\n    }\n    System.out.println(pets);\n  }\n}\n/* Output:\n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster\n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx 8:Cymric 9:Rat 10:EgyptianMau 11:Hamster\n[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]\n*/\n```\n\n有了 **Iterator** ，就不必再为集合中元素的数量操心了。这是由 `hasNext()` 和 `next()` 关心的事情。\n\n如果只是想向前遍历 **List** ，并不打算修改 **List** 对象本身，那么使用 for-in 语法更加简洁。\n\n**Iterator** 还可以删除由 `next()` 生成的最后一个元素，这意味着在调用 `remove()` 之前必须先调用 `next()` 。[^4]\n\n在集合中的每个对象上执行操作，这种思想十分强大，并且贯穿于本书。\n\n现在考虑创建一个 `display()` 方法，它不必知晓集合的确切类型：\n\n```java\n// collections/CrossCollectionIteration.java\nimport typeinfo.pets.*;\nimport java.util.*;\n\npublic class CrossCollectionIteration {\n  public static void display(Iterator<Pet> it) {\n    while(it.hasNext()) {\n      Pet p = it.next();\n      System.out.print(p.id() + \":\" + p + \" \");\n    }\n    System.out.println();\n  }\n  public static void main(String[] args) {\n    List<Pet> pets = Pets.list(8);\n    LinkedList<Pet> petsLL = new LinkedList<>(pets);\n    HashSet<Pet> petsHS = new HashSet<>(pets);\n    TreeSet<Pet> petsTS = new TreeSet<>(pets);\n    display(pets.iterator());\n    display(petsLL.iterator());\n    display(petsHS.iterator());\n    display(petsTS.iterator());\n  }\n}\n/* Output:\n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx\n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx\n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx\n5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug 0:Rat\n*/\n```\n\n`display()` 方法不包含任何有关它所遍历的序列的类型信息。这也展示了 **Iterator** 的真正威力：能够将遍历序列的操作与该序列的底层结构分离。出于这个原因，我们有时会说：迭代器统一了对集合的访问方式。\n\n我们可以使用 **Iterable** 接口生成上一个示例的更简洁版本，该接口描述了“可以产生 **Iterator** 的任何东西”：\n\n```java\n// collections/CrossCollectionIteration2.java\nimport typeinfo.pets.*;\nimport java.util.*;\n\npublic class CrossCollectionIteration2 {\n  public static void display(Iterable<Pet> ip) {\n    Iterator<Pet> it = ip.iterator();\n    while(it.hasNext()) {\n      Pet p = it.next();\n      System.out.print(p.id() + \":\" + p + \" \");\n    }\n    System.out.println();\n  }\n  public static void main(String[] args) {\n    List<Pet> pets = Pets.list(8);\n    LinkedList<Pet> petsLL = new LinkedList<>(pets);\n    HashSet<Pet> petsHS = new HashSet<>(pets);\n    TreeSet<Pet> petsTS = new TreeSet<>(pets);\n    display(pets);\n    display(petsLL);\n    display(petsHS);\n    display(petsTS);\n  }\n}\n/* Output:\n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx \n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx \n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx \n5:Cymric 2:Cymric 7:Manx 1:Manx 3:Mutt 6:Pug 4:Pug 0:Rat \n*/\n```\n\n这里所有的类都是 **Iterable** ，所以现在对 `display()` 的调用显然更简单。\n\n## ListIterator\n\n**ListIterator** 是一个更强大的 **Iterator** 子类型，它只能由各种 **List** 类生成。 **Iterator** 只能向前移动，而 **ListIterator** 可以双向移动。它可以生成迭代器在列表中指向位置的后一个和前一个元素的索引，并且可以使用 `set()` 方法替换它访问过的最近一个元素。可以通过调用 `listIterator()` 方法来生成指向 **List** 开头处的 **ListIterator** ，还可以通过调用 `listIterator(n)` 创建一个一开始就指向列表索引号为 **n** 的元素处的 **ListIterator** 。 下面的示例演示了所有这些能力：\n\n```java\n// collections/ListIteration.java\nimport typeinfo.pets.*;\nimport java.util.*;\n\npublic class ListIteration {\n  public static void main(String[] args) {\n    List<Pet> pets = Pets.list(8);\n    ListIterator<Pet> it = pets.listIterator();\n    while(it.hasNext())\n      System.out.print(it.next() +\n        \", \" + it.nextIndex() +\n        \", \" + it.previousIndex() + \"; \");\n    System.out.println();\n    // Backwards:\n    while(it.hasPrevious())\n      System.out.print(it.previous().id() + \" \");\n    System.out.println();\n    System.out.println(pets);\n    it = pets.listIterator(3);\n    while(it.hasNext()) {\n      it.next();\n      it.set(Pets.get());\n    }\n    System.out.println(pets);\n  }\n}\n/* Output:\nRat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug, 5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7; \n7 6 5 4 3 2 1 0 \n[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx]\n[Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster, EgyptianMau]\n*/\n```\n\n`Pets.get()` 方法用来从位置 3 开始替换 **List** 中的所有 Pet 对象。\n\n## 链表LinkedList\n\n**LinkedList** 也像 **ArrayList** 一样实现了基本的 **List** 接口，但它在 **List** 中间执行插入和删除操作时比 **ArrayList** 更高效。然而,它在随机访问操作效率方面却要逊色一些。\n\n**LinkedList 还添加了一些方法，使其可以被用作栈、队列或双端队列（deque）** 。在这些方法中，有些彼此之间可能只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用（特别是在 **Queue** 中）。例如：\n\n- `getFirst()` 和 `element()` 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 **List** 为空，则抛出 **NoSuchElementException** 异常。 `peek()` 方法与这两个方法只是稍有差异，它在列表为空时返回 **null** 。\n- `removeFirst()` 和 `remove()` 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 **NoSuchElementException** 异常。 `poll()` 稍有差异，它在列表为空时返回 **null** 。\n- `addFirst()` 在列表的开头插入一个元素。\n- `offer()` 与 `add()` 和 `addLast()` 相同。 它们都在列表的尾部（末尾）添加一个元素。\n- `removeLast()` 删除并返回列表的最后一个元素。\n\n下面的示例展示了这些功能之间基本的相似性和差异性。它并不是重复执行 **ListFeatures.java** 中所示的行为：\n\n```java\n// collections/LinkedListFeatures.java\nimport typeinfo.pets.*;\nimport java.util.*;\n\npublic class LinkedListFeatures {\n    public static void main(String[] args) {\n        LinkedList<Pet> pets = new LinkedList<>(Pets.list(5));\n        System.out.println(pets);\n        // Identical:\n        System.out.println(\"pets.getFirst(): \" + pets.getFirst());\n        System.out.println(\"pets.element(): \" + pets.element());\n        // Only differs in empty-list behavior:\n        System.out.println(\"pets.peek(): \" + pets.peek());\n        // Identical; remove and return the first element:\n        System.out.println(\"pets.remove(): \" + pets.remove());\n        System.out.println(\"pets.removeFirst(): \" + pets.removeFirst());\n        // Only differs in empty-list behavior:\n        System.out.println(\"pets.poll(): \" + pets.poll());\n        System.out.println(pets);\n        pets.addFirst(new Rat());\n        System.out.println(\"After addFirst(): \" + pets);\n        pets.offer(Pets.get());\n        System.out.println(\"After offer(): \" + pets);\n        pets.add(Pets.get());\n        System.out.println(\"After add(): \" + pets);\n        pets.addLast(new Hamster());\n        System.out.println(\"After addLast(): \" + pets);\n        System.out.println(\"pets.removeLast(): \" + pets.removeLast());\n    }\n}\n/* Output:\n[Rat, Manx, Cymric, Mutt, Pug]\npets.getFirst(): Rat\npets.element(): Rat\npets.peek(): Rat\npets.remove(): Rat\npets.removeFirst(): Manx\npets.poll(): Cymric\n[Mutt, Pug]\nAfter addFirst(): [Rat, Mutt, Pug]\nAfter offer(): [Rat, Mutt, Pug, Cymric]\nAfter add(): [Rat, Mutt, Pug, Cymric, Pug]\nAfter addLast(): [Rat, Mutt, Pug, Cymric, Pug, Hamster]\npets.removeLast(): Hamster\n*/\n```\n\n`Pets.list()` 的结果被传递给 **LinkedList** 的构造器，以便使用它来填充 **LinkedList** 。如果查看 **Queue** 接口就会发现，它在 **LinkedList** 的基础上添加了 `element()` ， `offer()` ， `peek()` ， `poll()` 和 `remove()` 方法，以使其可以成为一个 **Queue** 的实现。 \n\n## 堆栈Stack\n\n堆栈是“后进先出”（LIFO）集合。它有时被称为叠加栈（pushdown stack），因为最后“压入”（push）栈的元素，第一个被“弹出”（pop）栈。经常用来类比栈的事物是带有弹簧支架的自助餐厅托盘。最后装入的托盘总是最先拿出来使用的。\n\nJava 1.0 中附带了一个 **Stack** 类，结果设计得很糟糕（为了向后兼容，我们永远坚持 Java 中的旧设计错误）。Java 6 添加了 **ArrayDeque** ，其中包含直接实现堆栈功能的方法：\n\n```java\n// collections/StackTest.java\nimport java.util.*;\n\npublic class StackTest {\n    public static void main(String[] args) {\n        Deque<String> stack = new ArrayDeque<>();\n        for (String s : \"My dog has fleas\".split(\" \")) {\n            stack.push(s);\n        }\n        while (!stack.isEmpty()) {\n            System.out.print(stack.pop() + \" \");\n        }\n    }\n}\n/* Output:\nfleas has dog My\n*/\n```\n\n即使它是作为一个堆栈在使用，我们仍然必须将其声明为 **Deque** 。有时一个名为 **Stack** 的类更能把事情讲清楚：\n\n```java\n// onjava/Stack.java\n// A Stack class built with an ArrayDeque\npackage onjava;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\npublic class Stack<T> {\n  private Deque<T> storage = new ArrayDeque<>();\n  public void push(T v) { storage.push(v); }\n  public T peek() { return storage.peek(); }\n  public T pop() { return storage.pop(); }\n  public boolean isEmpty() { return storage.isEmpty(); }\n  @Override\n  public String toString() {\n    return storage.toString();\n  }\n}\n\n```\n\n这里引入了使用泛型的类定义的最简单的可能示例。类名称后面的 告诉编译器这是一个参数化类型，而其中的类型参数 **T** 会在使用类时被实际类型替换。基本上，这个类是在声明“我们在定义一个可以持有 **T** 类型对象的 **Stack** 。” **Stack** 是使用 **ArrayDeque** 实现的，而 **ArrayDeque** 也被告知它将持有 **T** 类型对象。注意， `push()` 接受类型为 **T** 的对象，而 `peek()` 和 `pop()` 返回类型为 **T** 的对象。 `peek()` 方法将返回栈顶元素，但并不将其从栈顶删除，而 `pop()` 删除并返回顶部元素。\n\n如果只需要栈的行为，那么使用继承是不合适的，因为这将产生一个具有 **ArrayDeque** 的其它所有方法的类（**Java 1.0** 设计者在创建 **java.util.Stack** 时，就犯了这个错误）。使用组合，可以选择要公开的方法以及如何命名它们。\n\n下面将使用 **StackTest.java** 中的相同代码来演示这个新的 **Stack** 类：\n\n```java\n// collections/StackTest2.java\nimport onjava.*;\n\npublic class StackTest2 {\n    public static void main(String[] args) {\n        Stack<String> stack = new Stack<>();\n        for (String s : \"My dog has fleas\".split(\" \")) {\n            stack.push(s);\n        }\n        while (!stack.isEmpty()) {\n            System.out.print(stack.pop() + \" \");\n        }\n    }\n}\n/* Output:\nfleas has dog My\n*/\n```\n\n如果想在自己的代码中使用这个 **Stack** 类，当在创建其实例时，就需要完整指定包名，或者更改这个类的名称；否则，就有可能会与 **java.util** 包中的 **Stack** 发生冲突。例如，如果我们在上面的例子中导入 **java.util.***，那么就必须使用包名来防止冲突：\n\n```java\n// collections/StackCollision.java\n\npublic class StackCollision {\n  public static void main(String[] args) {\n    onjava.Stack<String> stack = new onjava.Stack<>();\n    for(String s : \"My dog has fleas\".split(\" \"))\n      stack.push(s);\n    while(!stack.isEmpty())\n      System.out.print(stack.pop() + \" \");\n    System.out.println();\n    java.util.Stack<String> stack2 =\n      new java.util.Stack<>();\n    for(String s : \"My dog has fleas\".split(\" \"))\n      stack2.push(s);\n    while(!stack2.empty())\n      System.out.print(stack2.pop() + \" \");\n  }\n}\n/* Output:\nfleas has dog My\nfleas has dog My\n*/\n```\n\n尽管已经有了 **java.util.Stack** ，但是 **ArrayDeque** 可以产生更好的 **Stack** ，因此更可取。\n\n还可以使用显式导入来控制对“首选” **Stack** 实现的选择：\n\n```java\nimport onjava.Stack;\n```\n\n现在,任何对 **Stack** 的引用都将选择 **onjava** 版本，而在选择 **java.util.Stack** 时，必须使用全限定名称（full qualification）。\n\n## 集合Set\n\n**Set** 不保存重复的元素。 如果试图将相同对象的多个实例添加到 **Set** 中，那么它会阻止这种重复行为。 **Set** 最常见的用途是测试归属性，可以很轻松地询问某个对象是否在一个 **Set** 中。因此，查找通常是 **Set** 最重要的操作，因此通常会选择 **HashSet** 实现，该实现针对快速查找进行了优化。\n\n**Set** 具有与 **Collection** 相同的接口，因此没有任何额外的功能，不像前面两种不同类型的 **List** 那样。实际上， **Set** 就是一个 **Collection** ，只是行为不同。（这是继承和多态思想的典型应用：表现不同的行为。）**Set** 根据对象的“值”确定归属性。\n\n下面是使用存放 **Integer** 对象的 **HashSet** 的示例：\n\n```java\n// collections/SetOfInteger.java\nimport java.util.*;\n\npublic class SetOfInteger {\n    public static void main(String[] args) {\n        Random rand = new Random(47);\n        Set<Integer> intset = new HashSet<>();\n        for (int i = 0; i < 10000; i++) {\n            intset.add(rand.nextInt(30));\n        }\n        System.out.println(intset);\n    }\n}\n/* Output:\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]\n*/\n```\n\n在 0 到 29 之间的 10000 个随机整数被添加到 **Set** 中，因此可以想象每个值都重复了很多次。但是从结果中可以看到，每一个数只有一个实例出现在结果中。\n\n早期 Java 版本中的 **HashSet** 产生的输出没有可辨别的顺序。这是因为出于对速度的追求， **HashSet** 使用了散列。由 **HashSet** 维护的顺序与 **TreeSet** 或 **LinkedHashSet** 不同，因为它们的实现具有不同的元素存储方式。 **TreeSet** 将元素存储在红-黑树数据结构中，而 **HashSet** 使用散列函数。 **LinkedHashSet** 因为查询速度的原因也使用了散列，但是看起来使用了链表来维护元素的插入顺序。看起来散列算法好像已经改变了，现在 **Integer** 按顺序排序。但是，您不应该依赖此行为：\n\n```java\n// collections/SetOfString.java\nimport java.util.*;\n\npublic class SetOfString {\n  public static void main(String[] args) {\n    Set<String> colors = new HashSet<>();\n    for(int i = 0; i < 100; i++) {\n      colors.add(\"Yellow\");\n      colors.add(\"Blue\");\n      colors.add(\"Red\");\n      colors.add(\"Red\");\n      colors.add(\"Orange\");\n      colors.add(\"Yellow\");\n      colors.add(\"Blue\");\n      colors.add(\"Purple\");\n    }\n    System.out.println(colors);\n  }\n}\n/* Output:\n[Red, Yellow, Blue, Purple, Orange]\n*/\n```\n\n**String** 对象似乎没有排序。要对结果进行排序，一种方法是使用 **TreeSet** 而不是 **HashSet** ：\n\n```java\n// collections/SortedSetOfString.java\nimport java.util.*;\n\npublic class SortedSetOfString {\n    public static void main(String[] args) {\n        Set<String> colors = new TreeSet<>();\n        for (int i = 0; i < 100; i++) {\n            colors.add(\"Yellow\");\n            colors.add(\"Blue\");\n            colors.add(\"Red\");\n            colors.add(\"Red\");\n            colors.add(\"Orange\");\n            colors.add(\"Yellow\");\n            colors.add(\"Blue\");\n            colors.add(\"Purple\");\n        }\n        System.out.println(colors);\n    }\n}\n/* Output:\n[Blue, Orange, Purple, Red, Yellow]\n*/\n```\n\n最常见的操作之一是使用 `contains()` 测试成员归属性，但也有一些其它操作，这可能会让你想起在小学学过的维恩图：\n\n```java\n// collections/SetOperations.java\nimport java.util.*;\n\npublic class SetOperations {\n    public static void main(String[] args) {\n        Set<String> set1 = new HashSet<>();\n        Collections.addAll(set1, \"A B C D E F G H I J K L\".split(\" \"));\n        set1.add(\"M\");\n        System.out.println(\"H: \" + set1.contains(\"H\"));\n        System.out.println(\"N: \" + set1.contains(\"N\"));\n        Set<String> set2 = new HashSet<>();\n        Collections.addAll(set2, \"H I J K L\".split(\" \"));\n        System.out.println(\"set2 in set1: \" + set1.containsAll(set2));\n        set1.remove(\"H\");\n        System.out.println(\"set1: \" + set1);\n        System.out.println(\"set2 in set1: \" + set1.containsAll(set2));\n        set1.removeAll(set2);\n        System.out.println(\"set2 removed from set1: \" + set1);\n        Collections.addAll(set1, \"X Y Z\".split(\" \"));\n        System.out.println(\"\'X Y Z\' added to set1: \" + set1);\n    }\n}\n/* Output:\nH: true\nN: false\nset2 in set1: true\nset1: [A, B, C, D, E, F, G, I, J, K, L, M]\nset2 in set1: false\nset2 removed from set1: [A, B, C, D, E, F, G, M]\n\'X Y Z\' added to set1: [A, B, C, D, E, F, G, M, X, Y, Z]\n*/\n```\n\n这些方法名都是自解释的，JDK 文档中还有一些其它的方法。\n\n能够产生每个元素都唯一的列表是相当有用的功能。例如，假设想要列出上面的 **SetOperations.java** 文件中的所有单词，通过使用本书后面介绍的 `java.nio.file.Files.readAllLines()` 方法，可以打开一个文件，并将其作为一个 **List\\<String\\>** 读取，每个 **String** 都是输入文件中的一行：\n\n```java\n// collections/UniqueWords.java\nimport java.util.*;\nimport java.nio.file.*;\n\npublic class UniqueWords {\n    public static void main(String[] args) throws Exception {\n        List<String> lines = Files.readAllLines(Paths.get(\"SetOperations.java\"));\n        Set<String> words = new TreeSet<>();\n        for (String line : lines) {\n            for (String word : line.split(\"\\\\W+\")) {\n                if (word.trim().length() > 0) {\n                    words.add(word);\n                }\n            }\n        }\n        System.out.println(words);\n    }\n}\n/* Output:\n[A, B, C, Collections, D, E, F, G, H, HashSet, I, J, K,\nL, M, N, Output, Set, SetOperations, String, System, X,\nY, Z, add, addAll, added, args, class, collections,\ncontains, containsAll, false, from, import, in, java,\nmain, new, out, println, public, remove, removeAll,\nremoved, set1, set2, split, static, to, true, util,\nvoid]\n*/\n```\n\n我们逐步浏览文件中的每一行，并使用 `String.split()` 将其分解为单词，这里使用正则表达式 **\\\\\\\\ W +** ，这意味着它会依据一个或多个（即 **+** ）非单词字母来拆分字符串。每个结果单词都会添加到 **Set words** 中。因为它是 **TreeSet** ，所以对结果进行排序。这里，排序是按字典顺序（lexicographically）完成的，因此大写和小写字母位于不同的组中。如果想按字母顺序（alphabetically）对其进行排序，可以向 **TreeSet** 构造器传入 **String.CASE_INSENSITIVE_ORDER** 比较器（比较器是一个建立排序顺序的对象）：\n\n```java\n// collections/UniqueWordsAlphabetic.java\n// Producing an alphabetic listing\nimport java.util.*;\nimport java.nio.file.*;\n\npublic class UniqueWordsAlphabetic {\n    public static void main(String[] args) throws Exception {\n        List<String> lines = Files.readAllLines(Paths.get(\"SetOperations.java\"));\n        Set<String> words = new TreeSet<>(String.CASE_INSENSITIVE_ORDER);\n        for (String line : lines) {\n            for (String word : line.split(\"\\\\W+\")) {\n                if (word.trim().length() > 0) {\n                    words.add(word);\n                }\n            }\n        }\n        System.out.println(words);\n    }\n}\n/* Output:\n[A, add, addAll, added, args, B, C, class, collections,\ncontains, containsAll, D, E, F, false, from, G, H,\nHashSet, I, import, in, J, java, K, L, M, main, N, new,\nout, Output, println, public, remove, removeAll,\nremoved, Set, set1, set2, SetOperations, split, static,\nString, System, to, true, util, void, X, Y, Z]\n*/\n```\n\n## 映射Map\n\n将对象映射到其他对象的能力是解决编程问题的有效方法。例如，考虑一个程序，它被用来检查 Java 的 **Random** 类的随机性。理想情况下， **Random** 会产生完美的数字分布，但为了测试这一点，则需要生成大量的随机数，并计算落在各种范围内的数字个数。 **Map** 可以很容易地解决这个问题。在本例中，键是 **Random** 生成的数字，而值是该数字出现的次数：\n\n```java\n// collections/Statistics.java\n// Simple demonstration of HashMap\nimport java.util.*;\n\npublic class Statistics {\n  public static void main(String[] args) {\n    Random rand = new Random(47);\n    Map<Integer, Integer> m = new HashMap<>();\n    for(int i = 0; i < 10000; i++) {\n      // Produce a number between 0 and 20:\n      int r = rand.nextInt(20);\n      Integer freq = m.get(r); // [1]\n      m.put(r, freq == null ? 1 : freq + 1);\n    }\n    System.out.println(m);\n  }\n}\n/* Output:\n{0=481, 1=502, 2=489, 3=508, 4=481, 5=503, 6=519,\n7=471, 8=468, 9=549, 10=513, 11=531, 12=521, 13=506,\n14=477, 15=497, 16=533, 17=509, 18=478, 19=464}\n*/\n```\n\n**[1]**自动包装机制将随机生成的 **int** 转换为可以与 **HashMap** 一起使用的 **Integer** 引用（不能使用基本类型的集合）。如果键不在集合中，则 `get()` 返回 **null** （这意味着该数字第一次出现）。否则， `get()` 会为键生成与之关联的 **Integer** 值，然后该值被递增（自动包装机制再次简化了表达式，但实际上确实发生了对 **Integer** 的装箱和拆箱）。\n\n接下来的示例将使用一个 **String** 描述来查找 **Pet** 对象。它还展示了通过使用 `containsKey()` 和 `containsValue()` 方法去测试一个 **Map** ，以查看它是否包含某个键或某个值：\n\n```java\n// collections/PetMap.java\nimport typeinfo.pets.*;\nimport java.util.*;\n\npublic class PetMap {\n  public static void main(String[] args) {\n    Map<String, Pet> petMap = new HashMap<>();\n    petMap.put(\"My Cat\", new Cat(\"Molly\"));\n    petMap.put(\"My Dog\", new Dog(\"Ginger\"));\n    petMap.put(\"My Hamster\", new Hamster(\"Bosco\"));\n    System.out.println(petMap);\n    Pet dog = petMap.get(\"My Dog\");\n    System.out.println(dog);\n    System.out.println(petMap.containsKey(\"My Dog\"));\n    System.out.println(petMap.containsValue(dog));\n  }\n}\n/* Output:\n{My Dog=Dog Ginger, My Cat=Cat Molly, My Hamster=Hamster Bosco}\nDog Ginger\ntrue\ntrue\n*/\n```\n\n**Map** 与数组和其他的 **Collection** 一样，可以轻松地扩展到多个维度，只需要创建一个值为 **Map** 的 **Map**（这些 **Map** 的值可以是其他集合，甚至是其他 **Map**）。因此，能够很容易地将集合组合起来以快速生成强大的数据结构。例如，假设你正在追踪有多个宠物的人，只需要一个 **Map\\<Person, List\\<Pet\\>\\>** 即可：\n\n```java\n// collections/MapOfList.java\n// {java collections.MapOfList}\npackage collections;\nimport typeinfo.pets.*;\nimport java.util.*;\n\npublic class MapOfList {\n    public static final Map<Person, List<? extends Pet>> petPeople = new HashMap<>();\n\n    static {\n        petPeople.put(new Person(\"Dawn\"),\n                Arrays.asList(\n                        new Cymric(\"Molly\"),\n                        new Mutt(\"Spot\")));\n        petPeople.put(new Person(\"Kate\"),\n                Arrays.asList(\n                        new Cat(\"Shackleton\"),\n                        new Cat(\"Elsie May\"),\n                        new Dog(\"Margrett\")));\n        petPeople.put(new Person(\"Marilyn\"),\n                Arrays.asList(\n                        new Pug(\"Louie aka Louis Snorkelstein Dupree\"),\n                        new Cat(\"Stanford\"),\n                        new Cat(\"Pinkola\")));\n        petPeople.put(new Person(\"Luke\"),\n                Arrays.asList(\n                        new Rat(\"Fuzzy\"),\n                        new Rat(\"Fizzy\")));\n        petPeople.put(new Person(\"Isaac\"),\n                Arrays.asList(new Rat(\"Freckly\")));\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"People: \" + petPeople.keySet());\n        System.out.println(\"Pets: \" + petPeople.values());\n        for (Person person : petPeople.keySet()) {\n            System.out.println(person + \" has:\");\n            for (Pet pet : petPeople.get(person)) {\n                System.out.println(\"    \" + pet);\n            }\n        }\n    }\n}\n/* Output:\nPeople: [Person Dawn, Person Kate, Person Isaac, Person Marilyn, Person Luke]\nPets: [[Cymric Molly, Mutt Spot], [Cat Shackleton, Cat Elsie May, Dog Margrett], [Rat Freckly], [Pug Louie aka Louis Snorkelstein Dupree, Cat Stanford, Cat Pinkola],[Rat Fuzzy, Rat Fizzy]]\nPerson Dawn has:\n    Cymric Molly\n    Mutt Spot\nPerson Kate has:\n    Cat Shackleton\n    Cat Elsie May\n    Dog Margrett\nPerson Isaac has:\n    Rat Freckly\nPerson Marilyn has:\n    Pug Louie aka Louis Snorkelstein Dupree\n    Cat Stanford\n    Cat Pinkola\nPerson Luke has:\n    Rat Fuzzy\n    Rat Fizzy\n*/\n```\n\n**Map** 可以返回由其键组成的 **Set** ，由其值组成的 **Collection** ，或者其键值对的 **Set** 。 `keySet()` 方法生成由在 **petPeople** 中的所有键组成的 **Set** ，它在 for-in 语句中被用来遍历该 **Map** 。\n\n## 队列Queue\n\n队列是一个典型的“先进先出”（FIFO）集合。 即从集合的一端放入事物，再从另一端去获取它们，事物放入集合的顺序和被取出的顺序是相同的。队列通常被当做一种可靠的将对象从程序的某个区域传输到另一个区域的途径。队列在并发编程中尤为重要，因为它们可以安全地将对象从一个任务传输到另一个任务。\n\n**LinkedList** 实现了 **Queue** 接口，并且提供了一些方法以支持队列行为，因此 **LinkedList** 可以用作 **Queue** 的一种实现。 通过将 **LinkedList** 向上转换为 **Queue** ，下面的示例使用了在 **Queue** 接口中与 **Queue** 相关(Queue-specific)的方法：\n\n```java\n// collections/QueueDemo.java\n// Upcasting to a Queue from a LinkedList\nimport java.util.*;\n\npublic class QueueDemo {\n    public static void printQ(Queue queue) {\n        while (queue.peek() != null) {\n            System.out.print(queue.remove() + \" \");\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        Queue<Integer> queue = new LinkedList<>();\n        Random rand = new Random(47);\n        for (int i = 0; i < 10; i++) {\n            queue.offer(rand.nextInt(i + 10));\n        }\n        printQ(queue);\n        Queue<Character> qc = new LinkedList<>();\n        for (char c : \"Brontosaurus\".toCharArray()) {\n            qc.offer(c);\n        }\n        printQ(qc);\n    }\n}\n/* Output:\n8 1 1 1 5 14 3 1 0 1\nB r o n t o s a u r u s\n*/\n```\n\n`offer()` 是与 **Queue** 相关的方法之一，它在允许的情况下，在队列的尾部插入一个元素，或者返回 **false** 。 `peek()` 和 `element()` 都返回队头元素而不删除它，但是如果队列为空，则 `element()` 抛出 **NoSuchElementException** ，而 `peek()` 返回 **null** 。 `poll()` 和 `remove()` 都删除并返回队头元素，但如果队列为空，`poll()` 返回 **null** ，而 `remove()` 抛出 **NoSuchElementException** 。\n\n自动包装机制会自动将 `nextInt()` 的 **int** 结果转换为 **queue** 所需的 **Integer** 对象，并将 **char c** 转换为 **qc** 所需的 **Character** 对象。 **Queue** 接口窄化了对 **LinkedList** 方法的访问权限，因此只有适当的方法才能使用，因此能够访问到的 **LinkedList** 的方法会变少（这里实际上可以将 **Queue** 强制转换回 **LinkedList** ，但至少我们不鼓励这样做）。\n\nTODO 不了解自动包装机制。2020年10月13日\n\n与 **Queue** 相关的方法提供了完整而独立的功能。 也就是说，对于 **Queue** 所继承的 **Collection** ，在不需要使用它的任何方法的情况下，就可以拥有一个可用的 **Queue** 。\n\n## 优先级队列PriorityQueue\n\n先进先出（FIFO）描述了最典型的队列规则（queuing discipline）。队列规则是指在给定队列中的一组元素的情况下，确定下一个弹出队列的元素的规则。先进先出声明的是下一个弹出的元素应该是等待时间最长的元素。\n\n优先级队列声明下一个弹出的元素是最需要的元素（具有最高的优先级）。例如，在机场，当飞机临近起飞时，这架飞机的乘客可以在办理登机手续时排到队头。如果构建了一个消息传递系统，某些消息比其他消息更重要，应该尽快处理，而不管它们何时到达。在Java 5 中添加了 **PriorityQueue** ，以便自动实现这种行为。\n\n当在 **PriorityQueue** 上调用 `offer()` 方法来插入一个对象时，该对象会在队列中被排序。默认的排序使用队列中对象的自然顺序（natural order），但是可以通过提供自己的 **Comparator** 来修改这个顺序。 **PriorityQueue** 确保在调用 `peek()` ， `poll()` 或 `remove()` 方法时，获得的元素将是队列中优先级最高的元素。\n\n让 **PriorityQueue** 与 **Integer** ， **String** 和 **Character** 这样的内置类型一起工作易如反掌。在下面的示例中，第一组值与前一个示例中的随机值相同，可以看到它们从 **PriorityQueue** 中弹出的顺序与前一个示例不同：\n\n```java\n// collections/PriorityQueueDemo.java\nimport java.util.*;\n\npublic class PriorityQueueDemo {\n    public static void main(String[] args) {\n        PriorityQueue<Integer> priorityQueue = new PriorityQueue<>();\n        Random rand = new Random(47);\n        for (int i = 0; i < 10; i++) {\n            priorityQueue.offer(rand.nextInt(i + 10));\n        }\n        QueueDemo.printQ(priorityQueue);\n\n        List<Integer> ints = Arrays.asList(25, 22, 20, 18, 14, 9, 3, 1, 1, 2, 3, 9, 14, 18, 21, 23, 25);\n        priorityQueue = new PriorityQueue<>(ints);\n        QueueDemo.printQ(priorityQueue);\n        priorityQueue = new PriorityQueue<>(ints.size(), Collections.reverseOrder());\n        priorityQueue.addAll(ints);\n        QueueDemo.printQ(priorityQueue);\n\n        String fact = \"EDUCATION SHOULD ESCHEW OBFUSCATION\";\n        List<String> strings = Arrays.asList(fact.split(\"\"));\n        PriorityQueue<String> stringPQ = new PriorityQueue<>(strings);\n        QueueDemo.printQ(stringPQ);\n        stringPQ = new PriorityQueue<>(strings.size(), Collections.reverseOrder());\n        stringPQ.addAll(strings);\n        QueueDemo.printQ(stringPQ);\n\n        Set<Character> charSet = new HashSet<>();\n        for (char c : fact.toCharArray()) {\n            charSet.add(c); // Autoboxing\n        }\n        PriorityQueue<Character> characterPQ = new PriorityQueue<>(charSet);\n        QueueDemo.printQ(characterPQ);\n    }\n}\n/* Output:\n0 1 1 1 1 1 3 5 8 14 \n1 1 2 3 3 9 9 14 14 18 18 20 21 22 23 25 25 \n25 25 23 22 21 20 18 18 14 14 9 9 3 3 2 1 1 \n      A A B C C C D D E E E F H H I I L N N O O O O S S S T T U U U W \nW U U U T T S S S O O O O N N L I I H H F E E E D D C C C B A A       \n  A B C D E F H I L N O S T U W \n*/\n```\n\n**PriorityQueue** 是允许重复的，最小的值具有最高的优先级（如果是 **String** ，空格也可以算作值，并且比字母的优先级高）。为了展示如何通过提供自己的 **Comparator** 对象来改变顺序，第三个对 **PriorityQueue\\<Integer\\>** 构造器的调用，和第二个对 **PriorityQueue\\<String\\>** 的调用使用了由 `Collections.reverseOrder()` （Java 5 中新添加的）产生的反序的 **Comparator** 。\n\n最后一部分添加了一个 **HashSet** 来消除重复的 **Character**。\n\n**Integer** ， **String** 和 **Character** 可以与 **PriorityQueue** 一起使用，因为这些类已经内置了自然排序。如果想在 **PriorityQueue** 中使用自己的类，则必须包含额外的功能以产生自然排序，或者必须提供自己的 **Comparator** 。\n\n## 集合与迭代器\n\nTODO 本节有许多问题不理解，需要巩固。2020年10月13日\n\n**Collection** 是所有序列集合共有的根接口。它可能会被认为是一种“附属接口”（incidental interface），即因为要表示其他若干个接口的共性而出现的接口。此外，**java.util.AbstractCollection** 类提供了 **Collection** 的默认实现，使得你可以创建 **AbstractCollection** 的子类型，而其中没有不必要的代码重复。\n\n使用接口描述的一个理由是它可以使我们创建更通用的代码。通过针对接口而非具体实现来编写代码，我们的代码可以应用于更多类型的对象。因此，如果所编写的方法接受一个 **Collection** ，那么该方法可以应用于任何实现了 **Collection** 的类——这也就使得一个新类可以选择去实现 **Collection** 接口，以便该方法可以使用它。标准 C++ 类库中的集合并没有共同的基类——集合之间的所有共性都是通过迭代器实现的。在 Java 中，遵循 C++ 的方式看起来似乎很明智，即用迭代器而不是 **Collection** 来表示集合之间的共性。但是，这两种方法绑定在了一起，因为实现 **Collection** 就意味着需要提供 `iterator()` 方法：\n\n```java\n// collections/InterfaceVsIterator.java\nimport typeinfo.pets.*;\nimport java.util.*;\n\npublic class InterfaceVsIterator {\n    public static void display(Iterator<Pet> it) {\n        while (it.hasNext()) {\n            Pet p = it.next();\n            System.out.print(p.id() + \":\" + p + \" \");\n        }\n        System.out.println();\n    }\n\n    public static void display(Collection<Pet> pets) {\n        for (Pet p : pets) {\n            System.out.print(p.id() + \":\" + p + \" \");\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        List<Pet> petList = Pets.list(8);\n        Set<Pet> petSet = new HashSet<>(petList);\n        Map<String, Pet> petMap = new LinkedHashMap<>();\n        String[] names = (\"Ralph, Eric, Robin, Lacey, \" + \"Britney, Sam, Spot, Fluffy\").split(\", \");\n        for (int i = 0; i < names.length; i++) {\n            petMap.put(names[i], petList.get(i));\n        }\n        display(petList);\n        display(petSet);\n        display(petList.iterator());\n        display(petSet.iterator());\n        System.out.println(petMap);\n        System.out.println(petMap.keySet());\n        display(petMap.values());\n        display(petMap.values().iterator());\n    }\n}\n/* Output:\n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx \n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx \n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx \n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx \n{Ralph=Rat, Eric=Manx, Robin=Cymric, Lacey=Mutt, Britney=Pug, Sam=Cymric, Spot=Pug, Fluffy=Manx}\n[Ralph, Eric, Robin, Lacey, Britney, Sam, Spot, Fluffy]\n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx \n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx \n*/\n```\n\n两个版本的 `display()` 方法都可以使用 **Map** 或 **Collection** 的子类型来工作。 而且**Collection** 接口和 **Iterator** 都将 `display()` 方法与低层集合的特定实现解耦。\n\n在本例中，这两种方式都可以奏效。事实上， **Collection** 要更方便一点，因为它是 **Iterable** 类型，因此在 `display(Collection)` 的实现中可以使用 for-in 构造，这使得代码更加清晰。\n\n当需要实现一个不是 **Collection** 的外部类时，由于让它去实现 **Collection** 接口可能非常困难或麻烦，因此使用 **Iterator** 就会变得非常吸引人。例如，如果我们通过继承一个持有 **Pet** 对象的类来创建一个 **Collection** 的实现，那么我们必须实现 **Collection** 所有的方法，即使我们不在 `display()` 方法中使用它们，也必须这样做。虽然这可以通过继承 **AbstractCollection** 而很容易地实现，但是无论如何还是要被强制去实现 `iterator()` 和 `size()` 方法，这些方法 **AbstractCollection** 没有实现，但是 **AbstractCollection** 中的其它方法会用到：\n\n```java\n// collections/CollectionSequence.java\nimport typeinfo.pets.*;\nimport java.util.*;\n\npublic class CollectionSequence extends AbstractCollection<Pet> {\n    private Pet[] pets = Pets.array(8);\n\n    @Override\n    public int size() {\n        return pets.length;\n    }\n\n    @Override\n    public Iterator<Pet> iterator() {\n        return new Iterator<Pet>() { // [1]\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < pets.length;\n            }\n\n            @Override\n            public Pet next() {\n                return pets[index++];\n            }\n\n            @Override\n            public void remove() { // Not implemented\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    public static void main(String[] args) {\n        CollectionSequence c = new CollectionSequence();\n        InterfaceVsIterator.display(c);\n        InterfaceVsIterator.display(c.iterator());\n    }\n}\n/* Output:\n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx \n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx \n*/\n```\n\n`remove()` 方法是一个“可选操作”。 这里可以不必实现它，如果你调用它，它将抛出异常。\n\n**[1]** 你可能会认为，因为 `iterator()` 返回 **Iterator\\<Pet\\>** ，匿名内部类定义可以使用菱形语法，Java可以推断出类型。但这不起作用，类型推断仍然非常有限。\n\n这个例子表明，如果实现了 **Collection** ，就必须实现 `iterator()` ，并且只拿实现 `iterator()` 与继承 **AbstractCollection** 相比，花费的代价只有略微减少。但是，如果类已经继承了其他的类，那么就不能再继承 **AbstractCollection** 了。在这种情况下，要实现 **Collection** ，就必须实现该接口中的所有方法。此时，继承并提供创建迭代器的能力要容易得多：\n\n```java\n// collections/NonCollectionSequence.java\nimport typeinfo.pets.*;\nimport java.util.*;\n\nclass PetSequence {\n  protected Pet[] pets = Pets.array(8);\n}\n\npublic class NonCollectionSequence extends PetSequence {\n  public Iterator<Pet> iterator() {\n    return new Iterator<Pet>() {\n      private int index = 0;\n      @Override\n      public boolean hasNext() {\n        return index < pets.length;\n      }\n      @Override\n      public Pet next() { return pets[index++]; }\n      @Override\n      public void remove() { // Not implemented\n        throw new UnsupportedOperationException();\n      }\n    };\n  }\n  public static void main(String[] args) {\n    NonCollectionSequence nc =\n      new NonCollectionSequence();\n    InterfaceVsIterator.display(nc.iterator());\n  }\n}\n/* Output:\n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug\n7:Manx\n*/\n```\n\n生成 **Iterator** 是将序列与消费该序列的方法连接在一起耦合度最小的方式，并且与实现 **Collection** 相比，它在序列类上所施加的约束也少得多。\n\n## for-in和迭代器\n\n到目前为止，for-in 语法主要用于数组，但它也适用于任何 **Collection** 对象。实际上在使用 **ArrayList** 时，已经看到了一些使用它的示例，下面是一个更通用的证明：\n\n```java\n// collections/ForInCollections.java\n// All collections work with for-in\nimport java.util.*;\n\npublic class ForInCollections {\n    public static void main(String[] args) {\n        Collection<String> cs = new LinkedList<>();\n        Collections.addAll(cs, \"Take the long way home\".split(\" \"));\n        for (String s : cs) {\n            System.out.print(\"\'\" + s + \"\' \");\n        }\n    }\n}\n/* Output:\n\'Take\' \'the\' \'long\' \'way\' \'home\'\n*/\n```\n\n由于 **cs** 是一个 **Collection** ，因此该代码展示了使用 for-in 是所有 **Collection** 对象的特征。\n\n这样做的原因是 Java 5 引入了一个名为 **Iterable** 的接口，该接口包含一个能够生成 **Iterator** 的 `iterator()` 方法。for-in 使用此 **Iterable** 接口来遍历序列。因此，如果创建了任何实现了 **Iterable** 的类，都可以将它用于 for-in 语句中：\n\n```java\n// collections/IterableClass.java\n// Anything Iterable works with for-in\nimport java.util.*;\n\npublic class IterableClass implements Iterable<String> {\n    protected String[] words = (\"And that is how \" +\n            \"we know the Earth to be banana-shaped.\"\n    ).split(\" \");\n\n    @Override\n    public Iterator<String> iterator() {\n        return new Iterator<String>() {\n            private int index = 0;\n\n            @Override\n            public boolean hasNext() {\n                return index < words.length;\n            }\n\n            @Override\n            public String next() {\n                return words[index++];\n            }\n\n            @Override\n            public void remove() { // Not implemented\n                throw new UnsupportedOperationException();\n            }\n        };\n    }\n\n    public static void main(String[] args) {\n        for (String s : new IterableClass()) {\n            System.out.print(s + \" \");\n        }\n    }\n}\n/* Output:\nAnd that is how we know the Earth to be banana-shaped.\n*/\n```\n\n`iterator()` 返回的是实现了 **Iterator\\<String\\>** 的匿名内部类的实例，该匿名内部类可以遍历数组中的每个单词。在主方法中，可以看到 **IterableClass** 确实可以用于 for-in 语句。\n\n在 Java 5 中，许多类都是 **Iterable** ，主要包括所有的 **Collection** 类（但不包括各种 **Maps** ）。 例如，下面的代码可以显示所有的操作系统环境变量：\n\n```java\n// collections/EnvironmentVariables.java\n// {VisuallyInspectOutput}\nimport java.util.*;\n\npublic class EnvironmentVariables {\n  public static void main(String[] args) {\n    for(Map.Entry entry: System.getenv().entrySet()) {\n      System.out.println(entry.getKey() + \": \" +\n        entry.getValue());\n    }\n  }\n}\n```\n\nTODO 未学完。2020年10月13日\n\n\n\n## 小结\n\nJava 提供了许多保存对象的方法：\n\n1. 数组将数字索引与对象相关联。它保存类型明确的对象，因此在查找对象时不必对结果做类型转换。它可以是多维的，可以保存基本类型的数据。虽然可以在运行时创建数组，但是一旦创建数组，就无法更改数组的大小。\n2. **Collection** 保存单一的元素，而 **Map** 包含相关联的键值对。使用 Java 泛型，可以指定集合中保存的对象的类型，因此不能将错误类型的对象放入集合中，并且在从集合中获取元素时，不必进行类型转换。各种 **Collection** 和各种 **Map** 都可以在你向其中添加更多的元素时，自动调整其尺寸大小。集合不能保存基本类型，但自动装箱机制会负责执行基本类型和集合中保存的包装类型之间的双向转换。\n3. 像数组一样， **List** 也将数字索引与对象相关联，因此，数组和 **List** 都是有序集合。\n4. 如果要执行大量的随机访问，则使用 **ArrayList** ，如果要经常从表中间插入或删除元素，则应该使用 **LinkedList** 。\n5. 队列和堆栈的行为是通过 **LinkedList** 提供的。\n6. **Map** 是一种将对象（而非数字）与对象相关联的设计。 **HashMap** 专为快速访问而设计，而 **TreeMap** 保持键始终处于排序状态，所以没有 **HashMap** 快。 **LinkedHashMap** 按插入顺序保存其元素，但使用散列提供快速访问的能力。\n7. **Set** 不接受重复元素。 **HashSet** 提供最快的查询速度，而 **TreeSet** 保持元素处于排序状态。 **LinkedHashSet** 按插入顺序保存其元素，但使用散列提供快速访问的能力。\n8. 不要在新代码中使用遗留类 **Vector** ，**Hashtable** 和 **Stack** 。\n\nJava 集合框架简图，黄色为接口，绿色为抽象类，蓝色为具体类。虚线箭头表示实现关系，实线箭头表示继承关系。\n\n![collection](E:\\OneDrive - lanqilu\\我的图片库\\blogimg\\Java持有对象\\collection.png)![map](E:\\OneDrive - lanqilu\\我的图片库\\blogimg\\Java持有对象\\map.png)\n\n### 简单集合分类\n\n可以看到，实际上只有四个基本的集合组件： **Map** ， **List** ， **Set** 和 **Queue** ，它们各有两到三个实现版本（**Queue** 的 **java.util.concurrent** 实现未包含在此图中）。最常使用的集合用黑色粗线线框表示。\n\n虚线框表示接口，实线框表示普通的（具体的）类。带有空心箭头的虚线表示特定的类实现了一个接口。实心箭头表示某个类可以生成箭头指向的类的对象。例如，任何 **Collection** 都可以生成 **Iterator** ， **List** 可以生成 **ListIterator** （也能生成普通的 **Iterator** ，因为 **List** 继承自 **Collection** ）。\n\n下面的示例展示了各种不同的类在方法上的差异。程序的输出还展示了在每个类或接口中所实现的接口：\n\n```java\n// collections/CollectionDifferences.java\nimport onjava.*;\n\npublic class CollectionDifferences {\n  public static void main(String[] args) {\n    CollectionMethodDifferences.main(args);\n  }\n}\n```\n\n除 **TreeSet** 之外的所有 **Set** 都具有与 **Collection** 完全相同的接口。**List** 和 **Collection** 存在着明显的不同，尽管 **List** 所要求的方法都在 **Collection** 中。另一方面，在 **Queue** 接口中的方法是独立的，在创建具有 **Queue** 功能的实现时，不需要使用 **Collection** 方法。最后， **Map** 和 **Collection** 之间唯一的交集是 **Map** 可以使用 `entrySet()` 和 `values()` 方法来产生 **Collection** 。\n\n请注意，标记接口 **java.util.RandomAccess** 附加到了 **ArrayList** 上，但不附加到 **LinkedList** 上。这为根据特定 **List** 动态改变其行为的算法提供了信息。\n\n从面向对象的继承层次结构来看，这种组织结构确实有些奇怪。但是，当了解了 **java.util** 中更多的有关集合的内容后，就会发现除了继承结构有点奇怪外，还有更多的问题。集合类库一直以来都是设计难题——解决这些问题涉及到要去满足经常彼此之间互为牵制的各方面需求。所以要做好准备，在各处做出妥协。\n\n尽管存在这些问题，但 Java 集合仍是在日常工作中使用的基本工具，它可以使程序更简洁、更强大、更有效。你可能需要一段时间才能熟悉集合类库的某些方面，但我想你很快就会找到自己的路子，来获得和使用这个类库中的类。', '2021-10-14 11:22:23', 1, 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/macos.6z1mshl4twk0.svg', 0, '2021-10-14 11:22:23', NULL, NULL, NULL, 1, 1, 0, NULL, 0, '<p>了解有关 Java 集合类库的基本知识，以及对典型用法的重点介绍</p>\n<p>参考资料:</p>\n<ul>\n<li>《On Java 8》</li>\n<li><a href=\"https://www.pdai.tech/md/java/collection/java-collection-all.html\">Java 集合框架</a></li>\n</ul>\n<hr>\n<p>如果一个程序只包含固定数量的且其生命期都是已知的对象，那么这是一个非常简单程序。</p>\n<p>通常，程序总是根据运行时才知道的某些条件去创建新对象。在此之前，不会知道所需对象的数量，甚至不知道确切的类型。为解决这个普遍的编程问题，需要在任意时刻和任意位创建任意数量的对象。所以，就不能依靠创建命名的引用来持有每一个对象：</p>\n<pre><code class=\"hljs language-java\">MyType aReference<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>因为你不知道实际上会需要多少这样的引用。</p>\n<p>大多数语言都提供某种方法来解决这个基本问题。Java 有多种方式进行对象的引用。例如前面曾经学习过的数组，它是编译器支持的类型。数组是保存一组对象的最有效的方式，如果你想保存一组基本类型数据，也推荐使用这种方式。但是数组具有固定的尺寸而在更一般的情况中，你在写程序时并不知道将需要多少个对象，或者是否需要更复杂的方式来存储对象，因此数组尺寸固定这一限制显得过于受限了。</p>\n<p>Java 实用类库还提供了一套相当完整的容器类来解决这个问题，其中基本的类型是 List、Set、 Queue 和 Map。这些对象类型也称为集合类，集合提供了完善的方法来保存对象，你可以使用这些工具来解决数量惊人的问题。</p>\n<p>集合还有其他一些特性。例如，Set 对于每个值都只保存一个对象，Map 是允许你将某些对象与其他一些对象关联起来的关联数组，Java 集合类都可以自动地调整自己的尺寸。因此，与数组不同，在编程时，你可以将任意数量的对象放置到集合中，并且不需要担心集合应该设置为多大。</p>\n<p>即使在 Java 中没有直接的关键字支持，集合类仍旧是可以显著增强你的编程能力的基本工具。</p>\n<h2 id=\"java-容器\">Java 容器</h2>\n<p>容器，就是可以容纳其他 Java 对象的对象。Java Collections Framework (JCF) 为 Java 开发者提供了通用的容器，其始于 JDK 1.2，优点是：</p>\n<ul>\n<li>降低编程难度</li>\n<li>提高程序性能</li>\n<li>提高 API 间的互操作性</li>\n<li>降低学习难度</li>\n<li>降低设计和实现相关 API 的难度</li>\n<li>增加程序的重用性</li>\n</ul>\n<p>Java 容器里只能放对象，对于基本类型（int、long、float、double等），需要将其包装成对应的对象类型后（Integer、Long、Float、Double等）才能放到容器里。很多时候拆包装和解包装能够自动完成。这虽然会导致额外的性能和空间开销，但简化了设计和编程。</p>\n<p>容器主要包括 Collection 和 Map 两种</p>\n<ul>\n<li>Collection 存储着对象的集合，</li>\n<li>Map 存储着键值对（两个对象）的映射表。</li>\n</ul>\n<p><img src=\"https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-f@master/image.5y8i5yfb0n00.png\" alt=\"image\"></p>\n<p>其中 Set、List、Queue 实现自 Collection 接口</p>\n<p>Set：</p>\n<ul>\n<li>TreeSet：基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 $O(1)$，TreeSet 则为 $O(\\log N)$。</li>\n<li>HashSet：基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li>\n<li>LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</li>\n</ul>\n<p>List：</p>\n<ul>\n<li>ArrayList：基于动态数组实现，支持随机访问。</li>\n<li>Vector：和 ArrayList 类似，但它是线程安全的。</li>\n<li>LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li>\n</ul>\n<p>Queue：</p>\n<ul>\n<li>LinkedList：可以用它来实现双向队列。</li>\n<li>PriorityQueue：基于堆结构实现，可以用它来实现优先队列。</li>\n</ul>\n<p>Map：</p>\n<ul>\n<li>TreeMap：基于红黑树实现。</li>\n<li>HashMap：基于哈希表实现。</li>\n<li>HashTable：和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li>\n<li>LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。</li>\n</ul>\n<h2 id=\"泛型和类型安全的集合\">泛型和类型安全的集合</h2>\n<p>使用 Java 5 之前的集合的一个主要问题就是编译器允许你向集合中插入不正确的类型。</p>\n<p>例如，考虑一个 Apple 对象的集合，我们使用最基本最可靠的集合 ArrayList。现在，你可以把 ArrayList 当作“可以自动扩充自身尺寸的数组”来看待。使用 ArrayList 相当简单：</p>\n<ul>\n<li>创建一个实例，用 <code>add()</code> 插入对象；</li>\n<li>然后用 <code>get()</code> 访问这些对象，此时需要使用索引，就像数组一样，但是不需要方括号。</li>\n<li>ArrayList 还有一个  <code>size()</code> 方法，使你可以知道已经有多少元素添加了进来，从而不会不小心因索引越界而引发错误。</li>\n</ul>\n<p>在本例中，Apple 和 Orange 都放置在了集合中，然后将它们取出。正常情况下，Java 编译器会报告警告信息，因为这个示例没有使用泛型。在这里，我们使用特定的注解来抑制了警告信息。注解以“@”符号开头，可以接受参数，这里的 <code>@SuppressWarnings</code> 注解及其参数表示只抑制“unchecked”类型的警告信息：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Apple</span> {\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">long</span> counter;\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-variable\">id</span> <span class=\"hljs-operator\">=</span> counter++;\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title function_\">id</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> id; }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Orange</span> {}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ApplesAndOrangesWithoutGenerics</span> {\n  <span class=\"hljs-meta\">@SuppressWarnings(&quot;unchecked&quot;)</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    <span class=\"hljs-type\">ArrayList</span> <span class=\"hljs-variable\">apples</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>();\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">3</span>; i++)\n      apples.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Apple</span>());\n    <span class=\"hljs-comment\">// No problem adding an Orange to apples:</span>\n    apples.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Orange</span>());\n    <span class=\"hljs-keyword\">for</span>(Object apple : apples) {\n      ((Apple) apple).id();\n      <span class=\"hljs-comment\">// Orange is detected only at run time</span>\n    }\n  }\n}\n</code></pre>\n<p>Apple 和 Orange 是截然不同的，它们除了都是 Object 之外没有任何共同点</p>\n<blockquote>\n<p>如果一个类没有显式地声明继承自哪个类，那么它就自动继承自 Object</p>\n</blockquote>\n<p>因为 ArrayList 保存的是 Object ，所以不仅可以通过 ArrayList 的 <code>add()</code> 方法将 Apple 对象放入这个集合，而且可以放入 Orange 对象，这无论在编译期还是运行时都不会有问题。</p>\n<p>当使用 ArrayList 的 <code>get()</code> 方法来取出你认为是 Apple 的对象时，得到的只是 Object 引用，必须将其转型为 Apple。然后需要将整个表达式用括号括起来，以便在调用 Apple 的 <code>id()</code> 方法之前，强制执行转型。否则，将会产生语法错误。</p>\n<p>在运行时，当尝试将 Orange 对象转为 Apple 时，会出现输出中显示的错误。</p>\n<pre><code>___<span class=\"hljs-selector-attr\">[ Error Output ]</span>___\nException <span class=\"hljs-keyword\">in</span> thread <span class=\"hljs-string\">&quot;main&quot;</span>\njava<span class=\"hljs-selector-class\">.lang</span><span class=\"hljs-selector-class\">.ClassCastException</span>: Orange cannot be cast to Apple at \nApplesAndOrangesWithoutGenerics<span class=\"hljs-selector-class\">.main</span>(ApplesAndOrangesWithoutGenerics<span class=\"hljs-selector-class\">.java</span>:<span class=\"hljs-number\">23</span>)\n</code></pre>\n<p>Java 泛型来创建类可能很复杂。但是，使用预先定义的泛型类却相当简单。</p>\n<p>例如，要定义一个用于保存 Apple 对象的 ArrayList，只需要使用 <code>ArrayList&lt;Apple&gt;</code> 来代替 ArrayList。尖括号括起来的是类型参数（可能会有多个），它指定了这个集合实例可以保存的类型。</p>\n<p>通过使用泛型，就可以在编译期防止将错误类型的对象放置到集合中。下面还是这个示例，但是使用了泛型：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/ApplesAndOrangesWithGenerics.java</span>\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ApplesAndOrangesWithGenerics</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    ArrayList&lt;Apple&gt; apples = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">3</span>; i++)\n      apples.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Apple</span>());\n    <span class=\"hljs-comment\">// Compile-time error:</span>\n    <span class=\"hljs-comment\">// apples.add(new Orange());</span>\n    <span class=\"hljs-keyword\">for</span>(Apple apple : apples) {\n      System.out.println(apple.id());\n    }\n  }\n}\n<span class=\"hljs-comment\">/* Output:\n0\n1\n2\n*/</span>\n</code></pre>\n<p>在 <code>apples</code> 定义的右侧，可以看到 <code>new ArrayList&lt;&gt;()</code> 。这有时被称为“菱形语法”（diamond syntax）。</p>\n<p>在 Java 7 之前，必须要在两端都进行类型声明，如下所示：</p>\n<pre><code class=\"hljs language-java\">ArrayList&lt;Apple&gt; apples <span class=\"hljs-operator\">=</span> new ArrayList&lt;Apple&gt;()<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>随着类型变得越来越复杂，这种重复产生的代码非常混乱且难以阅读。程序员发现所有类型信息都可以从左侧获得，因此，编译器没有理由强迫右侧再重复这些。虽然类型推断（type inference）只是个很小的请求，Java 语言团队仍然欣然接受并进行了改进。</p>\n<p>有了 ArrayList 声明中的类型指定，编译器会阻止将 Orange 放入 apples，因此，这会成为一个编译期错误而不是运行时错误。</p>\n<p>使用泛型，从 List 中获取元素不需要强制类型转换。因为 List 知道它持有什么类型，因此当调用 <code>get()</code> 时，它会替你执行转型。因此，使用泛型，你不仅知道编译器将检查放入集合的对象类型，而且在使用集合中的对象时也可以获得更清晰的语法。</p>\n<p>当指定了某个类型为泛型参数时，并不仅限于只能将确切类型的对象放入集合中。向上转型也可以像作用于其他类型一样作用于泛型：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/GenericsAndUpcasting.java</span>\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GrannySmith</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Apple</span> </span>{}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Gala</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Apple</span> </span>{}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Fuji</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Apple</span> </span>{}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Braeburn</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Apple</span> </span>{}\n\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">GenericsAndUpcasting</span> </span>{\n  public static void main(<span class=\"hljs-type\">String</span>[] args) {\n    <span class=\"hljs-type\">ArrayList</span>&lt;<span class=\"hljs-type\">Apple</span>&gt; apples = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">ArrayList</span>&lt;&gt;();\n    apples.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">GrannySmith</span>());\n    apples.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Gala</span>());\n    apples.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Fuji</span>());\n    apples.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Braeburn</span>());\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">Apple</span> apple : apples)\n      <span class=\"hljs-type\">System</span>.out.println(apple);\n  }\n}\n<span class=\"hljs-comment\">/* Output:\nGrannySmith@15db9742\nGala@6d06d69c\nFuji@7852e922\nBraeburn@4e25154f\n*/</span>\n</code></pre>\n<p>因此，可以将 Apple 的子类型添加到被指定为保存 Apple 对象的集合中。</p>\n<p>程序的输出是从 Object 默认的 <code>toString()</code> 方法产生的，该方法打印类名，后边跟着对象的散列码的无符号十六进制表示（这个散列码是通过 <code>hashCode()</code> 方法产生的）。</p>\n<h2 id=\"集合类的基本介绍\">集合类的基本介绍</h2>\n<p>Java 集合类库采用“持有对象”（holding objects）的思想，并将其分为两个不同的概念——集合和映射，表示为类库的基本接口：</p>\n<p>集合（Collection）：一个独立元素的序列，这些元素都服从一条或多条规则。</p>\n<ul>\n<li>List 必须以插入的顺序保存元素</li>\n<li>Set 不能包含重复元素</li>\n<li>Queue 按照排队规则来确定对象产生的顺序（通常与它们被插入的顺序相同）</li>\n</ul>\n<p>映射（Map） ： 一组成对的“键值对”对象，允许使用键来查找值。Map 是强大的编程工具。</p>\n<ul>\n<li>ArrayList 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 </li>\n<li>Map 允许我们使用一个对象来查找另一个对象，它也被称作关联数组（associative array），因为它将对象和其它对象关联在一起</li>\n<li>Map 也被称作字典（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。 </li>\n</ul>\n<p>在理想情况下，我们编写的大部分代码都在与这些接口打交道，并且在创建的时候就需要指定，所使用的精确类型，并且也只能在创建时指定。因此，可以像下面这样创建一个 List ：</p>\n<pre><code class=\"hljs language-java\">List&lt;Apple&gt; apples <span class=\"hljs-operator\">=</span> new ArrayList&lt;&gt;()<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>请注意， ArrayList 已经被向上转型为了 List。使用接口的目的是，如果想要改变具体实现，只需在创建时修改它就行了，就像下面这样：</p>\n<pre><code class=\"hljs language-java\">List&lt;Apple&gt; apples <span class=\"hljs-operator\">=</span> new LinkedList&lt;&gt;()<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>因此，应该创建一个具体类的对象，将其向上转型为对应的接口，然后在其余代码中都是用这个接口。</p>\n<p>但这种方式并非总是有效，因为某些具体类有额外的功能。例如， LinkedList 具有 List 接口中未包含的额外方法，而 TreeMap 也具有在 Map 接口中未包含的方法。如果需要使用这些方法，就不能将它们向上转型为更通用的接口。</p>\n<p>Collection 接口概括了序列的概念（序列是指一种存放一组对象的方式）。下面是个简单的示例，用 Integer 对象填充了一个 Collection （这里用 ArrayList 表示），然后打印集合中的每个元素：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/SimpleCollection.java</span>\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleCollection</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    Collection&lt;Integer&gt; c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)\n      c.add(i); <span class=\"hljs-comment\">// Autoboxing</span>\n    <span class=\"hljs-keyword\">for</span>(Integer i : c)\n      System.out.print(i + <span class=\"hljs-string\">&quot;, &quot;</span>);\n  }\n}\n<span class=\"hljs-comment\">/* Output:\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9,\n*/</span>\n</code></pre>\n<p>这个例子仅使用了 Collection 中的方法（即 <code>add()</code> ），所以使用任何继承自 Collection 的类的对象都可以正常工作。但是 <code>ArrayList</code> 是最基本的序列类型。</p>\n<p><code>add()</code> 方法的名称就表明它是在 Collection 中添加一个新元素。</p>\n<p>但是，文档中非常详细地叙述到 <code>add()</code> “要确保这个 Collection 包含指定的元素。”</p>\n<ul>\n<li>这是因为考虑到了 Set 的含义，因为在 Set 中，只有当元素不存在时才会添加元素。</li>\n<li>在使用 <code>ArrayList</code> ，或任何其他类型的 List 时，<code>add()</code> 总是表示“把它放进去”，因为 List 不关心是否存在重复元素。</li>\n</ul>\n<p>可以使用 for-in 语法来遍历所有的 Collection，就像这里所展示的那样。后面还将学习到一个更灵活的概念，迭代器。</p>\n<h3 id=\"添加元素组\">添加元素组</h3>\n<p>在 java.util 包中的 Arrays 和 Collections 类中都有很多实用的方法，可以在一个 Collection 中添加一组元素。</p>\n<ul>\n<li><code>Arrays.asList()</code> 方法接受一个数组或是逗号分隔的元素列表（使用可变参数），并将其转换为 List 对象。 </li>\n<li><code>Collections.addAll()</code> 方法接受一个 Collection 对象，以及一个数组或是一个逗号分隔的列表，将其中元素添加到 Collection 中。</li>\n</ul>\n<p>下边的示例展示了这两个方法，以及更通用的 、所有 Collection 类型都包含的<code>addAll()</code> 方法：</p>\n<pre><code class=\"hljs language-java\">public <span class=\"hljs-keyword\">class</span> AddingGroups {\n  public static void main(String<span class=\"hljs-literal\">[]</span> args) {\n    Collection&lt;Integer&gt; collection = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Arrays</span>.</span></span><span class=\"hljs-keyword\">as</span><span class=\"hljs-constructor\">List(1, 2, 3, 4, 5)</span>);\n    Integer<span class=\"hljs-literal\">[]</span> moreInts = { <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span> };\n    collection.add<span class=\"hljs-constructor\">All(Arrays.<span class=\"hljs-params\">asList</span>(<span class=\"hljs-params\">moreInts</span>)</span>);\n    <span class=\"hljs-comment\">// Runs significantly faster, but you can&#x27;t construct a Collection this way:</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Collections</span>.</span></span>add<span class=\"hljs-constructor\">All(<span class=\"hljs-params\">collection</span>, 11, 12, 13, 14, 15)</span>;\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Collections</span>.</span></span>add<span class=\"hljs-constructor\">All(<span class=\"hljs-params\">collection</span>, <span class=\"hljs-params\">moreInts</span>)</span>;\n    <span class=\"hljs-comment\">// Produces a list &quot;backed by&quot; an array:</span>\n    List&lt;Integer&gt; <span class=\"hljs-built_in\">list</span> = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Arrays</span>.</span></span><span class=\"hljs-keyword\">as</span><span class=\"hljs-constructor\">List(16, 17, 18, 19, 20)</span>;\n    <span class=\"hljs-built_in\">list</span>.set(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">99</span>); <span class=\"hljs-comment\">// OK; 修改指定索引的元素值</span>\n    <span class=\"hljs-comment\">// list.add(21); // Runtime error; 数组的大小不能调整</span>\n  }\n}\n</code></pre>\n<p>Collection 的构造器可以接受另一个 Collection，用它来将自身初始化。因此，可以使用 <code>Arrays.asList()</code> 来为这个构造器产生输入。但是， <code>Collections.addAll()</code> 运行得更快，而且很容易构建一个不包含元素的 Collection，然后调用 <code>Collections.addAll()</code> ，因此这是首选方式。</p>\n<p><code>collection.addAll()</code> 方法只能接受另一个 Collection 作为参数，因此它没有 <code>Arrays.asList()</code> 或 <code>Collections.addAll()</code> 灵活。这两个方法都使用可变参数列表。</p>\n<p>也可以直接使用 <code>Arrays.asList()</code> 的输出作为一个 List ，但是这里的底层实现是数组，没法调整大小。如果尝试在这个 List 上调用 <code>add()</code> 或 <code>remove()</code>，由于这两个方法会尝试修改数组大小，所以会在运行时得到“Unsupported Operation（不支持的操作）”错误：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Snow</span> </span>{}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Powder</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Snow</span> </span>{}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Light</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Powder</span> </span>{}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Heavy</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Powder</span> </span>{}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Crusty</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Snow</span> </span>{}\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Slush</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">Snow</span> </span>{}\n\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">AsListInference</span> </span>{\n  public static void main(<span class=\"hljs-type\">String</span>[] args) {\n    <span class=\"hljs-type\">List</span>&lt;<span class=\"hljs-type\">Snow</span>&gt; snow1 = <span class=\"hljs-type\">Arrays</span>.asList(\n      <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Crusty</span>(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Slush</span>(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Powder</span>());\n    <span class=\"hljs-comment\">//- snow1.add(new Heavy()); // Exception</span>\n\n    <span class=\"hljs-type\">List</span>&lt;<span class=\"hljs-type\">Snow</span>&gt; snow2 = <span class=\"hljs-type\">Arrays</span>.asList(\n      <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Light</span>(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Heavy</span>());\n    <span class=\"hljs-comment\">//- snow2.add(new Slush()); // Exception</span>\n\n    <span class=\"hljs-type\">List</span>&lt;<span class=\"hljs-type\">Snow</span>&gt; snow3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">ArrayList</span>&lt;&gt;();\n    <span class=\"hljs-type\">Collections</span>.addAll(snow3,\n      <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Light</span>(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Heavy</span>(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Powder</span>());\n    snow3.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Crusty</span>());\n\n    <span class=\"hljs-comment\">// Hint with explicit type argument specification:</span>\n    <span class=\"hljs-type\">List</span>&lt;<span class=\"hljs-type\">Snow</span>&gt; snow4 = <span class=\"hljs-type\">Arrays</span>.&lt;<span class=\"hljs-type\">Snow</span>&gt;asList(\n       <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Light</span>(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Heavy</span>(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Slush</span>());\n    <span class=\"hljs-comment\">//- snow4.add(new Powder()); // Exception</span>\n  }\n}\n</code></pre>\n<p>在 snow4 中，注意 <code>Arrays.asList()</code> 中间的“暗示”（即 <code>&lt;Snow&gt;</code> ），告诉编译器 <code>Arrays.asList()</code> 生成的结果 *<em>List</em> 类型的实际目标类型是什么。这称为显式类型参数说明（explicit type argument specification）。</p>\n<h3 id=\"集合的打印\">集合的打印</h3>\n<p>必须使用 <code>Arrays.toString()</code> 来生成数组的可打印形式。但是打印集合无需任何帮助。下面是一个例子，这个例子中也介绍了基本的Java集合：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/PrintingCollections.java</span>\n<span class=\"hljs-comment\">// Collections print themselves automatically</span>\n<span class=\"hljs-keyword\">import</span> java.<span class=\"hljs-property\">util</span>.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PrintingCollections</span> {\n  <span class=\"hljs-keyword\">static</span> Collection <span class=\"hljs-built_in\">fill</span>(Collection&lt;<span class=\"hljs-built_in\">String</span>&gt; collection) {\n    collection.<span class=\"hljs-property\">add</span>(<span class=\"hljs-string\">&quot;rat&quot;</span>);\n    collection.<span class=\"hljs-property\">add</span>(<span class=\"hljs-string\">&quot;cat&quot;</span>);\n    collection.<span class=\"hljs-property\">add</span>(<span class=\"hljs-string\">&quot;dog&quot;</span>);\n    collection.<span class=\"hljs-property\">add</span>(<span class=\"hljs-string\">&quot;dog&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> collection;\n  }\n  <span class=\"hljs-keyword\">static</span> Map <span class=\"hljs-built_in\">fill</span>(Map&lt;<span class=\"hljs-built_in\">String</span>, <span class=\"hljs-built_in\">String</span>&gt; <span class=\"hljs-built_in\">map</span>) {\n    <span class=\"hljs-built_in\">map</span>.<span class=\"hljs-property\">put</span>(<span class=\"hljs-string\">&quot;rat&quot;</span>, <span class=\"hljs-string\">&quot;Fuzzy&quot;</span>);\n    <span class=\"hljs-built_in\">map</span>.<span class=\"hljs-property\">put</span>(<span class=\"hljs-string\">&quot;cat&quot;</span>, <span class=\"hljs-string\">&quot;Rags&quot;</span>);\n    <span class=\"hljs-built_in\">map</span>.<span class=\"hljs-property\">put</span>(<span class=\"hljs-string\">&quot;dog&quot;</span>, <span class=\"hljs-string\">&quot;Bosco&quot;</span>);\n    <span class=\"hljs-built_in\">map</span>.<span class=\"hljs-property\">put</span>(<span class=\"hljs-string\">&quot;dog&quot;</span>, <span class=\"hljs-string\">&quot;Spot&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">map</span>;\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-built_in\">String</span>[] args) {\n    System.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">println</span>(<span class=\"hljs-built_in\">fill</span>(<span class=\"hljs-keyword\">new </span><span class=\"hljs-class title_\">ArrayList</span>&lt;&gt;()));\n    System.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">println</span>(<span class=\"hljs-built_in\">fill</span>(<span class=\"hljs-keyword\">new </span><span class=\"hljs-class title_\">LinkedList</span>&lt;&gt;()));\n    System.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">println</span>(<span class=\"hljs-built_in\">fill</span>(<span class=\"hljs-keyword\">new </span><span class=\"hljs-class title_\">HashSet</span>&lt;&gt;()));\n    System.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">println</span>(<span class=\"hljs-built_in\">fill</span>(<span class=\"hljs-keyword\">new </span><span class=\"hljs-class title_\">TreeSet</span>&lt;&gt;()));\n    System.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">println</span>(<span class=\"hljs-built_in\">fill</span>(<span class=\"hljs-keyword\">new </span><span class=\"hljs-class title_\">LinkedHashSet</span>&lt;&gt;()));\n    System.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">println</span>(<span class=\"hljs-built_in\">fill</span>(<span class=\"hljs-keyword\">new </span><span class=\"hljs-class title_\">HashMap</span>&lt;&gt;()));\n    System.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">println</span>(<span class=\"hljs-built_in\">fill</span>(<span class=\"hljs-keyword\">new </span><span class=\"hljs-class title_\">TreeMap</span>&lt;&gt;()));\n    System.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">println</span>(<span class=\"hljs-built_in\">fill</span>(<span class=\"hljs-keyword\">new </span><span class=\"hljs-class title_\">LinkedHashMap</span>&lt;&gt;()));\n  }\n}\n<span class=\"hljs-comment\">/* Output:\n[rat, cat, dog, dog]\n[rat, cat, dog, dog]\n[rat, cat, dog]\n[cat, dog, rat]\n[rat, cat, dog]\n{rat=Fuzzy, cat=Rags, dog=Spot}\n{cat=Rags, dog=Spot, rat=Fuzzy}\n{rat=Fuzzy, cat=Rags, dog=Spot}\n*/</span>\n</code></pre>\n<p>这显示了Java集合库中的两个主要类型。它们的区别在于集合中的每个“槽”（slot）保存的元素个数。 <strong>Collection</strong> 类型在每个槽中只能保存一个元素。此类集合包括： <strong>List</strong> ，它以特定的顺序保存一组元素； <strong>Set</strong> ，其中元素不允许重复； <strong>Queue</strong> ，只能在集合一端插入对象，并从另一端移除对象（就本例而言，这只是查看序列的另一种方式，因此并没有显示它）。 <strong>Map</strong> 在每个槽中存放了两个元素，即键和与之关联的值。</p>\n<p>默认的打印行为，使用集合提供的 <code>toString()</code> 方法即可生成可读性很好的结果。 <strong>Collection</strong> 打印出的内容用方括号括住，每个元素由逗号分隔。 <strong>Map</strong> 则由大括号括住，每个键和值用等号连接（键在左侧，值在右侧）。</p>\n<p>第一个 <code>fill()</code> 方法适用于所有类型的 <strong>Collection</strong> ，这些类型都实现了 <code>add()</code> 方法以添加新元素。</p>\n<p><strong>ArrayList</strong> 和 <strong>LinkedList</strong> 都是 <strong>List</strong> 的类型，从输出中可以看出，它们都按插入顺序保存元素。两者之间的区别不仅在于执行某些类型的操作时的性能，而且 <strong>LinkedList</strong> 包含的操作多于 <strong>ArrayList</strong> 。本章后面将对这些内容进行更全面的探讨。</p>\n<p><strong>HashSet</strong> ， <strong>TreeSet</strong> 和 <strong>LinkedHashSet</strong> 是 <strong>Set</strong> 的类型。从输出中可以看到， <strong>Set</strong> 仅保存每个相同项中的一个，并且不同的 <strong>Set</strong> 实现存储元素的方式也不同。 <strong>HashSet</strong> 使用相当复杂的方法存储元素。现在只需要知道，这种技术是检索元素的最快方法，因此，存储顺序看上去没有什么意义（通常只关心某事物是否是 <strong>Set</strong> 的成员，而存储顺序并不重要）。如果存储顺序很重要，则可以使用 <strong>TreeSet</strong> ，它将按比较结果的升序保存对象）或 <strong>LinkedHashSet</strong> ，它按照被添加的先后顺序保存对象。</p>\n<p><strong>Map</strong> （也称为关联数组）使用键来查找对象，就像一个简单的数据库。所关联的对象称为值。 假设有一个 <strong>Map</strong> 将美国州名与它们的首府联系在一起，如果想要俄亥俄州（Ohio）的首府，可以用“Ohio”作为键来查找，几乎就像使用数组下标一样。正是由于这种行为，对于每个键， <strong>Map</strong> 只存储一次。</p>\n<p><code>Map.put(key, value)</code> 添加一个所想要添加的值并将它与一个键（用来查找值）相关联。 <code>Map.get(key)</code> 生成与该键相关联的值。上面的示例仅添加键值对，并没有执行查找。这将在稍后展示。</p>\n<p>请注意，这里没有指定（或考虑） <strong>Map</strong> 的大小，因为它会自动调整大小。 此外， <strong>Map</strong> 还知道如何打印自己，它会显示相关联的键和值。</p>\n<p>本例使用了 <strong>Map</strong> 的三种基本风格： <strong>HashMap</strong> ， <strong>TreeMap</strong> 和 <strong>LinkedHashMap</strong> 。</p>\n<p>键和值保存在 <strong>HashMap</strong> 中的顺序不是插入顺序，因为 <strong>HashMap</strong> 实现使用了非常快速的算法来控制顺序。 <strong>TreeMap</strong> 通过比较结果的升序来保存键， <strong>LinkedHashMap</strong> 在保持 <strong>HashMap</strong> 查找速度的同时按键的插入顺序保存键。</p>\n<h2 id=\"列表-list\">列表 List</h2>\n<p><strong>List</strong>承诺将元素保存在特定的序列中。 <strong>List</strong> 接口在 <strong>Collection</strong> 的基础上添加了许多方法，允许在 <strong>List</strong> 的中间插入和删除元素。</p>\n<p>有两种类型的 <strong>List</strong> ：</p>\n<ul>\n<li>基本的 <strong>ArrayList</strong> ，擅长随机访问元素，但在 <strong>List</strong> 中间插入和删除元素时速度较慢。</li>\n<li><strong>LinkedList</strong> ，它通过代价较低的在 <strong>List</strong> 中间进行的插入和删除操作，提供了优化的顺序访问。 <strong>LinkedList</strong> 对于随机访问来说相对较慢，但它具有比 <strong>ArrayList</strong> 更大的特征集。</li>\n</ul>\n<p>TODO 特征集？2020年10月12日</p>\n<p>下面的示例导入 <strong>typeinfo.pets</strong> ，超前使用了类型信息一章中的类库。这个类库包含了 <strong>Pet</strong> 类层次结构，以及用于随机生成 <strong>Pet</strong> 对象的一些工具类。此时不需要了解完整的详细信息，只需要知道两点：</p>\n<ol>\n<li>有一个 <strong>Pet</strong> 类，以及 <strong>Pet</strong> 的各种子类型。</li>\n<li>静态的 <code>Pets.arrayList()</code> 方法返回一个填充了随机选取的 <strong>Pet</strong> 对象的 <strong>ArrayList</strong>：</li>\n</ol>\n<pre><code class=\"hljs language-Java\"><span class=\"hljs-comment\">// collections/ListFeatures.java</span>\nimport typeinfo.pets.*;\nimport java.util.*;\n\npublic <span class=\"hljs-keyword\">class</span> ListFeatures {\n  public static void main(String<span class=\"hljs-literal\">[]</span> args) {\n    Random rand = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Random(47)</span>;\n    List&lt;Pet&gt; pets = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Pets</span>.</span></span><span class=\"hljs-built_in\">list</span>(<span class=\"hljs-number\">7</span>);\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;1: &quot;</span> + pets);\n    Hamster h = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Hamster()</span>;\n    pets.add(h); <span class=\"hljs-comment\">// Automatically resizes</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;2: &quot;</span> + pets);\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;3: &quot;</span> + pets.contains(h));\n    pets.remove(h); <span class=\"hljs-comment\">// Remove by object</span>\n    Pet p = pets.get(<span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;4: &quot;</span> +  p + <span class=\"hljs-string\">&quot; &quot;</span> + pets.index<span class=\"hljs-constructor\">Of(<span class=\"hljs-params\">p</span>)</span>);\n    Pet cymric = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Cymric()</span>;\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;5: &quot;</span> + pets.index<span class=\"hljs-constructor\">Of(<span class=\"hljs-params\">cymric</span>)</span>);\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;6: &quot;</span> + pets.remove(cymric));\n    <span class=\"hljs-comment\">// Must be the exact object:</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;7: &quot;</span> + pets.remove(p));\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;8: &quot;</span> + pets);\n    pets.add(<span class=\"hljs-number\">3</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Mouse()</span>); <span class=\"hljs-comment\">// Insert at an index</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;9: &quot;</span> + pets);\n    List&lt;Pet&gt; sub = pets.sub<span class=\"hljs-constructor\">List(1, 4)</span>;\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;subList: &quot;</span> + sub);\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;10: &quot;</span> + pets.contains<span class=\"hljs-constructor\">All(<span class=\"hljs-params\">sub</span>)</span>);\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Collections</span>.</span></span>sort(sub); <span class=\"hljs-comment\">// In-place sort</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;sorted subList: &quot;</span> + sub);\n    <span class=\"hljs-comment\">// Order is not important in containsAll():</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;11: &quot;</span> + pets.contains<span class=\"hljs-constructor\">All(<span class=\"hljs-params\">sub</span>)</span>);\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Collections</span>.</span></span>shuffle(sub, rand); <span class=\"hljs-comment\">// Mix it up</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;shuffled subList: &quot;</span> + sub);\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;12: &quot;</span> + pets.contains<span class=\"hljs-constructor\">All(<span class=\"hljs-params\">sub</span>)</span>);\n    List&lt;Pet&gt; copy = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;(pets);\n    sub = <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Arrays</span>.</span></span><span class=\"hljs-keyword\">as</span><span class=\"hljs-constructor\">List(<span class=\"hljs-params\">pets</span>.<span class=\"hljs-params\">get</span>(1)</span>, pets.get(<span class=\"hljs-number\">4</span>));\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;sub: &quot;</span> + sub);\n    copy.retain<span class=\"hljs-constructor\">All(<span class=\"hljs-params\">sub</span>)</span>;\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;13: &quot;</span> + copy);\n    copy = <span class=\"hljs-keyword\">new</span> ArrayList&lt;&gt;(pets); <span class=\"hljs-comment\">// Get a fresh copy</span>\n    copy.remove(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// Remove by index</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;14: &quot;</span> + copy);\n    copy.remove<span class=\"hljs-constructor\">All(<span class=\"hljs-params\">sub</span>)</span>; <span class=\"hljs-comment\">// Only removes exact objects</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;15: &quot;</span> + copy);\n    copy.set(<span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Mouse()</span>); <span class=\"hljs-comment\">// Replace an element</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;16: &quot;</span> + copy);\n    copy.add<span class=\"hljs-constructor\">All(2, <span class=\"hljs-params\">sub</span>)</span>; <span class=\"hljs-comment\">// Insert a list in the middle</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;17: &quot;</span> + copy);\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;18: &quot;</span> + pets.is<span class=\"hljs-constructor\">Empty()</span>);\n    pets.clear<span class=\"hljs-literal\">()</span>; <span class=\"hljs-comment\">// Remove all elements</span>\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;19: &quot;</span> + pets);\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;20: &quot;</span> + pets.is<span class=\"hljs-constructor\">Empty()</span>);\n    pets.add<span class=\"hljs-constructor\">All(Pets.<span class=\"hljs-params\">list</span>(4)</span>);\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;21: &quot;</span> + pets);\n    Object<span class=\"hljs-literal\">[]</span> o = pets.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">Array()</span>;\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;22: &quot;</span> + o<span class=\"hljs-literal\">[<span class=\"hljs-number\">3</span>]</span>);\n    Pet<span class=\"hljs-literal\">[]</span> pa = pets.<span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">Array(<span class=\"hljs-params\">new</span> Pet[0])</span>;\n    <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;23: &quot;</span> + pa<span class=\"hljs-literal\">[<span class=\"hljs-number\">3</span>]</span>.id<span class=\"hljs-literal\">()</span>);\n  }\n}\n<span class=\"hljs-comment\">/* Output:\n1: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug]\n2: [Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Hamster]\n3: true\n4: Cymric 2\n5: -1\n6: false\n7: true\n8: [Rat, Manx, Mutt, Pug, Cymric, Pug]\n9: [Rat, Manx, Mutt, Mouse, Pug, Cymric, Pug]\nsubList: [Manx, Mutt, Mouse]\n10: true\nsorted subList: [Manx, Mouse, Mutt]\n11: true\nshuffled subList: [Mouse, Manx, Mutt]\n12: true\nsub: [Mouse, Pug]\n13: [Mouse, Pug]\n14: [Rat, Mouse, Mutt, Pug, Cymric, Pug]\n15: [Rat, Mutt, Cymric, Pug]\n16: [Rat, Mouse, Cymric, Pug]\n17: [Rat, Mouse, Mouse, Pug, Cymric, Pug]\n18: false\n19: []\n20: true\n21: [Manx, Cymric, Rat, EgyptianMau]\n22: EgyptianMau\n23: 14\n*/</span>\n</code></pre>\n<p>打印行都编了号，因此可从输出追溯到源代码。 第 1 行输出展示了原始的由 <strong>Pet</strong> 组成的 <strong>List</strong> 。 与数组不同， <strong>List</strong> 可以在创建后添加或删除元素，并自行调整大小。这正是它的重要价值：一种可修改的序列。在第 2 行输出中可以看到添加一个 <strong>Hamster</strong> 的结果，该对象将被追加到列表的末尾。</p>\n<p>可以使用 <code>contains()</code> 方法确定对象是否在列表中。如果要删除一个对象，可以将该对象的引用传递给 <code>remove()</code> 方法。同样，如果有一个对象的引用，可以使用 <code>indexOf()</code> 在 <strong>List</strong> 中找到该对象所在位置的下标号，如第 4 行输出所示中所示。</p>\n<p>当确定元素是否是属于某个 <strong>List</strong> ，寻找某个元素的索引，以及通过引用从 <strong>List</strong> 中删除元素时，都会用到 <code>equals()</code> 方法（根类 <strong>Object</strong> 的一个方法）。每个 <strong>Pet</strong> 被定义为一个唯一的对象，所以即使列表中已经有两个 <strong>Cymrics</strong> ，如果再创建一个新的 <strong>Cymric</strong> 对象并将其传递给 <code>indexOf()</code> 方法，结果仍为 <strong>-1</strong> （表示未找到），并且尝试调用 <code>remove()</code> 方法来删除这个对象将返回 <strong>false</strong> 。对于其他类， <code>equals()</code> 的定义可能有所不同。例如，如果两个 <strong>String</strong> 的内容相同，则这两个 <strong>String</strong> 相等。因此，为了防止出现意外，请务必注意 <strong>List</strong> 行为会根据 <code>equals()</code> 行为而发生变化。</p>\n<p>第 7、8 行输出展示了删除与 <strong>List</strong> 中的对象完全匹配的对象是成功的。</p>\n<p>可以在 <strong>List</strong> 的中间插入一个元素，就像在第 9 行输出和它之前的代码那样。但这会带来一个问题：对于 <strong>LinkedList</strong> ，在列表中间插入和删除都是廉价操作（在本例中，除了对列表中间进行的真正的随机访问），但对于 <strong>ArrayList</strong> ，这可是代价高昂的操作。这是否意味着永远不应该在 <strong>ArrayList</strong> 的中间插入元素，并最好是转换为 <strong>LinkedList</strong> ？不，它只是意味着你应该意识到这个问题，如果你开始在某个 <strong>ArrayList</strong> 中间执行很多插入操作，并且程序开始变慢，那么你应该看看你的 <strong>List</strong> 实现有可能就是罪魁祸首（发现此类瓶颈的最佳方式是使用分析器 profiler）。优化是一个很棘手的问题，最好的策略就是置之不顾，直到发现必须要去担心它了（尽管去理解这些问题总是一个很好的主意）。</p>\n<p><code>subList()</code> 方法可以轻松地从更大的列表中创建切片，当将切片结果传递给原来这个较大的列表的 <code>containsAll()</code> 方法时，很自然地会得到 <strong>true</strong>。请注意，顺序并不重要，在第 11、12 行输出中可以看到，在 <strong>sub</strong> 上调用直观命名的 <code>Collections.sort()</code> 和 <code>Collections.shuffle()</code> 方法，不会影响 <code>containsAll()</code> 的结果。 <code>subList()</code> 所产生的列表的幕后支持就是原始列表。因此，对所返回列表的更改都将会反映在原始列表中，反之亦然。</p>\n<p><code>retainAll()</code> 方法实际上是一个“集合交集”操作，在本例中，它保留了同时在 <strong>copy</strong> 和 <strong>sub</strong> 中的所有元素。请再次注意，所产生的结果行为依赖于 <code>equals()</code> 方法。</p>\n<p>第 14 行输出展示了使用索引号来删除元素的结果，与通过对象引用来删除元素相比，它显得更加直观，因为在使用索引时，不必担心 <code>equals()</code> 的行为。</p>\n<p><code>removeAll()</code> 方法也是基于 <code>equals()</code> 方法运行的。 顾名思义，它会从 <strong>List</strong> 中删除在参数 <strong>List</strong> 中的所有元素。</p>\n<p><code>set()</code> 方法的命名显得很不合时宜，因为它与 <strong>Set</strong> 类存在潜在的冲突。在这里使用“replace”可能更适合，因为它的功能是用第二个参数替换索引处的元素（第一个参数）。</p>\n<p>第 17 行输出表明，对于 <strong>List</strong> ，有一个重载的 <code>addAll()</code> 方法可以将新列表插入到原始列表的中间位置，而不是仅能用 <strong>Collection</strong> 的 <code>addAll()</code> 方法将其追加到列表的末尾。</p>\n<p>第 18 - 20 行输出展示了 <code>isEmpty()</code> 和 <code>clear()</code> 方法的效果。</p>\n<p>第 22、23 行输出展示了如何使用 <code>toArray()</code> 方法将任意的 <strong>Collection</strong> 转换为数组。这是一个重载方法，其无参版本返回一个 <strong>Object</strong> 数组，但是如果将目标类型的数组传递给这个重载版本，那么它会生成一个指定类型的数组（假设它通过了类型检查）。如果参数数组太小而无法容纳 <strong>List</strong> 中的所有元素（就像本例一样），则 <code>toArray()</code> 会创建一个具有合适尺寸的新数组。 <strong>Pet</strong> 对象有一个 <code>id()</code> 方法，可以在所产生的数组中的对象上调用这个方法。</p>\n<h2 id=\"迭代器iterators\">迭代器Iterators</h2>\n<p>在任何集合中，都必须有某种方式可以插入元素并再次获取它们。毕竟，保存事物是集合最基本的工作。对于 <strong>List</strong> ， <code>add()</code> 是插入元素的一种方式， <code>get()</code> 是获取元素的一种方式。</p>\n<p>如果从更高层次的角度考虑，会发现这里有个缺点：要使用集合，必须对集合的确切类型编程。这一开始可能看起来不是很糟糕，但是考虑下面的情况：如果原本是对 <strong>List</strong> 编码的，但是后来发现如果能够将相同的代码应用于 <strong>Set</strong> 会更方便，此时应该怎么做？或者假设想从一开始就编写一段通用代码，它不知道或不关心它正在使用什么类型的集合，因此它可以用于不同类型的集合，那么如何才能不重写代码就可以应用于不同类型的集合？</p>\n<p>迭代器（也是一种设计模式）的概念实现了这种抽象。迭代器是一个对象，它在一个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底层结构。另外，迭代器通常被称为轻量级对象（lightweight object）：创建它的代价小。因此，经常可以看到一些对迭代器有些奇怪的约束。例如，Java 的 <strong>Iterator</strong> 只能单向移动。这个 <strong>Iterator</strong> 只能用来：</p>\n<ol>\n<li>使用 <code>iterator()</code> 方法要求集合返回一个 <strong>Iterator</strong>。 <strong>Iterator</strong> 将准备好返回序列中的第一个元素。</li>\n<li>使用 <code>next()</code> 方法获得序列中的下一个元素。</li>\n<li>使用 <code>hasNext()</code> 方法检查序列中是否还有元素。</li>\n<li>使用 <code>remove()</code> 方法将迭代器最近返回的那个元素删除。</li>\n</ol>\n<p>为了观察它的工作方式，这里再次使用 <strong>Pet</strong> 工具：</p>\n<pre><code class=\"hljs language-java\">/<span class=\"hljs-regexp\">/ collections/</span>SimpleIteration.java\nimport typeinfo.pets.*;\nimport java.util.*;\n\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SimpleIteration</span> {</span>\n  public static void main(String[] args) {\n    List&lt;Pet&gt; pets = Pets.list(<span class=\"hljs-number\">12</span>);\n    Iterator&lt;Pet&gt; it = pets.iterator();\n    <span class=\"hljs-keyword\">while</span>(it.hasNext()) {\n      Pet p = it.<span class=\"hljs-keyword\">next</span>();\n      System.out.print(p.id() + <span class=\"hljs-string\">&quot;:&quot;</span> + p + <span class=\"hljs-string\">&quot; &quot;</span>);\n    }\n    System.out.println();\n    <span class=\"hljs-regexp\">//</span> A simpler approach, <span class=\"hljs-keyword\">when</span> <span class=\"hljs-symbol\">possible:</span>\n    <span class=\"hljs-keyword\">for</span>(Pet p : pets)\n      System.out.print(p.id() + <span class=\"hljs-string\">&quot;:&quot;</span> + p + <span class=\"hljs-string\">&quot; &quot;</span>);\n    System.out.println();\n    <span class=\"hljs-regexp\">//</span> An Iterator can also remove <span class=\"hljs-symbol\">elements:</span>\n    it = pets.iterator();\n    <span class=\"hljs-keyword\">for</span>(int i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">6</span>; i++) {\n      it.<span class=\"hljs-keyword\">next</span>();\n      it.remove();\n    }\n    System.out.println(pets);\n  }\n}\n/* <span class=\"hljs-symbol\">Output:</span>\n<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:Rat</span> <span class=\"hljs-number\">1</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">2</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">3</span><span class=\"hljs-symbol\">:Mutt</span> <span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">5</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">6</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">7</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">8</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">9</span><span class=\"hljs-symbol\">:Rat</span> <span class=\"hljs-number\">10</span><span class=\"hljs-symbol\">:EgyptianMau</span> <span class=\"hljs-number\">11</span><span class=\"hljs-symbol\">:Hamster</span>\n<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:Rat</span> <span class=\"hljs-number\">1</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">2</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">3</span><span class=\"hljs-symbol\">:Mutt</span> <span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">5</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">6</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">7</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">8</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">9</span><span class=\"hljs-symbol\">:Rat</span> <span class=\"hljs-number\">10</span><span class=\"hljs-symbol\">:EgyptianMau</span> <span class=\"hljs-number\">11</span><span class=\"hljs-symbol\">:Hamster</span>\n[Pug, Manx, Cymric, Rat, EgyptianMau, Hamster]\n*<span class=\"hljs-regexp\">/</span>\n</code></pre>\n<p>有了 <strong>Iterator</strong> ，就不必再为集合中元素的数量操心了。这是由 <code>hasNext()</code> 和 <code>next()</code> 关心的事情。</p>\n<p>如果只是想向前遍历 <strong>List</strong> ，并不打算修改 <strong>List</strong> 对象本身，那么使用 for-in 语法更加简洁。</p>\n<p><strong>Iterator</strong> 还可以删除由 <code>next()</code> 生成的最后一个元素，这意味着在调用 <code>remove()</code> 之前必须先调用 <code>next()</code> 。[^4]</p>\n<p>在集合中的每个对象上执行操作，这种思想十分强大，并且贯穿于本书。</p>\n<p>现在考虑创建一个 <code>display()</code> 方法，它不必知晓集合的确切类型：</p>\n<pre><code class=\"hljs language-java\">/<span class=\"hljs-regexp\">/ collections/</span>CrossCollectionIteration.java\nimport typeinfo.pets.*;\nimport java.util.*;\n\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CrossCollectionIteration</span> {</span>\n  public static void display(Iterator&lt;Pet&gt; it) {\n    <span class=\"hljs-keyword\">while</span>(it.hasNext()) {\n      Pet p = it.<span class=\"hljs-keyword\">next</span>();\n      System.out.print(p.id() + <span class=\"hljs-string\">&quot;:&quot;</span> + p + <span class=\"hljs-string\">&quot; &quot;</span>);\n    }\n    System.out.println();\n  }\n  public static void main(String[] args) {\n    List&lt;Pet&gt; pets = Pets.list(<span class=\"hljs-number\">8</span>);\n    LinkedList&lt;Pet&gt; petsLL = new LinkedList&lt;&gt;(pets);\n    HashSet&lt;Pet&gt; petsHS = new HashSet&lt;&gt;(pets);\n    TreeSet&lt;Pet&gt; petsTS = new TreeSet&lt;&gt;(pets);\n    display(pets.iterator());\n    display(petsLL.iterator());\n    display(petsHS.iterator());\n    display(petsTS.iterator());\n  }\n}\n/* <span class=\"hljs-symbol\">Output:</span>\n<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:Rat</span> <span class=\"hljs-number\">1</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">2</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">3</span><span class=\"hljs-symbol\">:Mutt</span> <span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">5</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">6</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">7</span><span class=\"hljs-symbol\">:Manx</span>\n<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:Rat</span> <span class=\"hljs-number\">1</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">2</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">3</span><span class=\"hljs-symbol\">:Mutt</span> <span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">5</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">6</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">7</span><span class=\"hljs-symbol\">:Manx</span>\n<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:Rat</span> <span class=\"hljs-number\">1</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">2</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">3</span><span class=\"hljs-symbol\">:Mutt</span> <span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">5</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">6</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">7</span><span class=\"hljs-symbol\">:Manx</span>\n<span class=\"hljs-number\">5</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">2</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">7</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">1</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">3</span><span class=\"hljs-symbol\">:Mutt</span> <span class=\"hljs-number\">6</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:Rat</span>\n*<span class=\"hljs-regexp\">/</span>\n</code></pre>\n<p><code>display()</code> 方法不包含任何有关它所遍历的序列的类型信息。这也展示了 <strong>Iterator</strong> 的真正威力：能够将遍历序列的操作与该序列的底层结构分离。出于这个原因，我们有时会说：迭代器统一了对集合的访问方式。</p>\n<p>我们可以使用 <strong>Iterable</strong> 接口生成上一个示例的更简洁版本，该接口描述了“可以产生 <strong>Iterator</strong> 的任何东西”：</p>\n<pre><code class=\"hljs language-java\">/<span class=\"hljs-regexp\">/ collections/</span>CrossCollectionIteration2.java\nimport typeinfo.pets.*;\nimport java.util.*;\n\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CrossCollectionIteration2</span> {</span>\n  public static void display(Iterable&lt;Pet&gt; ip) {\n    Iterator&lt;Pet&gt; it = ip.iterator();\n    <span class=\"hljs-keyword\">while</span>(it.hasNext()) {\n      Pet p = it.<span class=\"hljs-keyword\">next</span>();\n      System.out.print(p.id() + <span class=\"hljs-string\">&quot;:&quot;</span> + p + <span class=\"hljs-string\">&quot; &quot;</span>);\n    }\n    System.out.println();\n  }\n  public static void main(String[] args) {\n    List&lt;Pet&gt; pets = Pets.list(<span class=\"hljs-number\">8</span>);\n    LinkedList&lt;Pet&gt; petsLL = new LinkedList&lt;&gt;(pets);\n    HashSet&lt;Pet&gt; petsHS = new HashSet&lt;&gt;(pets);\n    TreeSet&lt;Pet&gt; petsTS = new TreeSet&lt;&gt;(pets);\n    display(pets);\n    display(petsLL);\n    display(petsHS);\n    display(petsTS);\n  }\n}\n/* <span class=\"hljs-symbol\">Output:</span>\n<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:Rat</span> <span class=\"hljs-number\">1</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">2</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">3</span><span class=\"hljs-symbol\">:Mutt</span> <span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">5</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">6</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">7</span><span class=\"hljs-symbol\">:Manx</span> \n<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:Rat</span> <span class=\"hljs-number\">1</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">2</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">3</span><span class=\"hljs-symbol\">:Mutt</span> <span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">5</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">6</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">7</span><span class=\"hljs-symbol\">:Manx</span> \n<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:Rat</span> <span class=\"hljs-number\">1</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">2</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">3</span><span class=\"hljs-symbol\">:Mutt</span> <span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">5</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">6</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">7</span><span class=\"hljs-symbol\">:Manx</span> \n<span class=\"hljs-number\">5</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">2</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">7</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">1</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">3</span><span class=\"hljs-symbol\">:Mutt</span> <span class=\"hljs-number\">6</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:Rat</span> \n*<span class=\"hljs-regexp\">/</span>\n</code></pre>\n<p>这里所有的类都是 <strong>Iterable</strong> ，所以现在对 <code>display()</code> 的调用显然更简单。</p>\n<h2 id=\"listiterator\">ListIterator</h2>\n<p><strong>ListIterator</strong> 是一个更强大的 <strong>Iterator</strong> 子类型，它只能由各种 <strong>List</strong> 类生成。 <strong>Iterator</strong> 只能向前移动，而 <strong>ListIterator</strong> 可以双向移动。它可以生成迭代器在列表中指向位置的后一个和前一个元素的索引，并且可以使用 <code>set()</code> 方法替换它访问过的最近一个元素。可以通过调用 <code>listIterator()</code> 方法来生成指向 <strong>List</strong> 开头处的 <strong>ListIterator</strong> ，还可以通过调用 <code>listIterator(n)</code> 创建一个一开始就指向列表索引号为 <strong>n</strong> 的元素处的 <strong>ListIterator</strong> 。 下面的示例演示了所有这些能力：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/ListIteration.java</span>\n<span class=\"hljs-keyword\">import</span> typeinfo.pets.*;\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> ListIteration {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> main(String[] args) {\n    List&lt;Pet&gt; pets = Pets.list(<span class=\"hljs-number\">8</span>);\n    ListIterator&lt;Pet&gt; it = pets.listIterator();\n    <span class=\"hljs-keyword\">while</span>(it.hasNext())\n      System.out.<span class=\"hljs-keyword\">print</span>(it.<span class=\"hljs-keyword\">next</span>() +\n        <span class=\"hljs-string\">&quot;, &quot;</span> + it.nextIndex() +\n        <span class=\"hljs-string\">&quot;, &quot;</span> + it.previousIndex() + <span class=\"hljs-string\">&quot;; &quot;</span>);\n    System.out.<span class=\"hljs-keyword\">println</span>();\n    <span class=\"hljs-comment\">// Backwards:</span>\n    <span class=\"hljs-keyword\">while</span>(it.hasPrevious())\n      System.out.<span class=\"hljs-keyword\">print</span>(it.<span class=\"hljs-keyword\">previous</span>().id() + <span class=\"hljs-string\">&quot; &quot;</span>);\n    System.out.<span class=\"hljs-keyword\">println</span>();\n    System.out.<span class=\"hljs-keyword\">println</span>(pets);\n    it = pets.listIterator(<span class=\"hljs-number\">3</span>);\n    <span class=\"hljs-keyword\">while</span>(it.hasNext()) {\n      it.<span class=\"hljs-keyword\">next</span>();\n      it.set(Pets.get());\n    }\n    System.out.<span class=\"hljs-keyword\">println</span>(pets);\n  }\n}\n<span class=\"hljs-comment\">/* Output:\nRat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug, 5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7; \n7 6 5 4 3 2 1 0 \n[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx]\n[Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster, EgyptianMau]\n*/</span>\n</code></pre>\n<p><code>Pets.get()</code> 方法用来从位置 3 开始替换 <strong>List</strong> 中的所有 Pet 对象。</p>\n<h2 id=\"链表linkedlist\">链表LinkedList</h2>\n<p><strong>LinkedList</strong> 也像 <strong>ArrayList</strong> 一样实现了基本的 <strong>List</strong> 接口，但它在 <strong>List</strong> 中间执行插入和删除操作时比 <strong>ArrayList</strong> 更高效。然而,它在随机访问操作效率方面却要逊色一些。</p>\n<p><strong>LinkedList 还添加了一些方法，使其可以被用作栈、队列或双端队列（deque）</strong> 。在这些方法中，有些彼此之间可能只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用（特别是在 <strong>Queue</strong> 中）。例如：</p>\n<ul>\n<li><code>getFirst()</code> 和 <code>element()</code> 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 <strong>List</strong> 为空，则抛出 <strong>NoSuchElementException</strong> 异常。 <code>peek()</code> 方法与这两个方法只是稍有差异，它在列表为空时返回 <strong>null</strong> 。</li>\n<li><code>removeFirst()</code> 和 <code>remove()</code> 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 <strong>NoSuchElementException</strong> 异常。 <code>poll()</code> 稍有差异，它在列表为空时返回 <strong>null</strong> 。</li>\n<li><code>addFirst()</code> 在列表的开头插入一个元素。</li>\n<li><code>offer()</code> 与 <code>add()</code> 和 <code>addLast()</code> 相同。 它们都在列表的尾部（末尾）添加一个元素。</li>\n<li><code>removeLast()</code> 删除并返回列表的最后一个元素。</li>\n</ul>\n<p>下面的示例展示了这些功能之间基本的相似性和差异性。它并不是重复执行 <strong>ListFeatures.java</strong> 中所示的行为：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/LinkedListFeatures.java</span>\nimport typeinfo.pets.*;\nimport java.util.*;\n\npublic <span class=\"hljs-keyword\">class</span> LinkedListFeatures {\n    public static void main(String<span class=\"hljs-literal\">[]</span> args) {\n        LinkedList&lt;Pet&gt; pets = <span class=\"hljs-keyword\">new</span> LinkedList&lt;&gt;(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Pets</span>.</span></span><span class=\"hljs-built_in\">list</span>(<span class=\"hljs-number\">5</span>));\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(pets);\n        <span class=\"hljs-comment\">// Identical:</span>\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;pets.getFirst(): &quot;</span> + pets.get<span class=\"hljs-constructor\">First()</span>);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;pets.element(): &quot;</span> + pets.element<span class=\"hljs-literal\">()</span>);\n        <span class=\"hljs-comment\">// Only differs in empty-list behavior:</span>\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;pets.peek(): &quot;</span> + pets.peek<span class=\"hljs-literal\">()</span>);\n        <span class=\"hljs-comment\">// Identical; remove and return the first element:</span>\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;pets.remove(): &quot;</span> + pets.remove<span class=\"hljs-literal\">()</span>);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;pets.removeFirst(): &quot;</span> + pets.remove<span class=\"hljs-constructor\">First()</span>);\n        <span class=\"hljs-comment\">// Only differs in empty-list behavior:</span>\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;pets.poll(): &quot;</span> + pets.poll<span class=\"hljs-literal\">()</span>);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(pets);\n        pets.add<span class=\"hljs-constructor\">First(<span class=\"hljs-params\">new</span> Rat()</span>);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;After addFirst(): &quot;</span> + pets);\n        pets.offer(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Pets</span>.</span></span>get<span class=\"hljs-literal\">()</span>);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;After offer(): &quot;</span> + pets);\n        pets.add(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Pets</span>.</span></span>get<span class=\"hljs-literal\">()</span>);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;After add(): &quot;</span> + pets);\n        pets.add<span class=\"hljs-constructor\">Last(<span class=\"hljs-params\">new</span> Hamster()</span>);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;After addLast(): &quot;</span> + pets);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;pets.removeLast(): &quot;</span> + pets.remove<span class=\"hljs-constructor\">Last()</span>);\n    }\n}\n<span class=\"hljs-comment\">/* Output:\n[Rat, Manx, Cymric, Mutt, Pug]\npets.getFirst(): Rat\npets.element(): Rat\npets.peek(): Rat\npets.remove(): Rat\npets.removeFirst(): Manx\npets.poll(): Cymric\n[Mutt, Pug]\nAfter addFirst(): [Rat, Mutt, Pug]\nAfter offer(): [Rat, Mutt, Pug, Cymric]\nAfter add(): [Rat, Mutt, Pug, Cymric, Pug]\nAfter addLast(): [Rat, Mutt, Pug, Cymric, Pug, Hamster]\npets.removeLast(): Hamster\n*/</span>\n</code></pre>\n<p><code>Pets.list()</code> 的结果被传递给 <strong>LinkedList</strong> 的构造器，以便使用它来填充 <strong>LinkedList</strong> 。如果查看 <strong>Queue</strong> 接口就会发现，它在 <strong>LinkedList</strong> 的基础上添加了 <code>element()</code> ， <code>offer()</code> ， <code>peek()</code> ， <code>poll()</code> 和 <code>remove()</code> 方法，以使其可以成为一个 <strong>Queue</strong> 的实现。 </p>\n<h2 id=\"堆栈stack\">堆栈Stack</h2>\n<p>堆栈是“后进先出”（LIFO）集合。它有时被称为叠加栈（pushdown stack），因为最后“压入”（push）栈的元素，第一个被“弹出”（pop）栈。经常用来类比栈的事物是带有弹簧支架的自助餐厅托盘。最后装入的托盘总是最先拿出来使用的。</p>\n<p>Java 1.0 中附带了一个 <strong>Stack</strong> 类，结果设计得很糟糕（为了向后兼容，我们永远坚持 Java 中的旧设计错误）。Java 6 添加了 <strong>ArrayDeque</strong> ，其中包含直接实现堆栈功能的方法：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/StackTest.java</span>\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StackTest</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">String</span>[] args)</span> </span>{\n        Deque&lt;<span class=\"hljs-type\">String</span>&gt; stack = <span class=\"hljs-keyword\">new</span> ArrayDeque&lt;&gt;();\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">String</span> s : <span class=\"hljs-string\">&quot;My dog has fleas&quot;</span>.<span class=\"hljs-built_in\">split</span>(<span class=\"hljs-string\">&quot; &quot;</span>)) {\n            stack.<span class=\"hljs-built_in\">push</span>(s);\n        }\n        <span class=\"hljs-keyword\">while</span> (!stack.<span class=\"hljs-built_in\">isEmpty</span>()) {\n            System.out.<span class=\"hljs-built_in\">print</span>(stack.<span class=\"hljs-built_in\">pop</span>() + <span class=\"hljs-string\">&quot; &quot;</span>);\n        }\n    }\n}\n<span class=\"hljs-comment\">/* Output:\nfleas has dog My\n*/</span>\n</code></pre>\n<p>即使它是作为一个堆栈在使用，我们仍然必须将其声明为 <strong>Deque</strong> 。有时一个名为 <strong>Stack</strong> 的类更能把事情讲清楚：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// onjava/Stack.java</span>\n<span class=\"hljs-comment\">// A Stack class built with an ArrayDeque</span>\npackage onjava;\n<span class=\"hljs-keyword\">import</span> java.<span class=\"hljs-property\">util</span>.<span class=\"hljs-property\">Deque</span>;\n<span class=\"hljs-keyword\">import</span> java.<span class=\"hljs-property\">util</span>.<span class=\"hljs-property\">ArrayDeque</span>;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Stack</span>&lt;T&gt; {\n  <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">Deque</span>&lt;T&gt; storage = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayDeque</span>&lt;&gt;();\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">push</span>(<span class=\"hljs-params\">T v</span>) { storage.<span class=\"hljs-title function_\">push</span>(v); }\n  <span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title function_\">peek</span>(<span class=\"hljs-params\"></span>) { <span class=\"hljs-keyword\">return</span> storage.<span class=\"hljs-title function_\">peek</span>(); }\n  <span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title function_\">pop</span>(<span class=\"hljs-params\"></span>) { <span class=\"hljs-keyword\">return</span> storage.<span class=\"hljs-title function_\">pop</span>(); }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">boolean</span> <span class=\"hljs-title function_\">isEmpty</span>(<span class=\"hljs-params\"></span>) { <span class=\"hljs-keyword\">return</span> storage.<span class=\"hljs-title function_\">isEmpty</span>(); }\n  <span class=\"hljs-meta\">@Override</span>\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">String</span> <span class=\"hljs-title function_\">toString</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> storage.<span class=\"hljs-title function_\">toString</span>();\n  }\n}\n</code></pre>\n<p>这里引入了使用泛型的类定义的最简单的可能示例。类名称后面的 告诉编译器这是一个参数化类型，而其中的类型参数 <strong>T</strong> 会在使用类时被实际类型替换。基本上，这个类是在声明“我们在定义一个可以持有 <strong>T</strong> 类型对象的 <strong>Stack</strong> 。” <strong>Stack</strong> 是使用 <strong>ArrayDeque</strong> 实现的，而 <strong>ArrayDeque</strong> 也被告知它将持有 <strong>T</strong> 类型对象。注意， <code>push()</code> 接受类型为 <strong>T</strong> 的对象，而 <code>peek()</code> 和 <code>pop()</code> 返回类型为 <strong>T</strong> 的对象。 <code>peek()</code> 方法将返回栈顶元素，但并不将其从栈顶删除，而 <code>pop()</code> 删除并返回顶部元素。</p>\n<p>如果只需要栈的行为，那么使用继承是不合适的，因为这将产生一个具有 <strong>ArrayDeque</strong> 的其它所有方法的类（<strong>Java 1.0</strong> 设计者在创建 <strong>java.util.Stack</strong> 时，就犯了这个错误）。使用组合，可以选择要公开的方法以及如何命名它们。</p>\n<p>下面将使用 <strong>StackTest.java</strong> 中的相同代码来演示这个新的 <strong>Stack</strong> 类：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/StackTest2.java</span>\n<span class=\"hljs-keyword\">import</span> onjava.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StackTest2</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">String</span>[] args)</span> </span>{\n        Stack&lt;<span class=\"hljs-type\">String</span>&gt; stack = <span class=\"hljs-keyword\">new</span> Stack&lt;&gt;();\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">String</span> s : <span class=\"hljs-string\">&quot;My dog has fleas&quot;</span>.<span class=\"hljs-built_in\">split</span>(<span class=\"hljs-string\">&quot; &quot;</span>)) {\n            stack.<span class=\"hljs-built_in\">push</span>(s);\n        }\n        <span class=\"hljs-keyword\">while</span> (!stack.<span class=\"hljs-built_in\">isEmpty</span>()) {\n            System.out.<span class=\"hljs-built_in\">print</span>(stack.<span class=\"hljs-built_in\">pop</span>() + <span class=\"hljs-string\">&quot; &quot;</span>);\n        }\n    }\n}\n<span class=\"hljs-comment\">/* Output:\nfleas has dog My\n*/</span>\n</code></pre>\n<p>如果想在自己的代码中使用这个 <strong>Stack</strong> 类，当在创建其实例时，就需要完整指定包名，或者更改这个类的名称；否则，就有可能会与 <strong>java.util</strong> 包中的 <strong>Stack</strong> 发生冲突。例如，如果我们在上面的例子中导入 **java.util.***，那么就必须使用包名来防止冲突：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/StackCollision.java</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StackCollision</span> {\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">String</span>[] args)</span> </span>{\n    onjava.Stack&lt;<span class=\"hljs-type\">String</span>&gt; stack = <span class=\"hljs-keyword\">new</span> onjava.Stack&lt;&gt;();\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">String</span> s : <span class=\"hljs-string\">&quot;My dog has fleas&quot;</span>.<span class=\"hljs-built_in\">split</span>(<span class=\"hljs-string\">&quot; &quot;</span>))\n      stack.<span class=\"hljs-built_in\">push</span>(s);\n    <span class=\"hljs-keyword\">while</span>(!stack.<span class=\"hljs-built_in\">isEmpty</span>())\n      System.out.<span class=\"hljs-built_in\">print</span>(stack.<span class=\"hljs-built_in\">pop</span>() + <span class=\"hljs-string\">&quot; &quot;</span>);\n    System.out.<span class=\"hljs-built_in\">println</span>();\n    java.util.Stack&lt;<span class=\"hljs-type\">String</span>&gt; stack2 =\n      <span class=\"hljs-keyword\">new</span> java.util.Stack&lt;&gt;();\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">String</span> s : <span class=\"hljs-string\">&quot;My dog has fleas&quot;</span>.<span class=\"hljs-built_in\">split</span>(<span class=\"hljs-string\">&quot; &quot;</span>))\n      stack2.<span class=\"hljs-built_in\">push</span>(s);\n    <span class=\"hljs-keyword\">while</span>(!stack2.<span class=\"hljs-built_in\">empty</span>())\n      System.out.<span class=\"hljs-built_in\">print</span>(stack2.<span class=\"hljs-built_in\">pop</span>() + <span class=\"hljs-string\">&quot; &quot;</span>);\n  }\n}\n<span class=\"hljs-comment\">/* Output:\nfleas has dog My\nfleas has dog My\n*/</span>\n</code></pre>\n<p>尽管已经有了 <strong>java.util.Stack</strong> ，但是 <strong>ArrayDeque</strong> 可以产生更好的 <strong>Stack</strong> ，因此更可取。</p>\n<p>还可以使用显式导入来控制对“首选” <strong>Stack</strong> 实现的选择：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">import</span> onjava.<span class=\"hljs-built_in\">Stack</span>;\n</code></pre>\n<p>现在,任何对 <strong>Stack</strong> 的引用都将选择 <strong>onjava</strong> 版本，而在选择 <strong>java.util.Stack</strong> 时，必须使用全限定名称（full qualification）。</p>\n<h2 id=\"集合set\">集合Set</h2>\n<p><strong>Set</strong> 不保存重复的元素。 如果试图将相同对象的多个实例添加到 <strong>Set</strong> 中，那么它会阻止这种重复行为。 <strong>Set</strong> 最常见的用途是测试归属性，可以很轻松地询问某个对象是否在一个 <strong>Set</strong> 中。因此，查找通常是 <strong>Set</strong> 最重要的操作，因此通常会选择 <strong>HashSet</strong> 实现，该实现针对快速查找进行了优化。</p>\n<p><strong>Set</strong> 具有与 <strong>Collection</strong> 相同的接口，因此没有任何额外的功能，不像前面两种不同类型的 <strong>List</strong> 那样。实际上， <strong>Set</strong> 就是一个 <strong>Collection</strong> ，只是行为不同。（这是继承和多态思想的典型应用：表现不同的行为。）<strong>Set</strong> 根据对象的“值”确定归属性。</p>\n<p>下面是使用存放 <strong>Integer</strong> 对象的 <strong>HashSet</strong> 的示例：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/SetOfInteger.java</span>\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SetOfInteger</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-type\">Random</span> <span class=\"hljs-variable\">rand</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Random</span>(<span class=\"hljs-number\">47</span>);\n        Set&lt;Integer&gt; intset = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashSet</span>&lt;&gt;();\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10000</span>; i++) {\n            intset.add(rand.nextInt(<span class=\"hljs-number\">30</span>));\n        }\n        System.out.println(intset);\n    }\n}\n<span class=\"hljs-comment\">/* Output:\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,\n16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]\n*/</span>\n</code></pre>\n<p>在 0 到 29 之间的 10000 个随机整数被添加到 <strong>Set</strong> 中，因此可以想象每个值都重复了很多次。但是从结果中可以看到，每一个数只有一个实例出现在结果中。</p>\n<p>早期 Java 版本中的 <strong>HashSet</strong> 产生的输出没有可辨别的顺序。这是因为出于对速度的追求， <strong>HashSet</strong> 使用了散列。由 <strong>HashSet</strong> 维护的顺序与 <strong>TreeSet</strong> 或 <strong>LinkedHashSet</strong> 不同，因为它们的实现具有不同的元素存储方式。 <strong>TreeSet</strong> 将元素存储在红-黑树数据结构中，而 <strong>HashSet</strong> 使用散列函数。 <strong>LinkedHashSet</strong> 因为查询速度的原因也使用了散列，但是看起来使用了链表来维护元素的插入顺序。看起来散列算法好像已经改变了，现在 <strong>Integer</strong> 按顺序排序。但是，您不应该依赖此行为：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/SetOfString.java</span>\nimport java.util.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SetOfString</span> {\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>)</span> {\n    Set&lt;String&gt; colors = <span class=\"hljs-keyword\">new</span> HashSet&lt;&gt;();\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) {\n      colors.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-string\">&quot;Yellow&quot;</span>);\n      colors.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-string\">&quot;Blue&quot;</span>);\n      colors.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-string\">&quot;Red&quot;</span>);\n      colors.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-string\">&quot;Red&quot;</span>);\n      colors.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-string\">&quot;Orange&quot;</span>);\n      colors.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-string\">&quot;Yellow&quot;</span>);\n      colors.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-string\">&quot;Blue&quot;</span>);\n      colors.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-string\">&quot;Purple&quot;</span>);\n    }\n    System.<span class=\"hljs-keyword\">out</span>.println(colors);\n  }\n}\n<span class=\"hljs-comment\">/* Output:\n[Red, Yellow, Blue, Purple, Orange]\n*/</span>\n</code></pre>\n<p><strong>String</strong> 对象似乎没有排序。要对结果进行排序，一种方法是使用 <strong>TreeSet</strong> 而不是 <strong>HashSet</strong> ：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/SortedSetOfString.java</span>\nimport java.util.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SortedSetOfString</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>)</span> {\n        Set&lt;String&gt; colors = <span class=\"hljs-keyword\">new</span> TreeSet&lt;&gt;();\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) {\n            colors.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-string\">&quot;Yellow&quot;</span>);\n            colors.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-string\">&quot;Blue&quot;</span>);\n            colors.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-string\">&quot;Red&quot;</span>);\n            colors.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-string\">&quot;Red&quot;</span>);\n            colors.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-string\">&quot;Orange&quot;</span>);\n            colors.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-string\">&quot;Yellow&quot;</span>);\n            colors.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-string\">&quot;Blue&quot;</span>);\n            colors.<span class=\"hljs-keyword\">add</span>(<span class=\"hljs-string\">&quot;Purple&quot;</span>);\n        }\n        System.<span class=\"hljs-keyword\">out</span>.println(colors);\n    }\n}\n<span class=\"hljs-comment\">/* Output:\n[Blue, Orange, Purple, Red, Yellow]\n*/</span>\n</code></pre>\n<p>最常见的操作之一是使用 <code>contains()</code> 测试成员归属性，但也有一些其它操作，这可能会让你想起在小学学过的维恩图：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/SetOperations.java</span>\nimport java.util.*;\n\npublic <span class=\"hljs-keyword\">class</span> SetOperations {\n    public static void main(String<span class=\"hljs-literal\">[]</span> args) {\n        Set&lt;String&gt; set1 = <span class=\"hljs-keyword\">new</span> HashSet&lt;&gt;<span class=\"hljs-literal\">()</span>;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Collections</span>.</span></span>add<span class=\"hljs-constructor\">All(<span class=\"hljs-params\">set1</span>, <span class=\"hljs-string\">&quot;A B C D E F G H I J K L&quot;</span>.<span class=\"hljs-params\">split</span>(<span class=\"hljs-string\">&quot; &quot;</span>)</span>);\n        set1.add(<span class=\"hljs-string\">&quot;M&quot;</span>);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;H: &quot;</span> + set1.contains(<span class=\"hljs-string\">&quot;H&quot;</span>));\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;N: &quot;</span> + set1.contains(<span class=\"hljs-string\">&quot;N&quot;</span>));\n        Set&lt;String&gt; set2 = <span class=\"hljs-keyword\">new</span> HashSet&lt;&gt;<span class=\"hljs-literal\">()</span>;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Collections</span>.</span></span>add<span class=\"hljs-constructor\">All(<span class=\"hljs-params\">set2</span>, <span class=\"hljs-string\">&quot;H I J K L&quot;</span>.<span class=\"hljs-params\">split</span>(<span class=\"hljs-string\">&quot; &quot;</span>)</span>);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;set2 in set1: &quot;</span> + set1.contains<span class=\"hljs-constructor\">All(<span class=\"hljs-params\">set2</span>)</span>);\n        set1.remove(<span class=\"hljs-string\">&quot;H&quot;</span>);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;set1: &quot;</span> + set1);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;set2 in set1: &quot;</span> + set1.contains<span class=\"hljs-constructor\">All(<span class=\"hljs-params\">set2</span>)</span>);\n        set1.remove<span class=\"hljs-constructor\">All(<span class=\"hljs-params\">set2</span>)</span>;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;set2 removed from set1: &quot;</span> + set1);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Collections</span>.</span></span>add<span class=\"hljs-constructor\">All(<span class=\"hljs-params\">set1</span>, <span class=\"hljs-string\">&quot;X Y Z&quot;</span>.<span class=\"hljs-params\">split</span>(<span class=\"hljs-string\">&quot; &quot;</span>)</span>);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;&#x27;X Y Z&#x27; added to set1: &quot;</span> + set1);\n    }\n}\n<span class=\"hljs-comment\">/* Output:\nH: true\nN: false\nset2 in set1: true\nset1: [A, B, C, D, E, F, G, I, J, K, L, M]\nset2 in set1: false\nset2 removed from set1: [A, B, C, D, E, F, G, M]\n&#x27;X Y Z&#x27; added to set1: [A, B, C, D, E, F, G, M, X, Y, Z]\n*/</span>\n</code></pre>\n<p>这些方法名都是自解释的，JDK 文档中还有一些其它的方法。</p>\n<p>能够产生每个元素都唯一的列表是相当有用的功能。例如，假设想要列出上面的 <strong>SetOperations.java</strong> 文件中的所有单词，通过使用本书后面介绍的 <code>java.nio.file.Files.readAllLines()</code> 方法，可以打开一个文件，并将其作为一个 <strong>List&lt;String&gt;</strong> 读取，每个 <strong>String</strong> 都是输入文件中的一行：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/UniqueWords.java</span>\n<span class=\"hljs-keyword\">import</span> java.util.*;\n<span class=\"hljs-keyword\">import</span> java.nio.file.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UniqueWords</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">String</span>[] args)</span> throws Exception </span>{\n        List&lt;<span class=\"hljs-type\">String</span>&gt; lines = Files.<span class=\"hljs-built_in\">readAllLines</span>(Paths.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-string\">&quot;SetOperations.java&quot;</span>));\n        Set&lt;<span class=\"hljs-type\">String</span>&gt; words = <span class=\"hljs-keyword\">new</span> TreeSet&lt;&gt;();\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">String</span> line : lines) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">String</span> <span class=\"hljs-type\">word</span> : line.<span class=\"hljs-built_in\">split</span>(<span class=\"hljs-string\">&quot;\\\\W+&quot;</span>)) {\n                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-type\">word</span>.<span class=\"hljs-built_in\">trim</span>().<span class=\"hljs-built_in\">length</span>() &gt; <span class=\"hljs-number\">0</span>) {\n                    words.<span class=\"hljs-built_in\">add</span>(<span class=\"hljs-type\">word</span>);\n                }\n            }\n        }\n        System.out.<span class=\"hljs-built_in\">println</span>(words);\n    }\n}\n<span class=\"hljs-comment\">/* Output:\n[A, B, C, Collections, D, E, F, G, H, HashSet, I, J, K,\nL, M, N, Output, Set, SetOperations, String, System, X,\nY, Z, add, addAll, added, args, class, collections,\ncontains, containsAll, false, from, import, in, java,\nmain, new, out, println, public, remove, removeAll,\nremoved, set1, set2, split, static, to, true, util,\nvoid]\n*/</span>\n</code></pre>\n<p>我们逐步浏览文件中的每一行，并使用 <code>String.split()</code> 将其分解为单词，这里使用正则表达式 <strong>\\\\ W +</strong> ，这意味着它会依据一个或多个（即 <strong>+</strong> ）非单词字母来拆分字符串。每个结果单词都会添加到 <strong>Set words</strong> 中。因为它是 <strong>TreeSet</strong> ，所以对结果进行排序。这里，排序是按字典顺序（lexicographically）完成的，因此大写和小写字母位于不同的组中。如果想按字母顺序（alphabetically）对其进行排序，可以向 <strong>TreeSet</strong> 构造器传入 <strong>String.CASE_INSENSITIVE_ORDER</strong> 比较器（比较器是一个建立排序顺序的对象）：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/UniqueWordsAlphabetic.java</span>\n<span class=\"hljs-comment\">// Producing an alphabetic listing</span>\n<span class=\"hljs-keyword\">import</span> java.util.*;\n<span class=\"hljs-keyword\">import</span> java.nio.file.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">UniqueWordsAlphabetic</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">String</span>[] args)</span> throws Exception </span>{\n        List&lt;<span class=\"hljs-type\">String</span>&gt; lines = Files.<span class=\"hljs-built_in\">readAllLines</span>(Paths.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-string\">&quot;SetOperations.java&quot;</span>));\n        Set&lt;<span class=\"hljs-type\">String</span>&gt; words = <span class=\"hljs-keyword\">new</span> TreeSet&lt;&gt;(<span class=\"hljs-type\">String</span>.CASE_INSENSITIVE_ORDER);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">String</span> line : lines) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">String</span> <span class=\"hljs-type\">word</span> : line.<span class=\"hljs-built_in\">split</span>(<span class=\"hljs-string\">&quot;\\\\W+&quot;</span>)) {\n                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-type\">word</span>.<span class=\"hljs-built_in\">trim</span>().<span class=\"hljs-built_in\">length</span>() &gt; <span class=\"hljs-number\">0</span>) {\n                    words.<span class=\"hljs-built_in\">add</span>(<span class=\"hljs-type\">word</span>);\n                }\n            }\n        }\n        System.out.<span class=\"hljs-built_in\">println</span>(words);\n    }\n}\n<span class=\"hljs-comment\">/* Output:\n[A, add, addAll, added, args, B, C, class, collections,\ncontains, containsAll, D, E, F, false, from, G, H,\nHashSet, I, import, in, J, java, K, L, M, main, N, new,\nout, Output, println, public, remove, removeAll,\nremoved, Set, set1, set2, SetOperations, split, static,\nString, System, to, true, util, void, X, Y, Z]\n*/</span>\n</code></pre>\n<h2 id=\"映射map\">映射Map</h2>\n<p>将对象映射到其他对象的能力是解决编程问题的有效方法。例如，考虑一个程序，它被用来检查 Java 的 <strong>Random</strong> 类的随机性。理想情况下， <strong>Random</strong> 会产生完美的数字分布，但为了测试这一点，则需要生成大量的随机数，并计算落在各种范围内的数字个数。 <strong>Map</strong> 可以很容易地解决这个问题。在本例中，键是 <strong>Random</strong> 生成的数字，而值是该数字出现的次数：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/Statistics.java</span>\n<span class=\"hljs-comment\">// Simple demonstration of HashMap</span>\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Statistics</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n    <span class=\"hljs-type\">Random</span> <span class=\"hljs-variable\">rand</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Random</span>(<span class=\"hljs-number\">47</span>);\n    Map&lt;Integer, Integer&gt; m = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10000</span>; i++) {\n      <span class=\"hljs-comment\">// Produce a number between 0 and 20:</span>\n      <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">r</span> <span class=\"hljs-operator\">=</span> rand.nextInt(<span class=\"hljs-number\">20</span>);\n      <span class=\"hljs-type\">Integer</span> <span class=\"hljs-variable\">freq</span> <span class=\"hljs-operator\">=</span> m.get(r); <span class=\"hljs-comment\">// [1]</span>\n      m.put(r, freq == <span class=\"hljs-literal\">null</span> ? <span class=\"hljs-number\">1</span> : freq + <span class=\"hljs-number\">1</span>);\n    }\n    System.out.println(m);\n  }\n}\n<span class=\"hljs-comment\">/* Output:\n{0=481, 1=502, 2=489, 3=508, 4=481, 5=503, 6=519,\n7=471, 8=468, 9=549, 10=513, 11=531, 12=521, 13=506,\n14=477, 15=497, 16=533, 17=509, 18=478, 19=464}\n*/</span>\n</code></pre>\n<p>**[1]**自动包装机制将随机生成的 <strong>int</strong> 转换为可以与 <strong>HashMap</strong> 一起使用的 <strong>Integer</strong> 引用（不能使用基本类型的集合）。如果键不在集合中，则 <code>get()</code> 返回 <strong>null</strong> （这意味着该数字第一次出现）。否则， <code>get()</code> 会为键生成与之关联的 <strong>Integer</strong> 值，然后该值被递增（自动包装机制再次简化了表达式，但实际上确实发生了对 <strong>Integer</strong> 的装箱和拆箱）。</p>\n<p>接下来的示例将使用一个 <strong>String</strong> 描述来查找 <strong>Pet</strong> 对象。它还展示了通过使用 <code>containsKey()</code> 和 <code>containsValue()</code> 方法去测试一个 <strong>Map</strong> ，以查看它是否包含某个键或某个值：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/PetMap.java</span>\n<span class=\"hljs-keyword\">import</span> typeinfo.pets.*;\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PetMap</span> </span>{\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> void main(<span class=\"hljs-keyword\">String</span>[] args) {\n    Map&lt;<span class=\"hljs-keyword\">String</span>, Pet&gt; petMap = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">HashMap</span>&lt;&gt;();\n    petMap.put(<span class=\"hljs-string\">&quot;My Cat&quot;</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Cat</span>(<span class=\"hljs-string\">&quot;Molly&quot;</span>));\n    petMap.put(<span class=\"hljs-string\">&quot;My Dog&quot;</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Dog</span>(<span class=\"hljs-string\">&quot;Ginger&quot;</span>));\n    petMap.put(<span class=\"hljs-string\">&quot;My Hamster&quot;</span>, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Hamster</span>(<span class=\"hljs-string\">&quot;Bosco&quot;</span>));\n    System.out.println(petMap);\n    Pet dog = petMap.<span class=\"hljs-keyword\">get</span>(<span class=\"hljs-string\">&quot;My Dog&quot;</span>);\n    System.out.println(dog);\n    System.out.println(petMap.containsKey(<span class=\"hljs-string\">&quot;My Dog&quot;</span>));\n    System.out.println(petMap.containsValue(dog));\n  }\n}\n<span class=\"hljs-comment\">/* Output:\n{My Dog=Dog Ginger, My Cat=Cat Molly, My Hamster=Hamster Bosco}\nDog Ginger\ntrue\ntrue\n*/</span>\n</code></pre>\n<p><strong>Map</strong> 与数组和其他的 <strong>Collection</strong> 一样，可以轻松地扩展到多个维度，只需要创建一个值为 <strong>Map</strong> 的 <strong>Map</strong>（这些 <strong>Map</strong> 的值可以是其他集合，甚至是其他 <strong>Map</strong>）。因此，能够很容易地将集合组合起来以快速生成强大的数据结构。例如，假设你正在追踪有多个宠物的人，只需要一个 <strong>Map&lt;Person, List&lt;Pet&gt;&gt;</strong> 即可：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/MapOfList.java</span>\n<span class=\"hljs-comment\">// {java collections.MapOfList}</span>\n<span class=\"hljs-keyword\">package</span> collections;\n<span class=\"hljs-keyword\">import</span> typeinfo.pets.*;\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MapOfList</span> </span>{\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> final Map&lt;Person, List&lt;? extends Pet&gt;&gt; petPeople = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">HashMap</span>&lt;&gt;();\n\n    <span class=\"hljs-keyword\">static</span> {\n        petPeople.put(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Person</span>(<span class=\"hljs-string\">&quot;Dawn&quot;</span>),\n                Arrays.asList(\n                        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Cymric</span>(<span class=\"hljs-string\">&quot;Molly&quot;</span>),\n                        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Mutt</span>(<span class=\"hljs-string\">&quot;Spot&quot;</span>)));\n        petPeople.put(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Person</span>(<span class=\"hljs-string\">&quot;Kate&quot;</span>),\n                Arrays.asList(\n                        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Cat</span>(<span class=\"hljs-string\">&quot;Shackleton&quot;</span>),\n                        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Cat</span>(<span class=\"hljs-string\">&quot;Elsie May&quot;</span>),\n                        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Dog</span>(<span class=\"hljs-string\">&quot;Margrett&quot;</span>)));\n        petPeople.put(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Person</span>(<span class=\"hljs-string\">&quot;Marilyn&quot;</span>),\n                Arrays.asList(\n                        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Pug</span>(<span class=\"hljs-string\">&quot;Louie aka Louis Snorkelstein Dupree&quot;</span>),\n                        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Cat</span>(<span class=\"hljs-string\">&quot;Stanford&quot;</span>),\n                        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Cat</span>(<span class=\"hljs-string\">&quot;Pinkola&quot;</span>)));\n        petPeople.put(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Person</span>(<span class=\"hljs-string\">&quot;Luke&quot;</span>),\n                Arrays.asList(\n                        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Rat</span>(<span class=\"hljs-string\">&quot;Fuzzy&quot;</span>),\n                        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Rat</span>(<span class=\"hljs-string\">&quot;Fizzy&quot;</span>)));\n        petPeople.put(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Person</span>(<span class=\"hljs-string\">&quot;Isaac&quot;</span>),\n                Arrays.asList(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Rat</span>(<span class=\"hljs-string\">&quot;Freckly&quot;</span>)));\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> void main(<span class=\"hljs-keyword\">String</span>[] args) {\n        System.out.println(<span class=\"hljs-string\">&quot;People: &quot;</span> + petPeople.keySet());\n        System.out.println(<span class=\"hljs-string\">&quot;Pets: &quot;</span> + petPeople.values());\n        <span class=\"hljs-keyword\">for</span> (Person person : <span class=\"hljs-type\">petPeople</span>.keySet()) {\n            System.out.println(person + <span class=\"hljs-string\">&quot; has:&quot;</span>);\n            <span class=\"hljs-keyword\">for</span> (Pet pet : <span class=\"hljs-type\">petPeople</span>.<span class=\"hljs-keyword\">get</span>(person)) {\n                System.out.println(<span class=\"hljs-string\">&quot;    &quot;</span> + pet);\n            }\n        }\n    }\n}\n<span class=\"hljs-comment\">/* Output:\nPeople: [Person Dawn, Person Kate, Person Isaac, Person Marilyn, Person Luke]\nPets: [[Cymric Molly, Mutt Spot], [Cat Shackleton, Cat Elsie May, Dog Margrett], [Rat Freckly], [Pug Louie aka Louis Snorkelstein Dupree, Cat Stanford, Cat Pinkola],[Rat Fuzzy, Rat Fizzy]]\nPerson Dawn has:\n    Cymric Molly\n    Mutt Spot\nPerson Kate has:\n    Cat Shackleton\n    Cat Elsie May\n    Dog Margrett\nPerson Isaac has:\n    Rat Freckly\nPerson Marilyn has:\n    Pug Louie aka Louis Snorkelstein Dupree\n    Cat Stanford\n    Cat Pinkola\nPerson Luke has:\n    Rat Fuzzy\n    Rat Fizzy\n*/</span>\n</code></pre>\n<p><strong>Map</strong> 可以返回由其键组成的 <strong>Set</strong> ，由其值组成的 <strong>Collection</strong> ，或者其键值对的 <strong>Set</strong> 。 <code>keySet()</code> 方法生成由在 <strong>petPeople</strong> 中的所有键组成的 <strong>Set</strong> ，它在 for-in 语句中被用来遍历该 <strong>Map</strong> 。</p>\n<h2 id=\"队列queue\">队列Queue</h2>\n<p>队列是一个典型的“先进先出”（FIFO）集合。 即从集合的一端放入事物，再从另一端去获取它们，事物放入集合的顺序和被取出的顺序是相同的。队列通常被当做一种可靠的将对象从程序的某个区域传输到另一个区域的途径。队列在并发编程中尤为重要，因为它们可以安全地将对象从一个任务传输到另一个任务。</p>\n<p><strong>LinkedList</strong> 实现了 <strong>Queue</strong> 接口，并且提供了一些方法以支持队列行为，因此 <strong>LinkedList</strong> 可以用作 <strong>Queue</strong> 的一种实现。 通过将 <strong>LinkedList</strong> 向上转换为 <strong>Queue</strong> ，下面的示例使用了在 <strong>Queue</strong> 接口中与 <strong>Queue</strong> 相关(Queue-specific)的方法：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/QueueDemo.java</span>\n<span class=\"hljs-comment\">// Upcasting to a Queue from a LinkedList</span>\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">QueueDemo</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">printQ</span><span class=\"hljs-params\">(Queue queue)</span> </span>{\n        <span class=\"hljs-keyword\">while</span> (queue.<span class=\"hljs-built_in\">peek</span>() != null) {\n            System.out.<span class=\"hljs-built_in\">print</span>(queue.<span class=\"hljs-built_in\">remove</span>() + <span class=\"hljs-string\">&quot; &quot;</span>);\n        }\n        System.out.<span class=\"hljs-built_in\">println</span>();\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">String</span>[] args)</span> </span>{\n        Queue&lt;Integer&gt; queue = <span class=\"hljs-keyword\">new</span> LinkedList&lt;&gt;();\n        Random rand = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Random</span>(<span class=\"hljs-number\">47</span>);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) {\n            queue.<span class=\"hljs-built_in\">offer</span>(rand.<span class=\"hljs-built_in\">nextInt</span>(i + <span class=\"hljs-number\">10</span>));\n        }\n        <span class=\"hljs-built_in\">printQ</span>(queue);\n        Queue&lt;Character&gt; qc = <span class=\"hljs-keyword\">new</span> LinkedList&lt;&gt;();\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">char</span> c : <span class=\"hljs-string\">&quot;Brontosaurus&quot;</span>.<span class=\"hljs-built_in\">toCharArray</span>()) {\n            qc.<span class=\"hljs-built_in\">offer</span>(c);\n        }\n        <span class=\"hljs-built_in\">printQ</span>(qc);\n    }\n}\n<span class=\"hljs-comment\">/* Output:\n8 1 1 1 5 14 3 1 0 1\nB r o n t o s a u r u s\n*/</span>\n</code></pre>\n<p><code>offer()</code> 是与 <strong>Queue</strong> 相关的方法之一，它在允许的情况下，在队列的尾部插入一个元素，或者返回 <strong>false</strong> 。 <code>peek()</code> 和 <code>element()</code> 都返回队头元素而不删除它，但是如果队列为空，则 <code>element()</code> 抛出 <strong>NoSuchElementException</strong> ，而 <code>peek()</code> 返回 <strong>null</strong> 。 <code>poll()</code> 和 <code>remove()</code> 都删除并返回队头元素，但如果队列为空，<code>poll()</code> 返回 <strong>null</strong> ，而 <code>remove()</code> 抛出 <strong>NoSuchElementException</strong> 。</p>\n<p>自动包装机制会自动将 <code>nextInt()</code> 的 <strong>int</strong> 结果转换为 <strong>queue</strong> 所需的 <strong>Integer</strong> 对象，并将 <strong>char c</strong> 转换为 <strong>qc</strong> 所需的 <strong>Character</strong> 对象。 <strong>Queue</strong> 接口窄化了对 <strong>LinkedList</strong> 方法的访问权限，因此只有适当的方法才能使用，因此能够访问到的 <strong>LinkedList</strong> 的方法会变少（这里实际上可以将 <strong>Queue</strong> 强制转换回 <strong>LinkedList</strong> ，但至少我们不鼓励这样做）。</p>\n<p>TODO 不了解自动包装机制。2020年10月13日</p>\n<p>与 <strong>Queue</strong> 相关的方法提供了完整而独立的功能。 也就是说，对于 <strong>Queue</strong> 所继承的 <strong>Collection</strong> ，在不需要使用它的任何方法的情况下，就可以拥有一个可用的 <strong>Queue</strong> 。</p>\n<h2 id=\"优先级队列priorityqueue\">优先级队列PriorityQueue</h2>\n<p>先进先出（FIFO）描述了最典型的队列规则（queuing discipline）。队列规则是指在给定队列中的一组元素的情况下，确定下一个弹出队列的元素的规则。先进先出声明的是下一个弹出的元素应该是等待时间最长的元素。</p>\n<p>优先级队列声明下一个弹出的元素是最需要的元素（具有最高的优先级）。例如，在机场，当飞机临近起飞时，这架飞机的乘客可以在办理登机手续时排到队头。如果构建了一个消息传递系统，某些消息比其他消息更重要，应该尽快处理，而不管它们何时到达。在Java 5 中添加了 <strong>PriorityQueue</strong> ，以便自动实现这种行为。</p>\n<p>当在 <strong>PriorityQueue</strong> 上调用 <code>offer()</code> 方法来插入一个对象时，该对象会在队列中被排序。默认的排序使用队列中对象的自然顺序（natural order），但是可以通过提供自己的 <strong>Comparator</strong> 来修改这个顺序。 <strong>PriorityQueue</strong> 确保在调用 <code>peek()</code> ， <code>poll()</code> 或 <code>remove()</code> 方法时，获得的元素将是队列中优先级最高的元素。</p>\n<p>让 <strong>PriorityQueue</strong> 与 <strong>Integer</strong> ， <strong>String</strong> 和 <strong>Character</strong> 这样的内置类型一起工作易如反掌。在下面的示例中，第一组值与前一个示例中的随机值相同，可以看到它们从 <strong>PriorityQueue</strong> 中弹出的顺序与前一个示例不同：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-operator\">//</span> <span class=\"hljs-variable\">collections</span><span class=\"hljs-operator\">/</span><span class=\"hljs-variable\">PriorityQueueDemo</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">java</span>\n<span class=\"hljs-variable\">import</span> <span class=\"hljs-variable\">java</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">util</span><span class=\"hljs-operator\">.*;</span>\n\n<span class=\"hljs-variable\">public</span> <span class=\"hljs-variable\">class</span> <span class=\"hljs-variable\">PriorityQueueDemo</span> <span class=\"hljs-punctuation\">{</span>\n    <span class=\"hljs-variable\">public</span> <span class=\"hljs-variable\">static</span> <span class=\"hljs-variable\">void</span> <span class=\"hljs-variable\">main</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-built_in\">String</span><span class=\"hljs-punctuation\">[</span><span class=\"hljs-punctuation\">]</span> <span class=\"hljs-variable\">args</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-punctuation\">{</span>\n        <span class=\"hljs-variable\">PriorityQueue</span><span class=\"hljs-operator\">&lt;</span><span class=\"hljs-built_in\">Integer</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-variable\">priorityQueue</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">new</span> <span class=\"hljs-variable\">PriorityQueue</span><span class=\"hljs-operator\">&lt;&gt;</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n        <span class=\"hljs-built_in\">Random</span> <span class=\"hljs-variable\">rand</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">new</span> <span class=\"hljs-built_in\">Random</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">47</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n        <span class=\"hljs-variable\">for</span> <span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span><span class=\"hljs-operator\">;</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">&lt;</span> <span class=\"hljs-number\">10</span><span class=\"hljs-operator\">;</span> <span class=\"hljs-variable\">i</span><span class=\"hljs-operator\">++</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-punctuation\">{</span>\n            <span class=\"hljs-variable\">priorityQueue</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">offer</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">rand</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">nextInt</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">10</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n        <span class=\"hljs-punctuation\">}</span>\n        <span class=\"hljs-variable\">QueueDemo</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">printQ</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">priorityQueue</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n\n        <span class=\"hljs-built_in\">List</span><span class=\"hljs-operator\">&lt;</span><span class=\"hljs-built_in\">Integer</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-variable\">ints</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">Arrays</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">asList</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-number\">25</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">22</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">20</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">18</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">14</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">9</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">3</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">1</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">1</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">2</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">3</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">9</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">14</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">18</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">21</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">23</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-number\">25</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n        <span class=\"hljs-variable\">priorityQueue</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">new</span> <span class=\"hljs-variable\">PriorityQueue</span><span class=\"hljs-operator\">&lt;&gt;</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">ints</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n        <span class=\"hljs-variable\">QueueDemo</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">printQ</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">priorityQueue</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n        <span class=\"hljs-variable\">priorityQueue</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">new</span> <span class=\"hljs-variable\">PriorityQueue</span><span class=\"hljs-operator\">&lt;&gt;</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">ints</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">size</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">Collections</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">reverseOrder</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n        <span class=\"hljs-variable\">priorityQueue</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">addAll</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">ints</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n        <span class=\"hljs-variable\">QueueDemo</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">printQ</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">priorityQueue</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n\n        <span class=\"hljs-built_in\">String</span> <span class=\"hljs-variable\">fact</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;EDUCATION SHOULD ESCHEW OBFUSCATION&quot;</span><span class=\"hljs-operator\">;</span>\n        <span class=\"hljs-built_in\">List</span><span class=\"hljs-operator\">&lt;</span><span class=\"hljs-built_in\">String</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-variable\">strings</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">Arrays</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">asList</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">fact</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">split</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-string\">&quot;&quot;</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n        <span class=\"hljs-variable\">PriorityQueue</span><span class=\"hljs-operator\">&lt;</span><span class=\"hljs-built_in\">String</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-variable\">stringPQ</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">new</span> <span class=\"hljs-variable\">PriorityQueue</span><span class=\"hljs-operator\">&lt;&gt;</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">strings</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n        <span class=\"hljs-variable\">QueueDemo</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">printQ</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">stringPQ</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n        <span class=\"hljs-variable\">stringPQ</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">new</span> <span class=\"hljs-variable\">PriorityQueue</span><span class=\"hljs-operator\">&lt;&gt;</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">strings</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">size</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">,</span> <span class=\"hljs-variable\">Collections</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">reverseOrder</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n        <span class=\"hljs-variable\">stringPQ</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">addAll</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">strings</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n        <span class=\"hljs-variable\">QueueDemo</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">printQ</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">stringPQ</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n\n        <span class=\"hljs-built_in\">Set</span><span class=\"hljs-operator\">&lt;</span><span class=\"hljs-built_in\">Character</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-variable\">charSet</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">new</span> <span class=\"hljs-variable\">HashSet</span><span class=\"hljs-operator\">&lt;&gt;</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n        <span class=\"hljs-variable\">for</span> <span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">char</span> <span class=\"hljs-variable\">c</span> <span class=\"hljs-operator\">:</span> <span class=\"hljs-variable\">fact</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">toCharArray</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-punctuation\">)</span> <span class=\"hljs-punctuation\">{</span>\n            <span class=\"hljs-variable\">charSet</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">add</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">c</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span> <span class=\"hljs-operator\">//</span> <span class=\"hljs-variable\">Autoboxing</span>\n        <span class=\"hljs-punctuation\">}</span>\n        <span class=\"hljs-variable\">PriorityQueue</span><span class=\"hljs-operator\">&lt;</span><span class=\"hljs-built_in\">Character</span><span class=\"hljs-operator\">&gt;</span> <span class=\"hljs-variable\">characterPQ</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">new</span> <span class=\"hljs-variable\">PriorityQueue</span><span class=\"hljs-operator\">&lt;&gt;</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">charSet</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n        <span class=\"hljs-variable\">QueueDemo</span><span class=\"hljs-operator\">.</span><span class=\"hljs-variable\">printQ</span><span class=\"hljs-punctuation\">(</span><span class=\"hljs-variable\">characterPQ</span><span class=\"hljs-punctuation\">)</span><span class=\"hljs-operator\">;</span>\n    <span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-punctuation\">}</span>\n<span class=\"hljs-operator\">/*</span> <span class=\"hljs-variable\">Output</span><span class=\"hljs-operator\">:</span>\n<span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">14</span> \n<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">9</span> <span class=\"hljs-number\">9</span> <span class=\"hljs-number\">14</span> <span class=\"hljs-number\">14</span> <span class=\"hljs-number\">18</span> <span class=\"hljs-number\">18</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-number\">21</span> <span class=\"hljs-number\">22</span> <span class=\"hljs-number\">23</span> <span class=\"hljs-number\">25</span> <span class=\"hljs-number\">25</span> \n<span class=\"hljs-number\">25</span> <span class=\"hljs-number\">25</span> <span class=\"hljs-number\">23</span> <span class=\"hljs-number\">22</span> <span class=\"hljs-number\">21</span> <span class=\"hljs-number\">20</span> <span class=\"hljs-number\">18</span> <span class=\"hljs-number\">18</span> <span class=\"hljs-number\">14</span> <span class=\"hljs-number\">14</span> <span class=\"hljs-number\">9</span> <span class=\"hljs-number\">9</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">1</span> \n      <span class=\"hljs-variable\">A</span> <span class=\"hljs-variable\">A</span> <span class=\"hljs-variable\">B</span> <span class=\"hljs-built_in\">C</span> <span class=\"hljs-built_in\">C</span> <span class=\"hljs-built_in\">C</span> <span class=\"hljs-built_in\">D</span> <span class=\"hljs-built_in\">D</span> <span class=\"hljs-built_in\">E</span> <span class=\"hljs-built_in\">E</span> <span class=\"hljs-built_in\">E</span> <span class=\"hljs-variable\">F</span> <span class=\"hljs-variable\">H</span> <span class=\"hljs-variable\">H</span> <span class=\"hljs-built_in\">I</span> <span class=\"hljs-built_in\">I</span> <span class=\"hljs-variable\">L</span> <span class=\"hljs-built_in\">N</span> <span class=\"hljs-built_in\">N</span> <span class=\"hljs-built_in\">O</span> <span class=\"hljs-built_in\">O</span> <span class=\"hljs-built_in\">O</span> <span class=\"hljs-built_in\">O</span> <span class=\"hljs-variable\">S</span> <span class=\"hljs-variable\">S</span> <span class=\"hljs-variable\">S</span> <span class=\"hljs-variable\">T</span> <span class=\"hljs-variable\">T</span> <span class=\"hljs-variable\">U</span> <span class=\"hljs-variable\">U</span> <span class=\"hljs-variable\">U</span> <span class=\"hljs-variable\">W</span> \n<span class=\"hljs-variable\">W</span> <span class=\"hljs-variable\">U</span> <span class=\"hljs-variable\">U</span> <span class=\"hljs-variable\">U</span> <span class=\"hljs-variable\">T</span> <span class=\"hljs-variable\">T</span> <span class=\"hljs-variable\">S</span> <span class=\"hljs-variable\">S</span> <span class=\"hljs-variable\">S</span> <span class=\"hljs-built_in\">O</span> <span class=\"hljs-built_in\">O</span> <span class=\"hljs-built_in\">O</span> <span class=\"hljs-built_in\">O</span> <span class=\"hljs-built_in\">N</span> <span class=\"hljs-built_in\">N</span> <span class=\"hljs-variable\">L</span> <span class=\"hljs-built_in\">I</span> <span class=\"hljs-built_in\">I</span> <span class=\"hljs-variable\">H</span> <span class=\"hljs-variable\">H</span> <span class=\"hljs-variable\">F</span> <span class=\"hljs-built_in\">E</span> <span class=\"hljs-built_in\">E</span> <span class=\"hljs-built_in\">E</span> <span class=\"hljs-built_in\">D</span> <span class=\"hljs-built_in\">D</span> <span class=\"hljs-built_in\">C</span> <span class=\"hljs-built_in\">C</span> <span class=\"hljs-built_in\">C</span> <span class=\"hljs-variable\">B</span> <span class=\"hljs-variable\">A</span> <span class=\"hljs-variable\">A</span>       \n  <span class=\"hljs-variable\">A</span> <span class=\"hljs-variable\">B</span> <span class=\"hljs-built_in\">C</span> <span class=\"hljs-built_in\">D</span> <span class=\"hljs-built_in\">E</span> <span class=\"hljs-variable\">F</span> <span class=\"hljs-variable\">H</span> <span class=\"hljs-built_in\">I</span> <span class=\"hljs-variable\">L</span> <span class=\"hljs-built_in\">N</span> <span class=\"hljs-built_in\">O</span> <span class=\"hljs-variable\">S</span> <span class=\"hljs-variable\">T</span> <span class=\"hljs-variable\">U</span> <span class=\"hljs-variable\">W</span> \n<span class=\"hljs-operator\">*/</span>\n</code></pre>\n<p><strong>PriorityQueue</strong> 是允许重复的，最小的值具有最高的优先级（如果是 <strong>String</strong> ，空格也可以算作值，并且比字母的优先级高）。为了展示如何通过提供自己的 <strong>Comparator</strong> 对象来改变顺序，第三个对 <strong>PriorityQueue&lt;Integer&gt;</strong> 构造器的调用，和第二个对 <strong>PriorityQueue&lt;String&gt;</strong> 的调用使用了由 <code>Collections.reverseOrder()</code> （Java 5 中新添加的）产生的反序的 <strong>Comparator</strong> 。</p>\n<p>最后一部分添加了一个 <strong>HashSet</strong> 来消除重复的 <strong>Character</strong>。</p>\n<p><strong>Integer</strong> ， <strong>String</strong> 和 <strong>Character</strong> 可以与 <strong>PriorityQueue</strong> 一起使用，因为这些类已经内置了自然排序。如果想在 <strong>PriorityQueue</strong> 中使用自己的类，则必须包含额外的功能以产生自然排序，或者必须提供自己的 <strong>Comparator</strong> 。</p>\n<h2 id=\"集合与迭代器\">集合与迭代器</h2>\n<p>TODO 本节有许多问题不理解，需要巩固。2020年10月13日</p>\n<p><strong>Collection</strong> 是所有序列集合共有的根接口。它可能会被认为是一种“附属接口”（incidental interface），即因为要表示其他若干个接口的共性而出现的接口。此外，<strong>java.util.AbstractCollection</strong> 类提供了 <strong>Collection</strong> 的默认实现，使得你可以创建 <strong>AbstractCollection</strong> 的子类型，而其中没有不必要的代码重复。</p>\n<p>使用接口描述的一个理由是它可以使我们创建更通用的代码。通过针对接口而非具体实现来编写代码，我们的代码可以应用于更多类型的对象。因此，如果所编写的方法接受一个 <strong>Collection</strong> ，那么该方法可以应用于任何实现了 <strong>Collection</strong> 的类——这也就使得一个新类可以选择去实现 <strong>Collection</strong> 接口，以便该方法可以使用它。标准 C++ 类库中的集合并没有共同的基类——集合之间的所有共性都是通过迭代器实现的。在 Java 中，遵循 C++ 的方式看起来似乎很明智，即用迭代器而不是 <strong>Collection</strong> 来表示集合之间的共性。但是，这两种方法绑定在了一起，因为实现 <strong>Collection</strong> 就意味着需要提供 <code>iterator()</code> 方法：</p>\n<pre><code class=\"hljs language-java\">/<span class=\"hljs-regexp\">/ collections/</span>InterfaceVsIterator.java\nimport typeinfo.pets.*;\nimport java.util.*;\n\npublic <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">InterfaceVsIterator</span> {</span>\n    public static void display(Iterator&lt;Pet&gt; it) {\n        <span class=\"hljs-keyword\">while</span> (it.hasNext()) {\n            Pet p = it.<span class=\"hljs-keyword\">next</span>();\n            System.out.print(p.id() + <span class=\"hljs-string\">&quot;:&quot;</span> + p + <span class=\"hljs-string\">&quot; &quot;</span>);\n        }\n        System.out.println();\n    }\n\n    public static void display(Collection&lt;Pet&gt; pets) {\n        <span class=\"hljs-keyword\">for</span> (Pet p : pets) {\n            System.out.print(p.id() + <span class=\"hljs-string\">&quot;:&quot;</span> + p + <span class=\"hljs-string\">&quot; &quot;</span>);\n        }\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        List&lt;Pet&gt; petList = Pets.list(<span class=\"hljs-number\">8</span>);\n        Set&lt;Pet&gt; petSet = new HashSet&lt;&gt;(petList);\n        Map&lt;String, Pet&gt; petMap = new LinkedHashMap&lt;&gt;();\n        String[] names = (<span class=\"hljs-string\">&quot;Ralph, Eric, Robin, Lacey, &quot;</span> + <span class=\"hljs-string\">&quot;Britney, Sam, Spot, Fluffy&quot;</span>).split(<span class=\"hljs-string\">&quot;, &quot;</span>);\n        <span class=\"hljs-keyword\">for</span> (int i = <span class=\"hljs-number\">0</span>; i &lt; names.length; i++) {\n            petMap.put(names[i], petList.get(i));\n        }\n        display(petList);\n        display(petSet);\n        display(petList.iterator());\n        display(petSet.iterator());\n        System.out.println(petMap);\n        System.out.println(petMap.keySet());\n        display(petMap.values());\n        display(petMap.values().iterator());\n    }\n}\n/* <span class=\"hljs-symbol\">Output:</span>\n<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:Rat</span> <span class=\"hljs-number\">1</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">2</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">3</span><span class=\"hljs-symbol\">:Mutt</span> <span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">5</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">6</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">7</span><span class=\"hljs-symbol\">:Manx</span> \n<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:Rat</span> <span class=\"hljs-number\">1</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">2</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">3</span><span class=\"hljs-symbol\">:Mutt</span> <span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">5</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">6</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">7</span><span class=\"hljs-symbol\">:Manx</span> \n<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:Rat</span> <span class=\"hljs-number\">1</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">2</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">3</span><span class=\"hljs-symbol\">:Mutt</span> <span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">5</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">6</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">7</span><span class=\"hljs-symbol\">:Manx</span> \n<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:Rat</span> <span class=\"hljs-number\">1</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">2</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">3</span><span class=\"hljs-symbol\">:Mutt</span> <span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">5</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">6</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">7</span><span class=\"hljs-symbol\">:Manx</span> \n{Ralph=Rat, Eric=Manx, Robin=Cymric, Lacey=Mutt, Britney=Pug, Sam=Cymric, Spot=Pug, Fluffy=Manx}\n[Ralph, Eric, Robin, Lacey, Britney, Sam, Spot, Fluffy]\n<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:Rat</span> <span class=\"hljs-number\">1</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">2</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">3</span><span class=\"hljs-symbol\">:Mutt</span> <span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">5</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">6</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">7</span><span class=\"hljs-symbol\">:Manx</span> \n<span class=\"hljs-number\">0</span><span class=\"hljs-symbol\">:Rat</span> <span class=\"hljs-number\">1</span><span class=\"hljs-symbol\">:Manx</span> <span class=\"hljs-number\">2</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">3</span><span class=\"hljs-symbol\">:Mutt</span> <span class=\"hljs-number\">4</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">5</span><span class=\"hljs-symbol\">:Cymric</span> <span class=\"hljs-number\">6</span><span class=\"hljs-symbol\">:Pug</span> <span class=\"hljs-number\">7</span><span class=\"hljs-symbol\">:Manx</span> \n*<span class=\"hljs-regexp\">/</span>\n</code></pre>\n<p>两个版本的 <code>display()</code> 方法都可以使用 <strong>Map</strong> 或 <strong>Collection</strong> 的子类型来工作。 而且<strong>Collection</strong> 接口和 <strong>Iterator</strong> 都将 <code>display()</code> 方法与低层集合的特定实现解耦。</p>\n<p>在本例中，这两种方式都可以奏效。事实上， <strong>Collection</strong> 要更方便一点，因为它是 <strong>Iterable</strong> 类型，因此在 <code>display(Collection)</code> 的实现中可以使用 for-in 构造，这使得代码更加清晰。</p>\n<p>当需要实现一个不是 <strong>Collection</strong> 的外部类时，由于让它去实现 <strong>Collection</strong> 接口可能非常困难或麻烦，因此使用 <strong>Iterator</strong> 就会变得非常吸引人。例如，如果我们通过继承一个持有 <strong>Pet</strong> 对象的类来创建一个 <strong>Collection</strong> 的实现，那么我们必须实现 <strong>Collection</strong> 所有的方法，即使我们不在 <code>display()</code> 方法中使用它们，也必须这样做。虽然这可以通过继承 <strong>AbstractCollection</strong> 而很容易地实现，但是无论如何还是要被强制去实现 <code>iterator()</code> 和 <code>size()</code> 方法，这些方法 <strong>AbstractCollection</strong> 没有实现，但是 <strong>AbstractCollection</strong> 中的其它方法会用到：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/CollectionSequence.java</span>\n<span class=\"hljs-keyword\">import</span> typeinfo.<span class=\"hljs-property\">pets</span>.*;\n<span class=\"hljs-keyword\">import</span> java.<span class=\"hljs-property\">util</span>.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CollectionSequence</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">AbstractCollection</span>&lt;<span class=\"hljs-title class_\">Pet</span>&gt; {\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-title class_\">Pet</span>[] pets = <span class=\"hljs-title class_\">Pets</span>.<span class=\"hljs-title function_\">array</span>(<span class=\"hljs-number\">8</span>);\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> int <span class=\"hljs-title function_\">size</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">return</span> pets.<span class=\"hljs-property\">length</span>;\n    }\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">Iterator</span>&lt;<span class=\"hljs-title class_\">Pet</span>&gt; <span class=\"hljs-title function_\">iterator</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Iterator</span>&lt;<span class=\"hljs-title class_\">Pet</span>&gt;() { <span class=\"hljs-comment\">// [1]</span>\n            <span class=\"hljs-keyword\">private</span> int index = <span class=\"hljs-number\">0</span>;\n\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">boolean</span> <span class=\"hljs-title function_\">hasNext</span>(<span class=\"hljs-params\"></span>) {\n                <span class=\"hljs-keyword\">return</span> index &lt; pets.<span class=\"hljs-property\">length</span>;\n            }\n\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">Pet</span> <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>) {\n                <span class=\"hljs-keyword\">return</span> pets[index++];\n            }\n\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">remove</span>(<span class=\"hljs-params\"></span>) { <span class=\"hljs-comment\">// Not implemented</span>\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">UnsupportedOperationException</span>();\n            }\n        };\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-title class_\">CollectionSequence</span> c = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CollectionSequence</span>();\n        <span class=\"hljs-title class_\">InterfaceVsIterator</span>.<span class=\"hljs-title function_\">display</span>(c);\n        <span class=\"hljs-title class_\">InterfaceVsIterator</span>.<span class=\"hljs-title function_\">display</span>(c.<span class=\"hljs-title function_\">iterator</span>());\n    }\n}\n<span class=\"hljs-comment\">/* Output:\n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx \n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug 7:Manx \n*/</span>\n</code></pre>\n<p><code>remove()</code> 方法是一个“可选操作”。 这里可以不必实现它，如果你调用它，它将抛出异常。</p>\n<p><strong>[1]</strong> 你可能会认为，因为 <code>iterator()</code> 返回 <strong>Iterator&lt;Pet&gt;</strong> ，匿名内部类定义可以使用菱形语法，Java可以推断出类型。但这不起作用，类型推断仍然非常有限。</p>\n<p>这个例子表明，如果实现了 <strong>Collection</strong> ，就必须实现 <code>iterator()</code> ，并且只拿实现 <code>iterator()</code> 与继承 <strong>AbstractCollection</strong> 相比，花费的代价只有略微减少。但是，如果类已经继承了其他的类，那么就不能再继承 <strong>AbstractCollection</strong> 了。在这种情况下，要实现 <strong>Collection</strong> ，就必须实现该接口中的所有方法。此时，继承并提供创建迭代器的能力要容易得多：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/NonCollectionSequence.java</span>\n<span class=\"hljs-keyword\">import</span> typeinfo.<span class=\"hljs-property\">pets</span>.*;\n<span class=\"hljs-keyword\">import</span> java.<span class=\"hljs-property\">util</span>.*;\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PetSequence</span> {\n  <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-title class_\">Pet</span>[] pets = <span class=\"hljs-title class_\">Pets</span>.<span class=\"hljs-title function_\">array</span>(<span class=\"hljs-number\">8</span>);\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NonCollectionSequence</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_ inherited__\">PetSequence</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">Iterator</span>&lt;<span class=\"hljs-title class_\">Pet</span>&gt; <span class=\"hljs-title function_\">iterator</span>(<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Iterator</span>&lt;<span class=\"hljs-title class_\">Pet</span>&gt;() {\n      <span class=\"hljs-keyword\">private</span> int index = <span class=\"hljs-number\">0</span>;\n      <span class=\"hljs-meta\">@Override</span>\n      <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">boolean</span> <span class=\"hljs-title function_\">hasNext</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">return</span> index &lt; pets.<span class=\"hljs-property\">length</span>;\n      }\n      <span class=\"hljs-meta\">@Override</span>\n      <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">Pet</span> <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>) { <span class=\"hljs-keyword\">return</span> pets[index++]; }\n      <span class=\"hljs-meta\">@Override</span>\n      <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">remove</span>(<span class=\"hljs-params\"></span>) { <span class=\"hljs-comment\">// Not implemented</span>\n        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">UnsupportedOperationException</span>();\n      }\n    };\n  }\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n    <span class=\"hljs-title class_\">NonCollectionSequence</span> nc =\n      <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">NonCollectionSequence</span>();\n    <span class=\"hljs-title class_\">InterfaceVsIterator</span>.<span class=\"hljs-title function_\">display</span>(nc.<span class=\"hljs-title function_\">iterator</span>());\n  }\n}\n<span class=\"hljs-comment\">/* Output:\n0:Rat 1:Manx 2:Cymric 3:Mutt 4:Pug 5:Cymric 6:Pug\n7:Manx\n*/</span>\n</code></pre>\n<p>生成 <strong>Iterator</strong> 是将序列与消费该序列的方法连接在一起耦合度最小的方式，并且与实现 <strong>Collection</strong> 相比，它在序列类上所施加的约束也少得多。</p>\n<h2 id=\"for-in和迭代器\">for-in和迭代器</h2>\n<p>到目前为止，for-in 语法主要用于数组，但它也适用于任何 <strong>Collection</strong> 对象。实际上在使用 <strong>ArrayList</strong> 时，已经看到了一些使用它的示例，下面是一个更通用的证明：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/ForInCollections.java</span>\n<span class=\"hljs-comment\">// All collections work with for-in</span>\n<span class=\"hljs-keyword\">import</span> java.<span class=\"hljs-property\">util</span>.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ForInCollections</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-title class_\">Collection</span>&lt;<span class=\"hljs-title class_\">String</span>&gt; cs = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();\n        <span class=\"hljs-title class_\">Collections</span>.<span class=\"hljs-title function_\">addAll</span>(cs, <span class=\"hljs-string\">&quot;Take the long way home&quot;</span>.<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&quot; &quot;</span>));\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-title class_\">String</span> s : cs) {\n            <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">&quot;&#x27;&quot;</span> + s + <span class=\"hljs-string\">&quot;&#x27; &quot;</span>);\n        }\n    }\n}\n<span class=\"hljs-comment\">/* Output:\n&#x27;Take&#x27; &#x27;the&#x27; &#x27;long&#x27; &#x27;way&#x27; &#x27;home&#x27;\n*/</span>\n</code></pre>\n<p>由于 <strong>cs</strong> 是一个 <strong>Collection</strong> ，因此该代码展示了使用 for-in 是所有 <strong>Collection</strong> 对象的特征。</p>\n<p>这样做的原因是 Java 5 引入了一个名为 <strong>Iterable</strong> 的接口，该接口包含一个能够生成 <strong>Iterator</strong> 的 <code>iterator()</code> 方法。for-in 使用此 <strong>Iterable</strong> 接口来遍历序列。因此，如果创建了任何实现了 <strong>Iterable</strong> 的类，都可以将它用于 for-in 语句中：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/IterableClass.java</span>\n<span class=\"hljs-comment\">// Anything Iterable works with for-in</span>\n<span class=\"hljs-keyword\">import</span> java.<span class=\"hljs-property\">util</span>.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">IterableClass</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Iterable</span>&lt;<span class=\"hljs-title class_\">String</span>&gt; {\n    <span class=\"hljs-keyword\">protected</span> <span class=\"hljs-title class_\">String</span>[] words = (<span class=\"hljs-string\">&quot;And that is how &quot;</span> +\n            <span class=\"hljs-string\">&quot;we know the Earth to be banana-shaped.&quot;</span>\n    ).<span class=\"hljs-title function_\">split</span>(<span class=\"hljs-string\">&quot; &quot;</span>);\n\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">Iterator</span>&lt;<span class=\"hljs-title class_\">String</span>&gt; <span class=\"hljs-title function_\">iterator</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Iterator</span>&lt;<span class=\"hljs-title class_\">String</span>&gt;() {\n            <span class=\"hljs-keyword\">private</span> int index = <span class=\"hljs-number\">0</span>;\n\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">boolean</span> <span class=\"hljs-title function_\">hasNext</span>(<span class=\"hljs-params\"></span>) {\n                <span class=\"hljs-keyword\">return</span> index &lt; words.<span class=\"hljs-property\">length</span>;\n            }\n\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title class_\">String</span> <span class=\"hljs-title function_\">next</span>(<span class=\"hljs-params\"></span>) {\n                <span class=\"hljs-keyword\">return</span> words[index++];\n            }\n\n            <span class=\"hljs-meta\">@Override</span>\n            <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">remove</span>(<span class=\"hljs-params\"></span>) { <span class=\"hljs-comment\">// Not implemented</span>\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">UnsupportedOperationException</span>();\n            }\n        };\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-title class_\">String</span> s : <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">IterableClass</span>()) {\n            <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">print</span>(s + <span class=\"hljs-string\">&quot; &quot;</span>);\n        }\n    }\n}\n<span class=\"hljs-comment\">/* Output:\nAnd that is how we know the Earth to be banana-shaped.\n*/</span>\n</code></pre>\n<p><code>iterator()</code> 返回的是实现了 <strong>Iterator&lt;String&gt;</strong> 的匿名内部类的实例，该匿名内部类可以遍历数组中的每个单词。在主方法中，可以看到 <strong>IterableClass</strong> 确实可以用于 for-in 语句。</p>\n<p>在 Java 5 中，许多类都是 <strong>Iterable</strong> ，主要包括所有的 <strong>Collection</strong> 类（但不包括各种 <strong>Maps</strong> ）。 例如，下面的代码可以显示所有的操作系统环境变量：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/EnvironmentVariables.java</span>\n<span class=\"hljs-comment\">// {VisuallyInspectOutput}</span>\n<span class=\"hljs-keyword\">import</span> java.<span class=\"hljs-property\">util</span>.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EnvironmentVariables</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n    <span class=\"hljs-keyword\">for</span>(<span class=\"hljs-title class_\">Map</span>.<span class=\"hljs-property\">Entry</span> <span class=\"hljs-attr\">entry</span>: <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-title function_\">getenv</span>().<span class=\"hljs-title function_\">entrySet</span>()) {\n      <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(entry.<span class=\"hljs-title function_\">getKey</span>() + <span class=\"hljs-string\">&quot;: &quot;</span> +\n        entry.<span class=\"hljs-title function_\">getValue</span>());\n    }\n  }\n}\n</code></pre>\n<p>TODO 未学完。2020年10月13日</p>\n<h2 id=\"小结\">小结</h2>\n<p>Java 提供了许多保存对象的方法：</p>\n<ol>\n<li>数组将数字索引与对象相关联。它保存类型明确的对象，因此在查找对象时不必对结果做类型转换。它可以是多维的，可以保存基本类型的数据。虽然可以在运行时创建数组，但是一旦创建数组，就无法更改数组的大小。</li>\n<li><strong>Collection</strong> 保存单一的元素，而 <strong>Map</strong> 包含相关联的键值对。使用 Java 泛型，可以指定集合中保存的对象的类型，因此不能将错误类型的对象放入集合中，并且在从集合中获取元素时，不必进行类型转换。各种 <strong>Collection</strong> 和各种 <strong>Map</strong> 都可以在你向其中添加更多的元素时，自动调整其尺寸大小。集合不能保存基本类型，但自动装箱机制会负责执行基本类型和集合中保存的包装类型之间的双向转换。</li>\n<li>像数组一样， <strong>List</strong> 也将数字索引与对象相关联，因此，数组和 <strong>List</strong> 都是有序集合。</li>\n<li>如果要执行大量的随机访问，则使用 <strong>ArrayList</strong> ，如果要经常从表中间插入或删除元素，则应该使用 <strong>LinkedList</strong> 。</li>\n<li>队列和堆栈的行为是通过 <strong>LinkedList</strong> 提供的。</li>\n<li><strong>Map</strong> 是一种将对象（而非数字）与对象相关联的设计。 <strong>HashMap</strong> 专为快速访问而设计，而 <strong>TreeMap</strong> 保持键始终处于排序状态，所以没有 <strong>HashMap</strong> 快。 <strong>LinkedHashMap</strong> 按插入顺序保存其元素，但使用散列提供快速访问的能力。</li>\n<li><strong>Set</strong> 不接受重复元素。 <strong>HashSet</strong> 提供最快的查询速度，而 <strong>TreeSet</strong> 保持元素处于排序状态。 <strong>LinkedHashSet</strong> 按插入顺序保存其元素，但使用散列提供快速访问的能力。</li>\n<li>不要在新代码中使用遗留类 <strong>Vector</strong> ，<strong>Hashtable</strong> 和 <strong>Stack</strong> 。</li>\n</ol>\n<p>Java 集合框架简图，黄色为接口，绿色为抽象类，蓝色为具体类。虚线箭头表示实现关系，实线箭头表示继承关系。</p>\n<p>![collection](E:\\OneDrive - lanqilu\\我的图片库\\blogimg\\Java持有对象\\collection.png)![map](E:\\OneDrive - lanqilu\\我的图片库\\blogimg\\Java持有对象\\map.png)</p>\n<h3 id=\"简单集合分类\">简单集合分类</h3>\n<p>可以看到，实际上只有四个基本的集合组件： <strong>Map</strong> ， <strong>List</strong> ， <strong>Set</strong> 和 <strong>Queue</strong> ，它们各有两到三个实现版本（<strong>Queue</strong> 的 <strong>java.util.concurrent</strong> 实现未包含在此图中）。最常使用的集合用黑色粗线线框表示。</p>\n<p>虚线框表示接口，实线框表示普通的（具体的）类。带有空心箭头的虚线表示特定的类实现了一个接口。实心箭头表示某个类可以生成箭头指向的类的对象。例如，任何 <strong>Collection</strong> 都可以生成 <strong>Iterator</strong> ， <strong>List</strong> 可以生成 <strong>ListIterator</strong> （也能生成普通的 <strong>Iterator</strong> ，因为 <strong>List</strong> 继承自 <strong>Collection</strong> ）。</p>\n<p>下面的示例展示了各种不同的类在方法上的差异。程序的输出还展示了在每个类或接口中所实现的接口：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// collections/CollectionDifferences.java</span>\n<span class=\"hljs-keyword\">import</span> onjava.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CollectionDifferences</span> {\n  <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n    <span class=\"hljs-title class_\">CollectionMethodDifferences</span>.<span class=\"hljs-title function_\">main</span>(args);\n  }\n}\n</code></pre>\n<p>除 <strong>TreeSet</strong> 之外的所有 <strong>Set</strong> 都具有与 <strong>Collection</strong> 完全相同的接口。<strong>List</strong> 和 <strong>Collection</strong> 存在着明显的不同，尽管 <strong>List</strong> 所要求的方法都在 <strong>Collection</strong> 中。另一方面，在 <strong>Queue</strong> 接口中的方法是独立的，在创建具有 <strong>Queue</strong> 功能的实现时，不需要使用 <strong>Collection</strong> 方法。最后， <strong>Map</strong> 和 <strong>Collection</strong> 之间唯一的交集是 <strong>Map</strong> 可以使用 <code>entrySet()</code> 和 <code>values()</code> 方法来产生 <strong>Collection</strong> 。</p>\n<p>请注意，标记接口 <strong>java.util.RandomAccess</strong> 附加到了 <strong>ArrayList</strong> 上，但不附加到 <strong>LinkedList</strong> 上。这为根据特定 <strong>List</strong> 动态改变其行为的算法提供了信息。</p>\n<p>从面向对象的继承层次结构来看，这种组织结构确实有些奇怪。但是，当了解了 <strong>java.util</strong> 中更多的有关集合的内容后，就会发现除了继承结构有点奇怪外，还有更多的问题。集合类库一直以来都是设计难题——解决这些问题涉及到要去满足经常彼此之间互为牵制的各方面需求。所以要做好准备，在各处做出妥协。</p>\n<p>尽管存在这些问题，但 Java 集合仍是在日常工作中使用的基本工具，它可以使程序更简洁、更强大、更有效。你可能需要一段时间才能熟悉集合类库的某些方面，但我想你很快就会找到自己的路子，来获得和使用这个类库中的类。</p>\n');
INSERT INTO `m_blog` VALUES (28, 1, 'Java 初始化和清理', '参考资料：《On Java 8》', '“不安全”的编程是造成编程代价昂贵的罪魁祸首之一。有两个安全性问题：初始化和清理。C 语言中很多的 bug 都是因为程序员忘记初始化导致的。尤其是很多类库的使用者不知道如何初始化类库组件，甚至他们必须得去初始化。清理则是另一个特殊的问题，因为当你使用一个元素做完事后就不会去关心这个元素，所以你很容易忘记清理它。这样就造成了元素使用的资源滞留不会被回收，直到程序消耗完所有的资源（特别是内存）。\n\nC++ 引入了构造器的概念，这是一个特殊的方法，每创建一个对象，这个方法就会被自动调用。Java 采用了构造器的概念，另外还使用了垃圾收集器（Garbage Collector, GC）去自动回收不再被使用的对象所占的资源。这一章将讨论初始化和清理的问题，以及在 Java 中对它们的支持。\n\n## 利用构造器保证初始化\n\n你可能会想为每个类创建一个 `initialize()` 方法，该方法名暗示着在使用类之前需要先调用它。不幸的是，用户必须得记得去调用它。在 Java 中，类的设计者通过构造器保证每个对象的初始化。如果一个类有构造器，那么 Java 会在用户使用对象之前（即对象刚创建完成）自动调用对象的构造器方法，从而保证初始化。\n\n下个挑战是如何命名构造器方法。存在两个问题：\n\n+ 第一个是任何命名都可能与类中其他已有元素的命名冲突；\n+ 第二个是编译器必须始终知道构造器方法名称，从而调用它。\n\nC++ 的解决方法看起来是最简单且最符合逻辑的，所以 Java 中使用了同样的方式：构造器名称与类名相同。在初始化过程中自动调用构造器方法是有意义的。\n\n以下示例是包含了一个构造器的类：\n\n```java\n// housekeeping/SimpleConstructor.java\n// Demonstration of a simple constructor\n\nclass Rock {\n    Rock() { // 这是一个构造器\n        System.out.print(\"Rock \");\n    }\n}\n\npublic class SimpleConstructor {\n    public static void main(String[] args) {\n        for (int i = 0; i < 10; i++) {\n            new Rock();\n        }\n    }\n}\n```\n\n输出：\n\n````java\nRock Rock Rock Rock Rock Rock Rock Rock Rock Rock \n````\n\n现在，当创建一个对象时：`new Rock()` ，内存被分配，构造器被调用。构造器保证了对象在你使用它之前进行了正确的初始化。\n\n有一点需要注意，构造器方法名与类名相同，不需要符合首字母小写的编程风格。在 C++ 中，无参构造器被称为默认构造器，这个术语在 Java 出现之前使用了很多年。但是，出于一些原因，Java 设计者们决定使用无参构造器这个名称。\n\n跟其他方法一样，构造器方法也可以传入参数来定义如何创建一个对象。之前的例子稍作修改，使得构造器接收一个参数：\n\n```java\n// housekeeping/SimpleConstructor2.java\n// Constructors can have arguments\n\nclass Rock2 {\n    Rock2(int i) {\n        System.out.print(\"Rock \" + i + \" \");\n    }\n}\n\npublic class SimpleConstructor2 {\n    public static void main(String[] args) {\n        for (int i = 0; i < 8; i++) {\n            new Rock2(i);\n        }\n    }\n}\n```\n\n输出：\n\n```java\nRock 0 Rock 1 Rock 2 Rock 3 Rock 4 Rock 5 Rock 6 Rock 7\n```\n\n如果类 `Tree` 有一个构造方法，只接收一个参数用来表示树的高度，那么你可以像下面这样创建一棵树：\n\n```java\nTree t = new Tree(12); // 12-foot 树\n```\n\n如果 `Tree(int)` 是唯一的构造器，那么编译器就不允许你以其他任何方式创建 `Tree` 类型的对象。\n\n构造器消除了一类重要的问题，使得代码更易读。例如，在上面的代码块中，你看不到对 `initialize()` 方法的显式调用，而从概念上来看，`initialize()` 方法应该与对象的创建分离。在 Java 中，对象的创建与初始化是统一的概念，二者不可分割。\n\n构造器没有返回值，它是一种特殊的方法。但它和返回类型为 `void` 的普通方法不同：\n\n+ 普通方法可以返回空值，你还能选择让它返回别的类型；\n+ 而构造器没有返回值，却同时也没有给你选择的余地（ `new` 表达式虽然返回了刚创建的对象的引用，但构造器本身却没有返回任何值）。如果它有返回值，并且你也可以自己选择让它返回什么，那么编译器就还得知道接下来该怎么处理那个返回值（这个返回值没有接收者）。\n\n## 方法重载\n\n任何编程语言中都具备的一项重要特性就是命名。当你创建一个对象时，就会给此对象分配的内存空间命名。方法是行为的命名。你通过名字指代所有的对象，属性和方法。良好命名的系统易于理解和修改。就好比写散文，目的是与读者沟通。\n\n将人类语言细微的差别映射到编程语言中会产生一个问题。通常，相同的词可以表达多种不同的含义——它们被“重载”了。特别是当含义的差别很小时，这会更加有用。你会说“清洗衬衫”、“清洗车”和“清洗狗”。而如果硬要这么说就会显得很愚蠢：“以洗衬衫的方式洗衬衫”、“以洗车的方式洗车”和“以洗狗的方式洗狗”，因为听众根本不需要区分行为的动作。大多数人类语言都具有“冗余”性，所以即使漏掉几个词，你也能明白含义。你不需要对每个概念都使用不同的词汇，可以从上下文推断出含义。\n\n大多数编程语言（尤其是 C 语言）要求为每个方法（在这些语言中经常称为函数）提供一个独一无二的标识符。所以，你不能有一个 `print()` 函数既能打印整型，也能打印浮点型，每个函数名都必须不同。\n\n在 Java (C++) 中，还有一个因素也促使了必须使用方法重载：构造器。因为构造器方法名肯定是与类名相同，所以一个类中只会有一个构造器名。那么你怎么通过不同的方式创建一个对象呢？例如，你想创建一个类，这个类的初始化方式有两种：一种是标准化方式，另一种是从文件中读取信息的方式。你需要两个构造器：无参构造器和有一个 String 类型参数的构造器，该参数传入文件名。两个构造器具有相同的名字——与类名相同。因此，方法重载是必要的，它允许方法具有相同的方法名但接收的参数不同。尽管方法重载对于构造器是重要的，但是也可以对任何方法很方便地进行重载。\n\n下例展示了如何重载构造器和方法：\n\n```java\n// housekeeping/Overloading.java\n// Both constructor and ordinary method overloading\n\nclass Tree {\n    int height;\n    Tree() {\n        System.out.println(\"Planting a seedling\");\n        height = 0;\n    }\n    Tree(int initialHeight) {\n        height = initialHeight;\n        System.out.println(\"Creating new Tree that is \" + height + \" feet tall\");\n    }\n    void info() {\n        System.out.println(\"Tree is \" + height + \" feet tall\");\n    }\n    void info(String s) {\n        System.out.println(s + \": Tree is \" + height + \" feet tall\");\n    }\n}\npublic class Overloading {\n    public static void main(String[] args) {\n        for (int i = 0; i < 5; i++) {\n            Tree t = new Tree(i);\n            t.info();\n            t.info(\"overloaded method\");\n        }\n        new Tree(); \n    }\n}\n```\n\n输出：\n\n```\nCreating new Tree that is 0 feet tall\nTree is 0 feet tall\noverloaded method: Tree is 0 feet tall\nCreating new Tree that is 1 feet tall\nTree is 1 feet tall\noverloaded method: Tree is 1 feet tall\nCreating new Tree that is 2 feet tall\nTree is 2 feet tall\noverloaded method: Tree is 2 feet tall\nCreating new Tree that is 3 feet tall\nTree is 3 feet tall\noverloaded method: Tree is 3 feet tall\nCreating new Tree that is 4 feet tall\nTree is 4 feet tall\noverloaded method: Tree is 4 feet tall\nPlanting a seedling\n```\n\n一个 Tree 对象既可以是一颗树苗，使用无参构造器创建，也可以是一颗在温室中已长大的树，已经有一定高度，这时候，就需要使用有参构造器创建。\n\n你也许想以多种方式调用 `info()` 方法。比如，如果你想打印额外的消息，就可以使用 `info(String)` 方法。如果你无话可说，就可以使用 `info()` 方法。用两个命名定义完全相同的概念看起来很奇怪，而使用方法重载，你就可以使用一个命名来定义一个概念。\n\n### 区分重载方法\n\n如果两个方法命名相同，Java 是怎么知道你调用的是哪个呢？有一条简单的规则：每个被重载的方法必须有独一无二的参数列表。你稍微思考下，就会很明了了，除了通过参数列表的不同来区分两个相同命名的方法，其他也没什么方式了。你甚至可以根据参数列表中的参数顺序来区分不同的方法，尽管这会造成代码难以维护。例如：\n\n```java\n// housekeeping/OverloadingOrder.java\n// Overloading based on the order of the arguments\n\npublic class OverloadingOrder {\n    static void f(String s, int i) {\n        System.out.println(\"String: \" + s + \", int: \" + i);\n    }\n\n    static void f(int i, String s) {\n        System.out.println(\"int: \" + i + \", String: \" + s);\n    }\n\n    public static void main(String[] args) {\n        f(\"String first\", 1);\n        f(99, \"Int first\");\n    }\n}\n```\n\n输出：\n\n```\nString: String first, int: 1\nint: 99, String: Int first\n```\n\n两个 `f()` 方法具有相同的参数，但是参数顺序不同，根据这个就可以区分它们。\n\n### 重载与基本类型\n\n基本类型可以自动从较小的类型转型为较大的类型。当这与重载结合时，这会令人有点困惑，下面是一个这样的例子：\n\n```java\n// housekeeping/PrimitiveOverloading.java\n// Promotion of primitives and overloading\n\npublic class PrimitiveOverloading {\n    void f1(char x) {\n        System.out.print(\"f1(char)\");\n    }\n    void f1(byte x) {\n        System.out.print(\"f1(byte)\");\n    }\n    void f1(short x) {\n        System.out.print(\"f1(short)\");\n    }\n    void f1(int x) {\n        System.out.print(\"f1(int)\");\n    }\n    void f1(long x) {\n        System.out.print(\"f1(long)\");\n    }\n    void f1(float x) {\n        System.out.print(\"f1(float)\");\n    }\n    void f1(double x) {\n        System.out.print(\"f1(double)\");\n    }\n    void f2(byte x) {\n        System.out.print(\"f2(byte)\");\n    }\n    void f2(short x) {\n        System.out.print(\"f2(short)\");\n    }\n    void f2(int x) {\n        System.out.print(\"f2(int)\");\n    }\n    void f2(long x) {\n        System.out.print(\"f2(long)\");\n    }\n    void f2(float x) {\n        System.out.print(\"f2(float)\");\n    }\n    void f2(double x) {\n        System.out.print(\"f2(double)\");\n    }\n    void f3(short x) {\n        System.out.print(\"f3(short)\");\n    }\n    void f3(int x) {\n        System.out.print(\"f3(int)\");\n    }\n    void f3(long x) {\n        System.out.print(\"f3(long)\");\n    }\n    void f3(float x) {\n        System.out.print(\"f3(float)\");\n    }\n    void f3(double x) {\n        System.out.print(\"f3(double)\");\n    }\n    void f4(int x) {\n        System.out.print(\"f4(int)\");\n    }\n    void f4(long x) {\n        System.out.print(\"f4(long)\");\n    }\n    void f4(float x) {\n        System.out.print(\"f4(float)\");\n    }\n    void f4(double x) {\n        System.out.print(\"f4(double)\");\n    }\n    void f5(long x) {\n        System.out.print(\"f5(long)\");\n    }\n    void f5(float x) {\n        System.out.print(\"f5(float)\");\n    }\n    void f5(double x) {\n        System.out.print(\"f5(double)\");\n    }\n    void f6(float x) {\n        System.out.print(\"f6(float)\");\n    }\n    void f6(double x) {\n        System.out.print(\"f6(double)\");\n    }\n    void f7(double x) {\n        System.out.print(\"f7(double)\");\n    }\n    void testConstVal() {\n        System.out.print(\"5: \");\n        f1(5);f2(5);f3(5);f4(5);f5(5);f6(5);f7(5);\n        System.out.println();\n    }\n    void testChar() {\n        char x = \'x\';\n        System.out.print(\"char: \");\n        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);\n        System.out.println();\n    }\n    void testByte() {\n        byte x = 0;\n        System.out.print(\"byte: \");\n        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);\n        System.out.println();\n    }\n    void testShort() {\n        short x = 0;\n        System.out.print(\"short: \");\n        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);\n        System.out.println();\n    }\n    void testInt() {\n        int x = 0;\n        System.out.print(\"int: \");\n        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);\n        System.out.println();\n    }\n    void testLong() {\n        long x = 0;\n        System.out.print(\"long: \");\n        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);\n        System.out.println();\n    }\n    void testFloat() {\n        float x = 0;\n        System.out.print(\"float: \");\n        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);\n        System.out.println();\n    }\n    void testDouble() {\n        double x = 0;\n        System.out.print(\"double: \");\n        f1(x);f2(x);f3(x);f4(x);f5(x);f6(x);f7(x);\n        System.out.println();\n    }\n\n    public static void main(String[] args) {\n        PrimitiveOverloading p = new PrimitiveOverloading();\n        p.testConstVal();\n        p.testChar();\n        p.testByte();\n        p.testShort();\n        p.testInt();\n        p.testLong();\n        p.testFloat();\n        p.testDouble();\n    }\n}\n```\n\n输出：\n\n```\n5: f1(int)f2(int)f3(int)f4(int)f5(long)f6(float)f7(double)\nchar: f1(char)f2(int)f3(int)f4(int)f5(long)f6(float)f7(double)\nbyte: f1(byte)f2(byte)f3(short)f4(int)f5(long)f6(float)f7(double)\nshort: f1(short)f2(short)f3(short)f4(int)f5(long)f6(float)f7(double)\nint: f1(int)f2(int)f3(int)f4(int)f5(long)f6(float)f7(double)\nlong: f1(long)f2(long)f3(long)f4(long)f5(long)f6(float)f7(double)\nfloat: f1(float)f2(float)f3(float)f4(float)f5(float)f6(float)f7(double)\ndouble: f1(double)f2(double)f3(double)f4(double)f5(double)f6(double)f7(double)\n```\n\n如果传入的参数类型大于方法期望接收的参数类型，你必须首先做下转换，如果你不做的话，编译器就会报错。\n\n### 返回值的重载\n\n经常会有人困惑，“为什么只能通过方法名和参数列表，不能通过方法名和返回值区分方法呢？”。例如以下两个方法，它们有相同的命名和参数，但是很容易区分：\n\n```java\nvoid f(){}\nint f() {return 1;}\n```\n\n有些情况下，编译器很容易就可以从上下文准确推断出该调用哪个方法，如 `int x = f()`。\n\n但是，你可以调用一个方法且忽略返回值。这叫做调用一个函数的副作用，因为你不在乎返回值，只是想利用方法做些事。所以如果你直接调用 `f()`，Java 编译器就不知道你想调用哪个方法，阅读者也不明所以。因为这个原因，所以你不能根据返回值类型区分重载的方法。\n\n## 无参构造器\n\n如前文所说，一个无参构造器就是不接收参数的构造器，用来创建一个“默认的对象”。如果你创建一个类，类中没有构造器，那么编译器就会自动为你创建一个无参构造器。例如：\n\n```java\n// housekeeping/DefaultConstructor.java\nclass Bird {}\npublic class DefaultConstructor {\n    public static void main(String[] args) {\n        Bird bird = new Bird(); // 默认的\n    }\n}\n```\n\n表达式 `new Bird()` 创建了一个新对象，调用了无参构造器，尽管在 Bird 类中并没有显式的定义无参构造器。试想如果没有构造器，我们如何创建一个对象呢。但是，一旦你显式地定义了构造器（无论有参还是无参），编译器就不会自动为你创建无参构造器。如下：\n\n```java\n// housekeeping/NoSynthesis.java\nclass Bird2 {\n    Bird2(int i) {}\n    Bird2(double d) {}\n}\npublic class NoSynthesis {\n    public static void main(String[] args) {\n        //- Bird2 b = new Bird2(); // No default\n        Bird2 b2 = new Bird2(1);\n        Bird2 b3 = new Bird2(1.0);\n    }\n}\n```\n\n如果你调用了 `new Bird2()` ，编译器会提示找不到匹配的构造器。当类中没有构造器时，编译器会说“你一定需要构造器，那么让我为你创建一个吧”。但是如果类中有构造器，编译器会说“你已经写了构造器了，所以肯定知道你在做什么，如果你没有创建默认构造器，说明你本来就不需要”。\n\n## this 关键字\n\n对于两个相同类型的对象 a 和 b，你可能在想如何调用这两个对象的 `peel()` 方法：\n\n```java\n// housekeeping/BananaPeel.java\n\nclass Banana {\n    void peel(int i) {\n        /*...*/\n    }\n}\npublic class BananaPeel {\n    public static void main(String[] args) {\n        Banana a = new Banana(), b = new Banana();\n        a.peel(1);\n        b.peel(2);\n    }\n}\n```\n\n如果只有一个方法 `peel()` ，那么怎么知道调用的是对象 a 的 `peel()` 方法还是对象 b 的 `peel()` 方法呢？编译器做了一些底层工作，所以你可以像这样编写代码。`peel()` 方法中第一个参数隐密地传入了一个指向操作对象的\n\n引用。因此，上述例子中的方法调用像下面这样：\n\n```java\nBanana.peel(a, 1)\nBanana.peel(b, 1)\n```\n\n这是在内部实现的，你不可以直接这么编写代码，编译器不会接受，但能说明到底发生了什么。假设现在在方法内部，你想获得对当前对象的引用。但是，对象引用是被秘密地传达给编译器——并不在参数列表中。方便的是，有一个关键字: `this` 。\n\n`this` 关键字只能在非静态方法内部使用。当你调用一个对象的方法时，`this` 生成了一个对象引用。你可以像对待其他引用一样对待这个引用。如果你在一个类的方法里调用其他该类中的方法，不要使用 `this`，直接调用即可，`this` 自动地应用于其他方法上了。因此你可以像这样：\n\n```java\n// housekeeping/Apricot.java\n\npublic class Apricot {\n    void pick() {\n        /* ... */\n    }\n\n    void pit() {\n        pick();\n        /* ... */\n    }\n}\n```\n\n在 `pit()` 方法中，你可以使用 `this.pick()`，但是没有必要。编译器自动为你做了这些。`this` 关键字只用在一些必须显式使用当前对象引用的特殊场合。例如，用在 return 语句中返回对当前对象的引用。\n\n```java\n// housekeeping/Leaf.java\n// Simple use of the \"this\" keyword\n\npublic class Leaf {\n\n    int i = 0;\n\n    Leaf increment() {\n        i++;\n        return this;\n    }\n\n    void print() {\n        System.out.println(\"i = \" + i);\n    }\n\n    public static void main(String[] args) {\n        Leaf x = new Leaf();\n        x.increment().increment().increment().print();\n    }\n}\n```\n\n输出：\n\n```\ni = 3\n```\n\n因为 `increment()` 通过 `this` 关键字返回当前对象的引用，因此在相同的对象上可以轻易地执行多次操作。\n\n`this` 关键字在向其他方法传递当前对象时也很有用：\n\n```java\n// housekeeping/PassingThis.java\n\nclass Person {\n    public void eat(Apple apple) {\n        Apple peeled = apple.getPeeled();\n        System.out.println(\"Yummy\");\n    }\n}\n\nclass Peeler {\n    static Apple peel(Apple apple) {\n        // ... remove peel\n        return apple; // Peeled\n    }\n}\n\nclass Apple {\n    Apple getPeeled() {\n        return Peeler.peel(this);\n    }\n}\n\npublic class PassingThis {\n    public static void main(String[] args) {\n        new Person().eat(new Apple());\n    }\n}\n```\n\n输出：\n\n```\nYummy\n```\n\nApple 因为某些原因（比如说工具类中的方法在多个类中重复出现，你不想代码重复），必须调用一个外部工具方法 `Peeler.peel()` 做一些行为。必须使用 this 才能将自身传递给外部方法。\n\n### 在构造器中调用构造器\n\n当你在一个类中写了多个构造器，有时你想在一个构造器中调用另一个构造器来避免代码重复。你通过 this 关键字实现这样的调用。\n\n通常当你说 this，意味着“这个对象”或“当前对象”，它本身生成对当前对象的引用。在一个构造器中，当你给 this 一个参数列表时，它是另一层意思。它通过最直接的方式显式地调用匹配参数列表的构造器：\n\n```java\n// housekeeping/Flower.java\n// Calling constructors with \"this\"\n\npublic class Flower {\n    int petalCount = 0;\n    String s = \"initial value\";\n\n    Flower(int petals) {\n        petalCount = petals;\n        System.out.println(\"Constructor w/ int arg only, petalCount = \" + petalCount);\n    }\n\n    Flower(String ss) {\n        System.out.println(\"Constructor w/ string arg only, s = \" + ss);\n        s = ss;\n    }\n\n    Flower(String s, int petals) {\n        this(petals);\n        //- this(s); // Can\'t call two!\n        this.s = s; // Another use of \"this\"\n        System.out.println(\"String & int args\");\n    }\n\n    Flower() {\n        this(\"hi\", 47);\n        System.out.println(\"no-arg constructor\");\n    }\n\n    void printPetalCount() {\n        //- this(11); // Not inside constructor!\n        System.out.println(\"petalCount = \" + petalCount + \" s = \" + s);\n    }\n\n    public static void main(String[] args) {\n        Flower x = new Flower();\n        x.printPetalCount();\n    }\n}\n```\n\n输出：\n\n```\nConstructor w/ int arg only, petalCount = 47\nString & int args\nno-arg constructor\npetalCount = 47 s = hi\n```\n\n从构造器 `Flower(String s, int petals)` 可以看出，其中只能通过 this 调用一次构造器。另外，必须首先调用构造器，否则编译器会报错。这个例子同样展示了 this 的另一个用法。参数列表中的变量名 **s** 和成员变量名 s 相同，会引起混淆。你可以通过 `this.s` 表明你指的是成员变量 s，从而避免重复。你经常会在 Java 代码中看到这种用法，同时本书中也会多次出现这种写法。在 `printPetalCount()` 方法中，编译器不允许你在一个构造器之外的方法里调用构造器。\n\n### static 的含义\n\n记住了 this 关键字的内容，你会对 static 修饰的方法有更加深入的理解：static 方法中不会存在 this。\n\n你不能在静态方法中调用非静态方法（反之可以）。静态方法是为类而创建的，不需要任何对象。事实上，这就是静态方法的主要目的，静态方法看起来就像全局方法一样，但是 Java 中不允许全局方法，一个类中的静态方法可以被其他的静态方法和静态属性访问。\n\n一些人认为静态方法不是面向对象的，因为它们的确具有全局方法的语义。使用静态方法，因为不存在 this，所以你没有向一个对象发送消息。的确，如果你发现代码中出现了大量的 static 方法，就该重新考虑自己的设计了。然而，static 的概念很实用，许多时候都要用到它。至于它是否真的“面向对象”，就留给理论家去讨论吧。\n\n\n## 成员初始化\n\nJava 尽量保证所有变量在使用前都能得到恰当的初始化。对于方法的局部变量，这种保证会以编译时错误的方式呈现，所以如果写成：\n\n```java\nvoid f() {\n    int i;\n    i++;\n}\n```\n\n你会得到一条错误信息，告诉你 i 可能尚未初始化。编译器可以为 i 赋一个默认值，但是未初始化的局部变量更有可能是程序员的疏忽，所以采用默认值反而会掩盖这种失误。强制程序员提供一个初始值，往往能帮助找出程序里的 Bug。\n\n要是类的成员变量是基本类型，情况就会变得有些不同。类的每个基本类型数据成员保证都会有一个初始值。下面的程序可以验证这类情况，并显示它们的值：\n\n```java\n// housekeeping/InitialValues.java\n// Shows default initial values\n\npublic class InitialValues {\n    boolean t;\n    char c;\n    byte b;\n    short s;\n    int i;\n    long l;\n    float f;\n    double d;\n    InitialValues reference;\n\n    void printInitialValues() {\n        System.out.println(\"Data type Initial value\");\n        System.out.println(\"boolean \" + t);\n        System.out.println(\"char[\" + c + \"]\");\n        System.out.println(\"byte \" + b);\n        System.out.println(\"short \" + s);\n        System.out.println(\"int \" + i);\n        System.out.println(\"long \" + l);\n        System.out.println(\"float \" + f);\n        System.out.println(\"double \" + d);\n        System.out.println(\"reference \" + reference);\n    }\n\n    public static void main(String[] args) {\n        new InitialValues().printInitialValues();\n    }\n}\n```\n\n输出：\n\n```Java\nData type Initial value\nboolean false\nchar[NUL]\nbyte 0\nshort 0\nint 0\nlong 0\nfloat 0.0\ndouble 0.0\nreference null\n```\n\n可见尽管数据成员的初值没有给出，但它们确实有初值（char 值为 0，所以显示为空白）。所以这样至少不会出现“未初始化变量”的风险了。\n\n在类里定义一个对象引用时，如果不将其初始化，那么引用就会被赋值为 null。\n\n怎么给一个变量赋初值呢？一种很直接的方法是在定义类成员变量的地方为其赋值。以下代码修改了 InitialValues 类成员变量的定义，直接提供了初值：\n\n```java\n// housekeeping/InitialValues2.java\n// Providing explicit initial values\n\npublic class InitialValues2 {\n    boolean bool = true;\n    char ch = \'x\';\n    byte b = 47;\n    short s = 0xff;\n    int i = 999;\n    long lng = 1;\n    float f = 3.14f;\n    double d = 3.14159;\n}\n```\n\n你也可以用同样的方式初始化非基本类型的对象。如果 Depth 是一个类，那么可以像下面这样创建一个对象并初始化它：\n\n```java\n// housekeeping/Measurement.java\n\nclass Depth {}\n\npublic class Measurement {\n    Depth d = new Depth();\n    // ...\n}\n```\n\n如果没有为 d 赋予初值就尝试使用它，就会出现运行时错误，告诉你产生了一个异常。\n\n你也可以通过调用某个方法来提供初值：\n\n```java\n// housekeeping/MethodInit.java\n\npublic class MethodInit {\n    int i = f();\n    \n    int f() {\n        return 11;\n    }\n    \n}\n```\n\n这个方法可以带有参数，但这些参数不能是未初始化的类成员变量。因此，可以这么写：\n\n```java\n// housekeeping/MethodInit2.java\n\npublic class MethodInit2 {\n    int i = f();\n    int j = g(i);\n    \n    int f() {\n        return 11;\n    }\n    \n    int g(int n) {\n        return n * 10;\n    }\n}\n```\n\n但是你不能这么写：\n\n```java\n// housekeeping/MethodInit3.java\n\npublic class MethodInit3 {\n    //- int j = g(i); // Illegal forward reference\n    int i = f();\n\n    int f() {\n        return 11;\n    }\n\n    int g(int n) {\n        return n * 10;\n    }\n}\n```\n\n显然，上述程序的正确性取决于初始化的顺序，而与其编译方式无关。所以，编译器恰当地对“向前引用”发出了警告。\n\n这种初始化方式简单直观，但有个限制：类 InitialValues 的每个对象都有相同的初值，有时这的确是我们需要的，但有时却需要更大的灵活性。\n\n## 构造器初始化\n\n可以用构造器进行初始化，这种方式给了你更大的灵活性，因为你可以在运行时调用方法进行初始化。但是，这无法阻止自动初始化的进行，他会在构造器被调用之前发生。因此，如果使用如下代码：\n\n```java\n// housekeeping/Counter.java\n\npublic class Counter {\n    int i;\n    \n    Counter() {\n        i = 7;\n    }\n    // ...\n}\n```\n\ni 首先会被初始化为 0，然后变为 7。对于所有的基本类型和引用，包括在定义时已明确指定初值的变量，这种情况都是成立的。因此，编译器不会强制你一定要在构造器的某个地方或在使用它们之前初始化元素——初始化早已得到了保证。\n\n### 初始化的顺序\n\n在类中变量定义的顺序决定了它们初始化的顺序。即使变量定义散布在方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。例如：\n\n```java\n// housekeeping/OrderOfInitialization.java\n// Demonstrates initialization order\n// When the constructor is called to create a\n// Window object, you\'ll see a message:\n\nclass Window {\n    Window(int marker) {\n        System.out.println(\"Window(\" + marker + \")\");\n    }\n}\n\nclass House {\n    Window w1 = new Window(1); // Before constructor\n\n    House() {\n        // Show that we\'re in the constructor:\n        System.out.println(\"House()\");\n        w3 = new Window(33); // Reinitialize w3\n    }\n\n    Window w2 = new Window(2); // After constructor\n\n    void f() {\n        System.out.println(\"f()\");\n    }\n\n    Window w3 = new Window(3); // At end\n}\n\npublic class OrderOfInitialization {\n    public static void main(String[] args) {\n        House h = new House();\n        h.f(); // Shows that construction is done\n    }\n}\n```\n\n输出：\n\n```\nWindow(1)\nWindow(2)\nWindow(3)\nHouse()\nWindow(33)\nf()\n```\n\n在 House 类中，故意把几个 Window 对象的定义散布在各处，以证明它们全都会在调用构造器或其他方法之前得到初始化。此外，w3 在构造器中被再次赋值。\n\n由输出可见，引用 w3 被初始化了两次：一次在调用构造器前，一次在构造器调用期间（第一次引用的对象将被丢弃，并作为垃圾回收）。这乍一看可能觉得效率不高，但保证了正确的初始化。试想，如果定义了一个重载构造器，在其中没有初始化 w3，同时在定义 w3 时没有赋予初值，那会产生怎样的后果呢？w3 对象不存在造成空指针异常。\n\n### 静态数据的初始化\n\n无论创建多少个对象，静态数据都只占用一份存储区域。static 关键字不能应用于局部变量，所以只能作用于属性（字段、域）。如果一个字段是静态的基本类型，你没有初始化它，那么它就会获得基本类型的标准初值。如果它是对象引用，那么它的默认初值就是 null。\n\n如果在定义时进行初始化，那么静态变量看起来就跟非静态变量一样。\n\n下面例子显示了静态存储区是何时初始化的：\n\n```java\n// housekeeping/StaticInitialization.java\n// Specifying initial values in a class definition\n\nclass Bowl {\n    Bowl(int marker) {\n        System.out.println(\"Bowl(\" + marker + \")\");\n    }\n    \n    void f1(int marker) {\n        System.out.println(\"f1(\" + marker + \")\");\n    }\n}\n\nclass Table {\n    static Bowl bowl1 = new Bowl(1);\n    \n    Table() {\n        System.out.println(\"Table()\");\n        bowl2.f1(1);\n    }\n    \n    void f2(int marker) {\n        System.out.println(\"f2(\" + marker + \")\");\n    }\n    \n    static Bowl bowl2 = new Bowl(2);\n}\n\nclass Cupboard {\n    Bowl bowl3 = new Bowl(3);\n    static Bowl bowl4 = new Bowl(4);\n    \n    Cupboard() {\n        System.out.println(\"Cupboard()\");\n        bowl4.f1(2);\n    }\n    \n    void f3(int marker) {\n        System.out.println(\"f3(\" + marker + \")\");\n    }\n    \n    static Bowl bowl5 = new Bowl(5);\n}\n\npublic class StaticInitialization {\n    public static void main(String[] args) {\n        System.out.println(\"main creating new Cupboard()\");\n        new Cupboard();\n        System.out.println(\"main creating new Cupboard()\");\n        new Cupboard();\n        table.f2(1);\n        cupboard.f3(1);\n    }\n    \n    static Table table = new Table();\n    static Cupboard cupboard = new Cupboard();\n}\n```\n\n输出：\n\n```\nBowl(1)\nBowl(2)\nTable()\nf1(1)\nBowl(4)\nBowl(5)\nBowl(3)\nCupboard()\nf1(2)\nmain creating new Cupboard()\nBowl(3)\nCupboard()\nf1(2)\nmain creating new Cupboard()\nBowl(3)\nCupboard()\nf1(2)\nf2(1)\nf3(1)\n```\n\nBowl 类展示类的创建，而 Table 和 Cupboard 在它们的类定义中包含 Bowl 类型的静态数据成员。注意，在静态数据成员定义之前，Cupboard 类中先定义了一个 Bowl 类型的非静态成员 b3。\n\n由输出可见，静态初始化只有在必要时刻才会进行。如果不创建 Table 对象，也不引用 Table.bowl1 或 Table.bowl2，那么静态的 Bowl 类对象 bowl1 和 bowl2 永远不会被创建。只有在第一个 Table 对象被创建（或被访问）时，它们才会被初始化。此后，静态对象不会再次被初始化。\n\n初始化的顺序先是静态对象（如果它们之前没有被初始化的话），然后是非静态对象，从输出中可以看出。要执行 `main()` 方法，必须加载 StaticInitialization 类，它的静态属性 table 和 cupboard 随后被初始化，这会导致它们对应的类也被加载，而由于它们都包含静态的 Bowl 对象，所以 Bowl 类也会被加载。因此，在这个特殊的程序中，所有的类都会在 `main()` 方法之前被加载。实际情况通常并非如此，因为在典型的程序中，不会像本例中所示的那样，将所有事物通过 **static** 联系起来。\n\n概括一下创建对象的过程，假设有个名为 Dog 的类：\n\n1. 即使没有显式地使用 static 关键字，构造器实际上也是静态方法。所以，当首次创建 Dog 类型的对象或是首次访问 Dog 类的静态方法或属性时，Java 解释器必须在类路径中查找，以定位 Dog.class。\n2. 当加载完 Dog.class 后（后面会学到，这将创建一个 Class 对象），有关静态初始化的所有动作都会执行。因此，静态初始化只会在首次加载 Class 对象时初始化一次。\n3. 当用 `new Dog()` 创建对象时，首先会在堆上为 Dog 对象分配足够的存储空间。\n4. 分配的存储空间首先会被清零，即会将 Dog 对象中的所有基本类型数据设置为默认值（数字会被置为 0，布尔型和字符型也相同），引用被置为 null。\n5. 执行所有出现在字段定义处的初始化动作。\n6. 执行构造器。你将会在“复用”这一章看到，这可能会牵涉到很多动作，尤其当涉及继承的时候。\n\n### 显式的静态初始化\n\n你可以将一组静态初始化动作放在类里面一个特殊的“静态子句”（有时叫做静态块）中。像下面这样：\n\n```java\n// housekeeping/Spoon.java\n\npublic class Spoon {\n    static int i;\n    \n    static {\n        i = 47;\n    }\n}\n```\n\n这看起来像个方法，但实际上它只是一段跟在 static 关键字后面的代码块。与其他静态初始化动作一样，这段代码仅执行一次：当首次创建这个类的对象或首次访问这个类的静态成员（甚至不需要创建该类的对象）时。例如：\n\n```java\n// housekeeping/ExplicitStatic.java\n// Explicit static initialization with \"static\" clause\n\nclass Cup {\n    Cup(int marker) {\n        System.out.println(\"Cup(\" + marker + \")\");\n    }\n    \n    void f(int marker) {\n        System.out.println(\"f(\" + marker + \")\");\n    }\n}\n\nclass Cups {\n    static Cup cup1;\n    static Cup cup2;\n    \n    static {\n        cup1 = new Cup(1);\n        cup2 = new Cup(2);\n    }\n    \n    Cups() {\n        System.out.println(\"Cups()\");\n    }\n}\n\npublic class ExplicitStatic {\n    public static void main(String[] args) {\n        System.out.println(\"Inside main()\");\n        Cups.cup1.f(99); // [1]\n    }\n    \n    // static Cups cups1 = new Cups(); // [2]\n    // static Cups cups2 = new Cups(); // [2]\n}\n```\n\n输出：\n\n```\nInside main\nCup(1)\nCup(2)\nf(99)\n```\n\n无论是通过标为 [1] 的行访问静态的 cup1 对象，还是把标为 [1] 的行去掉，让它去运行标为 [2] 的那行代码（去掉  [2] 的注释），**Cups** 的静态初始化动作都会执行。如果同时注释 [1] 和 [2] 处，那么 **Cups** 的静态初始化就不会进行。此外，把标为 [2] 处的注释都去掉还是只去掉一个，静态初始化只会执行一次。\n\n### 非静态实例初始化\n\nJava 提供了被称为*实例初始化*的类似语法，用来初始化每个对象的非静态变量，例如：\n\n```java\n// housekeeping/Mugs.java\n// Instance initialization\n\nclass Mug {\n    Mug(int marker) {\n        System.out.println(\"Mug(\" + marker + \")\");\n    }\n}\n\npublic class Mugs {\n    Mug mug1;\n    Mug mug2;\n    { // [1]\n        mug1 = new Mug(1);\n        mug2 = new Mug(2);\n        System.out.println(\"mug1 & mug2 initialized\");\n    }\n    \n    Mugs() {\n        System.out.println(\"Mugs()\");\n    }\n    \n    Mugs(int i) {\n        System.out.println(\"Mugs(int)\");\n    }\n    \n    public static void main(String[] args) {\n        System.out.println(\"Inside main()\");\n        new Mugs();\n        System.out.println(\"new Mugs() completed\");\n        new Mugs(1);\n        System.out.println(\"new Mugs(1) completed\");\n    }\n}\n```\n\n输出：\n\n```\nInside main\nMug(1)\nMug(2)\nmug1 & mug2 initialized\nMugs()\nnew Mugs() completed\nMug(1)\nMug(2)\nmug1 & mug2 initialized\nMugs(int)\nnew Mugs(1) completed\n```\n\n看起来它很像静态代码块，只不过少了 **static** 关键字。这种语法对于支持\"匿名内部类\"（参见\"内部类\"一章）的初始化是必须的，但是你也可以使用它保证某些操作一定会发生，而不管哪个构造器被调用。从输出看出，实例初始化子句是在两个构造器之前执行的。\n\n## 数组初始化\n\n数组是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。数组是通过方括号下标操作符 [] 来定义和使用的。要定义一个数组引用，只需要在类型名加上方括号：\n\n```java\nint[] a1;\n```\n\n方括号也可放在标识符的后面，两者的含义是一样的：\n\n```java\nint a1[];\n```\n\n这种格式符合 C 和 C++ 程序员的习惯。不过前一种格式或许更合理，毕竟它表明类型是\"一个 **int** 型数组\"。本书中采用这种格式。\n\n编译器不允许指定数组的大小。这又把我们带回有关\"引用\"的问题上。你所拥有的只是对数组的一个引用（你已经为该引用分配了足够的存储空间），但是还没有给数组对象本身分配任何空间。为了给数组创建相应的存储空间，必须写初始化表达式。对于数组，初始化动作可以出现在代码的任何地方，但是也可以使用一种特殊的初始化表达式，它必须在创建数组的地方出现。这种特殊的初始化是由一对花括号括起来的值组成。这种情况下，存储空间的分配（相当于使用 **new**） 将由编译器负责。例如：\n\n```java\nint[] a1 = {1, 2, 3, 4, 5};\n```\n\n那么为什么在还没有数组的时候定义一个数组引用呢？\n\n```java\nint[] a2;\n```\n\n在 Java 中可以将一个数组赋值给另一个数组，所以可以这样：\n\n```java\na2 = a1;\n```\n\n其实真正做的只是复制了一个引用，就像下面演示的这样：\n\n```java\n// housekeeping/ArraysOfPrimitives.java\n\npublic class ArraysOfPrimitives {\n    public static void main(String[] args) {\n        int[] a1 = {1, 2, 3, 4, 5};\n        int[] a2;\n        a2 = a1;\n        for (int i = 0; i < a2.length; i++) {\n            a2[i] += 1;\n        }\n        for (int i = 0; i < a1.length; i++) {\n            System.out.println(\"a1[\" + i + \"] = \" + a1[i]);\n        }\n    }\n}\n```\n\n输出：\n\n```\na1[0] = 2;\na1[1] = 3;\na1[2] = 4;\na1[3] = 5;\na1[4] = 6;\n```\n\n**a1** 初始化了，但是 **a2** 没有；这里，**a2** 在后面被赋给另一个数组。由于 **a1** 和 **a2** 是相同数组的别名，因此通过 **a2** 所做的修改在 **a1** 中也能看到。\n\n所有的数组（无论是对象数组还是基本类型数组）都有一个固定成员 **length**，告诉你这个数组有多少个元素，你不能对其修改。与 C 和 C++ 类似，Java 数组计数也是从 0 开始的，所能使用的最大下标数是 **length - 1**。超过这个边界，C 和 C++ 会默认接受，允许你访问所有内存，许多声名狼藉的 bug 都是由此而生。但是 Java 在你访问超出这个边界时，会报运行时错误（异常），从而避免此类问题。\n\n### 动态数组创建\n\n如果在编写程序时，不确定数组中需要多少个元素，可以使用 **new** 在数组中创建元素。如下例所示，使用 **new** 创建基本类型数组。**new** 不能创建非数组以外的基本类型数据：\n\n```java\n// housekeeping/ArrayNew.java\n// Creating arrays with new\nimport java.util.*;\n\npublic class ArrayNew {\n    public static void main(String[] args) {\n        int[] a;\n        Random rand = new Random(47);\n        a = new int[rand.nextInt(20)];\n        System.out.println(\"length of a = \" + a.length);\n        System.out.println(Arrays.toString(a));\n    } \n}\n```\n\n输出：\n\n```\nlength of a = 18\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n```\n\n数组的大小是通过 `Random.nextInt()` 随机确定的，这个方法会返回 0 到输入参数之间的一个值。 由于随机性，很明显数组的创建确实是在运行时进行的。此外，程序输出表明，数组元素中的基本数据类型值会自动初始化为默认值（对于数字和字符是 0；对于布尔型是 **false**）。`Arrays.toString()` 是 **java.util** 标准类库中的方法，会产生一维数组的可打印版本。\n\n本例中，数组也可以在定义的同时进行初始化：\n\n```java\nint[] a = new int[rand.nextInt(20)];\n```\n\n如果可能的话，应该尽量这么做。\n\n如果你创建了一个非基本类型的数组，那么你创建的是一个引用数组。以整型的包装类型 **Integer** 为例，它是一个类而非基本类型：\n\n```java\n// housekeeping/ArrayClassObj.java\n// Creating an array of nonprimitive objects\n\nimport java.util.*;\n\npublic class ArrayClassObj {\n    public static void main(String[] args) {\n        Random rand = new Random(47);\n        Integer[] a = new Integer[rand.nextInt(20)];\n        System.out.println(\"length of a = \" + a.length);\n        for (int i = 0; i < a.length; i++) {\n            a[i] = rand.nextInt(500); // Autoboxing\n        }\n        System.out.println(Arrays.toString(a));\n    }\n}\n```\n\n输出：\n\n```\nlength of a = 18\n[55, 193, 361, 461, 429, 368, 200, 22, 207, 288, 128, 51, 89, 309, 278, 498, 361, 20]\n```\n\n这里，即使使用 new 创建数组之后：\n\n```java\nInteger[] a = new Integer[rand.nextInt(20)];	\n```\n\n它只是一个引用数组，直到通过创建新的 **Integer** 对象（通过自动装箱），并把对象赋值给引用，初始化才算结束：\n\n```java\na[i] = rand.nextInt(500);\n```\n\n如果忘记了创建对象，但试图使用数组中的空引用，就会在运行时产生异常。\n\n也可以用花括号括起来的列表来初始化数组，有两种形式：\n\n```java\n// housekeeping/ArrayInit.java\n// Array initialization\nimport java.util.*;\n\npublic class ArrayInit {\n    public static void main(String[] args) {\n        Integer[] a = {\n                1, 2,\n                3, // Autoboxing\n        };\n        Integer[] b = new Integer[] {\n                1, 2,\n                3, // Autoboxing\n        };\n        System.out.println(Arrays.toString(a));\n        System.out.println(Arrays.toString(b));\n\n    }\n}\n```\n\n输出：\n\n```\n[1, 2, 3]\n[1, 2, 3]\n```\n\n在这两种形式中，初始化列表的最后一个逗号是可选的（这一特性使维护长列表变得更容易）。\n\n尽管第一种形式很有用，但是它更加受限，因为它只能用于数组定义处。第二种和第三种形式可以用在任何地方，甚至用在方法的内部。例如，你创建了一个 **String** 数组，将其传递给另一个类的 `main()` 方法，如下：\n\n```java\n// housekeeping/DynamicArray.java\n// Array initialization\n\npublic class DynamicArray {\n    public static void main(String[] args) {\n        Other.main(new String[] {\"fiddle\", \"de\", \"dum\"});\n    }\n}\n\nclass Other {\n    public static void main(String[] args) {\n        for (String s: args) {\n            System.out.print(s + \" \");\n        }\n    }\n}\n```\n\n输出：\n\n```\nfiddle de dum \n```\n\n`Other.main()` 的参数是在调用处创建的，因此你甚至可以在方法调用处提供可替换的参数。\n\n### 可变参数列表\n\n你可以以一种类似 C 语言中的可变参数列表（C 通常把它称为\"varargs\"）来创建和调用方法。这可以应用在参数个数或类型未知的场合。由于所有的类都最后继承于 **Object** 类（随着本书的进展，你会对此有更深的认识），所以你可以创建一个以 Object 数组为参数的方法，并像下面这样调用：\n\n```java\n// housekeeping/VarArgs.java\n// Using array syntax to create variable argument lists\n\nclass A {}\n\npublic class VarArgs {\n    static void printArray(Object[] args) {\n        for (Object obj: args) {\n            System.out.print(obj + \" \");\n        }\n        System.out.println();\n    }\n    \n    public static void main(String[] args) {\n        printArray(new Object[] {47, (float) 3.14, 11.11});\n        printArray(new Object[] {\"one\", \"two\", \"three\"});\n        printArray(new Object[] {new A(), new A(), new A()});\n    }\n}\n```\n\n输出：\n\n```\n47 3.14 11.11 \none two three \nA@15db9742 A@6d06d69c A@7852e922\n```\n\n`printArray()` 的参数是 **Object** 数组，使用 for-in 语法遍历和打印数组的每一项。标准 Java 库能输出有意义的内容，但这里创建的是类的对象，打印出的内容是类名，后面跟着一个 **@** 符号以及多个十六进制数字。因而，默认行为（如果没有定义 `toString()` 方法的话，后面会讲这个方法）就是打印类名和对象的地址。\n\n你可能看到像上面这样编写的 Java 5 之前的代码，它们可以产生可变的参数列表。在 Java 5 中，这种期盼已久的特性终于添加了进来，就像在 `printArray()` 中看到的那样：\n\n```java\n// housekeeping/NewVarArgs.java\n// Using array syntax to create variable argument lists\n\npublic class NewVarArgs {\n    static void printArray(Object... args) {\n        for (Object obj: args) {\n            System.out.print(obj + \" \");\n        }\n        System.out.println();\n    }\n    \n    public static void main(String[] args) {\n        // Can take individual elements:\n        printArray(47, (float) 3.14, 11.11);\n        printArray(47, 3.14F, 11.11);\n        printArray(\"one\", \"two\", \"three\");\n        printArray(new A(), new A(), new A());\n        // Or an array:\n        printArray((Object[]) new Integer[] {1, 2, 3, 4});\n        printArray(); // Empty list is OK\n    }\n}\n```\n\n输出：\n\n```\n47 3.14 11.11 \n47 3.14 11.11 \none two three \nA@15db9742 A@6d06d69c A@7852e922 \n1 2 3 4 \n```\n\n有了可变参数，你就再也不用显式地编写数组语法了，当你指定参数时，编译器实际上会为你填充数组。你获取的仍然是一个数组，这就是为什么 `printArray()` 可以使用 for-in 迭代数组的原因。但是，这不仅仅只是从元素列表到数组的自动转换。注意程序的倒数第二行，一个 **Integer** 数组（通过自动装箱创建）被转型为一个 **Object** 数组（为了移除编译器的警告），并且传递给了 `printArray()`。显然，编译器会发现这是一个数组，不会执行转换。因此，如果你有一组事物，可以把它们当作列表传递，而如果你已经有了一个数组，该方法会把它们当作可变参数列表来接受。\n\n程序的最后一行表明，可变参数的个数可以为 0。当具有可选的尾随参数时，这一特性会有帮助：\n\n```java\n// housekeeping/OptionalTrailingArguments.java\n\npublic class OptionalTrailingArguments {\n    static void f(int required, String... trailing) {\n        System.out.print(\"required: \" + required + \" \");\n        for (String s: trailing) {\n            System.out.print(s + \" \");\n        }\n        System.out.println();\n    }\n    \n    public static void main(String[] args) {\n        f(1, \"one\");\n        f(2, \"two\", \"three\");\n        f(0);\n    }\n}\n```\n\n输出：\n\n```\nrequired: 1 one \nrequired: 2 two three \nrequired: 0 \n```\n\n这段程序展示了如何使用除了 **Object** 类之外类型的可变参数列表。这里，所有的可变参数都是 **String** 对象。可变参数列表中可以使用任何类型的参数，包括基本类型。下面例子展示了可变参数列表变为数组的情形，并且如果列表中没有任何元素，那么转变为大小为 0 的数组：\n\n```java\n// housekeeping/VarargType.java\n\npublic class VarargType {\n    static void f(Character... args) {\n        System.out.print(args.getClass());\n        System.out.println(\" length \" + args.length);\n    }\n    \n    static void g(int... args) {\n        System.out.print(args.getClass());\n        System.out.println(\" length \" + args.length)\n    }\n    \n    public static void main(String[] args) {\n        f(\'a\');\n        f();\n        g(1);\n        g();\n        System.out.println(\"int[]: \"+ new int[0].getClass());\n    }\n}\n```\n\n输出：\n\n```\nclass [Ljava.lang.Character; length 1\nclass [Ljava.lang.Character; length 0\nclass [I length 1\nclass [I length 0\nint[]: class [I\n```\n\n`getClass()` 方法属于 Object 类，将在\"类型信息\"一章中全面介绍。它会产生对象的类，并在打印该类时，看到表示该类类型的编码字符串。前导的 **[** 代表这是一个后面紧随的类型的数组，**I** 表示基本类型 **int**；为了进行双重检查，我在最后一行创建了一个 **int** 数组，打印了其类型。这样也验证了使用可变参数列表不依赖于自动装箱，而使用的是基本类型。\n\n然而，可变参数列表与自动装箱可以和谐共处，如下：\n\n```java\n// housekeeping/AutoboxingVarargs.java\n\npublic class AutoboxingVarargs {\n    public static void f(Integer... args) {\n        for (Integer i: args) {\n            System.out.print(i + \" \");\n        }\n        System.out.println();\n    }\n    \n    public static void main(String[] args) {\n        f(1, 2);\n        f(4, 5, 6, 7, 8, 9);\n        f(10, 11, 12);\n        \n    }\n}\n```\n\n输出：\n\n```\n1 2\n4 5 6 7 8 9\n10 11 12\n```\n\n注意吗，你可以在单个参数列表中将类型混合在一起，自动装箱机制会有选择地把 **int** 类型的参数提升为 **Integer**。\n\n可变参数列表使得方法重载更加复杂了，尽管乍看之下似乎足够安全：\n\n```java\n// housekeeping/OverloadingVarargs.java\n\npublic class OverloadingVarargs {\n    static void f(Character... args) {\n        System.out.print(\"first\");\n        for (Character c: args) {\n            System.out.print(\" \" + c);\n        }\n        System.out.println();\n    }\n    \n    static void f(Integer... args) {\n        System.out.print(\"second\");\n        for (Integer i: args) {\n            System.out.print(\" \" + i);\n        }\n        System.out.println();\n    }\n    \n    static void f(Long... args) {\n        System.out.println(\"third\");\n    }\n    \n    public static void main(String[] args) {\n        f(\'a\', \'b\', \'c\');\n        f(1);\n        f(2, 1);\n        f(0);\n        f(0L);\n        //- f(); // Won\'s compile -- ambiguous\n    }\n}\n```\n\n输出：\n\n```\nfirst a b c\nsecond 1\nsecond 2 1\nsecond 0\nthird\n```\n\n在每种情况下，编译器都会使用自动装箱来匹配重载的方法，然后调用最明确匹配的方法。\n\n但是如果调用不含参数的 `f()`，编译器就无法知道应该调用哪个方法了。尽管这个错误可以弄清楚，但是它可能会使客户端程序员感到意外。\n\n你可能会通过在某个方法中增加一个非可变参数解决这个问题：\n\n```java\n// housekeeping/OverloadingVarargs2.java\n// {WillNotCompile}\n\npublic class OverloadingVarargs2 {\n    static void f(float i, Character... args) {\n        System.out.println(\"first\");\n    }\n    \n    static void f(Character... args) {\n        System.out.println(\"second\");\n    }\n    \n    public static void main(String[] args) {\n        f(1, \'a\');\n        f(\'a\', \'b\');\n    }\n}\n```\n\n{WillNotCompile} 注释把该文件排除在了本书的 Gradle 构建之外。如果你手动编译它，会得到下面的错误信息：\n\n```\nOverloadingVarargs2.java:14:error:reference to f is ambiguous f(\'a\', \'b\');\n\\^\nboth method f(float, Character...) in OverloadingVarargs2 and method f(Character...) in OverloadingVarargs2 match 1 error\n```\n\n如果你给这两个方法都添加一个非可变参数，就可以解决问题了：\n\n```java\n// housekeeping/OverloadingVarargs3\n\npublic class OverloadingVarargs3 {\n    static void f(float i, Character... args) {\n        System.out.println(\"first\");\n    }\n    \n    static void f(char c, Character... args) {\n        System.out.println(\"second\");\n    }\n    \n    public static void main(String[] args) {\n        f(1, \'a\');\n        f(\'a\', \'b\');\n    }\n}\n```\n\n输出：\n\n```\nfirst\nsecond\n```\n\n你应该总是在重载方法的一个版本上使用可变参数列表，或者压根不用它。\n\n<!-- Enumerated Types -->\n\n## 枚举类型\n\nJava 5 中添加了一个看似很小的特性 enum 关键字，它使得我们在需要群组并使用枚举类型集时，可以很方便地处理。以前，你需要创建一个整数常量集，但是这些值并不会将自身限制在这个常量集的范围内，因此使用它们更有风险，而且更难使用。枚举类型属于非常普遍的需求，C、C++ 和其他许多语言都已经拥有它了。在 Java 5 之前，Java 程序员必须了解许多细节并格外仔细地去达成 enum 的效果。现在 Java 也有了 enum，并且它的功能比 C/C++ 中的完备得多。下面是个简单的例子：\n\n```java\n// housekeeping/Spiciness.java\n\npublic enum Spiciness {\n    NOT, MILD, MEDIUM, HOT, FLAMING\n}\n```\n\n这里创建了一个名为 Spiciness 的枚举类型，它有 5 个值。由于枚举类型的实例是常量，因此按照命名惯例，它们都用大写字母表示（如果名称中含有多个单词，使用下划线分隔）。\n\n要使用 **enum**，需要创建一个该类型的引用，然后将其赋值给某个实例：\n\n```java\n// housekeeping/SimpleEnumUse.java\n\npublic class SimpleEnumUse {\n    public static void main(String[] args) {\n        Spiciness howHot = Spiciness.MEDIUM;\n        System.out.println(howHot);\n    }\n}\n```\n\n输出：\n\n```\nMEDIUM\n```\n\n在你创建 **enum** 时，编译器会自动添加一些有用的特性。例如，它会创建 `toString()` 方法，以便你方便地显示某个 **enum** 实例的名称，这从上面例子中的输出可以看出。编译器还会创建 `ordinal()` 方法表示某个特定 **enum** 常量的声明顺序，`static values()` 方法按照 enum 常量的声明顺序，生成这些常量值构成的数组：\n\n```java\n// housekeeping/EnumOrder.java\n\npublic class EnumOrder {\n    public static void main(String[] args) {\n        for (Spiciness s: Spiciness.values()) {\n            System.out.println(s + \", ordinal \" + s.ordinal());\n        }\n    }\n}\n```\n\n输出：\n\n```\nNOT, ordinal 0\nMILD, ordinal 1\nMEDIUM, ordinal 2\nHOT, ordinal 3\nFLAMING, ordinal 4\n```\n\n尽管 **enum** 看起来像是一种新的数据类型，但是这个关键字只是在生成 **enum** 的类时，产生了某些编译器行为，因此在很大程度上你可以将 **enum** 当作其他任何类。事实上，**enum** 确实是类，并且具有自己的方法。\n\n**enum** 有一个很实用的特性，就是在 **switch** 语句中使用：\n\n```java\n// housekeeping/Burrito.java\n\npublic class Burrito {\n    Spiciness degree;\n    \n    public Burrito(Spiciness degree) {\n        this.degree = degree;\n    }\n    \n    public void describe() {\n        System.out.print(\"This burrito is \");\n        switch(degree) {\n            case NOT:\n                System.out.println(\"not spicy at all.\");\n                break;\n            case MILD:\n            case MEDIUM:\n                System.out.println(\"a little hot.\");\n                break;\n            case HOT:\n            case FLAMING:\n            default:\n                System.out.println(\"maybe too hot\");\n        }\n    }\n    \n    public static void main(String[] args) {\n        Burrito plain = new Burrito(Spiciness.NOT),\n        greenChile = new Burrito(Spiciness.MEDIUM),\n        jalapeno = new Burrito(Spiciness.HOT);\n        plain.describe();\n        greenChile.describe();\n        jalapeno.describe();\n    }\n}\n```\n\n输出：\n\n```\nThis burrito is not spicy at all.\nThis burrito is a little hot.\nThis burrito is maybe too hot.\n```\n\n由于 **switch** 是在有限的可能值集合中选择，因此它与 **enum** 是绝佳的组合。注意，enum 的名称是如何能够倍加清楚地表明程序的目的的。\n\n通常，你可以将 **enum** 用作另一种创建数据类型的方式，然后使用所得到的类型。这正是关键所在，所以你不用过多地考虑它们。在 **enum** 被引入之前，你必须花费大量的精力去创建一个等同的枚举类型，并是安全可用的。\n\n这些介绍对于你理解和使用基本的 **enum** 已经足够了，我们会在\"枚举\"一章中进行更深入的探讨。\n\n## 本章小结\n\n构造器，这种看起来精巧的初始化机制，应该给了你很强的暗示：初始化在编程语言中的重要地位。C++ 的发明者 Bjarne Stroustrup 在设计 C++ 期间，在针对 C 语言的生产效率进行的最初调查中发现，错误的初始化会导致大量编程错误。这些错误很难被发现，同样，不合理的清理也会如此。因为构造器能保证进行正确的初始化和清理（没有正确的构造器调用，编译器就不允许创建对象），所以你就有了完全的控制和安全。\n\n在 C++ 中，析构器很重要，因为用 new 创建的对象必须被明确地销毁。在 Java 中，垃圾回收器会自动地释放所有对象的内存，所以很多时候类似的清理方法就不太需要了（但是当要用到的时候，你得自己动手）。在不需要类似析构器行为的时候，Java 的垃圾回收器极大地简化了编程，并加强了内存管理上的安全性。一些垃圾回收器甚至能清理其他资源，如图形和文件句柄。然而，垃圾回收器确实增加了运行时开销，由于 Java 解释器从一开始就很慢，所以这种开销到底造成多大的影响很难看出来。随着时间的推移，Java 在性能方面提升了很多，但是速度问题仍然是它涉足某些特定编程领域的障碍。\n\n由于要保证所有对象被创建，实际上构造器比这里讨论得更加复杂。特别是当通过组合或继承创建新类的时候，这种保证仍然成立，并且需要一些额外的语法来支持。在后面的章节中，你会学习组合，继承以及它们如何影响构造器。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n', '2021-12-06 06:21:51', 1, 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/macos.6z1mshl4twk0.svg', 16, '2021-10-14 13:04:54', NULL, NULL, NULL, 1, 1, 0, NULL, 0, '<p>“不安全”的编程是造成编程代价昂贵的罪魁祸首之一。有两个安全性问题：初始化和清理。C 语言中很多的 bug 都是因为程序员忘记初始化导致的。尤其是很多类库的使用者不知道如何初始化类库组件，甚至他们必须得去初始化。清理则是另一个特殊的问题，因为当你使用一个元素做完事后就不会去关心这个元素，所以你很容易忘记清理它。这样就造成了元素使用的资源滞留不会被回收，直到程序消耗完所有的资源（特别是内存）。</p>\n<p>C++ 引入了构造器的概念，这是一个特殊的方法，每创建一个对象，这个方法就会被自动调用。Java 采用了构造器的概念，另外还使用了垃圾收集器（Garbage Collector, GC）去自动回收不再被使用的对象所占的资源。这一章将讨论初始化和清理的问题，以及在 Java 中对它们的支持。</p>\n<h2 id=\"利用构造器保证初始化\">利用构造器保证初始化</h2>\n<p>你可能会想为每个类创建一个 <code>initialize()</code> 方法，该方法名暗示着在使用类之前需要先调用它。不幸的是，用户必须得记得去调用它。在 Java 中，类的设计者通过构造器保证每个对象的初始化。如果一个类有构造器，那么 Java 会在用户使用对象之前（即对象刚创建完成）自动调用对象的构造器方法，从而保证初始化。</p>\n<p>下个挑战是如何命名构造器方法。存在两个问题：</p>\n<ul>\n<li>第一个是任何命名都可能与类中其他已有元素的命名冲突；</li>\n<li>第二个是编译器必须始终知道构造器方法名称，从而调用它。</li>\n</ul>\n<p>C++ 的解决方法看起来是最简单且最符合逻辑的，所以 Java 中使用了同样的方式：构造器名称与类名相同。在初始化过程中自动调用构造器方法是有意义的。</p>\n<p>以下示例是包含了一个构造器的类：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/SimpleConstructor.java</span>\n<span class=\"hljs-comment\">// Demonstration of a simple constructor</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rock</span> {\n    <span class=\"hljs-built_in\">Rock</span>() { <span class=\"hljs-comment\">// 这是一个构造器</span>\n        System.out.<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Rock &quot;</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleConstructor</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">String</span>[] args)</span> </span>{\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) {\n            <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Rock</span>();\n        }\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">Rock Rock Rock Rock Rock Rock Rock Rock Rock</span> <span class=\"hljs-comment\">Rock</span> \n</code></pre>\n<p>现在，当创建一个对象时：<code>new Rock()</code> ，内存被分配，构造器被调用。构造器保证了对象在你使用它之前进行了正确的初始化。</p>\n<p>有一点需要注意，构造器方法名与类名相同，不需要符合首字母小写的编程风格。在 C++ 中，无参构造器被称为默认构造器，这个术语在 Java 出现之前使用了很多年。但是，出于一些原因，Java 设计者们决定使用无参构造器这个名称。</p>\n<p>跟其他方法一样，构造器方法也可以传入参数来定义如何创建一个对象。之前的例子稍作修改，使得构造器接收一个参数：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/SimpleConstructor2.java</span>\n<span class=\"hljs-comment\">// Constructors can have arguments</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Rock2</span> {\n    <span class=\"hljs-built_in\">Rock2</span>(<span class=\"hljs-type\">int</span> i) {\n        System.out.<span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Rock &quot;</span> + i + <span class=\"hljs-string\">&quot; &quot;</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleConstructor2</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">String</span>[] args)</span> </span>{\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">8</span>; i++) {\n            <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Rock2</span>(i);\n        }\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-attribute\">Rock</span> <span class=\"hljs-number\">0</span> Rock <span class=\"hljs-number\">1</span> Rock <span class=\"hljs-number\">2</span> Rock <span class=\"hljs-number\">3</span> Rock <span class=\"hljs-number\">4</span> Rock <span class=\"hljs-number\">5</span> Rock <span class=\"hljs-number\">6</span> Rock <span class=\"hljs-number\">7</span>\n</code></pre>\n<p>如果类 <code>Tree</code> 有一个构造方法，只接收一个参数用来表示树的高度，那么你可以像下面这样创建一棵树：</p>\n<pre><code class=\"hljs language-java\">Tree t = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Tree</span>(<span class=\"hljs-number\">12</span>); <span class=\"hljs-comment\">// 12-foot 树</span>\n</code></pre>\n<p>如果 <code>Tree(int)</code> 是唯一的构造器，那么编译器就不允许你以其他任何方式创建 <code>Tree</code> 类型的对象。</p>\n<p>构造器消除了一类重要的问题，使得代码更易读。例如，在上面的代码块中，你看不到对 <code>initialize()</code> 方法的显式调用，而从概念上来看，<code>initialize()</code> 方法应该与对象的创建分离。在 Java 中，对象的创建与初始化是统一的概念，二者不可分割。</p>\n<p>构造器没有返回值，它是一种特殊的方法。但它和返回类型为 <code>void</code> 的普通方法不同：</p>\n<ul>\n<li>普通方法可以返回空值，你还能选择让它返回别的类型；</li>\n<li>而构造器没有返回值，却同时也没有给你选择的余地（ <code>new</code> 表达式虽然返回了刚创建的对象的引用，但构造器本身却没有返回任何值）。如果它有返回值，并且你也可以自己选择让它返回什么，那么编译器就还得知道接下来该怎么处理那个返回值（这个返回值没有接收者）。</li>\n</ul>\n<h2 id=\"方法重载\">方法重载</h2>\n<p>任何编程语言中都具备的一项重要特性就是命名。当你创建一个对象时，就会给此对象分配的内存空间命名。方法是行为的命名。你通过名字指代所有的对象，属性和方法。良好命名的系统易于理解和修改。就好比写散文，目的是与读者沟通。</p>\n<p>将人类语言细微的差别映射到编程语言中会产生一个问题。通常，相同的词可以表达多种不同的含义——它们被“重载”了。特别是当含义的差别很小时，这会更加有用。你会说“清洗衬衫”、“清洗车”和“清洗狗”。而如果硬要这么说就会显得很愚蠢：“以洗衬衫的方式洗衬衫”、“以洗车的方式洗车”和“以洗狗的方式洗狗”，因为听众根本不需要区分行为的动作。大多数人类语言都具有“冗余”性，所以即使漏掉几个词，你也能明白含义。你不需要对每个概念都使用不同的词汇，可以从上下文推断出含义。</p>\n<p>大多数编程语言（尤其是 C 语言）要求为每个方法（在这些语言中经常称为函数）提供一个独一无二的标识符。所以，你不能有一个 <code>print()</code> 函数既能打印整型，也能打印浮点型，每个函数名都必须不同。</p>\n<p>在 Java (C++) 中，还有一个因素也促使了必须使用方法重载：构造器。因为构造器方法名肯定是与类名相同，所以一个类中只会有一个构造器名。那么你怎么通过不同的方式创建一个对象呢？例如，你想创建一个类，这个类的初始化方式有两种：一种是标准化方式，另一种是从文件中读取信息的方式。你需要两个构造器：无参构造器和有一个 String 类型参数的构造器，该参数传入文件名。两个构造器具有相同的名字——与类名相同。因此，方法重载是必要的，它允许方法具有相同的方法名但接收的参数不同。尽管方法重载对于构造器是重要的，但是也可以对任何方法很方便地进行重载。</p>\n<p>下例展示了如何重载构造器和方法：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/Overloading.java</span>\n<span class=\"hljs-comment\">// Both constructor and ordinary method overloading</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Tree</span> {\n    <span class=\"hljs-type\">int</span> height;\n    <span class=\"hljs-built_in\">Tree</span>() {\n        System.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">&quot;Planting a seedling&quot;</span>);\n        height = <span class=\"hljs-number\">0</span>;\n    }\n    <span class=\"hljs-built_in\">Tree</span>(<span class=\"hljs-type\">int</span> initialHeight) {\n        height = initialHeight;\n        System.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">&quot;Creating new Tree that is &quot;</span> + height + <span class=\"hljs-string\">&quot; feet tall&quot;</span>);\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">info</span><span class=\"hljs-params\">()</span> </span>{\n        System.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">&quot;Tree is &quot;</span> + height + <span class=\"hljs-string\">&quot; feet tall&quot;</span>);\n    }\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">info</span><span class=\"hljs-params\">(<span class=\"hljs-type\">String</span> s)</span> </span>{\n        System.out.<span class=\"hljs-built_in\">println</span>(s + <span class=\"hljs-string\">&quot;: Tree is &quot;</span> + height + <span class=\"hljs-string\">&quot; feet tall&quot;</span>);\n    }\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Overloading</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">String</span>[] args)</span> </span>{\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; i++) {\n            Tree t = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Tree</span>(i);\n            t.<span class=\"hljs-built_in\">info</span>();\n            t.<span class=\"hljs-built_in\">info</span>(<span class=\"hljs-string\">&quot;overloaded method&quot;</span>);\n        }\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Tree</span>(); \n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code>Creating <span class=\"hljs-keyword\">new</span> Tree that <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">0</span> feet tall\nTree <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">0</span> feet tall\noverloaded <span class=\"hljs-function\"><span class=\"hljs-keyword\">method</span>:</span> Tree <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">0</span> feet tall\nCreating <span class=\"hljs-keyword\">new</span> Tree that <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">1</span> feet tall\nTree <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">1</span> feet tall\noverloaded <span class=\"hljs-function\"><span class=\"hljs-keyword\">method</span>:</span> Tree <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">1</span> feet tall\nCreating <span class=\"hljs-keyword\">new</span> Tree that <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">2</span> feet tall\nTree <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">2</span> feet tall\noverloaded <span class=\"hljs-function\"><span class=\"hljs-keyword\">method</span>:</span> Tree <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">2</span> feet tall\nCreating <span class=\"hljs-keyword\">new</span> Tree that <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">3</span> feet tall\nTree <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">3</span> feet tall\noverloaded <span class=\"hljs-function\"><span class=\"hljs-keyword\">method</span>:</span> Tree <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">3</span> feet tall\nCreating <span class=\"hljs-keyword\">new</span> Tree that <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">4</span> feet tall\nTree <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">4</span> feet tall\noverloaded <span class=\"hljs-function\"><span class=\"hljs-keyword\">method</span>:</span> Tree <span class=\"hljs-keyword\">is</span> <span class=\"hljs-number\">4</span> feet tall\nPlanting a seedling\n</code></pre>\n<p>一个 Tree 对象既可以是一颗树苗，使用无参构造器创建，也可以是一颗在温室中已长大的树，已经有一定高度，这时候，就需要使用有参构造器创建。</p>\n<p>你也许想以多种方式调用 <code>info()</code> 方法。比如，如果你想打印额外的消息，就可以使用 <code>info(String)</code> 方法。如果你无话可说，就可以使用 <code>info()</code> 方法。用两个命名定义完全相同的概念看起来很奇怪，而使用方法重载，你就可以使用一个命名来定义一个概念。</p>\n<h3 id=\"区分重载方法\">区分重载方法</h3>\n<p>如果两个方法命名相同，Java 是怎么知道你调用的是哪个呢？有一条简单的规则：每个被重载的方法必须有独一无二的参数列表。你稍微思考下，就会很明了了，除了通过参数列表的不同来区分两个相同命名的方法，其他也没什么方式了。你甚至可以根据参数列表中的参数顺序来区分不同的方法，尽管这会造成代码难以维护。例如：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/OverloadingOrder.java</span>\n<span class=\"hljs-comment\">// Overloading based on the order of the arguments</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OverloadingOrder</span> {\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span> s, int i</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;String: &quot;</span> + s + <span class=\"hljs-string\">&quot;, int: &quot;</span> + i);\n    }\n\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">int i, <span class=\"hljs-built_in\">String</span> s</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;int: &quot;</span> + i + <span class=\"hljs-string\">&quot;, String: &quot;</span> + s);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-string\">&quot;String first&quot;</span>, <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">99</span>, <span class=\"hljs-string\">&quot;Int first&quot;</span>);\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-built_in\">String</span>: <span class=\"hljs-built_in\">String</span> first, <span class=\"hljs-built_in\">int</span>: <span class=\"hljs-number\">1</span>\n<span class=\"hljs-built_in\">int</span>: <span class=\"hljs-number\">99</span>, <span class=\"hljs-built_in\">String</span>: <span class=\"hljs-built_in\">Int</span> first\n</code></pre>\n<p>两个 <code>f()</code> 方法具有相同的参数，但是参数顺序不同，根据这个就可以区分它们。</p>\n<h3 id=\"重载与基本类型\">重载与基本类型</h3>\n<p>基本类型可以自动从较小的类型转型为较大的类型。当这与重载结合时，这会令人有点困惑，下面是一个这样的例子：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/PrimitiveOverloading.java</span>\n<span class=\"hljs-comment\">// Promotion of primitives and overloading</span>\n\n<span class=\"hljs-variable\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PrimitiveOverloading</span> {\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f1</span>(<span class=\"hljs-params\">char</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f1(char)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f1</span>(<span class=\"hljs-params\">byte</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f1(byte)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f1</span>(<span class=\"hljs-params\">short</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f1(short)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f1</span>(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f1(int)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f1</span>(<span class=\"hljs-params\">long</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f1(long)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f1</span>(<span class=\"hljs-params\">float</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f1(float)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f1</span>(<span class=\"hljs-params\">double</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f1(double)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f2</span>(<span class=\"hljs-params\">byte</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f2(byte)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f2</span>(<span class=\"hljs-params\">short</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f2(short)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f2</span>(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f2(int)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f2</span>(<span class=\"hljs-params\">long</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f2(long)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f2</span>(<span class=\"hljs-params\">float</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f2(float)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f2</span>(<span class=\"hljs-params\">double</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f2(double)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f3</span>(<span class=\"hljs-params\">short</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f3(short)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f3</span>(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f3(int)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f3</span>(<span class=\"hljs-params\">long</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f3(long)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f3</span>(<span class=\"hljs-params\">float</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f3(float)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f3</span>(<span class=\"hljs-params\">double</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f3(double)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f4</span>(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f4(int)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f4</span>(<span class=\"hljs-params\">long</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f4(long)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f4</span>(<span class=\"hljs-params\">float</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f4(float)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f4</span>(<span class=\"hljs-params\">double</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f4(double)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f5</span>(<span class=\"hljs-params\">long</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f5(long)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f5</span>(<span class=\"hljs-params\">float</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f5(float)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f5</span>(<span class=\"hljs-params\">double</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f5(double)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f6</span>(<span class=\"hljs-params\">float</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f6(float)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f6</span>(<span class=\"hljs-params\">double</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f6(double)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">f7</span>(<span class=\"hljs-params\">double</span> <span class=\"hljs-params\">x</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;f7(double)&quot;</span>);\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">testConstVal</span>() {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;5: &quot;</span>);\n        <span class=\"hljs-title function_\">f1</span>(<span class=\"hljs-number\">5</span>);<span class=\"hljs-title function_\">f2</span>(<span class=\"hljs-number\">5</span>);<span class=\"hljs-title function_\">f3</span>(<span class=\"hljs-number\">5</span>);<span class=\"hljs-title function_\">f4</span>(<span class=\"hljs-number\">5</span>);<span class=\"hljs-title function_\">f5</span>(<span class=\"hljs-number\">5</span>);<span class=\"hljs-title function_\">f6</span>(<span class=\"hljs-number\">5</span>);<span class=\"hljs-title function_\">f7</span>(<span class=\"hljs-number\">5</span>);\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">println</span>();\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">testChar</span>() {\n        <span class=\"hljs-variable\">char</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> &#x27;<span class=\"hljs-variable\">x</span>&#x27;;\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;char: &quot;</span>);\n        <span class=\"hljs-title function_\">f1</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f2</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f3</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f4</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f5</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f6</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f7</span>(<span class=\"hljs-variable\">x</span>);\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">println</span>();\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">testByte</span>() {\n        <span class=\"hljs-variable\">byte</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;byte: &quot;</span>);\n        <span class=\"hljs-title function_\">f1</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f2</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f3</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f4</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f5</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f6</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f7</span>(<span class=\"hljs-variable\">x</span>);\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">println</span>();\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">testShort</span>() {\n        <span class=\"hljs-variable\">short</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;short: &quot;</span>);\n        <span class=\"hljs-title function_\">f1</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f2</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f3</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f4</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f5</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f6</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f7</span>(<span class=\"hljs-variable\">x</span>);\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">println</span>();\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">testInt</span>() {\n        int <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;int: &quot;</span>);\n        <span class=\"hljs-title function_\">f1</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f2</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f3</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f4</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f5</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f6</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f7</span>(<span class=\"hljs-variable\">x</span>);\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">println</span>();\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">testLong</span>() {\n        <span class=\"hljs-variable\">long</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;long: &quot;</span>);\n        <span class=\"hljs-title function_\">f1</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f2</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f3</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f4</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f5</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f6</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f7</span>(<span class=\"hljs-variable\">x</span>);\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">println</span>();\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">testFloat</span>() {\n        <span class=\"hljs-variable\">float</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;float: &quot;</span>);\n        <span class=\"hljs-title function_\">f1</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f2</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f3</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f4</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f5</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f6</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f7</span>(<span class=\"hljs-variable\">x</span>);\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">println</span>();\n    }\n    <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">testDouble</span>() {\n        <span class=\"hljs-variable\">double</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">print</span>(<span class=\"hljs-string\">&quot;double: &quot;</span>);\n        <span class=\"hljs-title function_\">f1</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f2</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f3</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f4</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f5</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f6</span>(<span class=\"hljs-variable\">x</span>);<span class=\"hljs-title function_\">f7</span>(<span class=\"hljs-variable\">x</span>);\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-property\">println</span>();\n    }\n\n    <span class=\"hljs-variable\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-variable\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\">String</span>[] <span class=\"hljs-params\">args</span>) {\n        <span class=\"hljs-title class_\">PrimitiveOverloading</span> <span class=\"hljs-variable\">p</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-variable\">new</span> <span class=\"hljs-title class_\">PrimitiveOverloading</span>();\n        <span class=\"hljs-variable\">p</span>.<span class=\"hljs-property\">testConstVal</span>();\n        <span class=\"hljs-variable\">p</span>.<span class=\"hljs-property\">testChar</span>();\n        <span class=\"hljs-variable\">p</span>.<span class=\"hljs-property\">testByte</span>();\n        <span class=\"hljs-variable\">p</span>.<span class=\"hljs-property\">testShort</span>();\n        <span class=\"hljs-variable\">p</span>.<span class=\"hljs-property\">testInt</span>();\n        <span class=\"hljs-variable\">p</span>.<span class=\"hljs-property\">testLong</span>();\n        <span class=\"hljs-variable\">p</span>.<span class=\"hljs-property\">testFloat</span>();\n        <span class=\"hljs-variable\">p</span>.<span class=\"hljs-property\">testDouble</span>();\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-number\">5</span>: <span class=\"hljs-function\"><span class=\"hljs-title\">f1</span>(<span class=\"hljs-variable\">int</span>)<span class=\"hljs-title\">f2</span>(<span class=\"hljs-variable\">int</span>)<span class=\"hljs-title\">f3</span>(<span class=\"hljs-variable\">int</span>)<span class=\"hljs-title\">f4</span>(<span class=\"hljs-variable\">int</span>)<span class=\"hljs-title\">f5</span>(<span class=\"hljs-variable\">long</span>)<span class=\"hljs-title\">f6</span>(<span class=\"hljs-variable\">float</span>)<span class=\"hljs-title\">f7</span>(<span class=\"hljs-variable\">double</span>)</span>\n<span class=\"hljs-variable\">char</span>: <span class=\"hljs-function\"><span class=\"hljs-title\">f1</span>(<span class=\"hljs-variable\">char</span>)<span class=\"hljs-title\">f2</span>(<span class=\"hljs-variable\">int</span>)<span class=\"hljs-title\">f3</span>(<span class=\"hljs-variable\">int</span>)<span class=\"hljs-title\">f4</span>(<span class=\"hljs-variable\">int</span>)<span class=\"hljs-title\">f5</span>(<span class=\"hljs-variable\">long</span>)<span class=\"hljs-title\">f6</span>(<span class=\"hljs-variable\">float</span>)<span class=\"hljs-title\">f7</span>(<span class=\"hljs-variable\">double</span>)</span>\n<span class=\"hljs-variable\">byte</span>: <span class=\"hljs-function\"><span class=\"hljs-title\">f1</span>(<span class=\"hljs-variable\">byte</span>)<span class=\"hljs-title\">f2</span>(<span class=\"hljs-variable\">byte</span>)<span class=\"hljs-title\">f3</span>(<span class=\"hljs-variable\">short</span>)<span class=\"hljs-title\">f4</span>(<span class=\"hljs-variable\">int</span>)<span class=\"hljs-title\">f5</span>(<span class=\"hljs-variable\">long</span>)<span class=\"hljs-title\">f6</span>(<span class=\"hljs-variable\">float</span>)<span class=\"hljs-title\">f7</span>(<span class=\"hljs-variable\">double</span>)</span>\n<span class=\"hljs-variable\">short</span>: <span class=\"hljs-function\"><span class=\"hljs-title\">f1</span>(<span class=\"hljs-variable\">short</span>)<span class=\"hljs-title\">f2</span>(<span class=\"hljs-variable\">short</span>)<span class=\"hljs-title\">f3</span>(<span class=\"hljs-variable\">short</span>)<span class=\"hljs-title\">f4</span>(<span class=\"hljs-variable\">int</span>)<span class=\"hljs-title\">f5</span>(<span class=\"hljs-variable\">long</span>)<span class=\"hljs-title\">f6</span>(<span class=\"hljs-variable\">float</span>)<span class=\"hljs-title\">f7</span>(<span class=\"hljs-variable\">double</span>)</span>\n<span class=\"hljs-variable\">int</span>: <span class=\"hljs-function\"><span class=\"hljs-title\">f1</span>(<span class=\"hljs-variable\">int</span>)<span class=\"hljs-title\">f2</span>(<span class=\"hljs-variable\">int</span>)<span class=\"hljs-title\">f3</span>(<span class=\"hljs-variable\">int</span>)<span class=\"hljs-title\">f4</span>(<span class=\"hljs-variable\">int</span>)<span class=\"hljs-title\">f5</span>(<span class=\"hljs-variable\">long</span>)<span class=\"hljs-title\">f6</span>(<span class=\"hljs-variable\">float</span>)<span class=\"hljs-title\">f7</span>(<span class=\"hljs-variable\">double</span>)</span>\n<span class=\"hljs-variable\">long</span>: <span class=\"hljs-function\"><span class=\"hljs-title\">f1</span>(<span class=\"hljs-variable\">long</span>)<span class=\"hljs-title\">f2</span>(<span class=\"hljs-variable\">long</span>)<span class=\"hljs-title\">f3</span>(<span class=\"hljs-variable\">long</span>)<span class=\"hljs-title\">f4</span>(<span class=\"hljs-variable\">long</span>)<span class=\"hljs-title\">f5</span>(<span class=\"hljs-variable\">long</span>)<span class=\"hljs-title\">f6</span>(<span class=\"hljs-variable\">float</span>)<span class=\"hljs-title\">f7</span>(<span class=\"hljs-variable\">double</span>)</span>\n<span class=\"hljs-variable\">float</span>: <span class=\"hljs-function\"><span class=\"hljs-title\">f1</span>(<span class=\"hljs-variable\">float</span>)<span class=\"hljs-title\">f2</span>(<span class=\"hljs-variable\">float</span>)<span class=\"hljs-title\">f3</span>(<span class=\"hljs-variable\">float</span>)<span class=\"hljs-title\">f4</span>(<span class=\"hljs-variable\">float</span>)<span class=\"hljs-title\">f5</span>(<span class=\"hljs-variable\">float</span>)<span class=\"hljs-title\">f6</span>(<span class=\"hljs-variable\">float</span>)<span class=\"hljs-title\">f7</span>(<span class=\"hljs-variable\">double</span>)</span>\n<span class=\"hljs-variable\">double</span>: <span class=\"hljs-function\"><span class=\"hljs-title\">f1</span>(<span class=\"hljs-variable\">double</span>)<span class=\"hljs-title\">f2</span>(<span class=\"hljs-variable\">double</span>)<span class=\"hljs-title\">f3</span>(<span class=\"hljs-variable\">double</span>)<span class=\"hljs-title\">f4</span>(<span class=\"hljs-variable\">double</span>)<span class=\"hljs-title\">f5</span>(<span class=\"hljs-variable\">double</span>)<span class=\"hljs-title\">f6</span>(<span class=\"hljs-variable\">double</span>)<span class=\"hljs-title\">f7</span>(<span class=\"hljs-variable\">double</span>)</span>\n</code></pre>\n<p>如果传入的参数类型大于方法期望接收的参数类型，你必须首先做下转换，如果你不做的话，编译器就会报错。</p>\n<h3 id=\"返回值的重载\">返回值的重载</h3>\n<p>经常会有人困惑，“为什么只能通过方法名和参数列表，不能通过方法名和返回值区分方法呢？”。例如以下两个方法，它们有相同的命名和参数，但是很容易区分：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>){}\nint <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\"></span>) {<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;}\n</code></pre>\n<p>有些情况下，编译器很容易就可以从上下文准确推断出该调用哪个方法，如 <code>int x = f()</code>。</p>\n<p>但是，你可以调用一个方法且忽略返回值。这叫做调用一个函数的副作用，因为你不在乎返回值，只是想利用方法做些事。所以如果你直接调用 <code>f()</code>，Java 编译器就不知道你想调用哪个方法，阅读者也不明所以。因为这个原因，所以你不能根据返回值类型区分重载的方法。</p>\n<h2 id=\"无参构造器\">无参构造器</h2>\n<p>如前文所说，一个无参构造器就是不接收参数的构造器，用来创建一个“默认的对象”。如果你创建一个类，类中没有构造器，那么编译器就会自动为你创建一个无参构造器。例如：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/DefaultConstructor.java</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Bird</span> </span>{}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DefaultConstructor</span> </span>{\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> void main(<span class=\"hljs-keyword\">String</span>[] args) {\n        Bird bird = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Bird</span>(); <span class=\"hljs-comment\">// 默认的</span>\n    }\n}\n</code></pre>\n<p>表达式 <code>new Bird()</code> 创建了一个新对象，调用了无参构造器，尽管在 Bird 类中并没有显式的定义无参构造器。试想如果没有构造器，我们如何创建一个对象呢。但是，一旦你显式地定义了构造器（无论有参还是无参），编译器就不会自动为你创建无参构造器。如下：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/NoSynthesis.java</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Bird2</span> {\n    Bird2(<span class=\"hljs-type\">int</span> i) {}\n    Bird2(<span class=\"hljs-type\">double</span> d) {}\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NoSynthesis</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-comment\">//- Bird2 b = new Bird2(); // No default</span>\n        <span class=\"hljs-type\">Bird2</span> <span class=\"hljs-variable\">b2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Bird2</span>(<span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-type\">Bird2</span> <span class=\"hljs-variable\">b3</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Bird2</span>(<span class=\"hljs-number\">1.0</span>);\n    }\n}\n</code></pre>\n<p>如果你调用了 <code>new Bird2()</code> ，编译器会提示找不到匹配的构造器。当类中没有构造器时，编译器会说“你一定需要构造器，那么让我为你创建一个吧”。但是如果类中有构造器，编译器会说“你已经写了构造器了，所以肯定知道你在做什么，如果你没有创建默认构造器，说明你本来就不需要”。</p>\n<h2 id=\"this-关键字\">this 关键字</h2>\n<p>对于两个相同类型的对象 a 和 b，你可能在想如何调用这两个对象的 <code>peel()</code> 方法：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/BananaPeel.java</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Banana</span> {\n    <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">peel</span>(<span class=\"hljs-params\">int i</span>) {\n        <span class=\"hljs-comment\">/*...*/</span>\n    }\n}\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BananaPeel</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-title class_\">Banana</span> a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Banana</span>(), b = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Banana</span>();\n        a.<span class=\"hljs-title function_\">peel</span>(<span class=\"hljs-number\">1</span>);\n        b.<span class=\"hljs-title function_\">peel</span>(<span class=\"hljs-number\">2</span>);\n    }\n}\n</code></pre>\n<p>如果只有一个方法 <code>peel()</code> ，那么怎么知道调用的是对象 a 的 <code>peel()</code> 方法还是对象 b 的 <code>peel()</code> 方法呢？编译器做了一些底层工作，所以你可以像这样编写代码。<code>peel()</code> 方法中第一个参数隐密地传入了一个指向操作对象的</p>\n<p>引用。因此，上述例子中的方法调用像下面这样：</p>\n<pre><code class=\"hljs language-java\">Banana<span class=\"hljs-selector-class\">.peel</span>(<span class=\"hljs-selector-tag\">a</span>, <span class=\"hljs-number\">1</span>)\nBanana<span class=\"hljs-selector-class\">.peel</span>(<span class=\"hljs-selector-tag\">b</span>, <span class=\"hljs-number\">1</span>)\n</code></pre>\n<p>这是在内部实现的，你不可以直接这么编写代码，编译器不会接受，但能说明到底发生了什么。假设现在在方法内部，你想获得对当前对象的引用。但是，对象引用是被秘密地传达给编译器——并不在参数列表中。方便的是，有一个关键字: <code>this</code> 。</p>\n<p><code>this</code> 关键字只能在非静态方法内部使用。当你调用一个对象的方法时，<code>this</code> 生成了一个对象引用。你可以像对待其他引用一样对待这个引用。如果你在一个类的方法里调用其他该类中的方法，不要使用 <code>this</code>，直接调用即可，<code>this</code> 自动地应用于其他方法上了。因此你可以像这样：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/Apricot.java</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Apricot</span> {\n    <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">pick</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-comment\">/* ... */</span>\n    }\n\n    <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">pit</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-title function_\">pick</span>();\n        <span class=\"hljs-comment\">/* ... */</span>\n    }\n}\n</code></pre>\n<p>在 <code>pit()</code> 方法中，你可以使用 <code>this.pick()</code>，但是没有必要。编译器自动为你做了这些。<code>this</code> 关键字只用在一些必须显式使用当前对象引用的特殊场合。例如，用在 return 语句中返回对当前对象的引用。</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/Leaf.java</span>\n<span class=\"hljs-comment\">// Simple use of the &quot;this&quot; keyword</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Leaf</span> {\n\n    int i = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-title class_\">Leaf</span> <span class=\"hljs-title function_\">increment</span>(<span class=\"hljs-params\"></span>) {\n        i++;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-variable language_\">this</span>;\n    }\n\n    <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">print</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;i = &quot;</span> + i);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-title class_\">Leaf</span> x = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Leaf</span>();\n        x.<span class=\"hljs-title function_\">increment</span>().<span class=\"hljs-title function_\">increment</span>().<span class=\"hljs-title function_\">increment</span>().<span class=\"hljs-title function_\">print</span>();\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-attribute\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span>\n</code></pre>\n<p>因为 <code>increment()</code> 通过 <code>this</code> 关键字返回当前对象的引用，因此在相同的对象上可以轻易地执行多次操作。</p>\n<p><code>this</code> 关键字在向其他方法传递当前对象时也很有用：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/PassingThis.java</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Person</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">eat</span>(<span class=\"hljs-params\">Apple apple</span>) {\n        <span class=\"hljs-title class_\">Apple</span> peeled = apple.<span class=\"hljs-title function_\">getPeeled</span>();\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;Yummy&quot;</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Peeler</span> {\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-title class_\">Apple</span> <span class=\"hljs-title function_\">peel</span>(<span class=\"hljs-params\">Apple apple</span>) {\n        <span class=\"hljs-comment\">// ... remove peel</span>\n        <span class=\"hljs-keyword\">return</span> apple; <span class=\"hljs-comment\">// Peeled</span>\n    }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Apple</span> {\n    <span class=\"hljs-title class_\">Apple</span> <span class=\"hljs-title function_\">getPeeled</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title class_\">Peeler</span>.<span class=\"hljs-title function_\">peel</span>(<span class=\"hljs-variable language_\">this</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">PassingThis</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Person</span>().<span class=\"hljs-title function_\">eat</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Apple</span>());\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-attribute\">Yummy</span>\n</code></pre>\n<p>Apple 因为某些原因（比如说工具类中的方法在多个类中重复出现，你不想代码重复），必须调用一个外部工具方法 <code>Peeler.peel()</code> 做一些行为。必须使用 this 才能将自身传递给外部方法。</p>\n<h3 id=\"在构造器中调用构造器\">在构造器中调用构造器</h3>\n<p>当你在一个类中写了多个构造器，有时你想在一个构造器中调用另一个构造器来避免代码重复。你通过 this 关键字实现这样的调用。</p>\n<p>通常当你说 this，意味着“这个对象”或“当前对象”，它本身生成对当前对象的引用。在一个构造器中，当你给 this 一个参数列表时，它是另一层意思。它通过最直接的方式显式地调用匹配参数列表的构造器：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/Flower.java</span>\n<span class=\"hljs-comment\">// Calling constructors with &quot;this&quot;</span>\n\npublic <span class=\"hljs-keyword\">class</span> Flower {\n    <span class=\"hljs-built_in\">int</span> petalCount = <span class=\"hljs-number\">0</span>;\n    String s = <span class=\"hljs-string\">&quot;initial value&quot;</span>;\n\n    <span class=\"hljs-constructor\">Flower(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">petals</span>)</span> {\n        petalCount = petals;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;Constructor w/ int arg only, petalCount = &quot;</span> + petalCount);\n    }\n\n    <span class=\"hljs-constructor\">Flower(String <span class=\"hljs-params\">ss</span>)</span> {\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;Constructor w/ string arg only, s = &quot;</span> + ss);\n        s = ss;\n    }\n\n    <span class=\"hljs-constructor\">Flower(String <span class=\"hljs-params\">s</span>, <span class=\"hljs-params\">int</span> <span class=\"hljs-params\">petals</span>)</span> {\n        this(petals);\n        <span class=\"hljs-comment\">//- this(s); // Can&#x27;t call two!</span>\n        this.s = s; <span class=\"hljs-comment\">// Another use of &quot;this&quot;</span>\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;String &amp; int args&quot;</span>);\n    }\n\n    <span class=\"hljs-constructor\">Flower()</span> {\n        this(<span class=\"hljs-string\">&quot;hi&quot;</span>, <span class=\"hljs-number\">47</span>);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;no-arg constructor&quot;</span>);\n    }\n\n    void print<span class=\"hljs-constructor\">PetalCount()</span> {\n        <span class=\"hljs-comment\">//- this(11); // Not inside constructor!</span>\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;petalCount = &quot;</span> + petalCount + <span class=\"hljs-string\">&quot; s = &quot;</span> + s);\n    }\n\n    public static void main(String<span class=\"hljs-literal\">[]</span> args) {\n        Flower x = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Flower()</span>;\n        x.print<span class=\"hljs-constructor\">PetalCount()</span>;\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-keyword\">Constructor</span> <span class=\"hljs-title\">w</span>/ <span class=\"hljs-title\">int</span> <span class=\"hljs-title\">arg</span> <span class=\"hljs-title\">only</span>, <span class=\"hljs-title\">petalCount</span> = 47\n<span class=\"hljs-title\">String</span> &amp; <span class=\"hljs-title\">int</span> <span class=\"hljs-title\">args</span>\n<span class=\"hljs-title\">no</span>-<span class=\"hljs-title\">arg</span> <span class=\"hljs-title\">constructor</span>\n<span class=\"hljs-title\">petalCount</span> = 47 <span class=\"hljs-title\">s</span> = <span class=\"hljs-title\">hi</span></span>\n</code></pre>\n<p>从构造器 <code>Flower(String s, int petals)</code> 可以看出，其中只能通过 this 调用一次构造器。另外，必须首先调用构造器，否则编译器会报错。这个例子同样展示了 this 的另一个用法。参数列表中的变量名 <strong>s</strong> 和成员变量名 s 相同，会引起混淆。你可以通过 <code>this.s</code> 表明你指的是成员变量 s，从而避免重复。你经常会在 Java 代码中看到这种用法，同时本书中也会多次出现这种写法。在 <code>printPetalCount()</code> 方法中，编译器不允许你在一个构造器之外的方法里调用构造器。</p>\n<h3 id=\"static-的含义\">static 的含义</h3>\n<p>记住了 this 关键字的内容，你会对 static 修饰的方法有更加深入的理解：static 方法中不会存在 this。</p>\n<p>你不能在静态方法中调用非静态方法（反之可以）。静态方法是为类而创建的，不需要任何对象。事实上，这就是静态方法的主要目的，静态方法看起来就像全局方法一样，但是 Java 中不允许全局方法，一个类中的静态方法可以被其他的静态方法和静态属性访问。</p>\n<p>一些人认为静态方法不是面向对象的，因为它们的确具有全局方法的语义。使用静态方法，因为不存在 this，所以你没有向一个对象发送消息。的确，如果你发现代码中出现了大量的 static 方法，就该重新考虑自己的设计了。然而，static 的概念很实用，许多时候都要用到它。至于它是否真的“面向对象”，就留给理论家去讨论吧。</p>\n<h2 id=\"成员初始化\">成员初始化</h2>\n<p>Java 尽量保证所有变量在使用前都能得到恰当的初始化。对于方法的局部变量，这种保证会以编译时错误的方式呈现，所以如果写成：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">int</span> i;\n    i++;\n}\n</code></pre>\n<p>你会得到一条错误信息，告诉你 i 可能尚未初始化。编译器可以为 i 赋一个默认值，但是未初始化的局部变量更有可能是程序员的疏忽，所以采用默认值反而会掩盖这种失误。强制程序员提供一个初始值，往往能帮助找出程序里的 Bug。</p>\n<p>要是类的成员变量是基本类型，情况就会变得有些不同。类的每个基本类型数据成员保证都会有一个初始值。下面的程序可以验证这类情况，并显示它们的值：</p>\n<pre><code class=\"hljs language-java\">// housekeeping/InitialValues.java\n// Shows <span class=\"hljs-keyword\">default</span> initial <span class=\"hljs-keyword\">values</span>\n\n<span class=\"hljs-built_in\">public</span> <span class=\"hljs-keyword\">class</span> InitialValues {\n    <span class=\"hljs-type\">boolean</span> t;\n    <span class=\"hljs-type\">char</span> c;\n    byte b;\n    short s;\n    <span class=\"hljs-type\">int</span> i;\n    long l;\n    <span class=\"hljs-type\">float</span> f;\n    <span class=\"hljs-type\">double</span> d;\n    InitialValues reference;\n\n    <span class=\"hljs-type\">void</span> printInitialValues() {\n        <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(&quot;Data type Initial value&quot;);\n        <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(&quot;boolean &quot; + t);\n        <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(&quot;char[&quot; + c + &quot;]&quot;);\n        <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(&quot;byte &quot; + b);\n        <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(&quot;short &quot; + s);\n        <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(&quot;int &quot; + i);\n        <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(&quot;long &quot; + l);\n        <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(&quot;float &quot; + f);\n        <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(&quot;double &quot; + d);\n        <span class=\"hljs-keyword\">System</span>.<span class=\"hljs-keyword\">out</span>.println(&quot;reference &quot; + reference);\n    }\n\n    <span class=\"hljs-built_in\">public</span> static <span class=\"hljs-type\">void</span> main(String[] args) {\n        <span class=\"hljs-built_in\">new</span> InitialValues().printInitialValues();\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code class=\"hljs language-Java\">Data type Initial value\n<span class=\"hljs-keyword\">boolean</span> <span class=\"hljs-keyword\">false</span>\n<span class=\"hljs-keyword\">char</span>[NUL]\n<span class=\"hljs-keyword\">byte</span> <span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">short</span> <span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">int</span> <span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">long</span> <span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">float</span> <span class=\"hljs-number\">0.0</span>\n<span class=\"hljs-keyword\">double</span> <span class=\"hljs-number\">0.0</span>\nreference <span class=\"hljs-keyword\">null</span>\n</code></pre>\n<p>可见尽管数据成员的初值没有给出，但它们确实有初值（char 值为 0，所以显示为空白）。所以这样至少不会出现“未初始化变量”的风险了。</p>\n<p>在类里定义一个对象引用时，如果不将其初始化，那么引用就会被赋值为 null。</p>\n<p>怎么给一个变量赋初值呢？一种很直接的方法是在定义类成员变量的地方为其赋值。以下代码修改了 InitialValues 类成员变量的定义，直接提供了初值：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/InitialValues2.java</span>\n<span class=\"hljs-comment\">// Providing explicit initial values</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">InitialValues2</span> {\n    <span class=\"hljs-type\">boolean</span> <span class=\"hljs-type\">bool</span> = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-type\">char</span> ch = <span class=\"hljs-string\">&#x27;x&#x27;</span>;\n    <span class=\"hljs-type\">byte</span> b = <span class=\"hljs-number\">47</span>;\n    <span class=\"hljs-type\">short</span> s = <span class=\"hljs-number\">0xff</span>;\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">999</span>;\n    <span class=\"hljs-type\">long</span> lng = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-type\">float</span> f = <span class=\"hljs-number\">3.14f</span>;\n    <span class=\"hljs-type\">double</span> d = <span class=\"hljs-number\">3.14159</span>;\n}\n</code></pre>\n<p>你也可以用同样的方式初始化非基本类型的对象。如果 Depth 是一个类，那么可以像下面这样创建一个对象并初始化它：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/Measurement.java</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Depth</span> </span>{}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Measurement</span> </span>{\n    Depth d = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Depth</span>();\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>如果没有为 d 赋予初值就尝试使用它，就会出现运行时错误，告诉你产生了一个异常。</p>\n<p>你也可以通过调用某个方法来提供初值：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/MethodInit.java</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">MethodInit</span> {\n    <span class=\"hljs-built_in\">int</span> i = f();\n    \n    <span class=\"hljs-built_in\">int</span> f() {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">11</span>;\n    }\n    \n}\n</code></pre>\n<p>这个方法可以带有参数，但这些参数不能是未初始化的类成员变量。因此，可以这么写：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/MethodInit2.java</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MethodInit2</span> {\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-built_in\">f</span>();\n    <span class=\"hljs-type\">int</span> j = <span class=\"hljs-built_in\">g</span>(i);\n    \n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">11</span>;\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> n * <span class=\"hljs-number\">10</span>;\n    }\n}\n</code></pre>\n<p>但是你不能这么写：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/MethodInit3.java</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MethodInit3</span> {\n    <span class=\"hljs-comment\">//- int j = g(i); // Illegal forward reference</span>\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-built_in\">f</span>();\n\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">11</span>;\n    }\n\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">g</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> n * <span class=\"hljs-number\">10</span>;\n    }\n}\n</code></pre>\n<p>显然，上述程序的正确性取决于初始化的顺序，而与其编译方式无关。所以，编译器恰当地对“向前引用”发出了警告。</p>\n<p>这种初始化方式简单直观，但有个限制：类 InitialValues 的每个对象都有相同的初值，有时这的确是我们需要的，但有时却需要更大的灵活性。</p>\n<h2 id=\"构造器初始化\">构造器初始化</h2>\n<p>可以用构造器进行初始化，这种方式给了你更大的灵活性，因为你可以在运行时调用方法进行初始化。但是，这无法阻止自动初始化的进行，他会在构造器被调用之前发生。因此，如果使用如下代码：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/Counter.java</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-symbol\">Counter</span> {\n    <span class=\"hljs-built_in\">int</span> i;\n    \n    Counter() {\n        i = <span class=\"hljs-number\">7</span>;\n    }\n    <span class=\"hljs-comment\">// ...</span>\n}\n</code></pre>\n<p>i 首先会被初始化为 0，然后变为 7。对于所有的基本类型和引用，包括在定义时已明确指定初值的变量，这种情况都是成立的。因此，编译器不会强制你一定要在构造器的某个地方或在使用它们之前初始化元素——初始化早已得到了保证。</p>\n<h3 id=\"初始化的顺序\">初始化的顺序</h3>\n<p>在类中变量定义的顺序决定了它们初始化的顺序。即使变量定义散布在方法定义之间，它们仍会在任何方法（包括构造器）被调用之前得到初始化。例如：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/OrderOfInitialization.java</span>\n<span class=\"hljs-comment\">// Demonstrates initialization order</span>\n<span class=\"hljs-comment\">// When the constructor is called to create a</span>\n<span class=\"hljs-comment\">// Window object, you&#x27;ll see a message:</span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Window</span> </span>{\n    Window(int marker) {\n        System.out.println(<span class=\"hljs-string\">&quot;Window(&quot;</span> + marker + <span class=\"hljs-string\">&quot;)&quot;</span>);\n    }\n}\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">House</span> </span>{\n    Window w1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Window</span>(<span class=\"hljs-number\">1</span>); <span class=\"hljs-comment\">// Before constructor</span>\n\n    House() {\n        <span class=\"hljs-comment\">// Show that we&#x27;re in the constructor:</span>\n        System.out.println(<span class=\"hljs-string\">&quot;House()&quot;</span>);\n        w3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Window</span>(<span class=\"hljs-number\">33</span>); <span class=\"hljs-comment\">// Reinitialize w3</span>\n    }\n\n    Window w2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Window</span>(<span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">// After constructor</span>\n\n    void f() {\n        System.out.println(<span class=\"hljs-string\">&quot;f()&quot;</span>);\n    }\n\n    Window w3 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">Window</span>(<span class=\"hljs-number\">3</span>); <span class=\"hljs-comment\">// At end</span>\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OrderOfInitialization</span> </span>{\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> void main(<span class=\"hljs-keyword\">String</span>[] args) {\n        House h = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-type\">House</span>();\n        h.f(); <span class=\"hljs-comment\">// Shows that construction is done</span>\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-title\">Window</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">Window</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">Window</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">House</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">Window</span><span class=\"hljs-params\">(<span class=\"hljs-number\">33</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">f</span><span class=\"hljs-params\">()</span></span>\n</code></pre>\n<p>在 House 类中，故意把几个 Window 对象的定义散布在各处，以证明它们全都会在调用构造器或其他方法之前得到初始化。此外，w3 在构造器中被再次赋值。</p>\n<p>由输出可见，引用 w3 被初始化了两次：一次在调用构造器前，一次在构造器调用期间（第一次引用的对象将被丢弃，并作为垃圾回收）。这乍一看可能觉得效率不高，但保证了正确的初始化。试想，如果定义了一个重载构造器，在其中没有初始化 w3，同时在定义 w3 时没有赋予初值，那会产生怎样的后果呢？w3 对象不存在造成空指针异常。</p>\n<h3 id=\"静态数据的初始化\">静态数据的初始化</h3>\n<p>无论创建多少个对象，静态数据都只占用一份存储区域。static 关键字不能应用于局部变量，所以只能作用于属性（字段、域）。如果一个字段是静态的基本类型，你没有初始化它，那么它就会获得基本类型的标准初值。如果它是对象引用，那么它的默认初值就是 null。</p>\n<p>如果在定义时进行初始化，那么静态变量看起来就跟非静态变量一样。</p>\n<p>下面例子显示了静态存储区是何时初始化的：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/StaticInitialization.java</span>\n<span class=\"hljs-comment\">// Specifying initial values in a class definition</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Bowl</span> {\n    Bowl(<span class=\"hljs-type\">int</span> marker) {\n        System.out.println(<span class=\"hljs-string\">&quot;Bowl(&quot;</span> + marker + <span class=\"hljs-string\">&quot;)&quot;</span>);\n    }\n    \n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">f1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> marker)</span> {\n        System.out.println(<span class=\"hljs-string\">&quot;f1(&quot;</span> + marker + <span class=\"hljs-string\">&quot;)&quot;</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Table</span> {\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">Bowl</span> <span class=\"hljs-variable\">bowl1</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Bowl</span>(<span class=\"hljs-number\">1</span>);\n    \n    Table() {\n        System.out.println(<span class=\"hljs-string\">&quot;Table()&quot;</span>);\n        bowl2.f1(<span class=\"hljs-number\">1</span>);\n    }\n    \n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">f2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> marker)</span> {\n        System.out.println(<span class=\"hljs-string\">&quot;f2(&quot;</span> + marker + <span class=\"hljs-string\">&quot;)&quot;</span>);\n    }\n    \n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">Bowl</span> <span class=\"hljs-variable\">bowl2</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Bowl</span>(<span class=\"hljs-number\">2</span>);\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cupboard</span> {\n    <span class=\"hljs-type\">Bowl</span> <span class=\"hljs-variable\">bowl3</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Bowl</span>(<span class=\"hljs-number\">3</span>);\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">Bowl</span> <span class=\"hljs-variable\">bowl4</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Bowl</span>(<span class=\"hljs-number\">4</span>);\n    \n    Cupboard() {\n        System.out.println(<span class=\"hljs-string\">&quot;Cupboard()&quot;</span>);\n        bowl4.f1(<span class=\"hljs-number\">2</span>);\n    }\n    \n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">f3</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> marker)</span> {\n        System.out.println(<span class=\"hljs-string\">&quot;f3(&quot;</span> + marker + <span class=\"hljs-string\">&quot;)&quot;</span>);\n    }\n    \n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">Bowl</span> <span class=\"hljs-variable\">bowl5</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Bowl</span>(<span class=\"hljs-number\">5</span>);\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">StaticInitialization</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        System.out.println(<span class=\"hljs-string\">&quot;main creating new Cupboard()&quot;</span>);\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cupboard</span>();\n        System.out.println(<span class=\"hljs-string\">&quot;main creating new Cupboard()&quot;</span>);\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cupboard</span>();\n        table.f2(<span class=\"hljs-number\">1</span>);\n        cupboard.f3(<span class=\"hljs-number\">1</span>);\n    }\n    \n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">Table</span> <span class=\"hljs-variable\">table</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Table</span>();\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">Cupboard</span> <span class=\"hljs-variable\">cupboard</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Cupboard</span>();\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-function\"><span class=\"hljs-title\">Bowl</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">Bowl</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">Table</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">f1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">Bowl</span><span class=\"hljs-params\">(<span class=\"hljs-number\">4</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">Bowl</span><span class=\"hljs-params\">(<span class=\"hljs-number\">5</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">Bowl</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">Cupboard</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">f1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>)</span></span>\n<span class=\"hljs-selector-tag\">main</span> creating new Cupboard()\n<span class=\"hljs-function\"><span class=\"hljs-title\">Bowl</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">Cupboard</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">f1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>)</span></span>\n<span class=\"hljs-selector-tag\">main</span> creating new Cupboard()\n<span class=\"hljs-function\"><span class=\"hljs-title\">Bowl</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">Cupboard</span><span class=\"hljs-params\">()</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">f1</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">f2</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">f3</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>\n</code></pre>\n<p>Bowl 类展示类的创建，而 Table 和 Cupboard 在它们的类定义中包含 Bowl 类型的静态数据成员。注意，在静态数据成员定义之前，Cupboard 类中先定义了一个 Bowl 类型的非静态成员 b3。</p>\n<p>由输出可见，静态初始化只有在必要时刻才会进行。如果不创建 Table 对象，也不引用 Table.bowl1 或 Table.bowl2，那么静态的 Bowl 类对象 bowl1 和 bowl2 永远不会被创建。只有在第一个 Table 对象被创建（或被访问）时，它们才会被初始化。此后，静态对象不会再次被初始化。</p>\n<p>初始化的顺序先是静态对象（如果它们之前没有被初始化的话），然后是非静态对象，从输出中可以看出。要执行 <code>main()</code> 方法，必须加载 StaticInitialization 类，它的静态属性 table 和 cupboard 随后被初始化，这会导致它们对应的类也被加载，而由于它们都包含静态的 Bowl 对象，所以 Bowl 类也会被加载。因此，在这个特殊的程序中，所有的类都会在 <code>main()</code> 方法之前被加载。实际情况通常并非如此，因为在典型的程序中，不会像本例中所示的那样，将所有事物通过 <strong>static</strong> 联系起来。</p>\n<p>概括一下创建对象的过程，假设有个名为 Dog 的类：</p>\n<ol>\n<li>即使没有显式地使用 static 关键字，构造器实际上也是静态方法。所以，当首次创建 Dog 类型的对象或是首次访问 Dog 类的静态方法或属性时，Java 解释器必须在类路径中查找，以定位 Dog.class。</li>\n<li>当加载完 Dog.class 后（后面会学到，这将创建一个 Class 对象），有关静态初始化的所有动作都会执行。因此，静态初始化只会在首次加载 Class 对象时初始化一次。</li>\n<li>当用 <code>new Dog()</code> 创建对象时，首先会在堆上为 Dog 对象分配足够的存储空间。</li>\n<li>分配的存储空间首先会被清零，即会将 Dog 对象中的所有基本类型数据设置为默认值（数字会被置为 0，布尔型和字符型也相同），引用被置为 null。</li>\n<li>执行所有出现在字段定义处的初始化动作。</li>\n<li>执行构造器。你将会在“复用”这一章看到，这可能会牵涉到很多动作，尤其当涉及继承的时候。</li>\n</ol>\n<h3 id=\"显式的静态初始化\">显式的静态初始化</h3>\n<p>你可以将一组静态初始化动作放在类里面一个特殊的“静态子句”（有时叫做静态块）中。像下面这样：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/Spoon.java</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Spoon</span> {\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> i;\n    \n    <span class=\"hljs-keyword\">static</span> {\n        i = <span class=\"hljs-number\">47</span>;\n    }\n}\n</code></pre>\n<p>这看起来像个方法，但实际上它只是一段跟在 static 关键字后面的代码块。与其他静态初始化动作一样，这段代码仅执行一次：当首次创建这个类的对象或首次访问这个类的静态成员（甚至不需要创建该类的对象）时。例如：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/ExplicitStatic.java</span>\n<span class=\"hljs-comment\">// Explicit static initialization with &quot;static&quot; clause</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Cup</span> {\n    Cup(<span class=\"hljs-built_in\">int</span> marker) {\n        System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">&quot;Cup(&quot;</span> + marker + <span class=\"hljs-string\">&quot;)&quot;</span>);\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> marker</span>)</span> {\n        System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">&quot;f(&quot;</span> + marker + <span class=\"hljs-string\">&quot;)&quot;</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Cups</span> {\n    <span class=\"hljs-keyword\">static</span> Cup cup1;\n    <span class=\"hljs-keyword\">static</span> Cup cup2;\n    \n    <span class=\"hljs-keyword\">static</span> {\n        cup1 = <span class=\"hljs-keyword\">new</span> Cup(<span class=\"hljs-number\">1</span>);\n        cup2 = <span class=\"hljs-keyword\">new</span> Cup(<span class=\"hljs-number\">2</span>);\n    }\n    \n    Cups() {\n        System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">&quot;Cups()&quot;</span>);\n    }\n}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ExplicitStatic</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>)</span> {\n        System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">&quot;Inside main()&quot;</span>);\n        Cups.cup1.f(<span class=\"hljs-number\">99</span>); <span class=\"hljs-comment\">// [1]</span>\n    }\n    \n    <span class=\"hljs-comment\">// static Cups cups1 = new Cups(); // [2]</span>\n    <span class=\"hljs-comment\">// static Cups cups2 = new Cups(); // [2]</span>\n}\n</code></pre>\n<p>输出：</p>\n<pre><code>Inside <span class=\"hljs-selector-tag\">main</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">Cup</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">Cup</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">f</span><span class=\"hljs-params\">(<span class=\"hljs-number\">99</span>)</span></span>\n</code></pre>\n<p>无论是通过标为 [1] 的行访问静态的 cup1 对象，还是把标为 [1] 的行去掉，让它去运行标为 [2] 的那行代码（去掉  [2] 的注释），<strong>Cups</strong> 的静态初始化动作都会执行。如果同时注释 [1] 和 [2] 处，那么 <strong>Cups</strong> 的静态初始化就不会进行。此外，把标为 [2] 处的注释都去掉还是只去掉一个，静态初始化只会执行一次。</p>\n<h3 id=\"非静态实例初始化\">非静态实例初始化</h3>\n<p>Java 提供了被称为<em>实例初始化</em>的类似语法，用来初始化每个对象的非静态变量，例如：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/Mugs.java</span>\n<span class=\"hljs-comment\">// Instance initialization</span>\n\n<span class=\"hljs-keyword\">class</span> Mug {\n    <span class=\"hljs-constructor\">Mug(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">marker</span>)</span> {\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;Mug(&quot;</span> + marker + <span class=\"hljs-string\">&quot;)&quot;</span>);\n    }\n}\n\npublic <span class=\"hljs-keyword\">class</span> Mugs {\n    Mug mug1;\n    Mug mug2;\n    { <span class=\"hljs-comment\">// [1]</span>\n        mug1 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Mug(1)</span>;\n        mug2 = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Mug(2)</span>;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;mug1 &amp; mug2 initialized&quot;</span>);\n    }\n    \n    <span class=\"hljs-constructor\">Mugs()</span> {\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;Mugs()&quot;</span>);\n    }\n    \n    <span class=\"hljs-constructor\">Mugs(<span class=\"hljs-params\">int</span> <span class=\"hljs-params\">i</span>)</span> {\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;Mugs(int)&quot;</span>);\n    }\n    \n    public static void main(String<span class=\"hljs-literal\">[]</span> args) {\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;Inside main()&quot;</span>);\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Mugs()</span>;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;new Mugs() completed&quot;</span>);\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-constructor\">Mugs(1)</span>;\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-string\">&quot;new Mugs(1) completed&quot;</span>);\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code>Inside <span class=\"hljs-selector-tag\">main</span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">Mug</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">Mug</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>)</span></span>\nmug1 &amp; mug2 initialized\n<span class=\"hljs-function\"><span class=\"hljs-title\">Mugs</span><span class=\"hljs-params\">()</span></span>\nnew Mugs() completed\n<span class=\"hljs-function\"><span class=\"hljs-title\">Mug</span><span class=\"hljs-params\">(<span class=\"hljs-number\">1</span>)</span></span>\n<span class=\"hljs-function\"><span class=\"hljs-title\">Mug</span><span class=\"hljs-params\">(<span class=\"hljs-number\">2</span>)</span></span>\nmug1 &amp; mug2 initialized\n<span class=\"hljs-function\"><span class=\"hljs-title\">Mugs</span><span class=\"hljs-params\">(int)</span></span>\nnew Mugs(<span class=\"hljs-number\">1</span>) completed\n</code></pre>\n<p>看起来它很像静态代码块，只不过少了 <strong>static</strong> 关键字。这种语法对于支持”匿名内部类”（参见”内部类”一章）的初始化是必须的，但是你也可以使用它保证某些操作一定会发生，而不管哪个构造器被调用。从输出看出，实例初始化子句是在两个构造器之前执行的。</p>\n<h2 id=\"数组初始化\">数组初始化</h2>\n<p>数组是相同类型的、用一个标识符名称封装到一起的一个对象序列或基本类型数据序列。数组是通过方括号下标操作符 [] 来定义和使用的。要定义一个数组引用，只需要在类型名加上方括号：</p>\n<pre><code class=\"hljs language-java\">int[] a1<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>方括号也可放在标识符的后面，两者的含义是一样的：</p>\n<pre><code class=\"hljs language-java\">int a1[]<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>这种格式符合 C 和 C++ 程序员的习惯。不过前一种格式或许更合理，毕竟它表明类型是”一个 <strong>int</strong> 型数组”。本书中采用这种格式。</p>\n<p>编译器不允许指定数组的大小。这又把我们带回有关”引用”的问题上。你所拥有的只是对数组的一个引用（你已经为该引用分配了足够的存储空间），但是还没有给数组对象本身分配任何空间。为了给数组创建相应的存储空间，必须写初始化表达式。对于数组，初始化动作可以出现在代码的任何地方，但是也可以使用一种特殊的初始化表达式，它必须在创建数组的地方出现。这种特殊的初始化是由一对花括号括起来的值组成。这种情况下，存储空间的分配（相当于使用 <strong>new</strong>） 将由编译器负责。例如：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-attribute\">int</span>[] a1 = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>};\n</code></pre>\n<p>那么为什么在还没有数组的时候定义一个数组引用呢？</p>\n<pre><code class=\"hljs language-java\">int[] a2<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>在 Java 中可以将一个数组赋值给另一个数组，所以可以这样：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-attribute\">a2</span> <span class=\"hljs-operator\">=</span> a1<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>其实真正做的只是复制了一个引用，就像下面演示的这样：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/ArraysOfPrimitives.java</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArraysOfPrimitives</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">String</span>[] args)</span> </span>{\n        <span class=\"hljs-type\">int</span>[] a1 = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>};\n        <span class=\"hljs-type\">int</span>[] a2;\n        a2 = a1;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; a2.length; i++) {\n            a2[i] += <span class=\"hljs-number\">1</span>;\n        }\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; a1.length; i++) {\n            System.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">&quot;a1[&quot;</span> + i + <span class=\"hljs-string\">&quot;] = &quot;</span> + a1[i]);\n        }\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code>a1[<span class=\"hljs-number\">0</span>] <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span><span class=\"hljs-comment\">;</span>\na1[<span class=\"hljs-number\">1</span>] <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">3</span><span class=\"hljs-comment\">;</span>\na1[<span class=\"hljs-number\">2</span>] <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">4</span><span class=\"hljs-comment\">;</span>\na1[<span class=\"hljs-number\">3</span>] <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">5</span><span class=\"hljs-comment\">;</span>\na1[<span class=\"hljs-number\">4</span>] <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">6</span><span class=\"hljs-comment\">;</span>\n</code></pre>\n<p><strong>a1</strong> 初始化了，但是 <strong>a2</strong> 没有；这里，<strong>a2</strong> 在后面被赋给另一个数组。由于 <strong>a1</strong> 和 <strong>a2</strong> 是相同数组的别名，因此通过 <strong>a2</strong> 所做的修改在 <strong>a1</strong> 中也能看到。</p>\n<p>所有的数组（无论是对象数组还是基本类型数组）都有一个固定成员 <strong>length</strong>，告诉你这个数组有多少个元素，你不能对其修改。与 C 和 C++ 类似，Java 数组计数也是从 0 开始的，所能使用的最大下标数是 <strong>length - 1</strong>。超过这个边界，C 和 C++ 会默认接受，允许你访问所有内存，许多声名狼藉的 bug 都是由此而生。但是 Java 在你访问超出这个边界时，会报运行时错误（异常），从而避免此类问题。</p>\n<h3 id=\"动态数组创建\">动态数组创建</h3>\n<p>如果在编写程序时，不确定数组中需要多少个元素，可以使用 <strong>new</strong> 在数组中创建元素。如下例所示，使用 <strong>new</strong> 创建基本类型数组。<strong>new</strong> 不能创建非数组以外的基本类型数据：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/ArrayNew.java</span>\n<span class=\"hljs-comment\">// Creating arrays with new</span>\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArrayNew</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-type\">int</span>[] a;\n        <span class=\"hljs-type\">Random</span> <span class=\"hljs-variable\">rand</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Random</span>(<span class=\"hljs-number\">47</span>);\n        a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[rand.nextInt(<span class=\"hljs-number\">20</span>)];\n        System.out.println(<span class=\"hljs-string\">&quot;length of a = &quot;</span> + a.length);\n        System.out.println(Arrays.toString(a));\n    } \n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-attribute\">length</span> of a = <span class=\"hljs-number\">18</span><span class=\"hljs-meta\">\n[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]</span>\n</code></pre>\n<p>数组的大小是通过 <code>Random.nextInt()</code> 随机确定的，这个方法会返回 0 到输入参数之间的一个值。 由于随机性，很明显数组的创建确实是在运行时进行的。此外，程序输出表明，数组元素中的基本数据类型值会自动初始化为默认值（对于数字和字符是 0；对于布尔型是 <strong>false</strong>）。<code>Arrays.toString()</code> 是 <strong>java.util</strong> 标准类库中的方法，会产生一维数组的可打印版本。</p>\n<p>本例中，数组也可以在定义的同时进行初始化：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-keyword\">int</span>[] a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-keyword\">int</span>[<span class=\"hljs-keyword\">rand</span><span class=\"hljs-variable\">.nextInt</span>(<span class=\"hljs-number\">20</span>)];\n</code></pre>\n<p>如果可能的话，应该尽量这么做。</p>\n<p>如果你创建了一个非基本类型的数组，那么你创建的是一个引用数组。以整型的包装类型 <strong>Integer</strong> 为例，它是一个类而非基本类型：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/ArrayClassObj.java</span>\n<span class=\"hljs-comment\">// Creating an array of nonprimitive objects</span>\n\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">ArrayClassObj</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-type\">Random</span> <span class=\"hljs-variable\">rand</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Random</span>(<span class=\"hljs-number\">47</span>);\n        Integer[] a = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Integer</span>[rand.nextInt(<span class=\"hljs-number\">20</span>)];\n        System.out.println(<span class=\"hljs-string\">&quot;length of a = &quot;</span> + a.length);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; a.length; i++) {\n            a[i] = rand.nextInt(<span class=\"hljs-number\">500</span>); <span class=\"hljs-comment\">// Autoboxing</span>\n        }\n        System.out.println(Arrays.toString(a));\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-attribute\">length</span> of a = <span class=\"hljs-number\">18</span><span class=\"hljs-meta\">\n[55, 193, 361, 461, 429, 368, 200, 22, 207, 288, 128, 51, 89, 309, 278, 498, 361, 20]</span>\n</code></pre>\n<p>这里，即使使用 new 创建数组之后：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-type\">Integer</span>[] a = <span class=\"hljs-built_in\">new</span> <span class=\"hljs-type\">Integer</span>[rand.nextInt(<span class=\"hljs-number\">20</span>)];    \n</code></pre>\n<p>它只是一个引用数组，直到通过创建新的 <strong>Integer</strong> 对象（通过自动装箱），并把对象赋值给引用，初始化才算结束：</p>\n<pre><code class=\"hljs language-java\">a[i] <span class=\"hljs-operator\">=</span> rand.nextInt(<span class=\"hljs-number\">500</span>)<span class=\"hljs-comment\">;</span>\n</code></pre>\n<p>如果忘记了创建对象，但试图使用数组中的空引用，就会在运行时产生异常。</p>\n<p>也可以用花括号括起来的列表来初始化数组，有两种形式：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/ArrayInit.java</span>\n<span class=\"hljs-comment\">// Array initialization</span>\nimport java.util.*;\n\npublic <span class=\"hljs-keyword\">class</span> ArrayInit {\n    public static void main(String<span class=\"hljs-literal\">[]</span> args) {\n        Integer<span class=\"hljs-literal\">[]</span> a = {\n                <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>,\n                <span class=\"hljs-number\">3</span>, <span class=\"hljs-comment\">// Autoboxing</span>\n        };\n        Integer<span class=\"hljs-literal\">[]</span> b = <span class=\"hljs-keyword\">new</span> Integer<span class=\"hljs-literal\">[]</span> {\n                <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>,\n                <span class=\"hljs-number\">3</span>, <span class=\"hljs-comment\">// Autoboxing</span>\n        };\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Arrays</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String(<span class=\"hljs-params\">a</span>)</span>);\n        <span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">System</span>.</span></span>out.println(<span class=\"hljs-module-access\"><span class=\"hljs-module\"><span class=\"hljs-identifier\">Arrays</span>.</span></span><span class=\"hljs-keyword\">to</span><span class=\"hljs-constructor\">String(<span class=\"hljs-params\">b</span>)</span>);\n\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-string\">[1, 2, 3]</span>\n<span class=\"hljs-string\">[1, 2, 3]</span>\n</code></pre>\n<p>在这两种形式中，初始化列表的最后一个逗号是可选的（这一特性使维护长列表变得更容易）。</p>\n<p>尽管第一种形式很有用，但是它更加受限，因为它只能用于数组定义处。第二种和第三种形式可以用在任何地方，甚至用在方法的内部。例如，你创建了一个 <strong>String</strong> 数组，将其传递给另一个类的 <code>main()</code> 方法，如下：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/DynamicArray.java</span>\n<span class=\"hljs-comment\">// Array initialization</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">DynamicArray</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-title class_\">Other</span>.<span class=\"hljs-title function_\">main</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">String</span>[] {<span class=\"hljs-string\">&quot;fiddle&quot;</span>, <span class=\"hljs-string\">&quot;de&quot;</span>, <span class=\"hljs-string\">&quot;dum&quot;</span>});\n    }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Other</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-title class_\">String</span> <span class=\"hljs-attr\">s</span>: args) {\n            <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">print</span>(s + <span class=\"hljs-string\">&quot; &quot;</span>);\n        }\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-attribute\">fiddle de dum</span> \n</code></pre>\n<p><code>Other.main()</code> 的参数是在调用处创建的，因此你甚至可以在方法调用处提供可替换的参数。</p>\n<h3 id=\"可变参数列表\">可变参数列表</h3>\n<p>你可以以一种类似 C 语言中的可变参数列表（C 通常把它称为”varargs”）来创建和调用方法。这可以应用在参数个数或类型未知的场合。由于所有的类都最后继承于 <strong>Object</strong> 类（随着本书的进展，你会对此有更深的认识），所以你可以创建一个以 Object 数组为参数的方法，并像下面这样调用：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/VarArgs.java</span>\n<span class=\"hljs-comment\">// Using array syntax to create variable argument lists</span>\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">A</span> {}\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">VarArgs</span> {\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">printArray</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">Object</span>[] args</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-title class_\">Object</span> <span class=\"hljs-attr\">obj</span>: args) {\n            <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">print</span>(obj + <span class=\"hljs-string\">&quot; &quot;</span>);\n        }\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>();\n    }\n    \n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-title function_\">printArray</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>[] {<span class=\"hljs-number\">47</span>, (float) <span class=\"hljs-number\">3.14</span>, <span class=\"hljs-number\">11.11</span>});\n        <span class=\"hljs-title function_\">printArray</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>[] {<span class=\"hljs-string\">&quot;one&quot;</span>, <span class=\"hljs-string\">&quot;two&quot;</span>, <span class=\"hljs-string\">&quot;three&quot;</span>});\n        <span class=\"hljs-title function_\">printArray</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Object</span>[] {<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">A</span>(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">A</span>(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">A</span>()});\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-attribute\">47</span> <span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">14</span> <span class=\"hljs-number\">11</span>.<span class=\"hljs-number\">11</span> \n<span class=\"hljs-attribute\">one</span> two three \n<span class=\"hljs-attribute\">A</span>@<span class=\"hljs-number\">15</span>db9742 A@<span class=\"hljs-number\">6</span>d06d69c A@<span class=\"hljs-number\">7852</span>e922\n</code></pre>\n<p><code>printArray()</code> 的参数是 <strong>Object</strong> 数组，使用 for-in 语法遍历和打印数组的每一项。标准 Java 库能输出有意义的内容，但这里创建的是类的对象，打印出的内容是类名，后面跟着一个 <strong>@</strong> 符号以及多个十六进制数字。因而，默认行为（如果没有定义 <code>toString()</code> 方法的话，后面会讲这个方法）就是打印类名和对象的地址。</p>\n<p>你可能看到像上面这样编写的 Java 5 之前的代码，它们可以产生可变的参数列表。在 Java 5 中，这种期盼已久的特性终于添加了进来，就像在 <code>printArray()</code> 中看到的那样：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/NewVarArgs.java</span>\n<span class=\"hljs-comment\">// Using array syntax to create variable argument lists</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">NewVarArgs</span> {\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">printArray</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">Object</span>... args</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-title class_\">Object</span> <span class=\"hljs-attr\">obj</span>: args) {\n            <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">print</span>(obj + <span class=\"hljs-string\">&quot; &quot;</span>);\n        }\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>();\n    }\n    \n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-comment\">// Can take individual elements:</span>\n        <span class=\"hljs-title function_\">printArray</span>(<span class=\"hljs-number\">47</span>, (float) <span class=\"hljs-number\">3.14</span>, <span class=\"hljs-number\">11.11</span>);\n        <span class=\"hljs-title function_\">printArray</span>(<span class=\"hljs-number\">47</span>, <span class=\"hljs-number\">3.</span>14F, <span class=\"hljs-number\">11.11</span>);\n        <span class=\"hljs-title function_\">printArray</span>(<span class=\"hljs-string\">&quot;one&quot;</span>, <span class=\"hljs-string\">&quot;two&quot;</span>, <span class=\"hljs-string\">&quot;three&quot;</span>);\n        <span class=\"hljs-title function_\">printArray</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">A</span>(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">A</span>(), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title function_\">A</span>());\n        <span class=\"hljs-comment\">// Or an array:</span>\n        <span class=\"hljs-title function_\">printArray</span>((<span class=\"hljs-title class_\">Object</span>[]) <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Integer</span>[] {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>});\n        <span class=\"hljs-title function_\">printArray</span>(); <span class=\"hljs-comment\">// Empty list is OK</span>\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-attribute\">47</span> <span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">14</span> <span class=\"hljs-number\">11</span>.<span class=\"hljs-number\">11</span> \n<span class=\"hljs-attribute\">47</span> <span class=\"hljs-number\">3</span>.<span class=\"hljs-number\">14</span> <span class=\"hljs-number\">11</span>.<span class=\"hljs-number\">11</span> \n<span class=\"hljs-attribute\">one</span> two three \n<span class=\"hljs-attribute\">A</span>@<span class=\"hljs-number\">15</span>db9742 A@<span class=\"hljs-number\">6</span>d06d69c A@<span class=\"hljs-number\">7852</span>e922 \n<span class=\"hljs-attribute\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> \n</code></pre>\n<p>有了可变参数，你就再也不用显式地编写数组语法了，当你指定参数时，编译器实际上会为你填充数组。你获取的仍然是一个数组，这就是为什么 <code>printArray()</code> 可以使用 for-in 迭代数组的原因。但是，这不仅仅只是从元素列表到数组的自动转换。注意程序的倒数第二行，一个 <strong>Integer</strong> 数组（通过自动装箱创建）被转型为一个 <strong>Object</strong> 数组（为了移除编译器的警告），并且传递给了 <code>printArray()</code>。显然，编译器会发现这是一个数组，不会执行转换。因此，如果你有一组事物，可以把它们当作列表传递，而如果你已经有了一个数组，该方法会把它们当作可变参数列表来接受。</p>\n<p>程序的最后一行表明，可变参数的个数可以为 0。当具有可选的尾随参数时，这一特性会有帮助：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/OptionalTrailingArguments.java</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OptionalTrailingArguments</span> {\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">int required, <span class=\"hljs-built_in\">String</span>... trailing</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">print</span>(<span class=\"hljs-string\">&quot;required: &quot;</span> + required + <span class=\"hljs-string\">&quot; &quot;</span>);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-title class_\">String</span> <span class=\"hljs-attr\">s</span>: trailing) {\n            <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">print</span>(s + <span class=\"hljs-string\">&quot; &quot;</span>);\n        }\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>();\n    }\n    \n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&quot;one&quot;</span>);\n        <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-string\">&quot;two&quot;</span>, <span class=\"hljs-string\">&quot;three&quot;</span>);\n        <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">0</span>);\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-attribute\">required</span>: <span class=\"hljs-number\">1</span> one \n<span class=\"hljs-attribute\">required</span>: <span class=\"hljs-number\">2</span> two three \n<span class=\"hljs-attribute\">required</span>: <span class=\"hljs-number\">0</span> \n</code></pre>\n<p>这段程序展示了如何使用除了 <strong>Object</strong> 类之外类型的可变参数列表。这里，所有的可变参数都是 <strong>String</strong> 对象。可变参数列表中可以使用任何类型的参数，包括基本类型。下面例子展示了可变参数列表变为数组的情形，并且如果列表中没有任何元素，那么转变为大小为 0 的数组：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/VarargType.java</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">VarargType</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\">Character... args</span>)</span> {\n        System.<span class=\"hljs-keyword\">out</span>.print(args.getClass());\n        System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">&quot; length &quot;</span> + args.length);\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">g</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span>... args</span>)</span> {\n        System.<span class=\"hljs-keyword\">out</span>.print(args.getClass());\n        System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">&quot; length &quot;</span> + args.length)\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>)</span> {\n        f(<span class=\"hljs-string\">&#x27;a&#x27;</span>);\n        f();\n        g(<span class=\"hljs-number\">1</span>);\n        g();\n        System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">&quot;int[]: &quot;</span>+ <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[<span class=\"hljs-number\">0</span>].getClass());\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-built_in\">class</span> [Ljava.lang.Character; <span class=\"hljs-built_in\">length</span> <span class=\"hljs-number\">1</span>\n<span class=\"hljs-built_in\">class</span> [Ljava.lang.Character; <span class=\"hljs-built_in\">length</span> <span class=\"hljs-number\">0</span>\n<span class=\"hljs-built_in\">class</span> [I <span class=\"hljs-built_in\">length</span> <span class=\"hljs-number\">1</span>\n<span class=\"hljs-built_in\">class</span> [I <span class=\"hljs-built_in\">length</span> <span class=\"hljs-number\">0</span>\nint[]: <span class=\"hljs-built_in\">class</span> [I\n</code></pre>\n<p><code>getClass()</code> 方法属于 Object 类，将在”类型信息”一章中全面介绍。它会产生对象的类，并在打印该类时，看到表示该类类型的编码字符串。前导的 <strong>[</strong> 代表这是一个后面紧随的类型的数组，<strong>I</strong> 表示基本类型 <strong>int</strong>；为了进行双重检查，我在最后一行创建了一个 <strong>int</strong> 数组，打印了其类型。这样也验证了使用可变参数列表不依赖于自动装箱，而使用的是基本类型。</p>\n<p>然而，可变参数列表与自动装箱可以和谐共处，如下：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/AutoboxingVarargs.java</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AutoboxingVarargs</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">Integer... args</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-title class_\">Integer</span> <span class=\"hljs-attr\">i</span>: args) {\n            <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">print</span>(i + <span class=\"hljs-string\">&quot; &quot;</span>);\n        }\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>();\n    }\n    \n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n        <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>);\n        <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">12</span>);\n        \n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-symbol\">1 </span><span class=\"hljs-number\">2</span>\n<span class=\"hljs-symbol\">4 </span><span class=\"hljs-number\">5</span> <span class=\"hljs-number\">6</span> <span class=\"hljs-number\">7</span> <span class=\"hljs-number\">8</span> <span class=\"hljs-number\">9</span>\n<span class=\"hljs-symbol\">10 </span><span class=\"hljs-number\">11</span> <span class=\"hljs-number\">12</span>\n</code></pre>\n<p>注意吗，你可以在单个参数列表中将类型混合在一起，自动装箱机制会有选择地把 <strong>int</strong> 类型的参数提升为 <strong>Integer</strong>。</p>\n<p>可变参数列表使得方法重载更加复杂了，尽管乍看之下似乎足够安全：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/OverloadingVarargs.java</span>\n\npublic <span class=\"hljs-keyword\">class</span> OverloadingVarargs {\n    static void <span class=\"hljs-built_in\">f</span>(Character... <span class=\"hljs-keyword\">args</span>) {\n        System.<span class=\"hljs-keyword\">out</span>.<span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">&quot;first&quot;</span>);\n        <span class=\"hljs-keyword\">for</span> (Character c: <span class=\"hljs-keyword\">args</span>) {\n            System.<span class=\"hljs-keyword\">out</span>.<span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">&quot; &quot;</span> + c);\n        }\n        System.<span class=\"hljs-keyword\">out</span>.println();\n    }\n    \n    static void <span class=\"hljs-built_in\">f</span>(Integer... <span class=\"hljs-keyword\">args</span>) {\n        System.<span class=\"hljs-keyword\">out</span>.<span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">&quot;second&quot;</span>);\n        <span class=\"hljs-keyword\">for</span> (Integer i: <span class=\"hljs-keyword\">args</span>) {\n            System.<span class=\"hljs-keyword\">out</span>.<span class=\"hljs-keyword\">print</span>(<span class=\"hljs-string\">&quot; &quot;</span> + i);\n        }\n        System.<span class=\"hljs-keyword\">out</span>.println();\n    }\n    \n    static void <span class=\"hljs-built_in\">f</span>(Long... <span class=\"hljs-keyword\">args</span>) {\n        System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">&quot;third&quot;</span>);\n    }\n    \n    public static void main(String[] <span class=\"hljs-keyword\">args</span>) {\n        <span class=\"hljs-built_in\">f</span>(&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;);\n        <span class=\"hljs-built_in\">f</span>(1);\n        <span class=\"hljs-built_in\">f</span>(2, 1);\n        <span class=\"hljs-built_in\">f</span>(0);\n        <span class=\"hljs-built_in\">f</span>(0L);\n        <span class=\"hljs-comment\">//- f(); // Won&#x27;s compile -- ambiguous</span>\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-keyword\">first</span> <span class=\"hljs-keyword\">a</span> b c\n<span class=\"hljs-keyword\">second</span> <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">second</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">second</span> <span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">third</span>\n</code></pre>\n<p>在每种情况下，编译器都会使用自动装箱来匹配重载的方法，然后调用最明确匹配的方法。</p>\n<p>但是如果调用不含参数的 <code>f()</code>，编译器就无法知道应该调用哪个方法了。尽管这个错误可以弄清楚，但是它可能会使客户端程序员感到意外。</p>\n<p>你可能会通过在某个方法中增加一个非可变参数解决这个问题：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/OverloadingVarargs2.java</span>\n<span class=\"hljs-comment\">// {WillNotCompile}</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">OverloadingVarargs2</span> {\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">float i, Character... args</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;first&quot;</span>);\n    }\n    \n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-params\">Character... args</span>) {\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(<span class=\"hljs-string\">&quot;second&quot;</span>);\n    }\n    \n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>);\n        <span class=\"hljs-title function_\">f</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>);\n    }\n}\n</code></pre>\n<p>{WillNotCompile} 注释把该文件排除在了本书的 Gradle 构建之外。如果你手动编译它，会得到下面的错误信息：</p>\n<pre><code>OverloadingVarargs2.java:<span class=\"hljs-number\">14</span>:error:<span class=\"hljs-keyword\">reference</span> <span class=\"hljs-keyword\">to</span> f <span class=\"hljs-keyword\">is</span> ambiguous f(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>);\n\\^\nboth <span class=\"hljs-function\"><span class=\"hljs-keyword\">method</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(float, Character...)</span> <span class=\"hljs-title\">in</span> <span class=\"hljs-title\">OverloadingVarargs2</span> <span class=\"hljs-title\">and</span> <span class=\"hljs-title\">method</span> <span class=\"hljs-title\">f</span><span class=\"hljs-params\">(Character...)</span> <span class=\"hljs-title\">in</span> <span class=\"hljs-title\">OverloadingVarargs2</span> <span class=\"hljs-title\">match</span> 1 <span class=\"hljs-title\">error</span></span>\n</code></pre>\n<p>如果你给这两个方法都添加一个非可变参数，就可以解决问题了：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/OverloadingVarargs3</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">OverloadingVarargs3</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">float</span> i, Character... args</span>)</span> {\n        System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">&quot;first&quot;</span>);\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">f</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">char</span> c, Character... args</span>)</span> {\n        System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">&quot;second&quot;</span>);\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>)</span> {\n        f(<span class=\"hljs-number\">1</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>);\n        f(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>);\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-keyword\">first</span>\n<span class=\"hljs-keyword\">second</span>\n</code></pre>\n<p>你应该总是在重载方法的一个版本上使用可变参数列表，或者压根不用它。</p>\n<!-- Enumerated Types -->\n\n<h2 id=\"枚举类型\">枚举类型</h2>\n<p>Java 5 中添加了一个看似很小的特性 enum 关键字，它使得我们在需要群组并使用枚举类型集时，可以很方便地处理。以前，你需要创建一个整数常量集，但是这些值并不会将自身限制在这个常量集的范围内，因此使用它们更有风险，而且更难使用。枚举类型属于非常普遍的需求，C、C++ 和其他许多语言都已经拥有它了。在 Java 5 之前，Java 程序员必须了解许多细节并格外仔细地去达成 enum 的效果。现在 Java 也有了 enum，并且它的功能比 C/C++ 中的完备得多。下面是个简单的例子：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/Spiciness.java</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">enum</span> Spiciness {\n    NOT, MILD, MEDIUM, HOT, FLAMING\n}\n</code></pre>\n<p>这里创建了一个名为 Spiciness 的枚举类型，它有 5 个值。由于枚举类型的实例是常量，因此按照命名惯例，它们都用大写字母表示（如果名称中含有多个单词，使用下划线分隔）。</p>\n<p>要使用 <strong>enum</strong>，需要创建一个该类型的引用，然后将其赋值给某个实例：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/SimpleEnumUse.java</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SimpleEnumUse</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-title class_\">Spiciness</span> howHot = <span class=\"hljs-title class_\">Spiciness</span>.<span class=\"hljs-property\">MEDIUM</span>;\n        <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(howHot);\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-attribute\">MEDIUM</span>\n</code></pre>\n<p>在你创建 <strong>enum</strong> 时，编译器会自动添加一些有用的特性。例如，它会创建 <code>toString()</code> 方法，以便你方便地显示某个 <strong>enum</strong> 实例的名称，这从上面例子中的输出可以看出。编译器还会创建 <code>ordinal()</code> 方法表示某个特定 <strong>enum</strong> 常量的声明顺序，<code>static values()</code> 方法按照 enum 常量的声明顺序，生成这些常量值构成的数组：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/EnumOrder.java</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">EnumOrder</span> {\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">void</span> <span class=\"hljs-title function_\">main</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">String</span>[] args</span>) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-title class_\">Spiciness</span> <span class=\"hljs-attr\">s</span>: <span class=\"hljs-title class_\">Spiciness</span>.<span class=\"hljs-title function_\">values</span>()) {\n            <span class=\"hljs-title class_\">System</span>.<span class=\"hljs-property\">out</span>.<span class=\"hljs-title function_\">println</span>(s + <span class=\"hljs-string\">&quot;, ordinal &quot;</span> + s.<span class=\"hljs-title function_\">ordinal</span>());\n        }\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code><span class=\"hljs-attribute\">NOT</span>, ordinal <span class=\"hljs-number\">0</span>\n<span class=\"hljs-attribute\">MILD</span>, ordinal <span class=\"hljs-number\">1</span>\n<span class=\"hljs-attribute\">MEDIUM</span>, ordinal <span class=\"hljs-number\">2</span>\n<span class=\"hljs-attribute\">HOT</span>, ordinal <span class=\"hljs-number\">3</span>\n<span class=\"hljs-attribute\">FLAMING</span>, ordinal <span class=\"hljs-number\">4</span>\n</code></pre>\n<p>尽管 <strong>enum</strong> 看起来像是一种新的数据类型，但是这个关键字只是在生成 <strong>enum</strong> 的类时，产生了某些编译器行为，因此在很大程度上你可以将 <strong>enum</strong> 当作其他任何类。事实上，<strong>enum</strong> 确实是类，并且具有自己的方法。</p>\n<p><strong>enum</strong> 有一个很实用的特性，就是在 <strong>switch</strong> 语句中使用：</p>\n<pre><code class=\"hljs language-java\"><span class=\"hljs-comment\">// housekeeping/Burrito.java</span>\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Burrito</span> {\n    Spiciness degree;\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">Burrito</span>(<span class=\"hljs-params\">Spiciness degree</span>)</span> {\n        <span class=\"hljs-keyword\">this</span>.degree = degree;\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">describe</span>(<span class=\"hljs-params\"></span>)</span> {\n        System.<span class=\"hljs-keyword\">out</span>.print(<span class=\"hljs-string\">&quot;This burrito is &quot;</span>);\n        <span class=\"hljs-keyword\">switch</span>(degree) {\n            <span class=\"hljs-keyword\">case</span> NOT:\n                System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">&quot;not spicy at all.&quot;</span>);\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> MILD:\n            <span class=\"hljs-keyword\">case</span> MEDIUM:\n                System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">&quot;a little hot.&quot;</span>);\n                <span class=\"hljs-keyword\">break</span>;\n            <span class=\"hljs-keyword\">case</span> HOT:\n            <span class=\"hljs-keyword\">case</span> FLAMING:\n            <span class=\"hljs-literal\">default</span>:\n                System.<span class=\"hljs-keyword\">out</span>.println(<span class=\"hljs-string\">&quot;maybe too hot&quot;</span>);\n        }\n    }\n    \n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">main</span>(<span class=\"hljs-params\">String[] args</span>)</span> {\n        Burrito plain = <span class=\"hljs-keyword\">new</span> Burrito(Spiciness.NOT),\n        greenChile = <span class=\"hljs-keyword\">new</span> Burrito(Spiciness.MEDIUM),\n        jalapeno = <span class=\"hljs-keyword\">new</span> Burrito(Spiciness.HOT);\n        plain.describe();\n        greenChile.describe();\n        jalapeno.describe();\n    }\n}\n</code></pre>\n<p>输出：</p>\n<pre><code>This burrito <span class=\"hljs-keyword\">is</span> <span class=\"hljs-built_in\">not</span> spicy at <span class=\"hljs-built_in\">all</span>.\nThis burrito <span class=\"hljs-keyword\">is</span> a little hot.\nThis burrito <span class=\"hljs-keyword\">is</span> maybe too hot.\n</code></pre>\n<p>由于 <strong>switch</strong> 是在有限的可能值集合中选择，因此它与 <strong>enum</strong> 是绝佳的组合。注意，enum 的名称是如何能够倍加清楚地表明程序的目的的。</p>\n<p>通常，你可以将 <strong>enum</strong> 用作另一种创建数据类型的方式，然后使用所得到的类型。这正是关键所在，所以你不用过多地考虑它们。在 <strong>enum</strong> 被引入之前，你必须花费大量的精力去创建一个等同的枚举类型，并是安全可用的。</p>\n<p>这些介绍对于你理解和使用基本的 <strong>enum</strong> 已经足够了，我们会在”枚举”一章中进行更深入的探讨。</p>\n<h2 id=\"本章小结\">本章小结</h2>\n<p>构造器，这种看起来精巧的初始化机制，应该给了你很强的暗示：初始化在编程语言中的重要地位。C++ 的发明者 Bjarne Stroustrup 在设计 C++ 期间，在针对 C 语言的生产效率进行的最初调查中发现，错误的初始化会导致大量编程错误。这些错误很难被发现，同样，不合理的清理也会如此。因为构造器能保证进行正确的初始化和清理（没有正确的构造器调用，编译器就不允许创建对象），所以你就有了完全的控制和安全。</p>\n<p>在 C++ 中，析构器很重要，因为用 new 创建的对象必须被明确地销毁。在 Java 中，垃圾回收器会自动地释放所有对象的内存，所以很多时候类似的清理方法就不太需要了（但是当要用到的时候，你得自己动手）。在不需要类似析构器行为的时候，Java 的垃圾回收器极大地简化了编程，并加强了内存管理上的安全性。一些垃圾回收器甚至能清理其他资源，如图形和文件句柄。然而，垃圾回收器确实增加了运行时开销，由于 Java 解释器从一开始就很慢，所以这种开销到底造成多大的影响很难看出来。随着时间的推移，Java 在性能方面提升了很多，但是速度问题仍然是它涉足某些特定编程领域的障碍。</p>\n<p>由于要保证所有对象被创建，实际上构造器比这里讨论得更加复杂。特别是当通过组合或继承创建新类的时候，这种保证仍然成立，并且需要一些额外的语法来支持。在后面的章节中，你会学习组合，继承以及它们如何影响构造器。</p>\n');
INSERT INTO `m_blog` VALUES (29, 1, '1111', '1111', '1111', '2021-10-14 14:14:31', 1, 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/macos.6z1mshl4twk0.svg', 0, '2021-10-14 14:14:31', NULL, NULL, NULL, 1, 1, 0, NULL, 0, '<p>1111</p>\n');
INSERT INTO `m_blog` VALUES (30, 1, 'Shiro', 'Shiro 课程知识点', '## 课程知识点\n\n```\n1、权限系统的整体概念\n2、shiro权限框架的核心组件\n3、springboot下shiro的使用\n4、shiro认证鉴权的缓存机制\n5、分布式下使用shrio处理统一会话\n6、密码重试次数，并发登录控制\n7、前后端分离的鉴权方式\n8、建立分布式统一鉴权系统\n```\n\n## 第一章  权限概述\n\n### 1、什么是权限\n\n​		权限管理，一般指根据系统设置的安全策略或者安全规则，用户可以访问而且只能访问自己被授权的资源，不多不少。权限管理几乎出现在任何系统里面，只要有用户和密码的系统。 \n\n权限管理在系统中一般分为：\n\n- 访问权限\n\n  ```properties\n  一般表示你能做什么样的操作，或者能够访问那些资源。例如：给张三赋予“店铺主管”角色，“店铺主管”具有“查询员工”、“添加员工”、“修改员工”和“删除员工”权限。此时张三能够进入系统，则可以进行这些操作\n  ```\n\n- 数据权限\n\n  ```properties\n  一般表示某些数据你是否属于你，或者属于你可以操作范围。例如：张三是\"店铺主管\"角色，他可以看他手下客服人员所有的服务的买家订单信息，他的手下只能看自己负责的订单信息\n  ```\n\n### 2、认证概念\n\n#### 【1】什么是认证\n\n​		身份认证，就是判断一个用户是否为合法用户的处理过程。最常用的简单身份认证方式是系统通过核对用户输入的用户名和密码，看其是否与系统中存储的该用户的用户名和密码一致，来判断用户身份是否正确。例如：密码登录，手机短信验证、三方授权等\n\n#### 【2】认证流程\n\n![1580044671870](image\\1580044671870.png)\n\n#### 【3】关键对象\n\n​		上边的流程图中需要理解以下关键对象：\n\n​        **Subject**：主体：访问系统的用户，主体可以是用户、程序等，进行认证的都称为主体；\n\n​        **Principal**：身份信息是主体（subject）进行身份认证的标识，标识必须具有唯一性，如用户名、手机号、邮箱地址等，一个主体可以有多个身份，但是必须有一个主身份（Primary Principal）。\n\n​        **credential**：凭证信息：是只有主体自己知道的安全信息，如密码、证书等。\n\n### 3、授权概念\n\n#### 【1】什么是授权\n\n​		授权，即访问控制，控制谁能访问哪些资源。主体进行身份认证后，系统会为其分配对应的权限，当访问资\n\n源时，会校验其是否有访问此资源的权限。\n\n这里首先理解4个对象。\n\n​		用户对象user：当前操作的用户、程序。\n\n​		资源对象resource：当前被访问的对象\n\n​		角色对象role ：一组 \"权限操作许可权\" 的集合。\n\n​		权限对象permission：权限操作许可权\n\n#### 【2】授权流程\n\n![1582789303655](image\\1582789303655.png)\n\n#### 【3】关键对象\n\n**授权可简单理解为who对what进行How操作**\n\n**Who：**主体（Subject），可以是一个用户、也可以是一个程序\n\n**What：**资源（Resource），如系统菜单、页面、按钮、方法、系统商品信息等。\n\n​		访问类型：商品菜单，订单菜单、分销商菜单\n\n​		数据类型：我的商品，我的订单，我的评价\n\n**How：**权限/许可（Permission）\n\n​		我的商品（资源）===>访问我的商品(权限许可)\n\n​		分销商菜单（资源）===》访问分销商列表（权限许可）		\n\n## 第二章 Shiro概述\n\n### 1、Shiro简介\n\n#### 【1】什么是Shiro?\n\n​		Shiro是apache旗下一个开源框架，它将软件系统的安全认证相关的功能抽取出来，实现用户身份认证，权限授权、加密、会话管理等功能，组成了一个通用的安全认证框架。\n\n#### 【2】Shiro 的特点\n\n​		Shiro 是一个强大而灵活的开源安全框架，能够非常清晰的处理认证、授权、管理会话以及密码加密。如下是它所具有的特点：\n\n· 易于理解的 Java Security API；\n\n· 简单的身份认证（登录），支持多种数据源（LDAP，JDBC 等）；\n\n· 对角色的简单的签权（访问控制），也支持细粒度的鉴权；\n\n· 支持一级缓存，以提升应用程序的性能；\n\n· 内置的基于 POJO 企业会话管理，适用于 Web 以及非 Web 的环境；\n\n· 异构客户端会话访问；\n\n· 非常简单的加密 API；\n\n· 不跟任何的框架或者容器捆绑，可以独立运行。\n\n### 2、核心组件\n\n- Shiro架构图\n\n\n\n![](image\\9b959a65-799d-396e-b5f5-b4fcfe88f53c.png)\n\n\n\n- Subject\n\n```properties\nSubject主体，外部应用与subject进行交互，subject将用户作为当前操作的主体，这个主体：可以是一个通过浏览器请求的用户，也可能是一个运行的程序。Subject在shiro中是一个接口，接口中定义了很多认证授相关的方法，外部程序通过subject进行认证授，而subject是通过SecurityManager安全管理器进行认证授权\n```\n\n- SecurityManager\n\n```properties\nSecurityManager权限管理器，它是shiro的核心，负责对所有的subject进行安全管理。通过SecurityManager可以完成subject的认证、授权等，SecurityManager是通过Authenticator进行认证，通过Authorizer进行授权，通过SessionManager进行会话管理等。SecurityManager是一个接口，继承了Authenticator, Authorizer, SessionManager这三个接口\n```\n\n- Authenticator\n\n```properties\nAuthenticator即认证器，对用户登录时进行身份认证\n```\n\n- Authorizer\n\n```properties\nAuthorizer授权器，用户通过认证器认证通过，在访问功能时需要通过授权器判断用户是否有此功能的操作权限。\n```\n\n- Realm（数据库读取+认证功能+授权功能实现）\n\n```properties\nRealm领域，相当于datasource数据源，securityManager进行安全认证需要通过Realm获取用户权限数据\n比如：\n	如果用户身份数据在数据库那么realm就需要从数据库获取用户身份信息。\n注意：\n	不要把realm理解成只是从数据源取数据，在realm中还有认证授权校验的相关的代码。　\n```\n\n- SessionManager\n\n```properties\nSessionManager会话管理，shiro框架定义了一套会话管理，它不依赖web容器的session，所以shiro可以使用在非web应用上，也可以将分布式应用的会话集中在一点管理，此特性可使它实现单点登录。\n```\n\n- SessionDAO\n\n```properties\nSessionDAO即会话dao，是对session会话操作的一套接口\n比如:\n	可以通过jdbc将会话存储到数据库\n	也可以把session存储到缓存服务器\n```\n\n- CacheManager \n\n```properties\nCacheManager缓存管理，将用户权限数据存储在缓存，这样可以提高性能\n```\n\n- Cryptography\n\n```\nCryptography密码管理，shiro提供了一套加密/解密的组件，方便开发。比如提供常用的散列、加/解密等功能\n```\n\n\n\n## 第三章 Shiro入门\n\n### 1、身份认证\n\n#### 【1】基本流程\n\n![1580047247677](image\\1580047247677.png)\n\n 流程如下：\n\n​	1、Shiro把用户的数据封装成标识token，token一般封装着用户名，密码等信息\n\n​	2、使用Subject门面获取到封装着用户的数据的标识token\n\n​	3、Subject把标识token交给SecurityManager，在SecurityManager安全中心中，SecurityManager把标识token委托给认证器Authenticator进行身份验证。认证器的作用一般是用来指定如何验证，它规定本次认证用到哪些Realm\n\n​	4、认证器Authenticator将传入的标识token，与数据源Realm对比，验证token是否合法\n\n#### 【2】案例演示\n\n##### 【2.1】需求\n\n```\n1、使用shiro完成一个用户的登录\n```\n\n##### 【2.2】实现\n\n###### 【2.2.1】新建项目\n\nshiro-day01-01authenticator\n\n![1580048751209](image\\1580048751209.png)\n\n\n\n###### 【2.2.2】导入依赖\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.itheima.shiro</groupId>\n  <artifactId>shiro-day01-01authenticator</artifactId>\n  <version>1.0-SNAPSHOT</version>\n\n  <name>shiro-day01-01authenticator</name>\n  <!-- FIXME change it to the project\'s website -->\n  <url>http://www.example.com</url>\n\n  <properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n  </properties>\n\n  <dependencies>\n\n    <dependency>\n      <groupId>commons-logging</groupId>\n      <artifactId>commons-logging</artifactId>\n      <version>1.1.3</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.apache.shiro</groupId>\n      <artifactId>shiro-core</artifactId>\n      <version>1.3.2</version>\n    </dependency>\n\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.11</version>\n    </dependency>\n\n  </dependencies>\n\n  <build>\n    <plugins>\n      <!-- compiler插件, 设定JDK版本 -->\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <version>3.1</version>\n        <configuration>\n          <source>8</source>\n          <target>8</target>\n          <showWarnings>true</showWarnings>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n</project>\n\n```\n\n###### 【2.2.3】编写shiro.ini\n\n```ini\n#声明用户账号\n[users]\njay=123\n```\n\n###### 【2.2.4】编写HelloShiro\n\n```java\npackage com.itheima.shiro;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.config.IniSecurityManagerFactory;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.util.Factory;\nimport org.junit.Test;\n\n/**\n * @Description：shiro的第一个例子\n */\npublic class HelloShiro {\n\n    @Test\n    public void shiroLogin() {\n        //导入权限ini文件构建权限工厂\n        Factory<SecurityManager> factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");\n        //工厂构建安全管理器\n        SecurityManager securityManager = factory.getInstance();\n        //使用SecurityUtils工具生效安全管理器\n        SecurityUtils.setSecurityManager(securityManager);\n        //使用SecurityUtils工具获得主体\n        Subject subject = SecurityUtils.getSubject();\n        //构建账号token\n        UsernamePasswordToken usernamePasswordToken = new UsernamePasswordToken(\"jay\", \"123\");\n        //登录操作\n        subject.login(usernamePasswordToken);\n        System.out.println(\"是否登录成功：\" + subject.isAuthenticated());\n    }\n}\n\n```\n\n【2.2.4】测试\n\n![1580049504816](image\\1580049504816.png)\n\n##### 【2.3】小结\n\n```\n1、权限定义：ini文件\n2、加载过程:\n	导入权限ini文件构建权限工厂\n	工厂构建安全管理器\n	使用SecurityUtils工具生效安全管理器\n	使用SecurityUtils工具获得主体\n	使构建账号token用SecurityUtils工具获得主体\n	构建账号token\n	登录操作\n```\n\n### 2、Realm\n\n#### 【1】Realm接口\n\n![1580050317405](image\\1580050317405.png)\n\n所以，一般在真实的项目中，我们不会直接实现Realm接口，我们一般的情况就是直接继承AuthorizingRealm，能够继承到认证与授权功能。它需要强制重写两个方法\n\n```java\npublic class DefinitionRealm extends AuthorizingRealm {\n \n    /**\n	 * @Description 认证\n	 * @param authcToken token对象\n	 * @return \n	 */\n	public abstract AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken) {\n        return null;\n    }\n\n	/**\n	 * @Description 鉴权\n	 * @param principals 令牌\n	 * @return\n	 */\n	public abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals){\n        return null;\n    }\n}\n```\n\n#### 【2】自定义Realm\n\n##### 【2.1】需求\n\n```\n1、自定义Realm，取得密码用于比较\n```\n\n##### 【2.2】实现\n\n###### 【2.2.1】创建项目\n\nshiro-day01-02realm\n\n![1580107180701](image\\1580107180701.png)\n\n###### 【2.2.2】定义SecurityService\n\nSecurityService\n\n```java\npackage com.itheima.shiro.service;\n\n/**\n * @Description：权限服务接口\n */\npublic interface SecurityService {\n\n    /**\n     * @Description 查找密码按用户登录名\n     * @param loginName 登录名称\n     * @return\n     */\n    String findPasswordByLoginName(String loginName);\n}\n\n```\n\nSecurityServiceImpl\n\n```java\npackage com.itheima.shiro.service.impl;\n\nimport com.itheima.shiro.service.SecurityService;\n\n/**\n * @Description：权限服务层\n */\npublic class SecurityServiceImpl implements SecurityService {\n\n    @Override\n    public String findPasswordByLoginName(String loginName) {\n        return \"123\";\n    }\n}\n\n```\n\n###### 【2.2.3】定义DefinitionRealm\n\n```java\npackage com.itheima.shiro.realm;\n\nimport com.itheima.shiro.service.SecurityService;\nimport com.itheima.shiro.service.impl.SecurityServiceImpl;\nimport org.apache.shiro.authc.*;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\n\n/**\n * @Description：声明自定义realm\n */\npublic class DefinitionRealm extends AuthorizingRealm {\n\n    /**\n     * @Description 认证接口\n     * @param token 传递登录token\n     * @return\n     */\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        //从AuthenticationToken中获得登录名称\n        String loginName = (String) token.getPrincipal();\n        SecurityService securityService = new SecurityServiceImpl();\n        String password = securityService.findPasswordByLoginName(loginName);\n        if (\"\".equals(password)||password==null){\n            throw new UnknownAccountException(\"账户不存在\");\n        }\n        //传递账号和密码\n        return  new SimpleAuthenticationInfo(loginName,password,getName());\n    }\n\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        return null;\n    }\n\n}\n\n```\n\n###### 【2.2.4】编辑shiro.ini\n\n```ini\n#声明自定义的realm，且为安全管理器指定realms\n[main]\ndefinitionRealm=com.itheima.shiro.realm.DefinitionRealm\nsecurityManager.realms=$definitionRealm\n#声明用户账号\n#[users]\n#jay=123\n```\n\n#### 【3】认证源码跟踪\n\n（1）通过debug模式追踪源码subject.login(token) 发现。首先是进入Subject接口的默认实现类。果然，Subject将用户的用户名密码委托给了securityManager去做。\n\n![1580107715689](image\\1580107715689.png)\n\n（2）然后，securityManager说：“卧槽，认证器authenticator小弟，听说你的大学学的专业就是认证呀，那么这个认证的任务就交给你咯”。遂将用户的token委托给内部认证组件authenticator去做\n\n![1580107767167](image\\1580107767167.png)\n\n（3）事实上，securityManager的内部组件一个比一个懒。内部认证组件authenticator说：“你们传过来的token我需要拿去跟数据源Realm做对比，这样吧，这个光荣的任务就交给Realm你去做吧”。Realm对象：“一群大懒虫！”。\n\n![1580107849133](image\\1580107849133.png)\n\n（4）Realm在接到内部认证组件authenticator组件后很伤心，最后对电脑前的你说：“大兄弟，对不住了，你去实现一下呗”。从图中的方法体中可以看到，当前对象是Realm类对象，即将调用的方法是doGetAuthenticationInfo(token)。而这个方法，就是你即将要重写的方法。如果帐号密码通过了，那么返回一个认证成功的info凭证。如果认证失败，抛出一个异常就好了。你说：“什么?最终还是劳资来认证？”没错，就是苦逼的你去实现了，谁叫你是程序猿呢。所以，你不得不查询一下数据库，重写doGetAuthenticationInfo方法，查出来正确的帐号密码，返回一个正确的凭证info\n![1580108004686](image\\1580108004686.png)\n\n（5）好了，这个时候你自己编写了一个类，继承了AuthorizingRealm，并实现了上述doGetAuthenticationInfo方法。你在doGetAuthenticationInfo中编写了查询数据库的代码，并将数据库中存放的用户名与密码封装成了一个AuthenticationInfo对象返回。可以看到下图中，info这个对象是有值的，说明从数据库中查询出来了正确的帐号密码\n\n![1580108049930](image\\1580108049930.png)\n\n（6）那么，接下来就很简单了。把用户输入的帐号密码与刚才你从数据库中查出来的帐号密码对比一下即可。token封装着用户的帐号密码，AuthenticationInfo封装着从数据库中查询出来的帐号密码。再往下追踪一下代码，最终到了下图中的核心区域。如果没有报异常，说明本次登录成功。\n\n![1580192296050](image\\1580192296050.png)\n\n### 3、编码、散列算法\n\n#### 【1】编码与解码\n\nShiro提供了base64和16进制字符串编码/解码的API支持，方便一些编码解码操作。\n\nShiro内部的一些数据的【存储/表示】都使用了base64和16进制字符串\n\n##### 【1.1】需求\n\n```\n理解base64和16进制字符串编码/解码\n```\n\n##### 【1.2】新建项目\n\n新建shiro-day01-03encode-decode\n\n![1580196809749](image\\1580196809749.png)\n\n##### 【1.3】新建EncodesUtil\n\n```java\npackage com.itheima.shiro.tools;\n\nimport org.apache.shiro.codec.Base64;\nimport org.apache.shiro.codec.Hex;\n\n/**\n * @Description：封装base64和16进制编码解码工具类\n */\npublic class EncodesUtil {\n\n    /**\n     * @Description HEX-byte[]--String转换\n     * @param input 输入数组\n     * @return String\n     */\n    public static String encodeHex(byte[] input){\n        return Hex.encodeToString(input);\n    }\n\n    /**\n     * @Description HEX-String--byte[]转换\n     * @param input 输入字符串\n     * @return byte数组\n     */\n    public static byte[] decodeHex(String input){\n        return Hex.decode(input);\n    }\n\n    /**\n     * @Description Base64-byte[]--String转换\n     * @param input 输入数组\n     * @return String\n     */\n    public static String encodeBase64(byte[] input){\n        return Base64.encodeToString(input);\n    }\n\n    /**\n     * @Description Base64-String--byte[]转换\n     * @param input 输入字符串\n     * @return byte数组\n     */\n    public static byte[] decodeBase64(String input){\n        return Base64.decode(input);\n    }\n\n}\n\n```\n\n##### 【1.4】新建ClientTest\n\n```java\npackage com.itheima.shiro.client;\n\nimport com.itheima.shiro.tools.EncodesUtil;\nimport org.junit.Test;\n\n/**\n * @Description：测试\n */\npublic class ClientTest {\n\n    /**\n     * @Description 测试16进制编码\n     */\n    @Test\n    public void testHex(){\n        String val = \"holle\";\n        String flag = EncodesUtil.encodeHex(val.getBytes());\n        String valHandler = new String(EncodesUtil.decodeHex(flag));\n        System.out.println(\"比较结果：\"+val.equals(valHandler));\n    }\n\n    /**\n     * @Description 测试base64编码\n     */\n    @Test\n    public void testBase64(){\n        String val = \"holle\";\n        String flag = EncodesUtil.encodeBase64(val.getBytes());\n        String valHandler = new String(EncodesUtil.decodeBase64(flag));\n        System.out.println(\"比较结果：\"+val.equals(valHandler));\n    }\n\n\n}\n\n```\n\n【1.5】小结\n\n```\n1、shiro目前支持的编码与解码：\n	base64\n   （HEX）16进制字符串\n2、那么shiro的编码与解码什么时候使用呢？又是怎么使用的呢？\n```\n\n#### 【2】散列算法\n\n散列算法一般用于生成数据的摘要信息，是一种不可逆的算法，一般适合存储密码之类的数据，常见的散列算法如MD5、SHA等。一般进行散列时最好提供一个salt（盐），比如加密密码“admin”，产生的散列值是“21232f297a57a5a743894a0e4a801fc3”，可以到一些md5解密网站很容易的通过散列值得到密码“admin”，即如果直接对密码进行散列相对来说破解更容易，此时我们可以加一些只有系统知道的干扰数据，如salt（即盐）；这样散列的对象是“密码+salt”，这样生成的散列值相对来说更难破解。\n\nshiro支持的散列算法：\n\nMd2Hash、Md5Hash、Sha1Hash、Sha256Hash、Sha384Hash、Sha512Hash\n\n![1580277706466](image\\1580277706466.png)\n\n##### 【2.1】新增DigestsUtil\n\n```java\npackage com.itheima.shiro.tools;\n\nimport com.sun.org.apache.bcel.internal.generic.NEW;\nimport org.apache.shiro.crypto.SecureRandomNumberGenerator;\nimport org.apache.shiro.crypto.hash.SimpleHash;\nimport sun.security.util.Password;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @Description：摘要\n */\npublic class DigestsUtil {\n\n    private static final String SHA1 = \"SHA-1\";\n\n    private static final Integer ITERATIONS =512;\n\n    /**\n     * @Description sha1方法\n     * @param input 需要散列字符串\n     * @param salt 盐字符串\n     * @return\n     */\n    public static String sha1(String input, String salt) {\n       return new SimpleHash(SHA1, input, salt,ITERATIONS).toString();\n    }\n\n    /**\n     * @Description 随机获得salt字符串\n     * @return\n     */\n    public static String generateSalt(){\n        SecureRandomNumberGenerator randomNumberGenerator = new SecureRandomNumberGenerator();\n        return randomNumberGenerator.nextBytes().toHex();\n    }\n\n\n    /**\n     * @Description 生成密码字符密文和salt密文\n     * @param\n     * @return\n     */\n    public static Map<String,String> entryptPassword(String passwordPlain) {\n       Map<String,String> map = new HashMap<>();\n       String salt = generateSalt();\n       String password =sha1(passwordPlain,salt);\n       map.put(\"salt\", salt);\n       map.put(\"password\", password);\n       return map;\n    }\n}\n\n```\n\n##### 【2.2】新增ClientTest\n\n```java\npackage com.itheima.shiro.client;\n\nimport com.itheima.shiro.tools.DigestsUtil;\nimport com.itheima.shiro.tools.EncodesUtil;\nimport org.junit.Test;\n\nimport java.util.Map;\n\n/**\n * @Description：测试\n */\npublic class ClientTest {\n\n    /**\n     * @Description 测试16进制编码\n     */\n    @Test\n    public void testHex(){\n        String val = \"holle\";\n        String flag = EncodesUtil.encodeHex(val.getBytes());\n        String valHandler = new String(EncodesUtil.decodeHex(flag));\n        System.out.println(\"比较结果：\"+val.equals(valHandler));\n    }\n\n    /**\n     * @Description 测试base64编码\n     */\n    @Test\n    public void testBase64(){\n        String val = \"holle\";\n        String flag = EncodesUtil.encodeBase64(val.getBytes());\n        String valHandler = new String(EncodesUtil.decodeBase64(flag));\n        System.out.println(\"比较结果：\"+val.equals(valHandler));\n    }\n\n    @Test\n    public void testDigestsUtil(){\n       Map<String,String> map =  DigestsUtil.entryptPassword(\"123\");\n        System.out.println(\"获得结果：\"+map.toString());\n    }\n\n}\n\n```\n\n\n\n### 4、Realm使用散列算法\n\n上面我们了解编码，以及散列算法，那么在realm中怎么使用？在shiro-day01-02realm中我们使用的密码是明文的校验方式，也就是SecurityServiceImpl中findPasswordByLoginName返回的是明文123的密码\n\n```java\npackage com.itheima.shiro.service.impl;\n\nimport com.itheima.shiro.service.SecurityService;\n\n/**\n * @Description：权限服务层\n */\npublic class SecurityServiceImpl implements SecurityService {\n\n    @Override\n    public String findPasswordByLoginName(String loginName) {\n        return \"123\";\n    }\n}\n\n```\n\n#### 【1】新建项目\n\nshiro-day01-05-ciphertext-realm\n\n![1580281644492](image\\1580281644492.png)\n\n#### 【2】创建密文密码\n\n使用ClientTest的testDigestsUtil创建密码为“123”的password密文和salt密文\n\n```\npassword:56265d624e484ca62c6dfbc523e6d6fc7932d0d5\nsalt:845a66ac80174c0e486db9354cf84f9a\n```\n\n#### 【3】修改SecurityService\n\nSecurityService修改成返回salt和password的map\n\n```java\npackage com.itheima.shiro.service;\n\nimport java.util.Map;\n\n/**\n * @Description：权限服务接口\n */\npublic interface SecurityService {\n\n    /**\n     * @Description 查找密码按用户登录名\n     * @param loginName 登录名称\n     * @return\n     */\n    Map<String,String> findPasswordByLoginName(String loginName);\n}\n\n```\n\n```java\npackage com.itheima.shiro.service.impl;\n\nimport com.itheima.shiro.service.SecurityService;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @Description：权限服务层\n */\npublic class SecurityServiceImpl implements SecurityService {\n\n    @Override\n    public Map<String,String> findPasswordByLoginName(String loginName) {\n        //模拟数据库中存储的密文信息\n       return  DigestsUtil.entryptPassword(\"123\");\n    }\n}\n\n```\n\n\n\n#### 【4】指定密码匹配方式\n\n为DefinitionRealm类添加构造方法如下：\n\n```java\n	/**\n     * @Description 构造函数\n     */\npublic DefinitionRealm() {\n    //指定密码匹配方式为sha1\n    HashedCredentialsMatcher matcher = new HashedCredentialsMatcher(DigestsUtil.SHA1);\n    //指定密码迭代次数\n    matcher.setHashIterations(DigestsUtil.ITERATIONS);\n    //使用父亲方法使匹配方式生效\n    setCredentialsMatcher(matcher);\n}\n```\n\n修改DefinitionRealm类的认证doGetAuthenticationInfo方法如下\n\n```java\n	/**\n     * @Description 认证接口\n     * @param token 传递登录token\n     * @return\n     */\n@Override\nprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n    //从AuthenticationToken中获得登录名称\n    String loginName = (String) token.getPrincipal();\n    SecurityService securityService = new SecurityServiceImpl();\n    Map<String, String> map = securityService.findPasswordByLoginName(loginName);\n    if (map.isEmpty()){\n        throw new UnknownAccountException(\"账户不存在\");\n    }\n    String salt = map.get(\"salt\");\n    String password = map.get(\"password\");\n    //传递账号和密码:参数1：缓存对象，参数2：明文密码，参数三：字节salt,参数4：当前DefinitionRealm名称\n    return  new SimpleAuthenticationInfo(loginName,password, ByteSource.Util.bytes(salt),getName());\n}\n```\n\n#### 【5】测试\n\n![1580282597761](image\\1580282597761.png)\n\n![1580282723275](image\\1580282723275.png)\n\n![1580282829816](image\\1580282829816.png)\n\n![1580282869315](image\\1580282869315.png)\n\n### 5、身份授权\n\n#### 【1】基本流程\n\n![1580284991759](image\\1580284991759.png)\n\n1、首先调用Subject.isPermitted/hasRole接口，其会委托给SecurityManager。\n\n2、SecurityManager接着会委托给内部组件Authorizer；\n\n3、Authorizer再将其请求委托给我们的Realm去做；Realm才是真正干活的；\n\n4、Realm将用户请求的参数封装成权限对象。再从我们重写的doGetAuthorizationInfo方法中获取从数据库中查询到的权限集合。\n\n5、Realm将用户传入的权限对象，与从数据库中查出来的权限对象，进行一一对比。如果用户传入的权限对象在从数据库中查出来的权限对象中，则返回true，否则返回false。\n\n进行授权操作的前提：用户必须通过认证。\n\n在真实的项目中，角色与权限都存放在数据库中。为了快速上手，我们先创建一个自定义DefinitionRealm，模拟它已经登录成功。直接返回一个登录验证凭证，告诉Shiro框架，我们从数据库中查询出来的密码是也是就是你输入的密码。所以，不管用户输入什么，本次登录验证都是通过的。\n\n```java\n  /**\n     * @Description 认证接口\n     * @param token 传递登录token\n     * @return\n     */\n@Override\nprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n    //从AuthenticationToken中获得登录名称\n    String loginName = (String) token.getPrincipal();\n    SecurityService securityService = new SecurityServiceImpl();\n    Map<String, String> map = securityService.findPasswordByLoginName(loginName);\n    if (map.isEmpty()){\n        throw new UnknownAccountException(\"账户不存在\");\n    }\n    String salt = map.get(\"salt\");\n    String password = map.get(\"password\");\n    //传递账号和密码:参数1：用户认证凭证信息，参数2：明文密码，参数三：字节salt,参数4：当前DefinitionRealm名称\n    return  new SimpleAuthenticationInfo(loginName,password, ByteSource.Util.bytes(salt),getName());\n}\n```\n\n好了，接下来，我们要重写我们本小节的核心方法了。在DefinitionRealm中找到下列方法：\n\n```java\n@Override\nprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n    return null;\n}\n```\n\n此方法的传入的参数PrincipalCollection  principals，是一个包装对象，它表示\"用户认证凭证信息\"。包装的是谁呢？没错，就是认证doGetAuthenticationInfo（）方法的返回值的第一个参数loginName。你可以通过这个包装对象的getPrimaryPrincipal（）方法拿到此值,然后再从数据库中拿到对应的角色和资源，构建SimpleAuthorizationInfo。\n\n```java\n/**\n     * @Description 授权方法\n     */\n@Override\nprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n    //拿到用户认证凭证信息\n    String loginName = (String) principals.getPrimaryPrincipal();\n    //从数据库中查询对应的角色和资源\n    SecurityService securityService = new SecurityServiceImpl();\n    List<String> roles = securityService.findRoleByloginName(loginName);\n    List<String> permissions = securityService.findPermissionByloginName(loginName);\n    //构建资源校验\n    SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n    authorizationInfo.addRoles(roles);\n    authorizationInfo.addStringPermissions(permissions);\n    return authorizationInfo;\n}\n```\n\n#### 【2】案例演示\n\n##### 【2.1】需求\n\n```\n1、实现doGetAuthorizationInfo方法实现鉴权\n2、使用subject类实现权限的校验\n```\n\n##### 【2.2】实现\n\n###### 【2.2.1】创建项目\n\n拷贝shiro-day01-05-ciphertext-realm新建shiro-day01-06-authentication-realm\n\n![1580367506898](image\\1580367506898.png)\n\n###### 【2.2.2】编写SecurityService\n\n在SecurityService中添加\n\n```java\n 	/**\n     * @Description 查找角色按用户登录名\n     * @param  loginName 登录名称\n     * @return\n     */\nList<String> findRoleByloginName(String loginName);\n\n	/**\n     * @Description 查找资源按用户登录名\n     * @param  loginName 登录名称\n     * @return\n     */\nList<String>  findPermissionByloginName(String loginName);\n```\n\nSecurityServiceImpl添加实现\n\n```java\n@Override\npublic List<String> findRoleByloginName(String loginName) {\n    List<String> list = new ArrayList<>();\n    list.add(\"admin\");\n    list.add(\"dev\");\n    return list;\n}\n\n@Override\npublic List<String>  findPermissionByloginName(String loginName) {\n    List<String> list = new ArrayList<>();\n    list.add(\"order:add\");\n    list.add(\"order:list\");\n    list.add(\"order:del\");\n    return list;\n}\n```\n\n###### 【2.2.3】编写DefinitionRealm\n\n在DefinitionRealm中修改doGetAuthorizationInfo方法如下\n\n```java\n/**\n  * @Description 授权方法\n  */\n@Override\nprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n    //拿到用户认证凭证信息\n    String loginName = (String) principals.getPrimaryPrincipal();\n    //从数据库中查询对应的角色和资源\n    SecurityService securityService = new SecurityServiceImpl();\n    List<String> roles = securityService.findRoleByloginName(loginName);\n    List<String> permissions = securityService.findPermissionByloginName(loginName);\n    //构建资源校验\n    SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n    authorizationInfo.addRoles(roles);\n    authorizationInfo.addStringPermissions(permissions);\n    return authorizationInfo;\n}\n```\n\n###### 【2.2.4】编写HelloShiro\n\n```java\npackage com.itheima.shiro;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.config.IniSecurityManagerFactory;\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.util.Factory;\nimport org.junit.Assert;\nimport org.junit.Test;\n\n/**\n * @Description：shiro的第一个例子\n */\npublic class HelloShiro {\n\n\n    @Test\n    public void testPermissionRealm() {\n        Subject subject = shiroLogin(\"jay\", \"123\");\n        //判断用户是否已经登录\n        System.out.println(\"是否登录成功：\" + subject.isAuthenticated());\n\n        //---------检查当前用户的角色信息------------\n        System.out.println(\"是否有管理员角色：\"+subject.hasRole(\"admin\"));\n        //---------如果当前用户有此角色，无返回值。若没有此权限，则抛 UnauthorizedException------------\n        try {\n            subject.checkRole(\"coder\");\n            System.out.println(\"有coder角色\");\n        }catch (Exception e){\n            System.out.println(\"没有coder角色\");\n        }\n\n        //---------检查当前用户的权限信息------------\n        System.out.println(\"是否有查看订单列表资源：\"+subject.isPermitted(\"order:list\"));\n        //---------如果当前用户有此权限，无返回值。若没有此权限，则抛 UnauthorizedException------------\n        try {\n            subject.checkPermissions(\"order:add\", \"order:del\");\n            System.out.println(\"有添加和删除订单资源\");\n        }catch (Exception e){\n            System.out.println(\"没有有添加和删除订单资源\");\n        }\n\n    }\n\n\n    /**\n     * @Description 登录方法\n     */\n    private Subject shiroLogin(String loginName,String password) {\n        //导入权限ini文件构建权限工厂\n        Factory<SecurityManager> factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");\n        //工厂构建安全管理器\n        SecurityManager securityManager = factory.getInstance();\n        //使用SecurityUtils工具生效安全管理器\n        SecurityUtils.setSecurityManager(securityManager);\n        //使用SecurityUtils工具获得主体\n        Subject subject = SecurityUtils.getSubject();\n        //构建账号token\n        UsernamePasswordToken usernamePasswordToken = new UsernamePasswordToken(loginName, password);\n        //登录操作\n        subject.login(usernamePasswordToken);\n        return subject;\n    }\n}\n\n```\n\n##### 【2.3】授权源码追踪\n\n（1）客户端调用 subject.hasRole(\"admin\")，判断当前用户是否有\"admin\"角色权限。\n\n![1580368931926](image\\1580368931926.png)\n\n(2）Subject门面对象接收到要被验证的角色信息\"admin\"，并将其委托给securityManager中验证。\n\n![1580368995672](image\\1580368995672.png)\n\n(3）securityManager将验证请求再次委托给内部的小弟：内部组件Authorizer authorizer\n\n![1580369087293](image\\1580369087293.png)\n\n(4)内部小弟authorizer也是个混子，将其委托给了我们自定义的Realm去做\n\n![1580369205937](image\\1580369205937.png)\n\n   （5） 先拿到PrincipalCollection principal对象，同时传入校验的角色循环校验,循环中先创建鉴权信息\n\n![1580369895496](image\\1580369895496.png)\n\n（6）先看缓存中是否已经有鉴权信息\n\n![1580369979541](image\\1580369979541.png)\n\n![1580370086849](image\\1580370086849.png)\n\n(7)都是一群懒货！！最后干活的还是我这个猴子！\n\n![1580370172670](image\\1580370172670.png)\n\n#### 【3】小结\n\n```\n1、鉴权需要实现doGetAuthorizationInfo方法\n2、鉴权使用门面subject中方法进行鉴权\n	以check开头的会抛出异常\n	以is和has开头会返回布尔值\n```\n\n\n\n## 第四章 Web项目集成Shiro\n\n### 1、Web集成原理分析\n\n#### 【1】web集成的配置\n\n还记得吗，以前我们在没有与WEB环境进行集成的时候，为了生成SecurityManager对象，是通过手动读取配置文件生成工厂对象，再通过工厂对象获取到SecurityManager的。就像下面代码展示的那样\n\n```java\n /**\n   * @Description 登录方法\n   */\nprivate Subject shiroLogin(String loginName,String password) {\n    //导入权限ini文件构建权限工厂\n    Factory<SecurityManager> factory = new IniSecurityManagerFactory(\"classpath:shiro.ini\");\n    //工厂构建安全管理器\n    SecurityManager securityManager = factory.getInstance();\n    //使用SecurityUtils工具生效安全管理器\n    SecurityUtils.setSecurityManager(securityManager);\n    //使用SecurityUtils工具获得主体\n    Subject subject = SecurityUtils.getSubject();\n    //构建账号token\n    UsernamePasswordToken usernamePasswordToken = new UsernamePasswordToken(loginName, password);\n    //登录操作\n    subject.login(usernamePasswordToken);\n    return subject;\n}\n```\n\n不过，现在我们既然说要与WEB集成，那么首先要做的事情就是把我们的shiro.ini这个配置文件交付到WEB环境中，定义shiro.ini文件如下\n\n```ini\n#声明自定义的realm，且为安全管理器指定realms\n[main]\ndefinitionRealm=com.itheima.shiro.realm.DefinitionRealm\nsecurityManager.realms=$definitionRealm\n```\n\n##### 【1.1】新建项目\n\n新建web项目shiro-day01-07web,其中realm、service、resources内容从shiro-day01-06authentication-realm中拷贝即可\n\n![1580538893171](image\\1580538893171.png)\n\n##### 【1.2】pom.xml配置\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.itheima.shiro</groupId>\n  <artifactId>shiro-day01-07web</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <packaging>war</packaging>\n\n  <name>shiro-day01-07web Maven Webapp</name>\n  <!-- FIXME change it to the project\'s website -->\n  <url>http://www.example.com</url>\n\n  <dependencies>\n\n    <dependency>\n      <groupId>commons-logging</groupId>\n      <artifactId>commons-logging</artifactId>\n      <version>1.1.3</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.apache.shiro</groupId>\n      <artifactId>shiro-core</artifactId>\n      <version>1.3.2</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.apache.shiro</groupId>\n      <artifactId>shiro-web</artifactId>\n      <version>1.3.2</version>\n    </dependency>\n\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.11</version>\n    </dependency>\n\n  </dependencies>\n\n  <build>\n    <plugins>\n      <!-- tomcat7插件,命令： mvn tomcat7:run -DskipTests -->\n      <plugin>\n        <groupId>org.apache.tomcat.maven</groupId>\n        <artifactId>tomcat7-maven-plugin</artifactId>\n        <version>2.2</version>\n        <configuration>\n          <uriEncoding>utf-8</uriEncoding>\n          <port>8080</port>\n          <path>/platform</path>\n        </configuration>\n      </plugin>\n\n      <!-- compiler插件, 设定JDK版本 -->\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <version>3.1</version>\n        <configuration>\n          <source>8</source>\n          <target>8</target>\n          <showWarnings>true</showWarnings>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n</project>\n\n```\n\n##### 【1.3】web.xml配置\n\n```xml\n<web-app xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n         xmlns=\"http://java.sun.com/xml/ns/javaee\"\n         xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\"\n         version=\"3.0\">\n  <display-name>shiro-day01-07web</display-name>\n\n  <!-- 初始化SecurityManager对象所需要的环境-->\n  <context-param>\n    <param-name>shiroEnvironmentClass</param-name>\n    <param-value>org.apache.shiro.web.env.IniWebEnvironment</param-value>\n  </context-param>\n\n  <!-- 指定Shiro的配置文件的位置 -->\n  <context-param>\n    <param-name>shiroConfigLocations</param-name>\n    <param-value>classpath:shiro.ini</param-value>\n  </context-param>\n\n  <!-- 监听服务器启动时，创建shiro的web环境。\n       即加载shiroEnvironmentClass变量指定的IniWebEnvironment类-->\n  <listener>\n    <listener-class>org.apache.shiro.web.env.EnvironmentLoaderListener</listener-class>\n  </listener>\n\n  <!-- shiro的l过滤入口，过滤一切请求 -->\n  <filter>\n    <filter-name>shiroFilter</filter-name>\n    <filter-class>org.apache.shiro.web.servlet.ShiroFilter</filter-class>\n  </filter>\n  <filter-mapping>\n    <filter-name>shiroFilter</filter-name>\n    <!-- 过滤所有请求 -->\n    <url-pattern>/*</url-pattern>\n  </filter-mapping>\n\n</web-app>\n\n```\n\n#### 【2】SecurityManager对象创建\n\n上面我们集成shiro到web项目了，下面我们来追踪下源码，看下SecurityManager对象是如何创建的\n\n（1）我启动了服务器，监听器捕获到了服务器启动事件。我现在所处的位置EnvironmentLoaderListener监听器的入口处\n\n![1580539365062](image\\1580539365062.png)\n\n（2）进入方法内查看，它先根据我们的shiroEnvironmentClass变量的值org.apache.shiro.web.env.IniWebEnvironment，初始化一个shiro环境对象\n\n![1580539658469](image\\1580539658469.png)\n\n（3）最后在创建一个SecurityManager对象，再将其绑定到刚才通过字节码创建的Shiro环境对象中\n\n![1580540126770](image\\1580540126770.png)\n\n![1580540180066](image\\1580540180066.png)\n\n![1580540218911](image\\1580540218911.png)\n\n到这来SecurityManager就完成了初始化\n\n### 2、Shiro默认过滤器\n\nShiro内置了很多默认的过滤器，比如身份验证、授权等相关的。默认过滤器可以参考org.apache.shiro.web.filter.mgt.DefaultFilter中的枚举过滤器\n\n![1580542509773](image\\1580542509773.png)\n\n#### 【1】认证相关\n\n| 过滤器 | 过滤器类                 | 说明                                                         | 默认 |\n| ------ | ------------------------ | ------------------------------------------------------------ | ---- |\n| authc  | FormAuthenticationFilter | 基于表单的过滤器；如“/**=authc”，如果没有登录会跳到相应的登录页面登录 | 无   |\n| logout | LogoutFilter             | 退出过滤器，主要属性：redirectUrl：退出成功后重定向的地址，如“/logout=logout” | /    |\n| anon   | AnonymousFilter          | 匿名过滤器，即不需要登录即可访问；一般用于静态资源过滤；示例“/static/**=anon” | 无   |\n\n#### 【2】授权相关\n\n| 过滤器 | 过滤器类                       | 说明                                                         | 默认 |\n| ------ | ------------------------------ | ------------------------------------------------------------ | ---- |\n| roles  | RolesAuthorizationFilter       | 角色授权拦截器，验证用户是否拥有所有角色；主要属性： loginUrl：登录页面地址（/login.jsp）；unauthorizedUrl：未授权后重定向的地址；示例“/admin/**=roles[admin]” | 无   |\n| perms  | PermissionsAuthorizationFilter | 权限授权拦截器，验证用户是否拥有所有权限；属性和roles一样；示例“/user/**=perms[\"user:create\"]” | 无   |\n| port   | PortFilter                     | 端口拦截器，主要属性：port（80）：可以通过的端口；示例“/test= port[80]”，如果用户访问该页面是非80，将自动将请求端口改为80并重定向到该80端口，其他路径/参数等都一样 | 无   |\n| rest   | HttpMethodPermissionFilter     | rest风格拦截器，自动根据请求方法构建权限字符串（GET=read, POST=create,PUT=update,DELETE=delete,HEAD=read,TRACE=read,OPTIONS=read, MKCOL=create）构建权限字符串；示例“/users=rest[user]”，会自动拼出“user:read,user:create,user:update,user:delete”权限字符串进行权限匹配（所有都得匹配，isPermittedAll） | 无   |\n| ssl    | SslFilter                      | SSL拦截器，只有请求协议是https才能通过；否则自动跳转会https端口（443）；其他和port拦截器一样； | 无   |\n\n### 3、Web集成完整案例\n\n基于shiro-day01-07web继续集成\n\n#### 【1】编写pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n  <modelVersion>4.0.0</modelVersion>\n\n  <groupId>com.itheima.shiro</groupId>\n  <artifactId>shiro-day01-07web</artifactId>\n  <version>1.0-SNAPSHOT</version>\n  <packaging>war</packaging>\n\n  <name>shiro-day01-07web Maven Webapp</name>\n  <!-- FIXME change it to the project\'s website -->\n  <url>http://www.example.com</url>\n\n  <dependencies>\n\n    <dependency>\n      <groupId>commons-logging</groupId>\n      <artifactId>commons-logging</artifactId>\n      <version>1.1.3</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.apache.shiro</groupId>\n      <artifactId>shiro-core</artifactId>\n      <version>1.3.2</version>\n    </dependency>\n\n    <dependency>\n      <groupId>org.apache.shiro</groupId>\n      <artifactId>shiro-web</artifactId>\n      <version>1.3.2</version>\n    </dependency>\n\n    <dependency>\n      <groupId>junit</groupId>\n      <artifactId>junit</artifactId>\n      <version>4.11</version>\n    </dependency>\n\n    <dependency>\n      <groupId>javax.servlet</groupId>\n      <artifactId>javax.servlet-api</artifactId>\n      <version>3.0.1</version>\n      <scope>provided</scope>\n    </dependency>\n    <dependency>\n      <groupId>jstl</groupId>\n      <artifactId>jstl</artifactId>\n      <version>1.2</version>\n    </dependency>\n    <dependency>\n      <groupId>taglibs</groupId>\n      <artifactId>standard</artifactId>\n      <version>1.1.2</version>\n    </dependency>\n\n  </dependencies>\n\n  <build>\n    <plugins>\n      <!-- tomcat7插件,命令： mvn tomcat7:run -DskipTests -->\n      <plugin>\n        <groupId>org.apache.tomcat.maven</groupId>\n        <artifactId>tomcat7-maven-plugin</artifactId>\n        <version>2.2</version>\n        <configuration>\n          <uriEncoding>utf-8</uriEncoding>\n          <port>8080</port>\n          <path>/platform</path>\n        </configuration>\n      </plugin>\n\n      <!-- compiler插件, 设定JDK版本 -->\n      <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <version>3.1</version>\n        <configuration>\n          <source>8</source>\n          <target>8</target>\n          <showWarnings>true</showWarnings>\n        </configuration>\n      </plugin>\n    </plugins>\n  </build>\n</project>\n\n```\n\n#### 【2】编写shiro.ini文件\n\n```ini\n#声明自定义的realm，且为安全管理器指定realms\n[main]\ndefinitionRealm=com.itheima.shiro.realm.DefinitionRealm\nsecurityManager.realms=$definitionRealm\n#用户退出后跳转指定JSP页面\nlogout.redirectUrl=/login.jsp\n#若没有登录，则被authc过滤器重定向到login.jsp页面\nauthc.loginUrl = /login.jsp\n[urls]\n/login=anon\n#发送/home请求需要先登录\n/home= authc\n#发送/order/list请求需要先登录\n/order-list = roles[admin]\n#提交代码需要order:add权限\n/order-add = perms[\"order:add\"]\n#更新代码需要order:del权限\n/order-del = perms[\"order:del\"]\n#发送退出请求则用退出过滤器\n/logout = logout\n```\n\n#### 【3】编写LoginService\n\n```java\npackage com.itheima.shiro.service;\n\nimport org.apache.shiro.authc.UsernamePasswordToken;\n\nimport java.lang.management.LockInfo;\n\n/**\n * @Description：登录服务\n */\npublic interface LoginService {\n\n    /**\n     * @Description 登录方法\n     * @param token 登录对象\n     * @return\n     */\n    boolean login(UsernamePasswordToken token);\n\n    /**\n     * @Description 登出方法\n     */\n    void logout();\n}\n\n```\n\n```java\npackage com.itheima.shiro.service.impl;\n\nimport com.itheima.shiro.service.LoginService;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.subject.Subject;\n\n\n/**\n * @Description：登录服务\n */\npublic class LoginServiceImpl implements LoginService {\n\n    @Override\n    public boolean login(UsernamePasswordToken token) {\n        Subject subject = SecurityUtils.getSubject();\n        try {\n            subject.login(token);\n        }catch (Exception e){\n            return false;\n        }\n        return subject.isAuthenticated();\n    }\n\n    @Override\n    public void logout() {\n        Subject subject = SecurityUtils.getSubject();\n        subject.logout();\n    }\n}\n\n```\n\n\n\n#### 【4】编写SecurityServiceImpl\n\n```java\npackage com.itheima.shiro.service.impl;\n\nimport com.itheima.shiro.service.SecurityService;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @Description：权限服务层\n */\npublic class SecurityServiceImpl implements SecurityService {\n\n    @Override\n    public Map<String,String> findPasswordByLoginName(String loginName) {\n        return DigestsUtil.entryptPassword(\"123\");\n        return map;\n    }\n\n    @Override\n    public List<String> findRoleByloginName(String loginName) {\n        List<String> list = new ArrayList<>();\n        if (\"admin\".equals(loginName)){\n            list.add(\"admin\");\n        }\n        list.add(\"dev\");\n        return list;\n    }\n\n    @Override\n    public List<String>  findPermissionByloginName(String loginName) {\n        List<String> list = new ArrayList<>();\n        if (\"jay\".equals(loginName)){\n            list.add(\"order:list\");\n            list.add(\"order:add\");\n            list.add(\"order:del\");\n        }\n        return list;\n    }\n}\n\n```\n\n#### 【5】添加web层内容\n\n##### 【5.1】LoginServlet\n\n```java\npackage com.itheima.shiro.web;\n\nimport com.itheima.shiro.service.LoginService;\nimport com.itheima.shiro.service.impl.LoginServiceImpl;\nimport org.apache.shiro.authc.UsernamePasswordToken;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * @Description：登录方法\n */\n@WebServlet(urlPatterns = \"/login\")\npublic class LoginServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        //获取输入的帐号密码\n        String username = req.getParameter(\"loginName\");\n        String password = req.getParameter(\"password\");\n        //封装用户数据，成为Shiro能认识的token标识\n        UsernamePasswordToken token = new UsernamePasswordToken(username, password);\n        LoginService loginService = new LoginServiceImpl();\n        //将封装用户信息的token进行验证\n        boolean isLoginSuccess = loginService.login(token);\n        if (!isLoginSuccess) {\n            //重定向到未登录成功页面\n            resp.sendRedirect(\"login.jsp\");\n            return;\n        }\n        req.getRequestDispatcher(\"/home\").forward(req, resp);\n    }\n\n}\n\n```\n\n##### 【5.2】HomeServlet\n\n```java\npackage com.itheima.shiro.web;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * @Description：系统home页面\n */\n@WebServlet(urlPatterns = \"/home\")\npublic class HomeServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        req.getRequestDispatcher(\"home.jsp\").forward(req, resp);\n    }\n}\n```\n\n##### 【5.3】OrderAddServlet\n\n```java\npackage com.itheima.shiro.web;\n\nimport com.itheima.shiro.service.LoginService;\nimport com.itheima.shiro.service.impl.LoginServiceImpl;\nimport org.apache.shiro.authc.UsernamePasswordToken;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * @Description：添加页码\n */\n@WebServlet(urlPatterns = \"/order-add\")\npublic class OrderAddServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        req.getRequestDispatcher(\"order-add.jsp\").forward(req, resp);\n    }\n\n}\n\n```\n\n##### 【5.4】OrderListServlet\n\n```java\npackage com.itheima.shiro.web;\n\nimport com.itheima.shiro.service.LoginService;\nimport com.itheima.shiro.service.impl.LoginServiceImpl;\nimport org.apache.shiro.authc.UsernamePasswordToken;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * @Description：订单列表\n */\n@WebServlet(urlPatterns = \"/order-list\")\npublic class OrderListServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        req.getRequestDispatcher(\"order-list.jsp\").forward(req, resp);\n    }\n}\n\n```\n\n##### 【5.5】LogoutServlet\n\n```java\npackage com.itheima.shiro.web;\n\nimport com.itheima.shiro.service.LoginService;\nimport com.itheima.shiro.service.impl.LoginServiceImpl;\nimport org.apache.shiro.authc.UsernamePasswordToken;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * @Description：登出\n */\n@WebServlet(urlPatterns = \"/logout\")\npublic class LogoutServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        LoginService loginService = new LoginServiceImpl();\n        loginService.logout();\n    }\n\n}\n\n```\n\n#### 【6】添加JSP\n\nlogin.jsp登录页面\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n<form method=\"post\" action=\"${pageContext.request.contextPath}/login\">\n    <table>\n        <tr>\n            <th>登陆名称</th>\n            <td><input type=\"text\"  name=\"loginName\"></td>\n        </tr>\n        <tr>\n            <th>密码</th>\n            <td><input type=\"password\" name=\"password\"></td>\n        </tr>\n        <tr>\n            <td colspan=\"2\">\n                <input type=\"submit\" value=\"提交\"/>\n            </td>\n        </tr>\n    </table>\n\n</form>\n</body>\n</html>\n```\n\nhome.jsp系统页\n\n```html\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n<h6>\n    <a href=\"${pageContext.request.contextPath}/logout\">退出</a>\n    <a href=\"${pageContext.request.contextPath}/order-list\">列表</a>\n    <a href=\"${pageContext.request.contextPath}/order-add\">添加</a>\n</h6>\n</body>\n</html>\n```\n\norder-add.jsp订单添加（伪代码）\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    <title>Title</title>\n</head>\n<body>\n添加页面\n</body>\n</html>\n```\n\norder-list.jsp订单列表\n\n```html\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<%--导入jstl标签库--%>\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n<html>\n<head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\">\n    <title>用户列表jsp页面</title>\n    <style>\n        table {border:1px solid #000000}\n        table th{border:1px solid #000000}\n        table td{border:1px solid #000000}\n    </style>\n\n</head>\n<body>\n<table cellpadding=\"0\" cellspacing=\"0\" width=\"80%\">\n    <tr>\n        <th>编号</th>\n        <th>公司名称</th>\n        <th>信息来源</th>\n        <th>所属行业</th>\n        <th>级别</th>\n        <th>联系地址</th>\n        <th>联系电话</th>\n    </tr>\n    <tr>\n        <td>1</td>\n        <td>传智播客</td>\n        <td>网络营销</td>\n        <td>互联网</td>\n        <td>普通客户</td>\n        <td>津安创意园</td>\n        <td>0208888887</td>\n    </tr>\n    <tr>\n        <td>2</td>\n        <td>黑马程序员</td>\n        <td>j2ee</td>\n        <td>互联网</td>\n        <td>VIP客户</td>\n        <td>津安创意园</td>\n        <td>0208888887</td>\n    </tr>\n    <tr>\n        <td>3</td>\n        <td>黑马程序员</td>\n        <td>大数据</td>\n        <td>互联网</td>\n        <td>VIP客户</td>\n        <td>津安创意园</td>\n        <td>0208888887</td>\n    </tr>\n</table>\n</body>\n\n</html>\n```\n\n#### 【7】测试\n\n##### 【7.1】启动\n\n![1580712098325](image\\1580712098325.png)\n\n![1580712149790](image\\1580712149790.png)\n\n![1580712207992](image\\1580712207992.png)\n\n点击apply然后点击OK\n\n![1580712304894](image\\1580712304894.png)\n\n##### 【7.2】登录过滤\n\n访问http://localhost:8080/platform/home的时候，会被\n\n![1580712567791](image\\1580712567791.png)\n\n![1580712593905](image\\1580712593905.png)\n\n##### 【7.3】角色过滤\n\n使用“admin”用户登录，密码：123\n\n![1580713051410](image\\1580713051410.png)\n\n根据SecurityServiceImpl我们可以知道使用admin账号\n\n![1580712777098](image\\1580712777098.png)\n\n登录成功之后：\n\n![1580713214523](image\\1580713214523.png)\n\n此时点击“列表”，因为当前admin用户是有admin角色\n\n![1580713320621](image\\1580713320621.png)\n\n所有可以正常访问\n\n![1580713360368](image\\1580713360368.png)\n\n点击“添加”，因为当前admin用户是没有order:add的资源\n\n![1580713455483](image\\1580713455483.png)\n\n所以回401\n\n![1580713488156](image\\1580713488156.png)\n\n##### 【7.4】资源过滤\n\n点击“退出”\n\n![1580713654616](image\\1580713654616.png)\n\n使用“jay”用户登录，密码为123\n\n![1580713770711](image\\1580713770711.png)\n\n点击“添加”\n\n![1580713818625](image\\1580713818625.png)\n\n因为SecurityServiceImpl中为jay用户添加如下的资源\n\n![1580713855307](image\\1580713855307.png)\n\n\n\n点击“添加”之后正常访问\n\n![1580713814501](image\\1580713814501.png)\n\n点击“列表”之后，因为“jay”用户满意“admin”角色，所以访问受限\n\n![1580713925370](image\\1580713925370.png)\n\n### 4、web项目授权\n\n前面我们学习了基于ini文件配置方式来完成授权，下面我们来看下其他2种方式的授权\n\n#### 【1】基于代码\n\n##### 【1.1】登录相关\n\n| Subject 登录相关方法 | 描述                                   |\n| -------------------- | -------------------------------------- |\n| isAuthenticated()    | 返回true 表示已经登录，否则返回false。 |\n\n##### 【1.2】角色相关\n\n| Subject 角色相关方法                     | 描述                                                         |\n| ---------------------------------------- | ------------------------------------------------------------ |\n| hasRole(String roleName)                 | 返回true 如果Subject 被分配了指定的角色，否则返回false。     |\n| hasRoles(List<String> roleNames)         | 返回true 如果Subject 被分配了所有指定的角色，否则返回false。 |\n| hasAllRoles(Collection<String>roleNames) | 返回一个与方法参数中目录一致的hasRole 结果的集合。有性能的提高如果许多角色需要执行检查（例如，当自定义一个复杂的视图）。 |\n| checkRole(String roleName)               | 安静地返回，如果Subject 被分配了指定的角色，不然的话就抛出AuthorizationException。 |\n| checkRoles(Collection<String>roleNames)  | 安静地返回，如果Subject 被分配了所有的指定的角色，不然的话就抛出AuthorizationException。 |\n| checkRoles(String… roleNames)            | 与上面的checkRoles 方法的效果相同，但允许Java5 的var-args 类型的参数 |\n\n##### 【1.3】资源相关\n\n| Subject 资源相关方法                           | 描述                                                         |\n| ---------------------------------------------- | ------------------------------------------------------------ |\n| isPermitted(Permission p)                      | 返回true 如果该Subject 被允许执行某动作或访问被权限实例指定的资源，否则返回false |\n| isPermitted(List<Permission> perms)            | 返回一个与方法参数中目录一致的isPermitted 结果的集合。       |\n| isPermittedAll(Collection<Permission>perms)    | 返回true 如果该Subject 被允许所有指定的权限，否则返回false有性能的提高如果需要执行许多检查（例如，当自定义一个复杂的视图） |\n| isPermitted(String perm)                       | 返回true 如果该Subject 被允许执行某动作或访问被字符串权限指定的资源，否则返回false。 |\n| isPermitted(String…perms)                      | 返回一个与方法参数中目录一致的isPermitted 结果的数组。有性能的提高如果许多字符串权限检查需要被执行（例如，当自定义一个复杂的视图）。 |\n| isPermittedAll(String…perms)                   | 返回true 如果该Subject 被允许所有指定的字符串权限，否则返回false。 |\n| checkPermission(Permission p)                  | 安静地返回，如果Subject 被允许执行某动作或访问被特定的权限实例指定的资源，不然的话就抛出AuthorizationException 异常。 |\n| checkPermission(String perm)                   | 安静地返回，如果Subject 被允许执行某动作或访问被特定的字符串权限指定的资源，不然的话就抛出AuthorizationException 异常。 |\n| checkPermissions(Collection<Permission> perms) | 安静地返回，如果Subject 被允许所有的权限，不然的话就抛出AuthorizationException 异常。有性能的提高如果需要执行许多检查（例如，当自定义一个复杂的视图） |\n| checkPermissions(String… perms)                | 和上面的checkPermissions 方法效果相同，但是使用的是基于字符串的权限。 |\n\n##### 【1.4】案例\n\n###### 【1.4.1】创建项目\n\n拷贝shiro-day01-07web新建shiro-day01-08web-java\n\n![1580799013486](image/1580799013486.png)\n\n###### 【1.4.2】修改shiro.ini\n\n```ini\n#声明自定义的realm，且为安全管理器指定realms\n[main]\ndefinitionRealm=com.itheima.shiro.realm.DefinitionRealm\nsecurityManager.realms=$definitionRealm\n#用户退出后跳转指定JSP页面\nlogout.redirectUrl=/login.jsp\n#若没有登录，则被authc过滤器重定向到login.jsp页面\nauthc.loginUrl = /login.jsp\n[urls]\n/login=anon\n#发送/home请求需要先登录\n#/home= authc\n#发送/order/list请求需要先登录\n#/order-list = roles[admin]\n#提交代码需要order:add权限\n#/order-add = perms[\"order:add\"]\n#更新代码需要order:del权限\n#/order-del = perms[\"order:del\"]\n#发送退出请求则用退出过滤器\n/logout = logout\n```\n\n###### 【1.4.3】登录相关\n\n修改HomeServlet的doPost方法\n\n```java\npackage com.itheima.shiro.web;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.subject.Subject;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * @Description：系统home页面\n */\n@WebServlet(urlPatterns = \"/home\")\npublic class HomeServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        //通过subjectd对象去判断是否登录\n        Subject subject = SecurityUtils.getSubject();\n        boolean flag  = subject.isAuthenticated();\n        if (flag){\n            resp.sendRedirect(\"home.jsp\");\n        }else {\n            req.getRequestDispatcher(\"/login\").forward(req, resp);\n        }\n    }\n}\n\n```\n\n访问http://localhost:8080/platform/home   进行debug\n\n![1580800060589](image\\1580800060589.png)\n\n此时我们通过subject.isAuthenticated()判断是否登录，如果登录则重定向到home.jsp,如果没有登录则转发到/login对应的servlet\n\n###### 【1.4.4】角色相关\n\n修改OrderListServlet的doPost方法，判断是否有admin角色，如果有则转发order-list.jsp,没有则转发/login\n\n```java\npackage com.itheima.shiro.web;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.subject.Subject;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * @Description：订单列表\n */\n@WebServlet(urlPatterns = \"/order-list\")\npublic class OrderListServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        Subject subject = SecurityUtils.getSubject();\n        //判断当前角色\n        boolean flag = subject.hasRole(\"admin\");\n        if (flag){\n            req.getRequestDispatcher(\"order-list.jsp\").forward(req, resp);\n        }else {\n            req.getRequestDispatcher(\"/login\").forward(req, resp);\n        }\n    }\n}\n```\n\n访问http://localhost:8080/platform/order-list\n\n![1580801658680](image\\1580801658680.png)\n\n因为此时我未登录，也就是说当前没有admin角色，这是通过subject.hasRole(\"admin\")返回未false\n\n###### 【1.4.5】资源相关\n\n修改OrderAddServlet\n\n```java\npackage com.itheima.shiro.web;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.subject.Subject;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * @Description：添加页码\n */\n@WebServlet(urlPatterns = \"/order-add\")\npublic class OrderAddServlet extends HttpServlet {\n\n    @Override\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        doPost(req, resp);\n    }\n\n    @Override\n    protected void doPost(HttpServletRequest req, HttpServletResponse resp)\n            throws ServletException, IOException {\n        Subject subject = SecurityUtils.getSubject();\n        //判断是否有对应资源\n        boolean flag = subject.isPermitted(\"order:add\");\n        if (flag){\n            req.getRequestDispatcher(\"order-add.jsp\").forward(req, resp);\n        }else {\n            req.getRequestDispatcher(\"/login\").forward(req, resp);\n        }\n    }\n\n}\n\n```\n\n访问http://localhost:8080/platform/order-add\n\n![1580802789329](image\\1580802789329.png)\n\n因为此时我未登录，也就是说当前没有order:add资源，通过 subject.isPermitted(\"order:add\")返回未false\n\n#### 【2】基于Jsp标签\n\n##### 【2.1】使用方式\n\nShiro提供了一套JSP标签库来实现页面级的授权控制， 在使用Shiro标签库前，首先需要在JSP引入shiro标签： \n\n```html\n<%@ taglib prefix=\"shiro\" uri=\"http://shiro.apache.org/tags\" %> \n\n```\n\n#####  【2.2】相关标签\n\n| 标签                                | 说明                                                         |\n| ----------------------------------- | ------------------------------------------------------------ |\n| < shiro:guest >                     | 验证当前用户是否为“访客”，即未认证（包含未记住）的用户       |\n| < shiro:user >                      | 认证通过或已记住的用户                                       |\n| < shiro:authenticated >             | 已认证通过的用户。不包含已记住的用户，这是与user标签的区别所在 |\n| < shiro:notAuthenticated >          | 未认证通过用户。与guest标签的区别是，该标签包含已记住用户    |\n| < shiro:principal />                | 输出当前用户信息，通常为登录帐号信息                         |\n| < shiro:hasRole name=\"角色\">        | 验证当前用户是否属于该角色                                   |\n| < shiro:lacksRole name=\"角色\">      | 与hasRole标签逻辑相反，当用户不属于该角色时验证通过          |\n| < shiro:hasAnyRoles name=\"a,b\">     | 验证当前用户是否属于以下任意一个角色                         |\n| <shiro:hasPermission name=“资源”>   | 验证当前用户是否拥有制定权限                                 |\n| <shiro:lacksPermission name=\"资源\"> | 与permission标签逻辑相反，当前用户没有制定权限时，验证通过   |\n\n##### 【2.3】案例\n\n###### 【2.3.1】新建项目\n\n拷贝shiro-day01-08web-java新建shiro-day01-09web-jsp-taglib项目\n\n![1580805725438](image\\1580805725438.png)\n\n###### 【2.3.2】修改home.jsp\n\n```html\n<%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %>\n<%@ taglib prefix=\"shiro\" uri=\"http://shiro.apache.org/tags\" %>\n<%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %>\n<html>\n<head>\n    <title></title>\n</head>\n<body>\n<h6>\n    <a href=\"${pageContext.request.contextPath}/logout\">退出</a>\n    <shiro:hasRole name=\"admin\">\n    <a href=\"${pageContext.request.contextPath}/order-list\">列表</a>\n    </shiro:hasRole>\n    <shiro:hasPermission name=\"order:add\">\n    <a href=\"${pageContext.request.contextPath}/order-add\">添加</a>\n    </shiro:hasPermission>\n</h6>\n</body>\n</html>\n```\n\n【2.3.3】测试\n\n访问http://localhost:8080/platform/login\n\n使用admin/123登录\n\n![1580806179855](image\\1580806179855.png)\n\n这个时候我们只能看见“列表”，看不见“添加”，点击“退出”\n\n使用jay/123登录\n\n![1580806253525](image\\1580806253525.png)\n\n这个时候我们只能看见“添加”，看不见“列表”，点击“退出”\n\n需要注意的是，这里只是页面是否显示内容，不能防止盗链的发生\n\n## 第五章 Springboot集成Shiro\n\n### 1、技术栈\n\n主框架：springboot\n\n响应层：springMVC\n\n持久层：mybatis\n\n事务控制：jta\n\n前端技术：easyui\n\n### 2、数据库设计\n\n#### 【1】数据库图解\n\n![1580807847384](image\\1580807847384.png)\n\nsh_user:用户表，一个用户可以有多个角色\n\nsh_role:角色表，一个角色可以有多个资源\n\nsh_resource:资源表\n\nsh_user_role:用户角色中间表\n\nsh_role_resource:角色资源中间表\n\n#### 【2】数据库脚本\n\nsh_user\n\n```sql\nCREATE TABLE `sh_user` (\n  `ID` varchar(36) NOT NULL COMMENT \'主键\',\n  `LOGIN_NAME` varchar(36) DEFAULT NULL COMMENT \'登录名称\',\n  `REAL_NAME` varchar(36) DEFAULT NULL COMMENT \'真实姓名\',\n  `NICK_NAME` varchar(36) DEFAULT NULL COMMENT \'昵称\',\n  `PASS_WORD` varchar(150) DEFAULT NULL COMMENT \'密码\',\n  `SALT` varchar(36) DEFAULT NULL COMMENT \'加密因子\',\n  `SEX` int(11) DEFAULT NULL COMMENT \'性别\',\n  `ZIPCODE` varchar(36) DEFAULT NULL COMMENT \'邮箱\',\n  `ADDRESS` varchar(36) DEFAULT NULL COMMENT \'地址\',\n  `TEL` varchar(36) DEFAULT NULL COMMENT \'固定电话\',\n  `MOBIL` varchar(36) DEFAULT NULL COMMENT \'电话\',\n  `EMAIL` varchar(36) DEFAULT NULL COMMENT \'邮箱\',\n  `DUTIES` varchar(36) DEFAULT NULL COMMENT \'职务\',\n  `SORT_NO` int(11) DEFAULT NULL COMMENT \'排序\',\n  `ENABLE_FLAG` varchar(18) DEFAULT NULL COMMENT \'是否有效\',\n  PRIMARY KEY (`ID`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT COMMENT=\'用户表\';\n\n```\n\nsh_role\n\n```sql\nCREATE TABLE `sh_role` (\n  `ID` varchar(36) NOT NULL COMMENT \'主键\',\n  `ROLE_NAME` varchar(36) DEFAULT NULL COMMENT \'角色名称\',\n  `LABEL` varchar(36) DEFAULT NULL COMMENT \'角色标识\',\n  `DESCRIPTION` varchar(200) DEFAULT NULL COMMENT \'角色描述\',\n  `SORT_NO` int(36) DEFAULT NULL COMMENT \'排序\',\n  `ENABLE_FLAG` varchar(18) DEFAULT NULL COMMENT \'是否有效\',\n  PRIMARY KEY (`ID`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT COMMENT=\'用户角色表\';\n```\n\nsh_resource\n\n```sql\nCREATE TABLE `sh_resource` (\n  `ID` varchar(36) NOT NULL COMMENT \'主键\',\n  `PARENT_ID` varchar(36) DEFAULT NULL COMMENT \'父资源\',\n  `RESOURCE_NAME` varchar(36) DEFAULT NULL COMMENT \'资源名称\',\n  `REQUEST_PATH` varchar(200) DEFAULT NULL COMMENT \'资源路径\',\n  `LABEL` varchar(200) DEFAULT NULL COMMENT \'资源标签\',\n  `ICON` varchar(20) DEFAULT NULL COMMENT \'图标\',\n  `IS_LEAF` varchar(18) DEFAULT NULL COMMENT \'是否叶子节点\',\n  `RESOURCE_TYPE` varchar(36) DEFAULT NULL COMMENT \'资源类型\',\n  `SORT_NO` int(11) DEFAULT NULL COMMENT \'排序\',\n  `DESCRIPTION` varchar(200) DEFAULT NULL COMMENT \'描述\',\n  `SYSTEM_CODE` varchar(36) DEFAULT NULL COMMENT \'系统code\',\n  `IS_SYSTEM_ROOT` varchar(18) DEFAULT NULL COMMENT \'是否根节点\',\n  `ENABLE_FLAG` varchar(18) DEFAULT NULL COMMENT \'是否有效\',\n  PRIMARY KEY (`ID`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT COMMENT=\'资源表\';\n\n```\n\nsh_role_resource\n\n```sql\nCREATE TABLE `sh_role_resource` (\n  `ID` varchar(36) NOT NULL,\n  `ENABLE_FLAG` varchar(18) DEFAULT NULL,\n  `ROLE_ID` varchar(36) DEFAULT NULL,\n  `RESOURCE_ID` varchar(36) DEFAULT NULL,\n  PRIMARY KEY (`ID`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT COMMENT=\'角色资源表\';\n```\n\nsh_user_role\n\n```sql\nCREATE TABLE `sh_user_role` (\n  `ID` varchar(36) NOT NULL,\n  `ENABLE_FLAG` varchar(18) DEFAULT NULL,\n  `USER_ID` varchar(36) DEFAULT NULL,\n  `ROLE_ID` varchar(36) DEFAULT NULL,\n  PRIMARY KEY (`ID`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8 ROW_FORMAT=COMPACT COMMENT=\'用户角色表\';\n```\n\n### 3、项目骨架\n\n![1581062691221](image\\1581062691221.png)\n\n### 4、ShiroDbRealm定义\n\n#### 【1】图解\n\n![1583895738811](image\\1583895738811.png)\n\n#### 【2】原理分析\n\n（1）、ShiroDbRealmImpl继承ShiroDbRealm向上继承AuthorizingRealm，ShiroDbRealmImpl实例化时会创建密码匹配器HashedCredentialsMatcher实例，HashedCredentialsMatcher指定hash次数与方式，交于AuthenticatingRealm\n\n（2）、调用login方法后，最终调用doGetAuthenticationInfo(AuthenticationToken authcToken)方法，拿到SimpleToken的对象，调用UserBridgeService的查找用户方法，把ShiroUser对象、密码和salt交于SimpleAuthenticationInfo去认证\n\n（3）、访问需要鉴权时，调用doGetAuthorizationInfo(PrincipalCollection principals)方法，然后调用UserBridgeService的授权验证 \n\n#### 【3】核心类代码\n\n##### 【3.1】ShiroDbRealm\n\n```java\n\npackage com.itheima.shiro.core;\n\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\n\nimport javax.annotation.PostConstruct;\n\n\n/**\n *\n * @Description shiro自定义realm\n */\npublic abstract class ShiroDbRealm extends AuthorizingRealm {\n	\n	/**\n	 * @Description 认证\n	 * @param authcToken token对象\n	 * @return \n	 */\n	public abstract AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken) ;\n\n	/**\n	 * @Description 鉴权\n	 * @param principals 令牌\n	 * @return\n	 */\n	public abstract AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals);\n	\n	/**\n	 * @Description 密码匹配器\n	 */\n	@PostConstruct\n	public abstract void initCredentialsMatcher() ;\n\n	\n}\n\n```\n\n##### 【3.2】ShiroDbRealmImpl\n\n```java\npackage com.itheima.shiro.core.impl;\n\nimport com.itheima.shiro.constant.SuperConstant;\nimport com.itheima.shiro.core.base.ShiroUser;\nimport com.itheima.shiro.core.base.SimpleToken;\nimport com.itheima.shiro.core.ShiroDbRealm;\nimport com.itheima.shiro.core.bridge.UserBridgeService;\nimport com.itheima.shiro.pojo.User;\nimport com.itheima.shiro.utils.BeanConv;\nimport com.itheima.shiro.utils.DigestsUtil;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authc.UnknownAccountException;\nimport org.apache.shiro.authc.credential.HashedCredentialsMatcher;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.util.ByteSource;\nimport org.springframework.beans.factory.annotation.Autowired;\n\n/**\n * @Description：自定义shiro的实现\n */\npublic class ShiroDbRealmImpl extends ShiroDbRealm {\n\n    @Autowired\n    private UserBridgeService userBridgeService;\n\n\n    /**\n     * @Description 认证方法\n     * @param authcToken 校验传入令牌\n     * @return AuthenticationInfo\n     */\n    @Override\n    public AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken) {\n        SimpleToken token = (SimpleToken)authcToken;\n        User user  = userBridgeService.findUserByLoginName(token.getUsername());\n        if(EmptyUtil.isNullOrEmpty(user)){\n            throw new UnknownAccountException(\"账号不存在\");\n        }\n        ShiroUser shiroUser = BeanConv.toBean(user, ShiroUser.class);\n        shiroUser.setResourceIds(userBridgeService.findResourcesIdsList(user.getId()));\n        String salt = user.getSalt();\n        String password = user.getPassWord();\n        return new SimpleAuthenticationInfo(shiroUser, password, ByteSource.Util.bytes(salt), getName());\n    }\n\n    /**\n     * @Description 授权方法\n     * @param principals SimpleAuthenticationInfo对象第一个参数\n     * @return\n     */\n    @Override\n    public AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        ShiroUser shiroUser = (ShiroUser) principals.getPrimaryPrincipal();\n        return userBridgeService.getAuthorizationInfo(shiroUser);\n    }\n\n    /**\n     * @Description 加密方式\n     */\n    @Override\n    public void initCredentialsMatcher() {\n        HashedCredentialsMatcher matcher = new HashedCredentialsMatcher(SuperConstant.HASH_ALGORITHM);\n        matcher.setHashIterations(SuperConstant.HASH_INTERATIONS);\n        setCredentialsMatcher(matcher);\n\n    }\n}\n\n```\n\n##### 【3.3】SimpleToken\n\n```java\n\npackage com.itheima.shiro.core.base;\n\nimport org.apache.shiro.authc.UsernamePasswordToken;\n\n\n/**\n * @Description 自定义tooken\n */\npublic class SimpleToken extends UsernamePasswordToken {\n	\n	/** serialVersionUID */\n	private static final long serialVersionUID = -4849823851197352099L;\n\n	private String tokenType;\n	\n	private String quickPassword;\n\n	/**\n	 * Constructor for SimpleToken\n	 * @param tokenType\n	 */\n	public SimpleToken(String tokenType, String username,String password) {\n		super(username,password);\n		this.tokenType = tokenType;\n	}\n	\n	public SimpleToken(String tokenType, String username,String password,String quickPassword) {\n		super(username,password);\n		this.tokenType = tokenType;\n		this.quickPassword = quickPassword;\n	}\n\n	public String getTokenType() {\n		return tokenType;\n	}\n\n	public void setTokenType(String tokenType) {\n		this.tokenType = tokenType;\n	}\n\n	public String getQuickPassword() {\n		return quickPassword;\n	}\n\n	public void setQuickPassword(String quickPassword) {\n		this.quickPassword = quickPassword;\n	}\n	\n	\n}\n\n```\n\n\n\n##### 【3.4】ShiroUser\n\n```java\n\npackage com.itheima.shiro.core.base;\n\nimport com.itheima.shiro.utils.ToString;\nimport lombok.Data;\n\nimport java.util.List;\n\n\n/**\n * @Description 自定义Authentication对象，使得Subject除了携带用户的登录名外还可以携带更多信息\n */\n@Data\npublic class  ShiroUser extends ToString {\n\n	/** serialVersionUID */\n	private static final long serialVersionUID = -5024855628064590607L;\n\n	/**\n	 * 主键\n	 */\n	private String id;\n\n	/**\n	 * 登录名称\n	 */\n	private String loginName;\n\n	/**\n	 * 真实姓名\n	 */\n	private String realName;\n\n	/**\n	 * 昵称\n	 */\n	private String nickName;\n\n	/**\n	 * 密码\n	 */\n	private String passWord;\n\n	/**\n	 * 加密因子\n	 */\n	private String salt;\n\n	/**\n	 * 性别\n	 */\n	private Integer sex;\n\n	/**\n	 * 邮箱\n	 */\n	private String zipcode;\n\n	/**\n	 * 地址\n	 */\n	private String address;\n\n	/**\n	 * 固定电话\n	 */\n	private String tel;\n\n	/**\n	 * 电话\n	 */\n	private String mobil;\n\n	/**\n	 * 邮箱\n	 */\n	private String email;\n\n	/**\n	 * 职务\n	 */\n	private String duties;\n\n	/**\n	 * 排序\n	 */\n	private Integer sortNo;\n\n	/**\n	 * 是否有效\n	 */\n	private String enableFlag;\n    \n	private List<String> resourceIds;\n\n	public ShiroUser() {\n		super();\n	}\n\n	public ShiroUser(String id, String loginName) {\n		super();\n		this.id = id;\n		this.loginName = loginName;\n	}\n\n\n	@Override\n	public int hashCode() {\n		final int prime = 31;\n		int result = 1;\n		result = prime * result + ((email == null) ? 0 : email.hashCode());\n		result = prime * result + ((id == null) ? 0 : id.hashCode());\n		result = prime * result\n				+ ((loginName == null) ? 0 : loginName.hashCode());\n		result = prime * result + ((mobil == null) ? 0 : mobil.hashCode());\n		return result;\n	}\n\n	@Override\n	public boolean equals(Object obj) {\n		if (this == obj)\n			return true;\n		if (obj == null)\n			return false;\n		if (getClass() != obj.getClass())\n			return false;\n		ShiroUser other = (ShiroUser) obj;\n		if (email == null) {\n			if (other.email != null)\n				return false;\n		} else if (!email.equals(other.email))\n			return false;\n		if (id == null) {\n			if (other.id != null)\n				return false;\n		} else if (!id.equals(other.id))\n			return false;\n		if (loginName == null) {\n			if (other.loginName != null)\n				return false;\n		} else if (!loginName.equals(other.loginName))\n			return false;\n		if (mobil == null) {\n			if (other.mobil != null)\n				return false;\n		} else if (!mobil.equals(other.mobil))\n			return false;\n		return true;\n	}\n	\n	\n}\n\n```\n\n##### 【3.5】UserBridgeService\n\n```java\npackage com.itheima.shiro.core.bridge;\n\nimport com.itheima.shiro.core.base.ShiroUser;\nimport com.itheima.shiro.pojo.User;\nimport org.apache.shiro.authz.AuthorizationInfo;\n\nimport java.util.List;\n\n/**\n * @Description：用户信息桥接（后期会做缓存）\n */\npublic interface UserBridgeService {\n\n\n    /**\n     * @Description 查找用户信息\n     * @param loginName 用户名称\n     * @return user对象\n     */\n    User findUserByLoginName(String loginName);\n\n    /**\n     * @Description 鉴权方法\n     * @param shiroUser 令牌对象\n     * @return 鉴权信息\n     */\n    AuthorizationInfo getAuthorizationInfo(ShiroUser shiroUser);\n\n    /**\n     * @Description 查询用户对应角色标识list\n     * @param userId 用户id\n     * @return 角色标识集合\n     */\n    List<String> findRoleList(String userId);\n\n    /**\n     * @Description 查询用户对应资源标识list\n     * @param userId 用户id\n     * @return 资源标识集合\n     */\n    List<String> findResourcesList(String userId);\n\n    /**\n     * @Description 查询资源ids\n     * @param userId 用户id\n     * @return 资源id集合\n     */\n    List<String> findResourcesIds(String userId);\n}\n\n```\n\n##### 【3.6】UserBridgeServiceImpl\n\n```java\npackage com.itheima.shiro.core.bridge.impl;\n\nimport com.itheima.shiro.core.adapter.UserAdapter;\nimport com.itheima.shiro.core.base.ShiroUser;\nimport com.itheima.shiro.core.bridge.UserBridgeService;\nimport com.itheima.shiro.pojo.Resource;\nimport com.itheima.shiro.pojo.Role;\nimport com.itheima.shiro.pojo.User;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @Description：用户信息桥接（后期会做缓存）\n */\n@Component(\"userBridgeService\")\npublic class UserBridgeServiceImpl implements UserBridgeService {\n\n    @Autowired\n    UserAdapter userAdapter;\n\n    @Override\n    public User findUserByLoginName(String loginName) {\n\n        return userAdapter.findUserByLoginName(loginName);\n    }\n\n    @Override\n    public AuthorizationInfo getAuthorizationInfo(ShiroUser shiroUser) {\n        //查询用户对应的角色标识\n        List<String> roleList = this.findRoleList(shiroUser.getId());\n        //查询用户对于的资源标识\n        List<String> resourcesList = this.findResourcesList(shiroUser.getId());\n        //构建鉴权信息对象\n        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();\n        simpleAuthorizationInfo.addRoles(roleList);\n        simpleAuthorizationInfo.addStringPermissions(resourcesList);\n        return simpleAuthorizationInfo;\n    }\n\n    @Override\n    public List<String> findRoleList(String userId){\n        List<Role> roles = userAdapter.findRoleByUserId(userId);\n        List<String> roleLabel = new ArrayList<>();\n        for (Role role : roles) {\n            roleLabel.add(role.getLabel());\n        }\n        return roleLabel;\n    }\n\n    @Override\n    public List<String> findResourcesList(String userId){\n        List<Resource> resources = userAdapter.findResourceByUserId(userId);\n        List<String> resourceLabel = new ArrayList<>();\n        for (Resource resource : resources) {\n            resourceLabel.add(resource.getLabel());\n        }\n        return resourceLabel;\n    }\n\n    @Override\n    public List<String> findResourcesIds(String userId) {\n        List<Resource> resources = userAdapter.findResourceByUserId(userId);\n        List<String> ids = new ArrayList<>();\n        for (Resource resource : resources) {\n            ids.add(resource.getId());\n        }\n        return ids;\n    }\n\n}\n\n```\n\n##### 【3.7】UserAdapter\n\n```java\npackage com.itheima.shiro.core.adapter;\n\nimport com.itheima.shiro.pojo.Resource;\nimport com.itheima.shiro.pojo.Role;\nimport com.itheima.shiro.pojo.User;\n\nimport java.util.List;\n\n\n/**\n * @Description 后台登陆用户适配器接口\n */\n\npublic interface UserAdapter {\n	\n	/**\n	 * @Description 按用户名查找用户\n	 * @param loginName 登录名\n	 * @return\n	 */\n	User findUserByLoginName(String loginName);\n\n	/**\n	 * @Description 查找用户所有角色\n	 * @param userId 用户Id\n	 * @return\n	 */\n	List<Role> findRoleByUserId(String userId);\n\n	/**\n	 * @Description 查询用户有那些资源\n	 * @param userId 用户Id\n	 * @return\n	 */\n	List<Resource> findResourceByUserId(String userId);\n\n}\n\n```\n\n##### 【3.8】UserAdapterImpl\n\n```java\npackage com.itheima.shiro.core.adapter.impl;\n\nimport com.itheima.shiro.constant.SuperConstant;\nimport com.itheima.shiro.core.adapter.UserAdapter;\nimport com.itheima.shiro.mapper.UserMapper;\nimport com.itheima.shiro.mappercustom.UserAdapterMapper;\nimport com.itheima.shiro.pojo.Resource;\nimport com.itheima.shiro.pojo.Role;\nimport com.itheima.shiro.pojo.User;\nimport com.itheima.shiro.pojo.UserExample;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\n\n/**\n * @Description 后台登陆用户适配器接口实现\n */\n@Component(\"userAdapter\")\npublic class UserAdapterImpl implements UserAdapter {\n\n	@Autowired\n	private UserMapper userMapper;\n\n	@Autowired\n	private UserAdapterMapper userAdapterMapper;\n\n	@Override\n	public User findUserByLoginName(String loginName) {\n		UserExample userExample = new UserExample();\n		userExample.createCriteria().andEnableFlagEqualTo(SuperConstant.YES).andLoginNameEqualTo(loginName);\n		List<User> userList = userMapper.selectByExample(userExample);\n		if (userList.size()==1) {\n			return userList.get(0);\n		}else {\n			return null;\n		}\n	}\n\n	@Override\n	public List<Role> findRoleByUserId(String userId) {\n		Map<String, Object> values = new HashMap<String, Object>();\n		values.put(\"userId\", userId);\n		values.put(\"enableFlag\", SuperConstant.YES);\n		List<Role> list = userAdapterMapper.findRoleByUserId(values);\n		return list;\n	}\n\n	@Override\n	public List<Resource> findResourceByUserId(String userId) {\n		Map<String, Object> values = new HashMap<String, Object>();\n		values.put(\"userId\", userId);\n		values.put(\"enableFlag\", SuperConstant.YES);\n		List<Resource> list=userAdapterMapper.findResourceByUserId(values);\n		return list;\n	}\n}\n\n```\n\n### 5、ShiroConfig配置\n\n#### 【1】图解\n\n![1581064915787](image/1581064915787.png)\n\n#### 【2】原理分析\n\n（1）、创建SimpleCookie，访问项目时，会在客户端中cookie中存放ShiroSession的对\n\n（2）、创建DefaultWebSessionManager会话管理器定义cookie机制、定时刷新、全局会话超时时间然后交\n\n于DefaultWebSecurityManager权限管理器管理\n\n（3）、创建自定义ShiroDbRealm实现，用于权限认证、授权、加密方式的管理，同时从数据库中取得相关的\n\n角色、资源、用户的信息，然后交于DefaultWebSecurityManager权限管理器管理\n\n（4）、创建DefaultWebSecurityManager权限管理器用于管理DefaultWebSessionManager会话管理器、ShiroDbRealm\n\n（5）、创建lifecycleBeanPostProcessor和DefaultAdvisorAutoProxyCreator相互配合事项注解的权限鉴权\n\n（6）、创建ShiroFilterFactoryBean的shiro过滤器指定权限管理器、同时启动连接链及登录URL、未登录的URL\n\n的跳转\n\n#### 【3】ShiroConfig代码\n\n```java\npackage com.itheima.shiro.config;\n\n\nimport com.itheima.shiro.core.ShiroDbRealm;\nimport com.itheima.shiro.core.impl.ShiroDbRealmImpl;\nimport com.itheima.shiro.properties.PropertiesUtil;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.shiro.spring.LifecycleBeanPostProcessor;\nimport org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.apache.shiro.web.servlet.SimpleCookie;\nimport org.apache.shiro.web.session.mgt.DefaultWebSessionManager;\nimport org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.DependsOn;\n\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @Description：权限配置类\n */\n@Configuration\n@ComponentScan(basePackages = \"com.itheima.shiro.core\")\n@Log4j2\npublic class ShiroConfig {\n\n    /**\n     * @Description 创建cookie对象\n     */\n    @Bean(name=\"sessionIdCookie\")\n    public SimpleCookie simpleCookie(){\n        SimpleCookie simpleCookie = new SimpleCookie();\n        simpleCookie.setName(\"ShiroSession\");\n        return simpleCookie;\n    }\n\n    /**\n     * @Description 权限管理器\n     */\n    @Bean(name=\"securityManager\")\n    public DefaultWebSecurityManager defaultWebSecurityManager(){\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n        securityManager.setRealm(shiroDbRealm());\n        securityManager.setSessionManager(shiroSessionManager());\n        return securityManager;\n    }\n\n    /**\n     * @Description 自定义RealmImpl\n     */\n    @Bean(name=\"shiroDbRealm\")\n    public ShiroDbRealm shiroDbRealm(){\n        return new ShiroDbRealmImpl();\n    }\n\n\n    /**\n     * @Description 会话管理器\n     */\n    @Bean(name=\"sessionManager\")\n    public DefaultWebSessionManager shiroSessionManager(){\n        DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();\n        sessionManager.setSessionValidationSchedulerEnabled(false);\n        sessionManager.setSessionIdCookieEnabled(true);\n        sessionManager.setSessionIdCookie(simpleCookie());\n        sessionManager.setGlobalSessionTimeout(3600000);\n        return sessionManager;\n    }\n\n    /**\n     * @Description 保证实现了Shiro内部lifecycle函数的bean执行\n     */\n    @Bean(name = \"lifecycleBeanPostProcessor\")\n    public static LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() {\n        return new LifecycleBeanPostProcessor();\n    }\n\n    /**\n     * @Description AOP式方法级权限检查\n     */\n    @Bean\n    @DependsOn(\"lifecycleBeanPostProcessor\")\n    public DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() {\n        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();\n        defaultAdvisorAutoProxyCreator.setProxyTargetClass(true);\n        return defaultAdvisorAutoProxyCreator;\n    }\n\n    /**\n     * @Description 配合DefaultAdvisorAutoProxyCreator事项注解权限校验\n     */\n    @Bean\n    public AuthorizationAttributeSourceAdvisor getAuthorizationAttributeSourceAdvisor() {\n        AuthorizationAttributeSourceAdvisor aasa = new AuthorizationAttributeSourceAdvisor();\n        aasa.setSecurityManager(defaultWebSecurityManager());\n        return new AuthorizationAttributeSourceAdvisor();\n    }\n\n    /**\n     * @Description 过滤器链\n     */\n    private Map<String, String> filterChainDefinition(){\n        List<Object> list  = PropertiesUtil.propertiesShiro.getKeyList();\n        Map<String, String> map = new LinkedHashMap<>();\n        for (Object object : list) {\n            String key = object.toString();\n            String value = PropertiesUtil.getShiroValue(key);\n            log.info(\"读取防止盗链控制：---key{},---value:{}\",key,value);\n            map.put(key, value);\n        }\n        return map;\n    }\n\n    /**\n     * @Description Shiro过滤器\n     */\n    @Bean(\"shiroFilter\")\n    public ShiroFilterFactoryBean shiroFilterFactoryBean(){\n        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();\n        shiroFilter.setSecurityManager(defaultWebSecurityManager());\n        shiroFilter.setFilterChainDefinitionMap(filterChainDefinition());\n        shiroFilter.setLoginUrl(\"/login\");\n        shiroFilter.setUnauthorizedUrl(\"/login\");\n        return shiroFilter;\n    }\n\n}\n\n```\n\n### 6、Shiro过滤器、过滤器链\n\n#### 【1】过滤器\n\nShiro内置了很多默认的过滤器，比如身份验证、授权等相关的。默认过滤器可以参考org.apache.shiro.web.filter.mgt.DefaultFilter中的枚举过滤器\n\n![1580542509773](image/1580542509773.png)\n\n#### 【2】过滤器链\n\n定义：authentication.properties\n\n```properties\n#静态资源不过滤\n/static/**=anon\n#登录链接不过滤\n/login/**=anon\n#其他链接是需要登录的\n/**=authc\n```\n\n注意：这里定义的过滤器是有执行顺序的，从上向下执行\n\n#### 【3】加载原理分析\n\n定义：PropertiesUtil，从classpath中加载authentication.properties\n\n```java\npackage com.itheima.shiro.properties;\n\nimport com.itheima.shiro.utils.EmptyUtil;\nimport lombok.extern.log4j.Log4j2;\n\n/**\n * @Description 读取Properties的工具类\n */\n@Log4j2\npublic class PropertiesUtil {\n\n    public static LinkProperties propertiesShiro = new LinkProperties();\n\n    /**\n     * 读取properties配置文件信息\n     */\n    static {\n        String sysName = System.getProperty(\"sys.name\");\n        if (EmptyUtil.isNullOrEmpty(sysName)) {\n            sysName = \"application.properties\";\n        } else {\n            sysName += \".properties\";\n        }\n        try {\n            propertiesShiro.load(PropertiesUtil.class.getClassLoader()\n                    .getResourceAsStream(\"authentication.properties\"));\n        } catch (Exception e) {\n            log.warn(\"资源路径中不存在authentication.properties权限文件，忽略读取！\");\n        }\n    }\n\n    /**\n     * 根据key得到value的值\n     */\n    public static String getShiroValue(String key) {\n        return propertiesShiro.getProperty(key);\n    }\n\n}\n\n```\n\n定义LinkProperties，这个类保证了Properties类的有序\n\n```java\npackage com.itheima.shiro.properties;\n\nimport java.io.*;\nimport java.util.ArrayList;\nimport java.util.Enumeration;\nimport java.util.List;\nimport java.util.Properties;\n\n\n/**\n * @Description 有序Properties类\n */\n\npublic class LinkProperties extends Properties{\n\n	/** serialVersionUID */\n	private static final long serialVersionUID = 7573016303908223266L;\n	\n	private List<Object> keyList = new ArrayList<Object>();  \n    \n    /** \n     * 默认构造方法 \n     */  \n    public LinkProperties() {  \n          \n    }  \n      \n    /** \n     * 从指定路径加载信息到Properties \n     * @param path \n     */  \n    public LinkProperties(String path) {  \n        try {  \n            InputStream is = new FileInputStream(path);  \n            this.load(is);  \n        } catch (FileNotFoundException e) {  \n            e.printStackTrace();  \n            throw new RuntimeException(\"指定文件不存在！\");  \n        } catch (IOException e) {  \n            e.printStackTrace();  \n        }  \n    }  \n      \n    /** \n     * 重写put方法，按照property的存入顺序保存key到keyList，遇到重复的后者将覆盖前者。 \n     */  \n    @Override  \n    public synchronized Object put(Object key, Object value) {  \n        this.removeKeyIfExists(key);  \n        keyList.add(key);  \n        return super.put(key, value);  \n    }  \n      \n  \n    /** \n     * 重写remove方法，删除属性时清除keyList中对应的key。 \n     */  \n    @Override  \n    public synchronized Object remove(Object key) {  \n        this.removeKeyIfExists(key);  \n        return super.remove(key);  \n    }  \n      \n    /** \n     * keyList中存在指定的key时则将其删除 \n     */  \n    private void removeKeyIfExists(Object key) {  \n        keyList.remove(key);  \n    }  \n      \n    /** \n     * 获取Properties中key的有序集合 \n     * @return \n     */  \n    public List<Object> getKeyList() {  \n        return keyList;  \n    }  \n      \n    /** \n     * 保存Properties到指定文件，默认使用UTF-8编码 \n     * @param path 指定文件路径 \n     */  \n    public void store(String path) {  \n        this.store(path, \"UTF-8\");  \n    }  \n      \n    /** \n     * 保存Properties到指定文件，并指定对应存放编码 \n     * @param path 指定路径 \n     * @param charset 文件编码 \n     */  \n    public void store(String path, String charset) {  \n        if (path != null && !\"\".equals(path)) {  \n            try {  \n                OutputStream os = new FileOutputStream(path);  \n                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(os, charset));  \n                this.store(bw, null);  \n                bw.close();  \n            } catch (FileNotFoundException e) {  \n                e.printStackTrace();  \n            } catch (IOException e) {  \n                e.printStackTrace();  \n            }  \n        } else {  \n            throw new RuntimeException(\"存储路径不能为空!\");  \n        }  \n    }  \n  \n    /** \n     * 重写keys方法，返回根据keyList适配的Enumeration，且保持HashTable keys()方法的原有语义， \n     * 每次都调用返回一个新的Enumeration对象，且和之前的不产生冲突 \n     */  \n    @Override  \n    public synchronized Enumeration<Object> keys() {  \n        return new EnumerationAdapter<Object>(keyList);  \n    }  \n      \n    /** \n     * List到Enumeration的适配器 \n     */  \n    private class EnumerationAdapter<T> implements Enumeration<T> {  \n        private int index = 0;  \n        private final List<T> list;  \n        private final boolean isEmpty;  \n          \n        public EnumerationAdapter(List<T> list) {  \n            this.list = list;  \n            this.isEmpty = list.isEmpty();  \n        }  \n          \n        public boolean hasMoreElements() {  \n            //isEmpty的引入是为了更贴近HashTable原有的语义，在HashTable中添加元素前调用其keys()方法获得一个Enumeration的引用，  \n            //之后往HashTable中添加数据后，调用之前获取到的Enumeration的hasMoreElements()将返回false，但如果此时重新获取一个  \n            //Enumeration的引用，则新Enumeration的hasMoreElements()将返回true，而且之后对HashTable数据的增、删、改都是可以在  \n            //nextElement中获取到的。  \n            return !isEmpty && index < list.size();  \n        }  \n  \n        public T nextElement() {  \n            if (this.hasMoreElements()) {  \n                return list.get(index++);  \n            }  \n            return null;  \n        }  \n          \n    }  \n}\n\n```\n\n查看shirocConfig\n\n![1581078295529](image\\1581078295529.png)\n\n加载完整之后交于ShiroFilterFactoryBean使用setFilterChainDefinitionMap使得过滤生效\n\n#### 【4】自定义过滤器\n\n上面我们使用了shiro的默认过滤器，但是由于业务需求，咱们可能要定义自己的过滤器，那么咱们定义呢？\n\n这里我们先查看RolesAuthorizationFilter\n\n![1581071730065](image\\1581071730065.png)\n\n分析：改源码表示，例如：/admin/order= roles[\"admin, root\"] ，只有当放问该接口同时具备admin和root两种角色时，才可以被访问。\n\n#### 【5】自定义过滤器使用\n\n##### 【5.1】需求\n\n```\n1、实现只要有其中一个角色，则可访问对应路径\n```\n\n##### 【5.2】RolesOrAuthorizationFilter\n\n新建filter层，新建类RolesOrAuthorizationFilter\n\n```java\npackage com.itheima.shiro.filter;\n\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.web.filter.authz.AuthorizationFilter;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\nimport java.util.Set;\n\n/**\n * @Description：角色或关系\n */\npublic class RolesOrAuthorizationFilter extends AuthorizationFilter {\n\n    //TODO - complete JavaDoc\n\n    @SuppressWarnings({\"unchecked\"})\n    public boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws IOException {\n\n        Subject subject = getSubject(request, response);\n        String[] rolesArray = (String[]) mappedValue;\n\n        if (rolesArray == null || rolesArray.length == 0) {\n            //no roles specified, so nothing to check - allow access.\n            return true;\n        }\n\n        Set<String> roles = CollectionUtils.asSet(rolesArray);\n        //循环roles判断只要有角色则返回true\n        for (String role : roles) {\n            if(subject.hasRole(role)){\n                return true;\n            }\n        }\n        return false;\n    }\n\n}\n\n```\n\n##### 【5.3】编辑ShiroConfig\n\n在ShiroConfig类中添加如下内容\n\n```java\n/**\n     * @Description 自定义过滤器定义\n     */\n    private Map<String, Filter> filters() {\n        Map<String, Filter> map = new HashMap<String, Filter>();\n        map.put(\"role-or\", new RolesOrAuthorizationFilter());\n        return map;\n    }\n\n    /**\n     * @Description Shiro过滤器\n     */\n    @Bean(\"shiroFilter\")\n    public ShiroFilterFactoryBean shiroFilterFactoryBean(){\n        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();\n        shiroFilter.setSecurityManager(defaultWebSecurityManager());\n        //使自定义过滤器生效\n        shiroFilter.setFilters(filters());\n        shiroFilter.setFilterChainDefinitionMap(filterChainDefinition());\n        shiroFilter.setLoginUrl(\"/login\");\n        shiroFilter.setUnauthorizedUrl(\"/login\");\n        return shiroFilter;\n    }\n```\n\n【2.2.3】编辑authentication.properties\n\n```ini\n#静态资源不过滤\n/static/**=anon\n#登录链接不过滤\n/login/**=anon\n#访问/resource/**需要有admin的角色\n/resource/**=role-or[admin]\n#其他链接是需要登录的\n/**=authc\n```\n\n### 7、注解方式鉴权\n\n#### 【1】注解介绍\n\n以下为常用注解\n\n| 注解                    | 说明                               |\n| ----------------------- | ---------------------------------- |\n| @RequiresAuthentication | 表明当前用户需是经过认证的用户     |\n| @ RequiresGuest         | 表明该用户需为”guest”用户          |\n| @RequiresPermissions    | 当前用户需拥有指定权限             |\n| @RequiresRoles          | 当前用户需拥有指定角色             |\n| @ RequiresUser          | 当前用户需为已认证用户或已记住用户 |\n\n例如RoleAction类中我们添加\n\n```java\n/**\n	 *@Description: 跳转到角色的初始化页面\n	 */\n	@RequiresRoles(value ={\"SuperAdmin\",\"dev\"},logical = Logical.OR)\n	@RequestMapping(value = \"listInitialize\")\n	public ModelAndView listInitialize(){\n		return  new ModelAndView(\"/role/role-listInitialize\");\n	}\n```\n\n#### 【2】注解原理分析\n\n#### 【2.1】装载过程\n\n#### 【2.2】调用过程\n\n## 第六章 Realm缓存机制\n\n### 1、Realm缓存机制意义\n\n在上面我们自定了自己的realm，但是我们发现\n\n![1581758782223](image\\1581758782223.png)\n\n在认证和授权的时候，程序需要频繁的访问数据库，这样对于数据库的压力可想而知，那我们怎么处理呢？\n\n### 2、Realm缓存机制实现思路\n\n#### 【1】缓存机制图解\n\n![1584067476241](image\\1584067476241.png)\n\n#### 【2】原理分析\n\n此时我们对UserBridgeServiceImpl的实现类里面的逻辑加入了自定义的SimpleCacheService缓存服务接口，简单来说实现了在认证和鉴权时不需要每次都去查询数据库，而是把认证和鉴权信息放入到redis缓存中，以减低数据库的访问压力\n\n```properties\n1、集成redis服务器，作为集中存储认证和鉴权信息\n2、改写UserBridgeServiceImpl使其优先从缓存中读取\n```\n\n\n\n### 3、redission集成\n\n#### 【1】添加ShiroRedisProperties\n\n此类主要负责yaml文件的配置类\n\n```java\npackage com.itheima.shiro.config;\n\nimport lombok.Data;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\nimport java.io.Serializable;\n\n/**\n * @Description  redis配置文件\n */\n@Data\n@ConfigurationProperties(prefix = \"itheima.framework.shiro.redis\")\npublic class ShiroRedisProperties implements Serializable {\n\n	/**\n	 * redis连接地址\n	 */\n	private String nodes ;\n\n	/**\n	 * 获取连接超时时间\n	 */\n	private int connectTimeout ;\n\n	/**\n	 * 连接池大小\n	 */\n	private int connectPoolSize;\n\n	/**\n	 * 初始化连接数\n	 */\n	private int connectionMinimumidleSize ;\n\n	/**\n	 * 等待数据返回超时时间\n	 */\n	private int timeout ;\n\n	/**\n	 *  全局超时时间\n	 */\n	private long globalSessionTimeout;\n\n}\n\n```\n\n#### 【2】编辑ShiroConfig\n\n集成redisson的相关配置，同时启用ShiroRedisProperties的配置\n\n```java\npackage com.itheima.shiro.config;\n\n\nimport com.itheima.shiro.core.ShiroDbRealm;\nimport com.itheima.shiro.core.impl.ShiroDbRealmImpl;\nimport com.itheima.shiro.filter.RolesOrAuthorizationFilter;\nimport com.itheima.shiro.properties.PropertiesUtil;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.shiro.spring.LifecycleBeanPostProcessor;\nimport org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.apache.shiro.web.servlet.SimpleCookie;\nimport org.apache.shiro.web.session.mgt.DefaultWebSessionManager;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.DependsOn;\n\nimport javax.servlet.Filter;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @Description 权限配置类\n */\n@Configuration\n@ComponentScan(basePackages = \"com.itheima.shiro.core\")\n@EnableConfigurationProperties({ShiroRedisProperties.class})\n@Log4j2\npublic class ShiroConfig {\n\n    @Autowired\n    private ShiroRedisProperties shiroRedisProperties;\n\n    /**\n     * @Description redission客户端\n     */\n    @Bean(\"redissonClientForShiro\")\n    public RedissonClient redissonClient() {\n        log.info(\"=====初始化redissonClientForShiro开始======\");\n        String[] nodeList = shiroRedisProperties.getNodes().split(\",\");\n        Config config = new Config();\n        if (nodeList.length == 1) {\n            config.useSingleServer().setAddress(nodeList[0])\n                    .setConnectTimeout(shiroRedisProperties.getConnectTimeout())\n                    .setConnectionMinimumIdleSize(shiroRedisProperties.getConnectionMinimumidleSize())\n                    .setConnectionPoolSize(shiroRedisProperties.getConnectPoolSize()).setTimeout(shiroRedisProperties.getTimeout());\n        } else {\n            config.useClusterServers().addNodeAddress(nodeList)\n                    .setConnectTimeout(shiroRedisProperties.getConnectTimeout())\n                    .setMasterConnectionMinimumIdleSize(shiroRedisProperties.getConnectionMinimumidleSize())\n                    .setMasterConnectionPoolSize(shiroRedisProperties.getConnectPoolSize()).setTimeout(shiroRedisProperties.getTimeout());\n        }\n        RedissonClient redissonClient =  Redisson.create(config);\n        log.info(\"=====初始化redissonClientForShiro完成======\");\n        return redissonClient;\n    }\n\n    /**\n     * @Description 创建cookie对象\n     */\n    @Bean(name=\"sessionIdCookie\")\n    public SimpleCookie simpleCookie(){\n        SimpleCookie simpleCookie = new SimpleCookie();\n        simpleCookie.setName(\"ShiroSession\");\n        return simpleCookie;\n    }\n\n    /**\n     * @Description 权限管理器\n     * @param\n     * @return\n     */\n    @Bean(name=\"securityManager\")\n    public DefaultWebSecurityManager defaultWebSecurityManager(){\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n        securityManager.setRealm(shiroDbRealm());\n        securityManager.setSessionManager(shiroSessionManager());\n        return securityManager;\n    }\n\n    /**\n     * @Description 自定义RealmImpl\n     */\n    @Bean(name=\"shiroDbRealm\")\n    public ShiroDbRealm shiroDbRealm(){\n        return new ShiroDbRealmImpl();\n    }\n\n\n    /**\n     * @Description 会话管理器\n     */\n    @Bean(name=\"sessionManager\")\n    public DefaultWebSessionManager shiroSessionManager(){\n        DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();\n        sessionManager.setSessionValidationSchedulerEnabled(false);\n        sessionManager.setSessionIdCookieEnabled(true);\n        sessionManager.setSessionIdCookie(simpleCookie());\n        sessionManager.setGlobalSessionTimeout(3600000);\n        return sessionManager;\n    }\n\n    /**\n     * @Description 保证实现了Shiro内部lifecycle函数的bean执行\n     */\n    @Bean(name = \"lifecycleBeanPostProcessor\")\n    public static LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() {\n        return new LifecycleBeanPostProcessor();\n    }\n\n    /**\n     * @Description AOP式方法级权限检查\n     */\n    @Bean\n    @DependsOn(\"lifecycleBeanPostProcessor\")\n    public DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() {\n        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();\n        defaultAdvisorAutoProxyCreator.setProxyTargetClass(true);\n        return defaultAdvisorAutoProxyCreator;\n    }\n\n    /**\n     * @Description 配合DefaultAdvisorAutoProxyCreator事项注解权限校验\n     */\n    @Bean\n    public AuthorizationAttributeSourceAdvisor getAuthorizationAttributeSourceAdvisor() {\n        AuthorizationAttributeSourceAdvisor aasa = new AuthorizationAttributeSourceAdvisor();\n        aasa.setSecurityManager(defaultWebSecurityManager());\n        return new AuthorizationAttributeSourceAdvisor();\n    }\n\n    /**\n     * @Description 过滤器链\n     */\n    private Map<String, String> filterChainDefinition(){\n        List<Object> list  = PropertiesUtil.propertiesShiro.getKeyList();\n        Map<String, String> map = new LinkedHashMap<>();\n        for (Object object : list) {\n            String key = object.toString();\n            String value = PropertiesUtil.getShiroValue(key);\n            log.info(\"读取防止盗链控制：---key{},---value:{}\",key,value);\n            map.put(key, value);\n        }\n        return map;\n    }\n\n    /**\n     * @Description 自定义过滤器定义\n     */\n    private Map<String, Filter> filters() {\n        Map<String, Filter> map = new HashMap<String, Filter>();\n        map.put(\"roleOr\", new RolesOrAuthorizationFilter());\n        return map;\n    }\n\n    /**\n     * @Description Shiro过滤器\n     */\n    @Bean(\"shiroFilter\")\n    public ShiroFilterFactoryBean shiroFilterFactoryBean(){\n        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();\n        shiroFilter.setSecurityManager(defaultWebSecurityManager());\n        //使自定义过滤器生效\n        shiroFilter.setFilters(filters());\n        shiroFilter.setFilterChainDefinitionMap(filterChainDefinition());\n        shiroFilter.setLoginUrl(\"/login\");\n        shiroFilter.setUnauthorizedUrl(\"/login\");\n        return shiroFilter;\n    }\n\n}\n\n```\n\n\n\n### 4、缓存对象SimpleMapCache\n\n```java\n\npackage com.itheima.shiro.core.base;\n\nimport com.itheima.shiro.utils.EmptyUtil;\nimport org.apache.shiro.cache.Cache;\nimport org.apache.shiro.cache.CacheException;\n\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.Set;\n\n\n/**\n * @Description 缓存实现类, 实现序列 接口方便对象存储于第三方容器(Map存放键值对)\n */\npublic class SimpleMapCache implements Cache<Object, Object>, Serializable {\n\n    private final Map<Object, Object> attributes;\n\n    private final String name;\n\n    public SimpleMapCache(String name, Map<Object, Object> backingMap) {\n        if (name == null)\n            throw new IllegalArgumentException(\"Cache name cannot be null.\");\n        if (backingMap == null) {\n            throw new IllegalArgumentException(\"Backing map cannot be null.\");\n        } else {\n            this.name = name;\n            attributes = backingMap;\n        }\n    }\n\n    public Object get(Object key) throws CacheException {\n        return attributes.get(key);\n    }\n\n    public Object put(Object key, Object value) throws CacheException {\n        return attributes.put(key, value);\n    }\n\n    public Object remove(Object key) throws CacheException {\n        return attributes.remove(key);\n    }\n\n    public void clear() throws CacheException {\n        attributes.clear();\n    }\n\n    public int size() {\n        return attributes.size();\n    }\n\n    public Set<Object> keys() {\n        Set<Object> keys = attributes.keySet();\n        if (!keys.isEmpty())\n            return Collections.unmodifiableSet(keys);\n        else\n            return Collections.emptySet();\n    }\n\n    public Collection<Object> values() {\n        Collection<Object> values = attributes.values();\n        if (!EmptyUtil.isNullOrEmpty(values))\n            return Collections.unmodifiableCollection(values);\n        else\n            return Collections.emptySet();\n    }\n\n    @Override\n    public String toString() {\n        return \"SimpleMapCache [attributes=\" + attributes + \", name=\" + name\n                + \", keys()=\" + keys() + \", size()=\" + size() + \", values()=\"\n                + values() + \"]\";\n    }\n}\n\n```\n\n\n\n### 5、ShiroRedissionSerialize序列化工具\n\n```java\npackage com.itheima.shiro.utils;\n\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.shiro.codec.Base64;\n\nimport java.io.*;\n\n/**\n * @Description：实现shiro会话的序列化存储\n */\n@Log4j2\npublic class ShiroRedissionSerialize {\n\n    public static Object deserialize(String str) {\n        if (EmptyUtil.isNullOrEmpty(str)) {\n            return null;\n        }\n        ByteArrayInputStream bis = null;\n        ObjectInputStream ois = null;\n        Object object=null;\n        try {\n            bis = new ByteArrayInputStream(EncodesUtil.decodeBase64(str));\n            ois = new ObjectInputStream(bis);\n            object = ois.readObject();\n        } catch (IOException |ClassNotFoundException e) {\n            log.error(\"流读取异常：{}\",e);\n        } finally {\n            try {\n                bis.close();\n                ois.close();\n            } catch (IOException e) {\n                log.error(\"流读取异常：{}\",e);\n            }\n        }\n        return object;\n    }\n\n    public static String serialize(Object obj) {\n\n        if (EmptyUtil.isNullOrEmpty(obj)) {\n            return null;\n        }\n        ByteArrayOutputStream bos = null;\n        ObjectOutputStream oos = null;\n        String base64String = null;\n        try {\n            bos = new ByteArrayOutputStream();\n            oos = new ObjectOutputStream(bos);\n            oos.writeObject(obj);\n            base64String = EncodesUtil.encodeBase64(bos.toByteArray());\n        } catch (IOException e) {\n            log.error(\"流写入异常：{}\",e);\n        } finally {\n            try {\n                bos.close();\n                oos.close();\n            } catch (IOException e) {\n                log.error(\"流写入异常：{}\",e);\n            }\n        }\n        return base64String;\n    }\n}\n\n```\n\n### 6、缓存服务接口SimpleCacheService\n\nSimpleCacheService\n\n```java\n\npackage com.itheima.shiro.core;\n\nimport org.apache.shiro.cache.Cache;\nimport org.apache.shiro.cache.CacheException;\n\n/**\n * @Description 简单的缓存管理接口\n */\npublic interface SimpleCacheService {\n\n    /**\n     * <b>功能说明：</b>：新增缓存堆到管理器<br>\n     */\n     void createCache(String cacheName, Cache<Object, Object> cache) throws CacheException;\n\n    /**\n     * <b>方法名：</b>：getCache<br>\n     * <b>功能说明：</b>：获取缓存堆<br>\n     */\n     Cache<Object, Object> getCache(String cacheName) throws CacheException;\n\n    /**\n     * <b>方法名：</b>：removeCache<br>\n     * <b>功能说明：</b>：移除缓存堆<br>\n     */\n     void removeCache(String cacheName) throws CacheException;\n\n    /**\n     * <b>方法名：</b>：updateCahce<br>\n     * <b>功能说明：</b>：更新缓存堆<br>\n     */\n     void updateCahce(String cacheName, Cache<Object, Object> cache) throws CacheException;\n}\n\n```\n\nSimpleCacheServiceImpl\n\n调用RedissonClient去实现缓存，同时使用ShiroRedissionSerialize实现序列化\n\n```java\n\npackage com.itheima.shiro.core.impl;\n\nimport com.itheima.shiro.constant.CacheConstant;\nimport com.itheima.shiro.core.SimpleCacheService;\nimport com.itheima.shiro.utils.ShiroRedissionSerialize;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.cache.Cache;\nimport org.apache.shiro.cache.CacheException;\nimport org.redisson.api.RBucket;\nimport org.redisson.api.RedissonClient;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.Resource;\nimport java.util.concurrent.TimeUnit;\n\n\n/**\n *\n * @Description 简单的缓存管理接口的实现\n */\n@Log4j2\n@Component\npublic class SimpleCacheServiceImpl implements SimpleCacheService {\n\n	@Resource(name = \"redissonClientForShiro\")\n	RedissonClient redissonClient;\n\n	@Override\n	public void createCache(String name, Cache<Object, Object> cache){\n		RBucket<String> bucket =  redissonClient.getBucket(CacheConstant.GROUP_CAS+name);\n		bucket.trySet(ShiroRedissionSerialize.serialize(cache), SecurityUtils.getSubject().getSession().getTimeout()/1000, TimeUnit.SECONDS);\n	}\n\n	@SuppressWarnings(\"unchecked\")\n	@Override\n	public Cache<Object, Object> getCache(String name) throws CacheException {\n		RBucket<String> bucket =  redissonClient.getBucket(CacheConstant.GROUP_CAS+name);\n		return (Cache<Object, Object>) ShiroRedissionSerialize.deserialize(bucket.get());\n	}\n\n	@Override\n	public void removeCache(String name) throws CacheException {\n		RBucket<String> bucket =  redissonClient.getBucket(CacheConstant.GROUP_CAS+name);\n		bucket.delete();\n	}\n\n	@Override\n	public void updateCahce(String name, Cache<Object, Object> cache){\n		RBucket<String> bucket =  redissonClient.getBucket(CacheConstant.GROUP_CAS+name);\n		bucket.set(ShiroRedissionSerialize.serialize(cache), SecurityUtils.getSubject().getSession().getTimeout()/1000, TimeUnit.MILLISECONDS);\n	}\n\n\n}\n\n```\n\n### 7、桥接器BridgeService\n\n```java\npackage com.itheima.shiro.core.bridge;\n\nimport com.itheima.shiro.core.base.ShiroUser;\nimport com.itheima.shiro.pojo.User;\nimport org.apache.shiro.authz.AuthorizationInfo;\n\nimport java.util.List;\n\n/**\n * @Description：用户信息桥接（后期会做缓存）\n */\npublic interface UserBridgeService {\n\n\n    /**\n     * @Description 查找用户信息\n     * @param loginName 用户名称\n     * @return user对象\n     */\n    User findUserByLoginName(String loginName);\n\n    /**\n     * @Description 鉴权方法\n     * @param shiroUser 令牌对象\n     * @return 鉴权信息\n     */\n    AuthorizationInfo getAuthorizationInfo(ShiroUser shiroUser);\n\n    /**\n     * @Description 查询用户对应角色标识list\n     * @param userId 用户id\n     * @return 角色标识集合\n     */\n    List<String> findRoleList(String key,String userId);\n\n    /**\n     * @Description 查询用户对应资源标识list\n     * @param userId 用户id\n     * @return 资源标识集合\n     */\n    List<String> findResourcesList(String key,String userId);\n\n    /**\n     * @Description 查询资源ids\n     * @param userId 用户id\n     * @return 资源id集合\n     */\n    List<String> findResourcesIds(String userId);\n\n    /**\n     * @Description 加载缓存\n     * @param shiroUser 令牌对象\n     * @return\n     */\n    void loadUserAuthorityToCache(ShiroUser shiroUser);\n}\n\n```\n\n此时我们就可以修改UserBridgeServiceImpl实现缓存了\n\n```java\npackage com.itheima.shiro.core.bridge.impl;\n\nimport com.itheima.shiro.constant.CacheConstant;\nimport com.itheima.shiro.core.SimpleCacheService;\nimport com.itheima.shiro.core.adapter.UserAdapter;\nimport com.itheima.shiro.core.base.ShiroUser;\nimport com.itheima.shiro.core.base.SimpleMapCache;\nimport com.itheima.shiro.core.bridge.UserBridgeService;\nimport com.itheima.shiro.pojo.Resource;\nimport com.itheima.shiro.pojo.Role;\nimport com.itheima.shiro.pojo.User;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport com.itheima.shiro.utils.ShiroUtil;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.cache.Cache;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @Description：用户信息桥接（后期会做缓存）\n */\n@Component(\"userBridgeService\")\npublic class UserBridgeServiceImpl implements UserBridgeService {\n\n    @Autowired\n    UserAdapter userAdapter;\n\n    @Autowired\n    SimpleCacheService simpleCacheService;\n\n    @Override\n    public User findUserByLoginName(String loginName) {\n        String key = CacheConstant.FIND_USER_BY_LOGINNAME + loginName;\n        //获取缓存\n        Cache<Object, Object> cache = simpleCacheService.getCache(key);\n        //缓存存在\n        if (!EmptyUtil.isNullOrEmpty(cache)){\n            return (User) cache.get(key);\n        }\n        //缓存不存在\n        User user = userAdapter.findUserByLoginName(loginName);\n        if (!EmptyUtil.isNullOrEmpty(user)){\n            Map<Object,Object> map = new HashMap<>();\n            map.put(key, user);\n            SimpleMapCache simpleMapCache = new SimpleMapCache(key, map);\n            simpleCacheService.creatCache(key, simpleMapCache);\n        }\n        return user;\n    }\n\n    @Override\n    public List<String> findResourcesIds(String userId) {\n        String sessionId = ShiroUtil.getShiroSessionId();\n        String key = CacheConstant.RESOURCES_KEY_IDS+sessionId;\n        List<Resource> resources = new ArrayList<>();\n        //获取缓存\n        Cache<Object, Object> cache = simpleCacheService.getCache(key);\n        //缓存存在\n        if (!EmptyUtil.isNullOrEmpty(cache)){\n            resources = (List<Resource>) cache.get(key);\n        }else {\n        //缓存不存在\n            resources = userAdapter.findResourceByUserId(userId);\n            if (!EmptyUtil.isNullOrEmpty(resources)){\n                Map<Object,Object> map = new HashMap<>();\n                map.put(key, resources);\n                SimpleMapCache simpleMapCache = new SimpleMapCache(key, map);\n                simpleCacheService.creatCache(key,simpleMapCache );\n            }\n\n        }\n\n        List<String> ids = new ArrayList<>();\n        for (Resource resource : resources) {\n            ids.add(resource.getId());\n        }\n        return ids;\n    }\n\n    @Override\n    public AuthorizationInfo getAuthorizationInfo(ShiroUser shiroUser) {\n        String sessionId = ShiroUtil.getShiroSessionId();\n        String roleKey = CacheConstant.ROLE_KEY+sessionId;\n        String resourcesKey = CacheConstant.RESOURCES_KEY+sessionId;\n        //查询用户对应的角色标识\n        List<String> roleList = this.findRoleList(roleKey,shiroUser.getId());\n        //查询用户对于的资源标识\n        List<String> resourcesList = this.findResourcesList(resourcesKey,shiroUser.getId());\n        //构建鉴权信息对象\n        SimpleAuthorizationInfo simpleAuthorizationInfo = new SimpleAuthorizationInfo();\n        simpleAuthorizationInfo.addRoles(roleList);\n        simpleAuthorizationInfo.addStringPermissions(resourcesList);\n        return simpleAuthorizationInfo;\n    }\n\n    @Override\n    public List<String> findRoleList(String key,String userId){\n        List<Role> roles = new ArrayList<>();\n        //获得缓存\n        Cache<Object, Object> cache = simpleCacheService.getCache(key);\n        //缓存存在\n        if (!EmptyUtil.isNullOrEmpty(cache)){\n            roles = (List<Role>) cache.get(key);\n        }else {\n        //缓存不存在\n            roles = userAdapter.findRoleByUserId(userId);\n            if (!EmptyUtil.isNullOrEmpty(roles)){\n                Map<Object,Object> map = new HashMap<>();\n                map.put(key, roles);\n                SimpleMapCache simpleMapCache = new SimpleMapCache(key, map);\n                simpleCacheService.creatCache(key,simpleMapCache );\n            }\n        }\n\n        List<String> roleLabel = new ArrayList<>();\n        for (Role role : roles) {\n            roleLabel.add(role.getLabel());\n        }\n        return roleLabel;\n    }\n\n    @Override\n    public List<String> findResourcesList(String key,String userId){\n        List<Resource> resources = new ArrayList<>();\n        //获得缓存\n        Cache<Object, Object> cache = simpleCacheService.getCache(key);\n        //缓存存在\n        if (!EmptyUtil.isNullOrEmpty(cache)){\n            resources = (List<Resource>) cache.get(key);\n        }else {\n            //缓存不存在\n            resources = userAdapter.findResourceByUserId(userId);\n            if (!EmptyUtil.isNullOrEmpty(resources)){\n                Map<Object,Object> map = new HashMap<>();\n                map.put(key, resources);\n                SimpleMapCache simpleMapCache = new SimpleMapCache(key, map);\n                simpleCacheService.creatCache(key,simpleMapCache );\n            }\n        }\n        List<String> resourceLabel = new ArrayList<>();\n        for (Resource resource : resources) {\n            resourceLabel.add(resource.getLabel());\n        }\n        return resourceLabel;\n    }\n\n\n\n\n    @Override\n    public void loadUserAuthorityToCache(ShiroUser shiroUser) {\n        String sessionId = ShiroUtil.getShiroSessionId();\n        String roleKey = CacheConstant.ROLE_KEY+sessionId;\n        String resourcesKey = CacheConstant.RESOURCES_KEY+sessionId;\n        //查询用户对应的角色标识\n        List<String> roleList = this.findRoleList(roleKey,shiroUser.getId());\n        //查询用户对于的资源标识\n        List<String> resourcesList = this.findResourcesList(resourcesKey,shiroUser.getId());\n    }\n}\n\n```\n\n### 8、测试\n\n使用debug模式启动项目，使用admin/pass登录系统，访问资源，进入debug模式\n\n第一次访问走数据库\n\n![1581845508601](image\\1581845508601.png)\n\n第二次走缓存\n\n![1581845570053](image\\1581845570053.png)\n\n### 9、缓存的清理\n\n我们实现的realm的集中式缓存，那么还有什么问题没有解决呢？\n\n![1584603830411](image/1584603830411.png)\n\n用户在点击退出时候，我们还没有清理缓存！如果不清理，在用户量大的时候，可能会有大量的垃圾信息在redis中存在。\n\n重写ShiroConfig\n\n```java\npackage com.itheima.shiro.core.impl;\n\nimport com.itheima.shiro.constant.CacheConstant;\nimport com.itheima.shiro.constant.SuperConstant;\nimport com.itheima.shiro.core.ShiroDbRealm;\nimport com.itheima.shiro.core.SimpleCacheService;\nimport com.itheima.shiro.core.base.ShiroUser;\nimport com.itheima.shiro.core.base.SimpleToken;\nimport com.itheima.shiro.core.bridge.UserBridgeService;\nimport com.itheima.shiro.pojo.User;\nimport com.itheima.shiro.utils.BeanConv;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport com.itheima.shiro.utils.ShiroUtil;\nimport org.apache.shiro.authc.*;\nimport org.apache.shiro.authc.credential.HashedCredentialsMatcher;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.util.ByteSource;\nimport org.springframework.beans.factory.annotation.Autowired;\n\n/**\n * @Description：自定义realm的抽象类实现\n */\npublic class ShiroDbRealmImpl extends ShiroDbRealm {\n\n    @Autowired\n    UserBridgeService userBridgeService;\n\n    @Autowired\n    SimpleCacheService simpleCacheService;\n\n    @Override\n    public AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n        //token令牌信息\n        SimpleToken simpleToken = (SimpleToken) token;\n        //查询user对象\n        User user = userBridgeService.findUserByLoginName(simpleToken.getUsername());\n        if (EmptyUtil.isNullOrEmpty(user)){\n            throw new UnknownAccountException(\"账号不存在！\");\n        }\n        //构建认证令牌对象\n        ShiroUser shiroUser = BeanConv.toBean(user, ShiroUser.class);\n        shiroUser.setResourceIds(userBridgeService.findResourcesIds(shiroUser.getId()));\n        String slat  = shiroUser.getSalt();\n        String password = shiroUser.getPassWord();\n        //构建认证信息对象:1、令牌对象 2、密文密码  3、加密因子 4、当前realm的名称\n        return new SimpleAuthenticationInfo(shiroUser, password, ByteSource.Util.bytes(slat), getName());\n    }\n\n    @Override\n    public AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        ShiroUser shiroUser = (ShiroUser) principals.getPrimaryPrincipal();\n        return userBridgeService.getAuthorizationInfo(shiroUser);\n    }\n\n    @Override\n    protected void doClearCache(PrincipalCollection principals) {\n        ShiroUser shiroUser = (ShiroUser) principals.getPrimaryPrincipal();\n        String sessionId = ShiroUtil.getShiroSessionId();\n        String roleKey = CacheConstant.ROLE_KEY+sessionId;\n        String resourcesKey = CacheConstant.RESOURCES_KEY+sessionId;\n        String loginNamekey = CacheConstant.FIND_USER_BY_LOGINNAME + shiroUser.getLoginName();\n        String resourcesIdKey = CacheConstant.RESOURCES_KEY_IDS+sessionId;\n        simpleCacheService.removeCache(roleKey);\n        simpleCacheService.removeCache(resourcesKey);\n        simpleCacheService.removeCache(loginNamekey);\n        simpleCacheService.removeCache(resourcesIdKey);\n        super.doClearCache(principals);\n    }\n\n    @Override\n    public void initCredentialsMatcher() {\n        //指定密码算法\n        HashedCredentialsMatcher hashedCredentialsMatcher = new HashedCredentialsMatcher(SuperConstant.HASH_ALGORITHM);\n        //指定迭代次数\n        hashedCredentialsMatcher.setHashIterations(SuperConstant.HASH_INTERATIONS);\n        //生效密码比较器\n        setCredentialsMatcher(hashedCredentialsMatcher);\n    }\n}\n\n```\n\n\n\n## 第七章 实现分布式会话SessionManager\n\n### 1、会话的问题\n\n![1581846589128](image\\1581846589128.png)\n\n\n\n### 2、分布式会话实现思路\n\n#### 【1】原理分析\n\n​		所有服务器的session信息都存储到了同一个Redis集群中，即所有的服务都将 Session 的信息存储到 Redis 集群中，无论是对 Session 的注销、更新都会同步到集群中，达到了 Session 共享的目的。\n\n![1581846769926](image\\1581846769926.png)\n\n​		Cookie 保存在客户端浏览器中，而 Session 保存在服务器上。客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上，这就是 Session。客户端浏览器再次访问时只需要从该 Session 中查找该客户的状态就可以了。\n\n​		在实际工作中我们建议使用外部的缓存设备(包括Redis)来共享 Session，避免单个服务器节点挂掉而影响服务，共享数据都会放到外部缓存容器中\n\n#### 【2】设计类图详解\n\n![1584524503148](image\\1584524503148.png)\n\n\n\n### 3、RedisSessionDao\n\nRedisSessionDao继承AbstractSessionDAO，重写了会话的创建、读取、修改等操作，全部缓存与redis中\n\n```java\npackage com.itheima.shiro.core.impl;\n\nimport com.itheima.shiro.constant.CacheConstant;\nimport com.itheima.shiro.utils.ShiroRedissionSerialize;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.session.mgt.eis.AbstractSessionDAO;\nimport org.redisson.api.RBucket;\nimport org.redisson.api.RedissonClient;\n\nimport javax.annotation.Resource;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @Description 实现shiro session的memcached集中式管理~\n */\n@Log4j2\npublic class RedisSessionDao extends AbstractSessionDAO {\n\n	@Resource(name = \"redissonClientForShiro\")\n	RedissonClient redissonClient;\n\n	private Long globalSessionTimeout;\n\n	@Override\n	protected Serializable doCreate(Session session) {\n		Serializable sessionId = generateSessionId(session);\n		assignSessionId(session, sessionId);\n//		log.info(\"=============创建sessionId:{}\",sessionId);\n		RBucket<String> sessionIdRBucket = redissonClient.getBucket(CacheConstant.GROUP_CAS+sessionId.toString());\n		sessionIdRBucket.trySet(ShiroRedissionSerialize.serialize(session), globalSessionTimeout, TimeUnit.SECONDS);\n		return sessionId;\n	}\n\n	@Override\n	protected Session doReadSession(Serializable sessionId) {\n		RBucket<String> sessionIdRBucket = redissonClient.getBucket(CacheConstant.GROUP_CAS+sessionId.toString());\n		Session session = (Session) ShiroRedissionSerialize.deserialize(sessionIdRBucket.get());\n//		log.info(\"=============读取sessionId:{}\",session.getId().toString());\n		return session;\n	}\n\n	@Override\n	public void delete(Session session) {\n//		log.info(\"=============删除sessionId:{}\",session.getId().toString());\n		RBucket<String> sessionIdRBucket = redissonClient.getBucket(CacheConstant.GROUP_CAS+session.getId().toString());\n		sessionIdRBucket.delete();\n	}\n\n	@Override\n	public Collection<Session> getActiveSessions() {\n		return Collections.emptySet();  \n	}\n\n	@Override\n	public void update(Session session) {\n		RBucket<String> sessionIdRBucket = redissonClient.getBucket(CacheConstant.GROUP_CAS+session.getId().toString());\n		sessionIdRBucket.set(ShiroRedissionSerialize.serialize(session), globalSessionTimeout, TimeUnit.SECONDS);\n//		log.info(\"=============修改sessionId:{}\",session.getId().toString());\n	}\n\n	public void setGlobalSessionTimeout(Long globalSessionTimeout) {\n		this.globalSessionTimeout = globalSessionTimeout;\n	}\n}\n\n\n```\n\n\n\n### 4、重写ShiroConfig\n\n```java\npackage com.itheima.shiro.config;\n\n\nimport com.itheima.shiro.core.ShiroDbRealm;\nimport com.itheima.shiro.core.impl.RedisSessionDao;\nimport com.itheima.shiro.core.impl.ShiroCacheManager;\nimport com.itheima.shiro.core.impl.ShiroDbRealmImpl;\nimport com.itheima.shiro.filter.RolesOrAuthorizationFilter;\nimport com.itheima.shiro.properties.PropertiesUtil;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.shiro.session.mgt.eis.SessionDAO;\nimport org.apache.shiro.spring.LifecycleBeanPostProcessor;\nimport org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.apache.shiro.web.servlet.SimpleCookie;\nimport org.apache.shiro.web.session.mgt.DefaultWebSessionManager;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.DependsOn;\n\nimport javax.servlet.Filter;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @Description 权限配置类\n */\n@Configuration\n@ComponentScan(basePackages = \"com.itheima.shiro.core\")\n@EnableConfigurationProperties({ShiroRedisProperties.class})\n@Log4j2\npublic class ShiroConfig {\n\n    @Autowired\n    private ShiroRedisProperties shiroRedisProperties;\n\n    /**\n     * @Description redission客户端\n     */\n    @Bean(\"redissonClientForShiro\")\n    public RedissonClient redissonClient() {\n        log.info(\"=====初始化redissonClientForShiro开始======\");\n        String[] nodeList = shiroRedisProperties.getNodes().split(\",\");\n        Config config = new Config();\n        if (nodeList.length == 1) {\n            config.useSingleServer().setAddress(nodeList[0])\n                    .setConnectTimeout(shiroRedisProperties.getConnectTimeout())\n                    .setConnectionMinimumIdleSize(shiroRedisProperties.getConnectionMinimumidleSize())\n                    .setConnectionPoolSize(shiroRedisProperties.getConnectPoolSize()).setTimeout(shiroRedisProperties.getTimeout());\n        } else {\n            config.useClusterServers().addNodeAddress(nodeList)\n                    .setConnectTimeout(shiroRedisProperties.getConnectTimeout())\n                    .setMasterConnectionMinimumIdleSize(shiroRedisProperties.getConnectionMinimumidleSize())\n                    .setMasterConnectionPoolSize(shiroRedisProperties.getConnectPoolSize()).setTimeout(shiroRedisProperties.getTimeout());\n        }\n        RedissonClient redissonClient =  Redisson.create(config);\n        log.info(\"=====初始化redissonClientForShiro完成======\");\n        return redissonClient;\n    }\n\n    /**\n     * @Description 创建cookie对象\n     */\n    @Bean(name=\"sessionIdCookie\")\n    public SimpleCookie simpleCookie(){\n        SimpleCookie simpleCookie = new SimpleCookie();\n        simpleCookie.setName(\"ShiroSession\");\n        return simpleCookie;\n    }\n    /**\n     * @Description 权限管理器\n     * @param\n     * @return\n     */\n    @Bean(name=\"securityManager\")\n    public DefaultWebSecurityManager defaultWebSecurityManager(){\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n        securityManager.setRealm(shiroDbRealm());\n        securityManager.setSessionManager(shiroSessionManager());\n        return securityManager;\n    }\n\n    /**\n     * @Description 自定义RealmImpl\n     */\n    @Bean(name=\"shiroDbRealm\")\n    public ShiroDbRealm shiroDbRealm(){\n        return new ShiroDbRealmImpl();\n    }\n\n\n    /**\n     * @Description 自定义session会话存储的实现类 ，使用Redis来存储共享session，达到分布式部署目的\n     */\n    @Bean(\"redisSessionDao\")\n    public SessionDAO redisSessionDao(){\n        RedisSessionDao sessionDAO =   new RedisSessionDao();\n        sessionDAO.setGlobalSessionTimeout(shiroRedisProperties.getGlobalSessionTimeout());\n        return sessionDAO;\n    }\n\n    /**\n     * @Description 会话管理器\n     */\n    @Bean(name=\"sessionManager\")\n    public DefaultWebSessionManager shiroSessionManager(){\n        DefaultWebSessionManager sessionManager = new DefaultWebSessionManager();\n        sessionManager.setSessionDAO(redisSessionDao());\n        sessionManager.setSessionValidationSchedulerEnabled(false);\n        sessionManager.setSessionIdCookieEnabled(true);\n        sessionManager.setSessionIdCookie(simpleCookie());\n        sessionManager.setGlobalSessionTimeout(shiroRedisProperties.getGlobalSessionTimeout());\n        return sessionManager;\n    }\n\n    /**\n     * @Description 保证实现了Shiro内部lifecycle函数的bean执行\n     */\n    @Bean(name = \"lifecycleBeanPostProcessor\")\n    public static LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() {\n        return new LifecycleBeanPostProcessor();\n    }\n\n    /**\n     * @Description AOP式方法级权限检查\n     */\n    @Bean\n    @DependsOn(\"lifecycleBeanPostProcessor\")\n    public DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() {\n        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();\n        defaultAdvisorAutoProxyCreator.setProxyTargetClass(true);\n        return defaultAdvisorAutoProxyCreator;\n    }\n\n    /**\n     * @Description 配合DefaultAdvisorAutoProxyCreator事项注解权限校验\n     */\n    @Bean\n    public AuthorizationAttributeSourceAdvisor getAuthorizationAttributeSourceAdvisor() {\n        AuthorizationAttributeSourceAdvisor aasa = new AuthorizationAttributeSourceAdvisor();\n        aasa.setSecurityManager(defaultWebSecurityManager());\n        return new AuthorizationAttributeSourceAdvisor();\n    }\n\n    /**\n     * @Description 过滤器链\n     */\n    private Map<String, String> filterChainDefinition(){\n        List<Object> list  = PropertiesUtil.propertiesShiro.getKeyList();\n        Map<String, String> map = new LinkedHashMap<>();\n        for (Object object : list) {\n            String key = object.toString();\n            String value = PropertiesUtil.getShiroValue(key);\n            log.info(\"读取防止盗链控制：---key{},---value:{}\",key,value);\n            map.put(key, value);\n        }\n        return map;\n    }\n\n    /**\n     * @Description 自定义过滤器定义\n     */\n    private Map<String, Filter> filters() {\n        Map<String, Filter> map = new HashMap<String, Filter>();\n        map.put(\"roleOr\", new RolesOrAuthorizationFilter());\n        return map;\n    }\n\n    /**\n     * @Description Shiro过滤器\n     */\n    @Bean(\"shiroFilter\")\n    public ShiroFilterFactoryBean shiroFilterFactoryBean(){\n        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();\n        shiroFilter.setSecurityManager(defaultWebSecurityManager());\n        //使自定义过滤器生效\n        shiroFilter.setFilters(filters());\n        shiroFilter.setFilterChainDefinitionMap(filterChainDefinition());\n        shiroFilter.setLoginUrl(\"/login\");\n        shiroFilter.setUnauthorizedUrl(\"/login\");\n        return shiroFilter;\n    }\n\n}\n\n```\n\n### 5、测试\n\n此时我们需要2个相同的项目shiro-day01-12shiro-redis-SessionManager-A和shiro-day01-13shiro-redis-SessionManager-B\n\n![1581929726816](image\\1581929726816.png)\n\n分别启动A,B2个项目\n\n访问http://127.0.0.1:8081/shiro/login，使用admin/pass登录\n\n![1581929790783](image\\1581929790783.png)\n\n修改地址栏http://127.0.0.1:8081/shiro/menus/system为http://127.0.0.1:8082/shiro/menus/system，也可以正常访问\n\n![1581929843249](image\\1581929843249.png)\n\n此时我们实现了在A服务登录，直接访问B服务则无需登录\n\n\n\n## 第八章 限制密码重试次数\n\n### 1、实现原理\n\n保证原子性：\n\n​		单系统：AtomicLong计数\n\n​		集群系统：RedissionClient提供的RAtomicLong计数\n\n```properties\n1、获取系统中是否已有登录次数缓存,缓存对象结构预期为：\"用户名--登录次数\"。\n\n2、如果之前没有登录缓存，则创建一个登录次数缓存。\n\n3、如果缓存次数已经超过限制，则驳回本次登录请求。\n\n4、将缓存记录的登录次数加1,设置指定时间内有效\n\n5、验证用户本次输入的帐号密码，如果登录登录成功，则清除掉登录次数的缓存\n\n```\n\n思路有了，那我们在哪里实现呢？我们知道AuthenticatingRealm里有比较密码的入口doCredentialsMatch方法\n\n![1581930861293](image\\1581930861293.png)\n\n查看其实现\n\n![1581930945007](image\\1581930945007.png)\n\n### 2、自定义密码比较器\n\n新建项目shiro-day01-14shiro-RetryLimit\n\n![1581934188203](image\\1581934188203.png)\n\n#### 【1】RetryLimitCredentialsMatcher\n\n```java\npackage com.itheima.shiro.core.impl;\n\nimport com.itheima.shiro.core.base.ShiroUser;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.ExcessiveAttemptsException;\nimport org.apache.shiro.authc.credential.HashedCredentialsMatcher;\nimport org.redisson.api.RAtomicLong;\nimport org.redisson.api.RedissonClient;\n\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @Description：密码重试比较器\n */\npublic class RetryLimitCredentialsMatcher extends HashedCredentialsMatcher {\n\n    private RedissonClient redissonClient;\n\n    private static Long RETRY_LIMIT_NUM = 4L;\n\n    /**\n     * @Description 构造函数\n     * @param hashAlgorithmName 匹配次数\n     * @return\n     */\n    public RetryLimitCredentialsMatcher(String hashAlgorithmName,RedissonClient redissonClient) {\n        super(hashAlgorithmName);\n        this.redissonClient = redissonClient;\n    }\n\n    @Override\n    public boolean doCredentialsMatch(AuthenticationToken token, AuthenticationInfo info) {\n        //获得登录吗\n        String loginName = (String) token.getPrincipal();\n        //获得缓存\n        RAtomicLong atomicLong = redissonClient.getAtomicLong(loginName);\n        long retryFlag = atomicLong.get();\n        //判断次数\n        if (retryFlag>RETRY_LIMIT_NUM){\n            //超过次数设计10分钟后重试\n            atomicLong.expire(10, TimeUnit.MICROSECONDS);\n            throw new ExcessiveAttemptsException(\"密码错误5次，请10分钟以后再试\");\n        }\n        //累加次数\n        atomicLong.incrementAndGet();\n        atomicLong.expire(10, TimeUnit.MICROSECONDS);\n        //密码校验\n        boolean flag =  super.doCredentialsMatch(token, info);\n        if (flag){\n            //校验成功删除限制\n            atomicLong.delete();\n        }\n        return flag;\n    }\n\n\n}\n\n```\n\n#### 【2】重写ShiroDbRealmImpl\n\n修改initCredentialsMatcher方法，使用RetryLimitCredentialsMatcher\n\n```java\npackage com.itheima.shiro.core.impl;\n\nimport com.itheima.shiro.constant.CacheConstant;\nimport com.itheima.shiro.constant.SuperConstant;\nimport com.itheima.shiro.core.SimpleCacheManager;\nimport com.itheima.shiro.core.base.ShiroUser;\nimport com.itheima.shiro.core.base.SimpleToken;\nimport com.itheima.shiro.core.ShiroDbRealm;\nimport com.itheima.shiro.core.bridge.UserBridgeService;\nimport com.itheima.shiro.pojo.User;\nimport com.itheima.shiro.utils.*;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authc.UnknownAccountException;\nimport org.apache.shiro.authc.credential.HashedCredentialsMatcher;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.util.ByteSource;\nimport org.redisson.api.RedissonClient;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport javax.annotation.Resource;\n\n/**\n * @Description：自定义shiro的实现\n */\npublic class ShiroDbRealmImpl extends ShiroDbRealm {\n\n    @Autowired\n    private UserBridgeService userBridgeService;\n\n    @Autowired\n    private SimpleCacheManager simpleCacheManager;\n\n    @Resource(name = \"redissonClientForShiro\")\n    private RedissonClient redissonClient;\n\n\n    /**\n     * @Description 认证方法\n     * @param authcToken 校验传入令牌\n     * @return AuthenticationInfo\n     */\n    @Override\n    public AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken) {\n        SimpleToken token = (SimpleToken)authcToken;\n        User user  = userBridgeService.findUserByLoginName(token.getUsername());\n        if(EmptyUtil.isNullOrEmpty(user)){\n            throw new UnknownAccountException(\"账号不存在\");\n        }\n        ShiroUser shiroUser = BeanConv.toBean(user, ShiroUser.class);\n        String sessionId = ShiroUserUtil.getShiroSessionId();\n        String cacheKeyResourcesIds = CacheConstant.RESOURCES_KEY_IDS+sessionId;\n        shiroUser.setResourceIds(userBridgeService.findResourcesIdsList(cacheKeyResourcesIds,user.getId()));\n        String salt = user.getSalt();\n        String password = user.getPassWord();\n        return new SimpleAuthenticationInfo(shiroUser, password, ByteSource.Util.bytes(salt), getName());\n    }\n\n    /**\n     * @Description 授权方法\n     * @param principals SimpleAuthenticationInfo对象第一个参数\n     * @return\n     */\n    @Override\n    public AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        ShiroUser shiroUser = (ShiroUser) principals.getPrimaryPrincipal();\n        return userBridgeService.getAuthorizationInfo(shiroUser);\n    }\n\n    /**\n     * @Description 清理缓存\n     */\n    @Override\n    public void doClearCache(PrincipalCollection principalcollection) {\n        String sessionId = ShiroUtil.getShiroSessionId();\n        simpleCacheManager.removeCache(CacheConstant.ROLE_KEY+sessionId);\n        simpleCacheManager.removeCache(CacheConstant.RESOURCES_KEY+sessionId);\n        simpleCacheManager.removeCache(CacheConstant.TOKEN+sessionId);\n    }\n\n    /**\n     * @Description 加密方式\n     */\n    @Override\n    public void initCredentialsMatcher() {\n        RetryLimitCredentialsMatcher matcher = new RetryLimitCredentialsMatcher(SuperConstant.HASH_ALGORITHM,redissonClient);\n        matcher.setHashIterations(SuperConstant.HASH_INTERATIONS);\n        setCredentialsMatcher(matcher);\n\n    }\n}\n\n```\n\n### 3、测试\n\n访问http://127.0.0.1/shiro/login，使用admin账号输入错误密码5次\n\n![1581933402187](image\\1581933402187.png)\n\n## 第九章 在线并发登录人数控制\n\n### 1、实现原理\n\n在实际开发中，我们可能会遇到这样的需求，一个账号只允许同时一个在线，当账号在其他地方登陆的时候，会踢出前面登陆的账号，那我们怎么实现\n\n- 自定义过滤器:继承AccessControlFilter\n\n- 使用redis队列控制账号在线数目\n\n  实现步骤：\n\n```properties\n1、只针对登录用户处理，首先判断是否登录\n2、使用RedissionClien创建队列\n3、判断当前sessionId是否存在于此用户的队列=key:登录名 value：多个sessionId\n4、不存在则放入队列尾端==>存入sessionId\n5、判断当前队列大小是否超过限定此账号的可在线人数\n6、超过：\n	*从队列头部拿到用户sessionId\n	*从sessionManger根据sessionId拿到session\n	*从sessionDao中移除session会话\n7、未超过：放过操作\n```\n\n### 2、代码实现\n\n#### 【1】KickedOutAuthorizationFilter\n\n```java\npackage com.itheima.shiro.filter;\n\nimport com.itheima.shiro.core.impl.RedisSessionDao;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport com.itheima.shiro.utils.ShiroUserUtil;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.shiro.session.ExpiredSessionException;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.session.UnknownSessionException;\nimport org.apache.shiro.session.mgt.DefaultSessionKey;\nimport org.apache.shiro.session.mgt.eis.SessionDAO;\nimport org.apache.shiro.subject.Subject;\nimport org.apache.shiro.web.filter.AccessControlFilter;\nimport org.apache.shiro.web.session.mgt.DefaultWebSessionManager;\nimport org.redisson.api.RDeque;\nimport org.redisson.api.RedissonClient;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport javax.annotation.Resource;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\n/**\n * @Description：\n */\n@Log4j2\npublic class KickedOutAuthorizationFilter extends AccessControlFilter {\n\n    private RedissonClient redissonClient;\n\n    private SessionDAO redisSessionDao;\n\n    private DefaultWebSessionManager sessionManager;\n\n    public KickedOutAuthorizationFilter(RedissonClient redissonClient, SessionDAO redisSessionDao, DefaultWebSessionManager sessionManager) {\n        this.redissonClient = redissonClient;\n        this.redisSessionDao = redisSessionDao;\n        this.sessionManager = sessionManager;\n    }\n\n    @Override\n    protected boolean isAccessAllowed(ServletRequest servletRequest, ServletResponse servletResponse, Object o) throws Exception {\n        return false;\n    }\n\n    @Override\n    protected boolean onAccessDenied(ServletRequest servletRequest, ServletResponse servletResponse) throws Exception {\n        Subject subject = getSubject(servletRequest, servletResponse);\n        if (!subject.isAuthenticated()) {\n            //如果没有登录，直接进行之后的流程\n            return true;\n        }\n        //存放session对象进入队列\n        String sessionId = ShiroUserUtil.getShiroSessionId();\n        String LoginName = ShiroUserUtil.getShiroUser().getLoginName();\n        RDeque<String> queue = redissonClient.getDeque(\"KickedOutAuthorizationFilter:\"+LoginName);\n        //判断sessionId是否存在于此用户的队列中\n        boolean flag = queue.contains(sessionId);\n        if (!flag) {\n            queue.addLast(sessionId);\n        }\n        //如果此时队列大于1，则开始踢人\n        if (queue.size() > 1) {\n            sessionId = queue.getFirst();\n            queue.removeFirst();\n            Session session = null;\n            try {\n                session = sessionManager.getSession(new DefaultSessionKey(sessionId));\n            }catch (UnknownSessionException ex){\n                log.info(\"session已经失效\");\n            }catch (ExpiredSessionException expiredSessionException){\n                log.info(\"session已经过期\");\n            }\n            if (!EmptyUtil.isNullOrEmpty(session)){\n                redisSessionDao.delete(session);\n            }\n        }\n        return true;\n    }\n}\n\n\n\n```\n\n#### 【2】修改ShiroConfig\n\n```java\n/**\n  * @Description 自定义过滤器定义\n  */\nprivate Map<String, Filter> filters() {\n    Map<String, Filter> map = new HashMap<String, Filter>();\n    map.put(\"roleOr\", new RolesOrAuthorizationFilter());\n    map.put(\"kickedOut\", new KickedOutAuthorizationFilter(redissonClient(), redisSessionDao(), shiroSessionManager()));\n    return map;\n}\n```\n\n#### 【3】修改authentication.properties\n\n```properties\n#静态资源不过滤\n/static/**=anon\n#登录链接不过滤\n/login/**=anon\n#访问/resource/**需要有admin的角色\n/resource/**=role-or[MangerRole,SuperAdmin]\n#其他链接是需要登录的\n/**=kickedOut,auth\n```\n\n### 3、测试\n\n使用谷歌访问http://127.0.0.1/shiro/login，使用admin/pass登陆\n\n![1581948184529](image\\1581948184529.png)\n\n\n\n使用IE再访问http://127.0.0.1/shiro/login，使用admin/pass登陆\n\n![1581948255302](image\\1581948255302.png)\n\n再刷新谷歌浏览器,发现账号被踢出\n\n![1581948283827](image\\1581948283827.png)\n\n## 第十章 Springboot+Shiro+Jwt前后端分离鉴权\n\n### 1、前后端分离会话问题\n\n#### 【1】问题追踪\n\n​		前面我们实现分布式的会话缓存，但是我们发现此功能的实现是基于浏览的cookie机制，也就是说用户禁用cookie后，我们的系统会就会产生会话不同的问题\n\n#### 【2】解决方案\n\n​	   我们的前端可能是web、Android、ios等应用，同时我们每一个接口都提供了无状态的应答方式，这里我们提供了基于JWT的token生成方案\n\n```properties\n1、用户登陆之后，获得此时会话的sessionId,使用JWT根据sessionId颁发签名并设置过期时间(与session过期时间相同)返回token\n\n2、将token保存到客户端本地，并且每次发送请求时都在header上携带JwtToken\n\n3、ShiroSessionManager继承DefaultWebSessionManager，重写getSessionId方法，从header上检测是否携带JwtToken，如果携带，则进行解码JwtToken，使用JwtToken中的jti作为SessionId。\n\n4、重写shiro的默认过滤器，使其支持jwtToken有效期校验、及对JSON的返回支持\n	JwtAuthcFilter:实现是否需要登录的过滤，拒绝时如果header上携带JwtToken,则返回对应json\n	JwtPermsFilter:实现是否有对应资源的过滤，拒绝时如果header上携带JwtToken,则返回对应json\n	JwtRolesFilter:实现是否有对应角色的过滤，拒绝时如果header上携带JwtToken,则返回对应json\n```\n\n\n\n### 2、JWT概述\n\nJWT（JSON WEB TOKEN）：JSON网络令牌，JWT是一个轻便的安全跨平台传输格式，定义了一个紧凑的自包含的方式在不同实体之间安全传输信息（JSON格式）。它是在Web环境下两个实体之间传输数据的一项标准。实际上传输的就是一个字符串。\n\n- 广义上：JWT是一个标准的名称；\n\n- 狭义上：JWT指的就是用来传递的那个token字符串\n\n\nJWT由三部分构成：header（头部）、payload（载荷）和signature（签名）。\n\n1. Header\n\n   存储两个变量\n\n   1. 秘钥（可以用来比对）\n   2. 算法（也就是下面将Header和payload加密成Signature）\n\n2. payload\n\n   存储很多东西，基础信息有如下几个\n\n   1. 签发人，也就是这个“令牌”归属于哪个用户。一般是`userId` \n   2. 创建时间，也就是这个令牌是什么时候创建的\n   3. 失效时间，也就是这个令牌什么时候失效(session的失效时间)\n   4. 唯一标识，一般可以使用算法生成一个唯一标识（jti==>sessionId）\n\n3. Signature\n\n   这个是上面两个经过Header中的算法加密生成的，用于比对信息，防止篡改Header和payload\n\n然后将这三个部分的信息经过加密生成一个`JwtToken`的字符串，发送给客户端，客户端保存在本地。当客户端发起请求的时候携带这个到服务端(可以是在`cookie`，可以是在`header`)，在服务端进行验证，我们需要解密对于的payload的内容\n\n### 3、集成JWT\n\n#### 【1】JwtProperties\n\n​	用于支持yaml文件配置的配置类\n\n```java\npackage com.itheima.shiro.config;\n\nimport lombok.Data;\nimport org.springframework.boot.context.properties.ConfigurationProperties;\n\nimport java.io.Serializable;\n\n/**\n * @Description：jw配置文件\n */\n@Data\n@ConfigurationProperties(prefix = \"itheima.framework.jwt\")\npublic class JwtProperties implements Serializable {\n\n    /**\n     * @Description 签名密码\n     */\n    private String hexEncodedSecretKey;\n}\n\n```\n\n#### 【2】JwtTokenManager\n\n负责令牌的颁发、解析、校验\n\n```java\npackage com.itheima.shiro.core.impl;\n\nimport com.auth0.jwt.JWT;\nimport com.auth0.jwt.JWTVerifier;\nimport com.auth0.jwt.algorithms.Algorithm;\nimport com.itheima.shiro.config.JwtProperties;\nimport com.itheima.shiro.utils.EncodesUtil;\nimport io.jsonwebtoken.Claims;\nimport io.jsonwebtoken.JwtBuilder;\nimport io.jsonwebtoken.Jwts;\nimport io.jsonwebtoken.SignatureAlgorithm;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.stereotype.Service;\n\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.UUID;\n\n@Service(\"jwtTokenManager\")\n@EnableConfigurationProperties({JwtProperties.class})\npublic class JwtTokenManager {\n\n    @Autowired\n    JwtProperties jwtProperties;\n\n\n    /**\n     * @Description 签发令牌\n     *      jwt字符串包括三个部分\n     *        1. header\n     *            -当前字符串的类型，一般都是“JWT”\n     *            -哪种算法加密，“HS256”或者其他的加密算法\n     *            所以一般都是固定的，没有什么变化\n     *        2. payload\n     *            一般有四个最常见的标准字段（下面有）\n     *            iat：签发时间，也就是这个jwt什么时候生成的\n     *            jti：JWT的唯一标识\n     *            iss：签发人，一般都是username或者userId\n     *            exp：过期时间\n     * @param iss 签发人\n     * @param ttlMillis 有效时间\n     * @param claims jwt中存储的一些非隐私信息\n     * @return\n     */\n    public String IssuedToken(String iss, long ttlMillis,String sessionId, Map<String, Object> claims) {\n        if (claims == null) {\n            claims = new HashMap<>();\n        }\n        long nowMillis = System.currentTimeMillis();\n\n        String base64EncodedSecretKey = EncodesUtil.encodeHex(jwtProperties.getBase64EncodedSecretKey().getBytes());\n\n        JwtBuilder builder = Jwts.builder()\n                .setClaims(claims)\n                .setId(sessionId)//2. 这个是JWT的唯一标识，一般设置成唯一的，这个方法可以生成唯一标识,此时存储的为sessionId,登录成功后回写\n                .setIssuedAt(new Date(nowMillis))//1. 这个地方就是以毫秒为单位，换算当前系统时间生成的iat\n                .setSubject(iss)//3. 签发人，也就是JWT是给谁的（逻辑上一般都是username或者userId）\n                .signWith(SignatureAlgorithm.HS256, base64EncodedSecretKey);//这个地方是生成jwt使用的算法和秘钥\n        if (ttlMillis >= 0) {\n            long expMillis = nowMillis + ttlMillis;\n            Date exp = new Date(expMillis);//4. 过期时间，这个也是使用毫秒生成的，使用当前时间+前面传入的持续时间生成\n            builder.setExpiration(exp);\n        }\n        return builder.compact();\n    }\n\n    /**\n     * @Description 解析令牌\n     * @param jwtToken 令牌\n     * @return\n     */\n    public Claims decodeToken(String jwtToken) {\n\n        String base64EncodedSecretKey = EncodesUtil.encodeHex(jwtProperties.getBase64EncodedSecretKey().getBytes());\n\n        // 得到 DefaultJwtParser\n        return Jwts.parser()\n                // 设置签名的秘钥\n                .setSigningKey(base64EncodedSecretKey)\n                // 设置需要解析的 jwt\n                .parseClaimsJws(jwtToken)\n                .getBody();\n    }\n\n    /**\n     * @Description 判断令牌是否合法\n     * @param jwtToken 令牌\n     * @return\n     */\n    public boolean isVerifyToken(String jwtToken) {\n\n        String base64EncodedSecretKey = EncodesUtil.encodeHex(jwtProperties.getBase64EncodedSecretKey().getBytes());\n\n        //这个是官方的校验规则，这里只写了一个”校验算法“，可以自己加\n        Algorithm algorithm = Algorithm.HMAC256(EncodesUtil.decodeBase64(base64EncodedSecretKey));\n        JWTVerifier verifier = JWT.require(algorithm).build();\n        verifier.verify(jwtToken);  // 校验不通过会抛出异常\n        //判断合法的标准：1. 头部和荷载部分没有篡改过。2. 没有过期\n        return true;\n    }\n\n}\n```\n\n### 4、重写DefaultWebSessionManager\n\nShiroSessionManager主要是添加jwtToken的jti作为会话的唯一标识\n\n```java\npackage com.itheima.shiro.core.impl;\n\nimport com.itheima.shiro.utils.EmptyUtil;\nimport io.jsonwebtoken.Claims;\nimport org.apache.shiro.web.servlet.ShiroHttpServletRequest;\nimport org.apache.shiro.web.session.mgt.DefaultWebSessionManager;\nimport org.apache.shiro.web.util.WebUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\n\n/**\n * @Description 重写Jwt会话管理\n */\n\npublic class ShiroSessionManager extends DefaultWebSessionManager {\n	\n	private static final String AUTHORIZATION = \"jwtToken\";\n\n    private static final String REFERENCED_SESSION_ID_SOURCE = \"Stateless request\";\n\n    public ShiroSessionManager(){\n        super();\n    }\n\n    @Autowired\n    JwtTokenManager jwtTokenManager;\n\n    @Override\n    protected Serializable getSessionId(ServletRequest request, ServletResponse response){\n        String jwtToken = WebUtils.toHttp(request).getHeader(AUTHORIZATION);\n        if(EmptyUtil.isNullOrEmpty(jwtToken)){\n            //如果没有携带id参数则按照父类的方式在cookie进行获取\n            return super.getSessionId(request, response);\n        }else{\n            //如果请求头中有 authToken 则其值为jwtToken，然后解析出会话session\n        	request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,REFERENCED_SESSION_ID_SOURCE);\n            Claims decode = jwtTokenManager.decodeToken(jwtToken);\n            String id = (String) decode.get(\"jti\");\n            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID,id);\n            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID,Boolean.TRUE);\n            return id;\n        }\n    }\n\n}\n\n```\n\n### 5、重写默认过滤器\n\nBaseResponse返回统一json的对象\n\n```java\npackage com.itheima.shiro.core.base;\n\nimport com.itheima.shiro.utils.ToString;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\n\n/**\n * @Description 基础返回封装\n */\n@Data\npublic class BaseResponse extends ToString {\n    private Integer code ;\n\n    private String msg ;\n\n    private String date;\n\n    private static final long serialVersionUID = -1;\n\n    public BaseResponse(Integer code, String msg) {\n        this.code = code;\n        this.msg = msg;\n    }\n\n    public BaseResponse(Integer code, String msg, String date) {\n        this.code = code;\n        this.msg = msg;\n        this.date = date;\n    }\n}\n\n```\n\n\n\n#### 【1】JwtAuthcFilter\n\n使用wtTokenManager.isVerifyToken(jwtToken)校验颁发jwtToken是否合法，同时在拒绝的时候返回对应的json数据格式\n\n```java\npackage com.itheima.shiro.core.filter;\n\nimport com.alibaba.fastjson.JSONObject;\nimport com.itheima.shiro.constant.ShiroConstant;\nimport com.itheima.shiro.core.base.BaseResponse;\nimport com.itheima.shiro.core.impl.JwtTokenManager;\nimport com.itheima.shiro.core.impl.ShiroSessionManager;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport org.apache.shiro.web.filter.authc.FormAuthenticationFilter;\nimport org.apache.shiro.web.util.WebUtils;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\n/**\n * @Description：自定义登录验证过滤器\n */\npublic class JwtAuthcFilter extends FormAuthenticationFilter {\n\n    private JwtTokenManager jwtTokenManager;\n\n    public JwtAuthcFilter(JwtTokenManager jwtTokenManager) {\n        this.jwtTokenManager = jwtTokenManager;\n    }\n\n    /**\n     * @Description 是否允许访问\n     */\n    @Override\n    protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) {\n        //判断当前请求头中是否带有jwtToken的字符串\n        String jwtToken = WebUtils.toHttp(request).getHeader(\"jwtToken\");\n        //如果有：走jwt校验\n        if (!EmptyUtil.isNullOrEmpty(jwtToken)){\n            boolean verifyToken = jwtTokenManager.isVerifyToken(jwtToken);\n            if (verifyToken){\n                return super.isAccessAllowed(request, response, mappedValue);\n            }else {\n                return false;\n            }\n        }\n        //没有没有：走原始校验\n        return super.isAccessAllowed(request, response, mappedValue);\n    }\n\n    /**\n     * @Description 访问拒绝时调用\n     */\n    @Override\n    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws Exception {\n        //判断当前请求头中是否带有jwtToken的字符串\n        String jwtToken = WebUtils.toHttp(request).getHeader(\"jwtToken\");\n        //如果有：返回json的应答\n        if (!EmptyUtil.isNullOrEmpty(jwtToken)){\n            BaseResponse baseResponse = new BaseResponse(ShiroConstant.NO_LOGIN_CODE,ShiroConstant.NO_LOGIN_MESSAGE);\n            response.setCharacterEncoding(\"UTF-8\");\n            response.setContentType(\"application/json; charset=utf-8\");\n            response.getWriter().write(JSONObject.toJSONString(baseResponse));\n            return false;\n        }\n        //如果没有：走原始方式\n        return super.onAccessDenied(request, response);\n    }\n}\n\n```\n\n#### 【2】JwtPermsFilter\n\n```java\npackage com.itheima.shiro.core.filter;\n\nimport com.alibaba.fastjson.JSONObject;\nimport com.itheima.shiro.constant.ShiroConstant;\nimport com.itheima.shiro.core.base.BaseResponse;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter;\nimport org.apache.shiro.web.util.WebUtils;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\n\n/**\n * @Description：自定义jwt的资源校验\n */\npublic class JwtPermsFilter extends PermissionsAuthorizationFilter {\n\n    /**\n     * @Description 访问拒绝时调用\n     */\n    @Override\n    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws IOException {\n        //判断当前请求头中是否带有jwtToken的字符串\n        String jwtToken = WebUtils.toHttp(request).getHeader(\"jwtToken\");\n        //如果有：返回json的应答\n        if (!EmptyUtil.isNullOrEmpty(jwtToken)){\n            BaseResponse baseResponse = new BaseResponse(ShiroConstant.NO_AUTH_CODE,ShiroConstant.NO_AUTH_MESSAGE);\n            response.setCharacterEncoding(\"UTF-8\");\n            response.setContentType(\"application/json; charset=utf-8\");\n            response.getWriter().write(JSONObject.toJSONString(baseResponse));\n            return false;\n        }\n        //如果没有：走原始方式\n        return super.onAccessDenied(request, response);\n    }\n}\n\n```\n\n#### 【3】JwtRolesFilter\n\n```java\npackage com.itheima.shiro.core.filter;\n\nimport com.alibaba.fastjson.JSONObject;\nimport com.itheima.shiro.constant.ShiroConstant;\nimport com.itheima.shiro.core.base.BaseResponse;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport org.apache.shiro.web.filter.authz.RolesAuthorizationFilter;\nimport org.apache.shiro.web.util.WebUtils;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.IOException;\n\n/**\n * @Description：自定义jwt角色校验\n */\npublic class JwtRolesFilter extends RolesAuthorizationFilter {\n\n    /**\n     * @Description 访问拒绝时调用\n     */\n    @Override\n    protected boolean onAccessDenied(ServletRequest request, ServletResponse response) throws IOException {\n        //判断当前请求头中是否带有jwtToken的字符串\n        String jwtToken = WebUtils.toHttp(request).getHeader(\"jwtToken\");\n        //如果有：返回json的应答\n        if (!EmptyUtil.isNullOrEmpty(jwtToken)){\n            BaseResponse baseResponse = new BaseResponse(ShiroConstant.NO_ROLE_CODE,ShiroConstant.NO_ROLE_MESSAGE);\n            response.setCharacterEncoding(\"UTF-8\");\n            response.setContentType(\"application/json; charset=utf-8\");\n            response.getWriter().write(JSONObject.toJSONString(baseResponse));\n            return false;\n        }\n        //如果没有：走原始方式\n        return super.onAccessDenied(request, response);\n    }\n}\n\n```\n\n\n\n### 6、重写ShiroConfig\n\n1、ShiroSessionManager替换DefaultWebSessionManager\n\n2、生效过滤器\n\n```java\npackage com.itheima.shiro.config;\n\n\nimport com.itheima.shiro.core.ShiroDbRealm;\nimport com.itheima.shiro.core.impl.*;\nimport com.itheima.shiro.filter.*;\nimport com.itheima.shiro.properties.PropertiesUtil;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.shiro.session.mgt.eis.SessionDAO;\nimport org.apache.shiro.spring.LifecycleBeanPostProcessor;\nimport org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.apache.shiro.web.servlet.SimpleCookie;\nimport org.apache.shiro.web.session.mgt.DefaultWebSessionManager;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.DependsOn;\n\nimport javax.servlet.Filter;\nimport java.util.HashMap;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @Description 权限配置类\n */\n@Configuration\n@ComponentScan(basePackages = {\"com.itheima.shiro.core\"})\n@EnableConfigurationProperties({ShiroRedisProperties.class})\n@Log4j2\npublic class ShiroConfig {\n\n    @Autowired\n    private ShiroRedisProperties shiroRedisProperties;\n\n    @Autowired\n    JwtTokenManager jwtTokenManager;\n\n    /**\n     * @Description redission客户端\n     */\n    @Bean(\"redissonClientForShiro\")\n    public RedissonClient redissonClient() {\n        log.info(\"=====初始化redissonClientForShiro开始======\");\n        String[] nodeList = shiroRedisProperties.getNodes().split(\",\");\n        Config config = new Config();\n        if (nodeList.length == 1) {\n            config.useSingleServer().setAddress(nodeList[0])\n                    .setConnectTimeout(shiroRedisProperties.getConnectTimeout())\n                    .setConnectionMinimumIdleSize(shiroRedisProperties.getConnectionMinimumidleSize())\n                    .setConnectionPoolSize(shiroRedisProperties.getConnectPoolSize()).setTimeout(shiroRedisProperties.getTimeout());\n        } else {\n            config.useClusterServers().addNodeAddress(nodeList)\n                    .setConnectTimeout(shiroRedisProperties.getConnectTimeout())\n                    .setMasterConnectionMinimumIdleSize(shiroRedisProperties.getConnectionMinimumidleSize())\n                    .setMasterConnectionPoolSize(shiroRedisProperties.getConnectPoolSize()).setTimeout(shiroRedisProperties.getTimeout());\n        }\n        RedissonClient redissonClient =  Redisson.create(config);\n        log.info(\"=====初始化redissonClientForShiro完成======\");\n        return redissonClient;\n    }\n\n    /**\n     * @Description 创建cookie对象\n     */\n    @Bean(name=\"sessionIdCookie\")\n    public SimpleCookie simpleCookie(){\n        SimpleCookie simpleCookie = new SimpleCookie();\n        simpleCookie.setName(\"ShiroSession\");\n        return simpleCookie;\n    }\n\n    /**\n     * @Description 缓存管理器\n     * @param\n     * @return\n     */\n    @Bean(name=\"shiroCacheManager\")\n    public ShiroCacheManager shiroCacheManager(){\n        return new ShiroCacheManager();\n    }\n\n    /**\n     * @Description 权限管理器\n     * @param\n     * @return\n     */\n    @Bean(name=\"securityManager\")\n    public DefaultWebSecurityManager defaultWebSecurityManager(){\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n        securityManager.setRealm(shiroDbRealm());\n        securityManager.setSessionManager(shiroSessionManager());\n        securityManager.setCacheManager(shiroCacheManager());\n        return securityManager;\n    }\n\n    /**\n     * @Description 自定义RealmImpl\n     */\n    @Bean(name=\"shiroDbRealm\")\n    public ShiroDbRealm shiroDbRealm(){\n        return new ShiroDbRealmImpl();\n    }\n\n\n    /**\n     * @Description 自定义session会话存储的实现类 ，使用Redis来存储共享session，达到分布式部署目的\n     */\n    @Bean(\"redisSessionDao\")\n    public SessionDAO redisSessionDao(){\n        RedisSessionDao sessionDAO =   new RedisSessionDao();\n        sessionDAO.setGlobalSessionTimeout(shiroRedisProperties.getGlobalSessionTimeout());\n        return sessionDAO;\n    }\n\n    /**\n     * @Description 会话管理器\n     */\n    @Bean(name=\"sessionManager\")\n    public ShiroSessionManager shiroSessionManager(){\n        ShiroSessionManager sessionManager = new ShiroSessionManager();\n        sessionManager.setSessionDAO(redisSessionDao());\n        sessionManager.setSessionValidationSchedulerEnabled(false);\n        sessionManager.setSessionIdCookieEnabled(true);\n        sessionManager.setSessionIdCookie(simpleCookie());\n        sessionManager.setGlobalSessionTimeout(shiroRedisProperties.getGlobalSessionTimeout());\n        return sessionManager;\n    }\n\n    /**\n     * @Description 保证实现了Shiro内部lifecycle函数的bean执行\n     */\n    @Bean(name = \"lifecycleBeanPostProcessor\")\n    public static LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() {\n        return new LifecycleBeanPostProcessor();\n    }\n\n    /**\n     * @Description AOP式方法级权限检查\n     */\n    @Bean\n    @DependsOn(\"lifecycleBeanPostProcessor\")\n    public DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() {\n        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();\n        defaultAdvisorAutoProxyCreator.setProxyTargetClass(true);\n        return defaultAdvisorAutoProxyCreator;\n    }\n\n    /**\n     * @Description 配合DefaultAdvisorAutoProxyCreator事项注解权限校验\n     */\n    @Bean\n    public AuthorizationAttributeSourceAdvisor getAuthorizationAttributeSourceAdvisor() {\n        AuthorizationAttributeSourceAdvisor aasa = new AuthorizationAttributeSourceAdvisor();\n        aasa.setSecurityManager(defaultWebSecurityManager());\n        return new AuthorizationAttributeSourceAdvisor();\n    }\n\n    /**\n     * @Description 过滤器链\n     */\n    private Map<String, String> filterChainDefinition(){\n        List<Object> list  = PropertiesUtil.propertiesShiro.getKeyList();\n        Map<String, String> map = new LinkedHashMap<>();\n        for (Object object : list) {\n            String key = object.toString();\n            String value = PropertiesUtil.getShiroValue(key);\n            log.info(\"读取防止盗链控制：---key{},---value:{}\",key,value);\n            map.put(key, value);\n        }\n        return map;\n    }\n\n\n    /**\n     * @Description 自定义过滤器定义\n     */\n    private Map<String, Filter> filters() {\n        Map<String, Filter> map = new HashMap<String, Filter>();\n        map.put(\"roleOr\", new RolesOrAuthorizationFilter());\n        map.put(\"kicked-out\", new KickedOutAuthorizationFilter(redissonClient(), redisSessionDao(), shiroSessionManager()));\n        map.put(\"jwt-authc\", new JwtAuthcFilter(jwtTokenManager));\n        map.put(\"jwt-perms\", new JwtPermsFilter());\n        map.put(\"jwt-roles\", new JwtRolesFilter());\n        return map;\n    }\n\n    /**\n     * @Description Shiro过滤器\n     */\n    @Bean(\"shiroFilter\")\n    public ShiroFilterFactoryBean shiroFilterFactoryBean(){\n        ShiroFilterFactoryBean shiroFilter = new ShiroFilterFactoryBean();\n        shiroFilter.setSecurityManager(defaultWebSecurityManager());\n        //使自定义过滤器生效\n        shiroFilter.setFilters(filters());\n        shiroFilter.setFilterChainDefinitionMap(filterChainDefinition());\n        shiroFilter.setLoginUrl(\"/login\");\n        shiroFilter.setUnauthorizedUrl(\"/login\");\n        return shiroFilter;\n    }\n\n}\n\n```\n\n### 7、业务代码\n\n#### 【1】LoginAction\n\n添加LoginForJwt方法\n\n```java\n/**\n	 * @Description jwt的json登录方式\n	 * @param loginVo\n	 * @return\n	 */\n	@RequestMapping(\"login-jwt\")\n	@ResponseBody\n	public BaseResponse LoginForJwt(@RequestBody LoginVo loginVo){\n		return loginService.routeForJwt(loginVo);\n	}\n```\n\n#### 【2】LoginService\n\n添加routeForJwt方法\n\n```java\npackage com.itheima.shiro.service;\n\nimport com.itheima.shiro.core.base.BaseResponse;\nimport com.itheima.shiro.vo.LoginVo;\nimport org.apache.shiro.authc.IncorrectCredentialsException;\nimport org.apache.shiro.authc.UnknownAccountException;\n\nimport java.util.Map;\n\n/**\n * @Description 登陆业务接口\n */\n\npublic interface LoginService {\n	\n	/**\n	 * @Description 登陆路由\n	 * @param loginVo 登录参数\n	 * @return\n	 */\n	public Map<String, String> route(LoginVo loginVo) throws UnknownAccountException,IncorrectCredentialsException;\n\n	/**\n	 * @Description jwt方式登录\n	 @param loginVo 登录参数\n	 * @return\n	 */\n	public BaseResponse routeForJwt(LoginVo loginVo) throws UnknownAccountException,IncorrectCredentialsException;\n\n}\n\n\n```\n\n#### 【3】LoginServiceImpl\n\n```java\n\n\npackage com.itheima.shiro.service.impl;\n\nimport com.alibaba.fastjson.JSONObject;\nimport com.itheima.shiro.constant.CacheConstant;\nimport com.itheima.shiro.constant.ShiroConstant;\nimport com.itheima.shiro.core.base.BaseResponse;\nimport com.itheima.shiro.core.base.ShiroUser;\nimport com.itheima.shiro.core.base.SimpleToken;\nimport com.itheima.shiro.core.bridge.UserBridgeService;\nimport com.itheima.shiro.core.impl.JwtTokenManager;\nimport com.itheima.shiro.pojo.User;\nimport com.itheima.shiro.service.LoginService;\nimport com.itheima.shiro.utils.BeanConv;\nimport com.itheima.shiro.utils.ShiroUserUtil;\nimport com.itheima.shiro.utils.ShiroUtil;\nimport com.itheima.shiro.vo.LoginVo;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.IncorrectCredentialsException;\nimport org.apache.shiro.authc.UnknownAccountException;\nimport org.apache.shiro.subject.Subject;\nimport org.redisson.api.RedissonClient;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.Resource;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @Description 登陆业务实现\n */\n@Service(\"loginService\")\n@Log4j2\npublic class LoginServiceImpl implements LoginService {\n\n    @Resource(name = \"redissonClientForShiro\")\n    RedissonClient redissonClient;\n\n    @Autowired\n    UserBridgeService userBridgeService;\n\n    @Autowired\n    JwtTokenManager jwtTokenManager;\n\n    /* (non-Javadoc)\n     * @see LoginService#route(com.yz.commons.vo.LoginVo)\n     */\n    @Override\n    public Map<String, String> route(LoginVo loginVo) throws UnknownAccountException, IncorrectCredentialsException {\n        Map<String, String> map = new HashMap<>();\n        try {\n            SimpleToken token = new SimpleToken(null, loginVo.getLoginName(), loginVo.getPassWord());\n            Subject subject = SecurityUtils.getSubject();\n            subject.login(token);\n            //创建缓存\n            this.loadAuthorityToCache();\n        } catch (UnknownAccountException ex) {\n            log.error(\"登陆异常:{}\", ex);\n            throw new UnknownAccountException(ex);\n        } catch (IncorrectCredentialsException ex) {\n            log.error(\"登陆异常:{}\", ex);\n            throw new IncorrectCredentialsException(ex);\n        }\n        return map;\n    }\n\n    @Override\n    public BaseResponse routeForJwt(LoginVo loginVo) throws UnknownAccountException, IncorrectCredentialsException {\n        Map<String, String> map = new HashMap<>();\n        String jwtToken = null;\n        try {\n            SimpleToken token = new SimpleToken(null, loginVo.getLoginName(), loginVo.getPassWord());\n            Subject subject = SecurityUtils.getSubject();\n            subject.login(token);\n            String shiroSessionId = ShiroUserUtil.getShiroSessionId();\n            //登录后颁发的令牌\n            ShiroUser shiroUser = ShiroUserUtil.getShiroUser();\n            Map<String, Object> claims = new HashMap<>();\n            claims.put(\"shiroUser\", JSONObject.toJSONString(shiroUser));\n            jwtToken = jwtTokenManager.IssuedToken(\"system\", subject.getSession().getTimeout(),shiroSessionId,claims);\n            map.put(\"jwtToken\",jwtToken );\n            log.info(\"jwtToken:{}\",map.toString());\n            //创建缓存\n            this.loadAuthorityToCache();\n        } catch (Exception ex) {\n            BaseResponse baseResponse = new BaseResponse(ShiroConstant.LOGIN_FAILURE_CODE, ShiroConstant.LOGIN_FAILURE_MESSAGE);\n            return baseResponse;\n        }\n        BaseResponse baseResponse = new BaseResponse(ShiroConstant.LOGIN_SUCCESS_CODE,ShiroConstant.LOGIN_SUCCESS_MESSAGE,jwtToken);\n        return baseResponse;\n    }\n\n    /**\n     *\n     * <b>方法名：</b>：loadAuthorityToCache<br>\n     * <b>功能说明：</b>：加载缓存<br>\n     */\n    private void loadAuthorityToCache(){\n        //登陆成功后缓存用户的权限信息进入缓存\n        ShiroUser shiroUser = ShiroUserUtil.getShiroUser();\n        User user = BeanConv.toBean(shiroUser, User.class);\n        userBridgeService.loadUserAuthorityToCache(user);\n\n    }\n\n}\n\n```\n\n【5】authentication.properties\n\n```properties\n#静态资源不过滤\n/static/**=anon\n#登录链接不过滤\n/login/**=anon\n#访问/resource/**需要有admin的角色\n#/resource/**=roleOr[MangerRole,SuperAdmin]\n/role/** =jwt-roles[SuperAdmin]\n/resource/** =jwt-perms[role:listInitialize]\n#其他链接是需要登录的\n/**=kicked-out,jwt-authc\n```\n\n### 8、测试\n\n1、测试登录后，jwtToken的生成，且校验会话是否使用新的jwtToken里的会话jti\n\n2、测试自定义过滤器是否生效\n\n使用jay/pass登录\n\n![1582109588294](image\\1582109588294.png)\n\n![1582109618404](image\\1582109618404.png)\n\n使用admin/pass登录\n\n![1582116805841](image\\1582116805841.png)\n\n![1582116832446](image\\1582116832446.png)\n\n## 第十一章 分布式统一权限系统\n\n### 1、系统需求\n\n#### 【1】前后端分离\n\n在第十章中我们已经实现，使用jwt的令牌实现，重写DefaultWebSessionManager,从ServletRequest获得jwtToken作为会话sessionId\n\n```java\npackage com.itheima.shiro.core.impl;\n\nimport com.itheima.shiro.utils.EmptyUtil;\nimport io.jsonwebtoken.Claims;\nimport org.apache.shiro.web.servlet.ShiroHttpServletRequest;\nimport org.apache.shiro.web.session.mgt.DefaultWebSessionManager;\nimport org.apache.shiro.web.util.WebUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.io.Serializable;\n\n/**\n * @Description 重写Jwt会话管理\n */\n\npublic class ShiroSessionManager extends DefaultWebSessionManager {\n	\n	private static final String AUTHORIZATION = \"jwtToken\";\n\n    private static final String REFERENCED_SESSION_ID_SOURCE = \"Stateless request\";\n\n    public ShiroSessionManager(){\n        super();\n    }\n\n    @Autowired\n    JwtTokenManager jwtTokenManager;\n\n    @Override\n    protected Serializable getSessionId(ServletRequest request, ServletResponse response){\n        String jwtToken = WebUtils.toHttp(request).getHeader(AUTHORIZATION);\n        if(EmptyUtil.isNullOrEmpty(jwtToken)){\n            //如果没有携带id参数则按照父类的方式在cookie进行获取\n            return super.getSessionId(request, response);\n        }else{\n            //如果请求头中有 authToken 则其值为jwtToken，然后解析出会话session\n        	request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_SOURCE,REFERENCED_SESSION_ID_SOURCE);\n            Claims decode = jwtTokenManager.decodeToken(jwtToken);\n            String id = (String) decode.get(\"jti\");\n            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID,id);\n            request.setAttribute(ShiroHttpServletRequest.REFERENCED_SESSION_ID_IS_VALID,Boolean.TRUE);\n            return id;\n        }\n    }\n\n}\n\n```\n\n#### 【2】集中式会话\n\n在第七章中RedisSessionDao继承AbstractSessionDAO，重写了会话的创建、读取、修改等操作，全部缓存于redis中\n\n```java\npackage com.itheima.shiro.core.impl;\n\nimport com.itheima.shiro.constant.CacheConstant;\nimport com.itheima.shiro.utils.ShiroRedissionSerialize;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.shiro.session.Session;\nimport org.apache.shiro.session.mgt.eis.AbstractSessionDAO;\nimport org.redisson.api.RBucket;\nimport org.redisson.api.RedissonClient;\n\nimport javax.annotation.Resource;\nimport java.io.Serializable;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @Description 实现shiro session的memcached集中式管理~\n */\n@Log4j2\npublic class RedisSessionDao extends AbstractSessionDAO {\n\n	@Resource(name = \"redissonClientForShiro\")\n	RedissonClient redissonClient;\n\n	private Long globalSessionTimeout;\n\n	@Override\n	protected Serializable doCreate(Session session) {\n		Serializable sessionId = generateSessionId(session);\n		assignSessionId(session, sessionId);\n//		log.info(\"=============创建sessionId:{}\",sessionId);\n		RBucket<String> sessionIdRBucket = redissonClient.getBucket(CacheConstant.GROUP_CAS+sessionId.toString());\n		sessionIdRBucket.trySet(ShiroRedissionSerialize.serialize(session), globalSessionTimeout, TimeUnit.SECONDS);\n		return sessionId;\n	}\n\n	@Override\n	protected Session doReadSession(Serializable sessionId) {\n		RBucket<String> sessionIdRBucket = redissonClient.getBucket(CacheConstant.GROUP_CAS+sessionId.toString());\n		Session session = (Session) ShiroRedissionSerialize.deserialize(sessionIdRBucket.get());\n//		log.info(\"=============读取sessionId:{}\",session.getId().toString());\n		return session;\n	}\n\n	@Override\n	public void delete(Session session) {\n//		log.info(\"=============删除sessionId:{}\",session.getId().toString());\n		RBucket<String> sessionIdRBucket = redissonClient.getBucket(CacheConstant.GROUP_CAS+session.getId().toString());\n		sessionIdRBucket.delete();\n	}\n\n	@Override\n	public Collection<Session> getActiveSessions() {\n		return Collections.emptySet();  \n	}\n\n	@Override\n	public void update(Session session) {\n		RBucket<String> sessionIdRBucket = redissonClient.getBucket(CacheConstant.GROUP_CAS+session.getId().toString());\n		sessionIdRBucket.set(ShiroRedissionSerialize.serialize(session), globalSessionTimeout, TimeUnit.SECONDS);\n//		log.info(\"=============修改sessionId:{}\",session.getId().toString());\n	}\n\n	public void setGlobalSessionTimeout(Long globalSessionTimeout) {\n		this.globalSessionTimeout = globalSessionTimeout;\n	}\n}\n\n\n```\n\n#### 【3】认证与鉴权服务化\n\n第六章中，我们实现了realm的缓存机制，这里我们会把UserBridgeService使用dubbo服务化\n\n![](image\\1581844376847.png)\n\n其目的使得实际项目中的认证与鉴权走dubbo，减少服务器压力\n\n#### 【4】动态过滤器链\n\n在第十章中，我们加载过滤器链的方式\n\n```properties\n#静态资源不过滤\n/static/**=anon\n#登录链接不过滤\n/login/**=anon\n#访问/resource/**需要有admin的角色\n#/resource/**=role-or[MangerRole,SuperAdmin]\n#/role/** =jwt-roles[SuperAdmin]\n/resource/** =jwt-perms[role:listInitialize]\n#其他链接是需要登录的\n/**=kicked-out,jwt-authc\n```\n\n在统一鉴权系统中，我们不可能每次发布新的过滤器链，就去重启服务器，我们更希望可以动态管理过滤器链\n\n#### 【5】权限客户端\n\nshiro-client作为jar的依赖，满足以下需求：\n\n1、非侵入式：使用者只需要对jar依赖和做少量的配置，就可以达到统一鉴权的目标\n\n2、可扩展性：用户除使用提供的过滤器外，可以轻松安自己的业务去定义过滤器\n\n3、集中式管理：依赖jar之后，shiro-mgt后台可以同时管控多个平台的权限的认证、鉴权、及动态配置过滤器链\n\n#### 【6】网关平台\n\nspringboot-shiro-gateway:\n\n1、依赖shiro-client项目作为权限的被控制层\n\n2、实现dubbo传输协议到HTTP传输协议的转化，当然这里提供的为通用的转换方式。\n\n3、可复制、复制后只需要在shiro-mgt后台中做简单的配置，就可以实现一个新网关的接入\n\n### 2、架构设计\n\n#### 【1】系统网络通讯\n\n![1582876876486](image\\1582876876486.png)\n\n\n\n1、网关服务集群性，同时实现会话的统一管理\n\n2、鉴权服务集群化，提供统一鉴权服务\n\n3、管理后台集群化\n\n#### 【2】模块依赖关系\n\n##### 【1.1】springboot-shiro-parent\n\nspringboot-shiro-parent:项目统一jar和plugIn的POM定义\n\n![1582880473745](image\\1582880473745.png)\n\n##### 【1.2】springboot-shiro-gateway-handler\n\n​		1、dubbo业务服务转换http通讯\n\n​		2、认证与鉴权服务化消费者\n\n​		3、生成业务服务化消费者\n\n![1582880165581](image\\1582880165581.png)\n\n##### 【1.3】springboot-shiro-producer\n\n​		认证与鉴权服务化的生成者\n\n![1582710657210](image\\1582710657210.png)\n\n##### 【1.4】springboot-shiro-mgt\n\n​		认证与鉴权服务化消费者\n\n![1582881763304](image\\1582881763304.png)\n\n\n\n##### 【1.5】springboot-shiro-dubbo-app-handler\n\n​		生产业务服务化生产者\n\n![1582711000178](image/1582711000178.png)\n\n\n\n### 3、认证鉴权服务化\n\n![1585539347157](image\\1585539347157.png)\n\n上面的图解中我们可以看到，这里服务化的为UserAdapterFace\n\n模块springboot-shiro-face中的接口定义UserAdapterFace\n\n```java\npackage com.itheima.shiro.face;\n\nimport com.itheima.shiro.vo.ResourceVo;\nimport com.itheima.shiro.vo.RoleVo;\nimport com.itheima.shiro.vo.UserVo;\n\nimport java.util.List;\n\n/**\n * @Description：用户服务接口定义\n */\npublic interface UserAdapterFace {\n\n    /**\n     * @Description 按用户名查找用户\n     * @param loginName 登录名\n     * @return\n     */\n    UserVo findUserByLoginName(String loginName);\n\n    /**\n     * @Description 查找用户所有角色\n     * @param userId 用户Id\n     * @return\n     */\n    List<RoleVo> findRoleByUserId(String userId);\n\n    /**\n     * @Description 查询用户有那些资源\n     * @param userId 用户Id\n     * @return\n     */\n    List<ResourceVo> findResourceByUserId(String userId);\n\n}\n\n```\n\nspringboot-shiro-producer模块中的生产者UserAdapterFaceImpl\n\n```java\npackage com.itheima.shiro.faceImpl;\n\nimport com.itheima.shiro.adapter.UserAdapter;\nimport com.itheima.shiro.face.UserAdapterFace;\nimport com.itheima.shiro.pojo.Resource;\nimport com.itheima.shiro.pojo.Role;\nimport com.itheima.shiro.pojo.User;\nimport com.itheima.shiro.utils.BeanConv;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport com.itheima.shiro.vo.ResourceVo;\nimport com.itheima.shiro.vo.RoleVo;\nimport com.itheima.shiro.vo.UserVo;\nimport org.apache.dubbo.config.annotation.Service;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport java.util.List;\n\n/**\n * @Description：\n */\n@Service(version = \"1.0.0\", retries = 3,timeout = 5000)\npublic class UserAdapterFaceImpl implements UserAdapterFace {\n\n    @Autowired\n    UserAdapter userAdapter;\n\n\n    @Override\n    public UserVo findUserByLoginName(String loginName) {\n        User user = userAdapter.findUserByLoginName(loginName);\n        if (!EmptyUtil.isNullOrEmpty(user)){\n            return BeanConv.toBean(user,UserVo.class);\n        }\n        return null;\n    }\n\n    @Override\n    public List<RoleVo> findRoleByUserId(String userId) {\n        List<Role> list = userAdapter.findRoleByUserId(userId);\n        if (!EmptyUtil.isNullOrEmpty(list)){\n            return BeanConv.toBeanList(list, RoleVo.class);\n        }\n        return null;\n    }\n\n    @Override\n    public List<ResourceVo> findResourceByUserId(String userId) {\n        List<Resource> list = userAdapter.findResourceByUserId(userId);\n        if (!EmptyUtil.isNullOrEmpty(list)){\n            return BeanConv.toBeanList(list, ResourceVo.class);\n        }\n        return null;\n    }\n}\n\n```\n\nspringboot-shiro-handler模块下的消费者UserBridgeServiceImpl\n\n```java\npackage com.itheima.shiro.client;\n\nimport com.itheima.shiro.constant.CacheConstant;\nimport com.itheima.shiro.core.SimpleCacheManager;\nimport com.itheima.shiro.core.base.ShiroUser;\nimport com.itheima.shiro.core.base.SimpleMapCache;\nimport com.itheima.shiro.core.base.SimpleToken;\nimport com.itheima.shiro.core.bridge.UserBridgeService;\nimport com.itheima.shiro.face.UserAdapterFace;\nimport com.itheima.shiro.utils.BeanConv;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport com.itheima.shiro.utils.ShiroUserUtil;\nimport com.itheima.shiro.vo.ResourceVo;\nimport com.itheima.shiro.vo.RoleVo;\nimport com.itheima.shiro.vo.UserVo;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.dubbo.config.annotation.Reference;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authc.UnknownAccountException;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.util.ByteSource;\nimport org.redisson.api.RBucket;\nimport org.redisson.api.RedissonClient;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\n\n/**\n * @Description 权限桥接器\n */\n@Slf4j\n@Component(\"userBridgeService\")\npublic class UserBridgeServiceImpl implements UserBridgeService {\n\n    @Reference(version = \"1.0.0\")\n    private UserAdapterFace userAdapterFace;\n\n    @Autowired\n    private SimpleCacheManager simpleCacheManager;\n\n    @javax.annotation.Resource(name = \"redissonClientForShiro\")\n    private RedissonClient redissonClient;\n\n    public AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken,String realmName) {\n        SimpleToken token = (SimpleToken)authcToken;\n        UserVo user  = this.findUserByLoginName(token.getUsername());\n        if(EmptyUtil.isNullOrEmpty(user)){\n            throw new UnknownAccountException(\"账号不存在\");\n        }\n        ShiroUser shiroUser = BeanConv.toBean(user, ShiroUser.class);\n        String sessionId = ShiroUserUtil.getShiroSessionId();\n        String cacheKeyResourcesIds = CacheConstant.RESOURCES_KEY_IDS+sessionId;\n        shiroUser.setResourceIds(this.findResourcesIdsList(cacheKeyResourcesIds,user.getId()));\n        String salt = user.getSalt();\n        String password = user.getPassWord();\n        return new SimpleAuthenticationInfo(shiroUser, password, ByteSource.Util.bytes(salt), realmName);\n    }\n\n    @Override\n    public SimpleAuthorizationInfo getAuthorizationInfo(ShiroUser shiroUser) {\n        UserVo user = BeanConv.toBean(shiroUser, UserVo.class);\n        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n        String sessionId = ShiroUserUtil.getShiroSessionId();\n        //查询用户拥有的角色\n        String cacheKeyRole = CacheConstant.ROLE_KEY + sessionId;\n        info.addRoles(this.findRoleList(cacheKeyRole, user.getId()));\n\n        //查询用户拥有的资源\n        String cacheKeyResources = CacheConstant.RESOURCES_KEY + sessionId;\n        info.addStringPermissions(this.findResourcesList(cacheKeyResources, user.getId()));\n        return info;\n    }\n\n\n    @Override\n    public List<String> findRoleList(String cacheKeyRole, String userId) {\n        List<RoleVo> roles = new ArrayList<RoleVo>();\n        if (simpleCacheManager.getCache(cacheKeyRole) != null) {\n            roles = (List<RoleVo>) simpleCacheManager.getCache(cacheKeyRole).get(cacheKeyRole);\n        } else {\n            roles = userAdapterFace.findRoleByUserId(userId);\n            if (roles.size() > 0) {\n                //用户角色存放到map\n                Map<Object, Object> mapRole = new HashMap<Object, Object>();\n                mapRole.put(cacheKeyRole, roles);\n                //新建SimpleMapCache实例并放入缓存管理器\n                SimpleMapCache cacheRole = new SimpleMapCache(cacheKeyRole, mapRole);\n                simpleCacheManager.createCache(cacheKeyRole, cacheRole);\n            }\n        }\n        List<String> rolesLabel = new ArrayList<String>();\n        for (RoleVo role : roles) {\n            rolesLabel.add(role.getLabel());\n        }\n        return rolesLabel;\n    }\n\n\n    @Override\n    public List<String> findResourcesList(String cacheKeyResources,String userId) {\n        List<ResourceVo> resourcesList = new ArrayList<ResourceVo>();\n        if (simpleCacheManager.getCache(cacheKeyResources) != null) {\n            resourcesList = (List<ResourceVo>) simpleCacheManager.getCache(cacheKeyResources).get(cacheKeyResources);\n        } else {\n            resourcesList = userAdapterFace.findResourceByUserId(userId);\n            if (resourcesList.size() > 0) {\n                //用户资源存放到map\n                Map<Object, Object> mapResource = new HashMap<Object, Object>();\n                mapResource.put(cacheKeyResources, resourcesList);\n                //新建SimpleMapCache实例并放入缓存管理器\n                SimpleMapCache cacheResource = new SimpleMapCache(cacheKeyResources, mapResource);\n                simpleCacheManager.createCache(cacheKeyResources, cacheResource);\n            }\n        }\n        List<String> resourcesLabel = new ArrayList<String>();\n        for (ResourceVo resources : resourcesList) {\n            resourcesLabel.add(resources.getLabel());\n        }\n        return resourcesLabel;\n    }\n\n\n    @Override\n    public UserVo findUserByLoginName(String loginName) {\n        String key = CacheConstant.FIND_USER_BY_LOGINNAME+loginName;\n        RBucket<UserVo> rBucket = redissonClient.getBucket(key);\n        UserVo user = rBucket.get();\n        if (!EmptyUtil.isNullOrEmpty(user)) {\n            return user;\n        }else {\n            user = userAdapterFace.findUserByLoginName(loginName);\n            if (!EmptyUtil.isNullOrEmpty(user)) {\n                rBucket.set(user, 300, TimeUnit.SECONDS);\n                return user;\n            }\n        }\n        rBucket.set(new UserVo(), 3, TimeUnit.SECONDS);\n        return null;\n    }\n\n    @Override\n    public List<String> findResourcesIdsList(String cacheKeyResources,String userId) {\n        List<ResourceVo> resourcesList = new ArrayList<ResourceVo>();\n        if (simpleCacheManager.getCache(cacheKeyResources) != null) {\n            resourcesList = (List<ResourceVo>) simpleCacheManager.getCache(cacheKeyResources).get(cacheKeyResources);\n        } else {\n            resourcesList = userAdapterFace.findResourceByUserId(userId);\n            if (resourcesList.size() > 0) {\n                //用户资源存放到map\n                Map<Object, Object> mapResource = new HashMap<Object, Object>();\n                mapResource.put(cacheKeyResources, resourcesList);\n                //新建SimpleMapCache实例并放入缓存管理器\n                SimpleMapCache cacheResource = new SimpleMapCache(cacheKeyResources, mapResource);\n                simpleCacheManager.createCache(cacheKeyResources, cacheResource);\n            }\n        }\n        List<String> resourcesLabel = new ArrayList<String>();\n        for (ResourceVo resources : resourcesList) {\n            resourcesLabel.add(resources.getId());\n        }\n        return resourcesLabel;\n    }\n\n    @Override\n    public void loadUserAuthorityToCache(ShiroUser user) {\n        String sessionId = user.getSessionId();\n        List<RoleVo> roles = userAdapterFace.findRoleByUserId(user.getId());\n        //创建角色cachaeKey\n        String cacheKeyRole = CacheConstant.ROLE_KEY + sessionId;\n        //用户角色存放到map\n        Map<Object, Object> mapRole = new HashMap<Object, Object>();\n        mapRole.put(cacheKeyRole, roles);\n        //新建SimpleMapCache实例并放入缓存管理器\n        SimpleMapCache cacheRole = new SimpleMapCache(cacheKeyRole, mapRole);\n        simpleCacheManager.createCache(cacheKeyRole, cacheRole);\n\n        List<ResourceVo> resourcesList = userAdapterFace.findResourceByUserId(user.getId());\n        if (resourcesList.size() > 0) {\n            //创建资源cachaeKey\n            String cacheKeyResources = CacheConstant.RESOURCES_KEY + sessionId;\n            //用户资源存放到map\n            Map<Object, Object> mapResource = new HashMap<Object, Object>();\n            mapResource.put(cacheKeyResources, resourcesList);\n            //新建SimpleMapCache实例并放入缓存管理器\n            SimpleMapCache cacheResource = new SimpleMapCache(cacheKeyResources, mapResource);\n            simpleCacheManager.createCache(cacheKeyResources, cacheResource);\n        }\n    }\n}\n\n```\n\n通过上面的改造，我们可以发现：用户在认证与鉴权时走的都是dubbo的服务，而在实际业务项目中不会再去操作鉴权相关的内容\n\n### 4、动态过滤器链\n\n在第十章中，我们加载过滤器链的方式\n\n```properties\n#静态资源不过滤\n/static/**=anon\n#登录链接不过滤\n/login/**=anon\n#访问/resource/**需要有admin的角色\n#/resource/**=roleOr[MangerRole,SuperAdmin]\n#/role/** =jwt-roles[SuperAdmin]\n/resource/** =jwt-perms[role:listInitialize]\n#其他链接是需要登录的\n/**=kicked-out,jwt-authc\n```\n\n在统计鉴权系统中，我们不可能每次发布新的过滤器链，就去重启服务器，我们更希望可以动态管理过滤器链\n\n#### 【1】需求分析\n\n实现动态过滤器链，我们需要保证以下几个特性：\n\n1、持久化：原有的properties内容放入数据库，\n\n2、有序性：因过滤器链有序加载的特性，读取过滤器链的时保证其有序性\n\n3、服务化：过滤器链的服务做成dubbo服务，做到集中式管理\n\n4、同步性：不同业务系统对于过滤器链的加载需要同步\n\n5、热加载：过滤器链修改之后，各个业务系统不需要重启服务，以达到热加载的目的\n\n![1582619578346](image\\1582619578346.png)\n\n#### 【2】代码实现\n\n##### 【2.1】持久化、有序化\n\n![1582683705723](image\\1582683705723.png)\n\n主要是对FilterChain类的CRUD这里就不做赘述，需要注意的是排序：升序排列，以保障过滤器链的有序加载\n\n##### 【2.2】服务化\n\n服务化过滤器链加载\n\n```properties\nFilterChainFace:过滤器链桥接器dubbo接口层\nFilterChainFaceImpl:过滤器链桥接器dubbo接口层实现\n```\n\nFilterChainFace接口\n\n```java\npackage com.itheima.shiro.face;\n\nimport com.itheima.shiro.vo.FilterChainVo;\n\nimport java.util.List;\n\n/**\n * @Description：过滤器查询接口\n */\npublic interface FilterChainFace {\n\n    public List<FilterChainVo> findFilterChainList();\n}\n\n```\n\nFilterChainFaceImpl\n\n```java\npackage com.itheima.shiro.faceImpl;\n\nimport com.itheima.shiro.face.FilterChainFace;\nimport com.itheima.shiro.pojo.FilterChain;\nimport com.itheima.shiro.service.FilterChainService;\nimport com.itheima.shiro.utils.BeanConv;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport com.itheima.shiro.vo.FilterChainVo;\nimport org.apache.dubbo.config.annotation.Service;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport java.util.List;\n\n/**\n * @Description：\n */\n@Service(version = \"1.0.0\", retries = 3,timeout = 5000)\npublic class FilterChainFaceImpl implements FilterChainFace {\n\n    @Autowired\n    FilterChainService filterChainService;\n\n    @Override\n    public List<FilterChainVo> findFilterChainList() {\n        List<FilterChain> filterChainList = filterChainService.findFilterChainList();\n        if (!EmptyUtil.isNullOrEmpty(filterChainList)){\n            return BeanConv.toBeanList(filterChainList, FilterChainVo.class);\n        }\n        return null;\n    }\n}\n\n```\n\n这里只是简单的dubbo服务，也不做赘述\n\n##### 【2.3】同步性\n\n定义启动加载过滤器链服务同步：\n\n```properties\nFilterChainBridgeService:过滤器链桥接器service接口层\nFilterChainBridgeServiceImpl:过滤器链桥接器service接口层实现\n\nShiroFilerChainService:shiro过滤器链服务加载接口\nShiroFilerChainService:shiro过滤器链服务加载接口实现\n\n```\n\nFilterChainBridgeService\n\n```java\npackage com.itheima.shiro.core.bridge;\n\nimport com.itheima.shiro.vo.FilterChainVo;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.util.List;\n\n/**\n * @Description 过滤器链service接口层\n */\npublic interface FilterChainBridgeService {\n\n    /**\n     * @Description 查询所有有效的过滤器链\n     * @return\n     */\n    List<FilterChainVo> findFilterChainList();\n\n\n\n}\n```\n\nFilterChainBridgeServiceImpl\n\n```java\npackage com.itheima.shiro.client;\n\nimport com.itheima.shiro.core.bridge.FilterChainBridgeService;\nimport com.itheima.shiro.face.FilterChainFace;\nimport com.itheima.shiro.vo.FilterChainVo;\nimport org.apache.dubbo.config.annotation.Reference;\nimport org.springframework.stereotype.Component;\n\nimport java.util.List;\n\n/**\n * @Description：\n */\n@Component(\"filterChainBridgeService\")\npublic class FilterChainBridgeServiceImpl implements FilterChainBridgeService {\n\n    @Reference(version = \"1.0.0\")\n    private FilterChainFace filterChainFace;\n\n    @Override\n    public List<FilterChainVo> findFilterChainList() {\n\n        return filterChainFace.findFilterChainList();\n    }\n}\n\n```\n\nShiroFilerChainService过滤器链同步接口\n\n```java\npackage com.itheima.shiro.service;\n\nimport com.itheima.shiro.vo.FilterChainVo;\n\nimport javax.annotation.PostConstruct;\nimport java.util.List;\n\n/**\n * @Description：过滤器链同步接口\n */\npublic interface ShiroFilerChainService {\n\n    /**\n     * @Description 启动时加载数据库中的过滤器链\n     */\n    void init();\n\n    /**\n     * @Description 初始化过滤器链\n     * @param\n     * @return\n     */\n    void initFilterChains(List<FilterChainVo> FilterChainVos);\n}\n\n```\n\nShiroFilerChainServiceImpl过滤器链同步接口实现\n\n```java\npackage com.itheima.shiro.service.impl;\n\nimport com.itheima.shiro.core.impl.CustomDefaultFilterChainManager;\nimport com.itheima.shiro.service.ShiroFilerChainService;\nimport com.itheima.shiro.core.bridge.FilterChainBridgeService;\nimport com.itheima.shiro.vo.FilterChainVo;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.shiro.web.filter.mgt.DefaultFilterChainManager;\nimport org.apache.shiro.web.filter.mgt.NamedFilterList;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport javax.annotation.PostConstruct;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @Description：过滤器链同步接口实现\n */\n@Service(\"shiroFilerChainManager\")\n@Log4j2\npublic class ShiroFilerChainServiceImpl implements ShiroFilerChainService {\n\n    //此时注入的为CustomDefaultFilterChainManager\n    @Autowired\n    private CustomDefaultFilterChainManager filterChainManager;\n\n    @Autowired\n    FilterChainBridgeService filterChainBridgeService;\n\n    private Map<String, NamedFilterList> defaultFilterChains;\n\n    private ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n\n    /**\n     * @Description 启动定时器，间隔2分钟同步数据库的过滤器链\n     */\n    @Override\n    @PostConstruct\n    public void init() {\n        defaultFilterChains = new LinkedHashMap<>();\n        executor.scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    initFilterChains(filterChainBridgeService.findFilterChainList());\n                } catch (Exception e) {\n                    log.error(e.getMessage(), e);\n                }\n            }\n        }, 0, 120, TimeUnit.SECONDS);\n\n    }\n\n    @Override\n    public void initFilterChains(List<FilterChainVo> FilterChainVos) {\n\n        //1、首先删除以前老的filter chain并注册默认的\n        filterChainManager.getFilterChains().clear();\n\n        //2、循环URL Filter 注册filter chain\n        for (FilterChainVo urlFilterVo : FilterChainVos) {\n            String url = urlFilterVo.getUrl();\n            String filterName = urlFilterVo.getFilterName();\n            String[] filterNames = filterName.split(\",\");\n            for (String name : filterNames) {\n                //注册所有filter，包含自定义的过滤器\n                switch(name){\n                    case \"anon\":\n                        filterChainManager.addToChain(url, name);\n                        break;\n                    case \"authc\":\n                        filterChainManager.addToChain(url, name);\n                        break;\n                    case \"roles\":\n                        filterChainManager.addToChain(url, name, urlFilterVo.getRoles());\n                        break;\n                    case \"perms\":\n                        filterChainManager.addToChain(url, name,urlFilterVo.getPermissions());\n                        break;\n                    case \"role-or\":\n                        filterChainManager.addToChain(url, name,urlFilterVo.getRoles());\n                        break;\n                    case \"kicked-out\":\n                        filterChainManager.addToChain(url, name);\n                        break;\n                    case \"jwt-authc\":\n                        filterChainManager.addToChain(url, name);\n                        break;\n                    case \"jwt-roles\":\n                        filterChainManager.addToChain(url, name, urlFilterVo.getRoles());\n                        break;\n                    case \"jwt-perms\":\n                        filterChainManager.addToChain(url, name,urlFilterVo.getPermissions());\n                        break;\n                    default:\n                        break;\n                }\n            }\n        }\n    }\n}\n\n```\n\n\n\n##### 【2.4】热加载\n\n为了实现热加载我们需要定义以下3个类\n\n```properties\nCustomDefaultFilterChainManager:自定义的默认过滤器链管理者\nCustomPathMatchingFilterChainResolver:自定义的路径匹配过滤器链解析器\nCustomShiroFilterFactoryBean:自定义shiro过滤器工厂bean\n```\n\n###### 【2.4.1】CustomDefaultFilterChainManager\n\n![1582685943872](image\\1582685943872.png)\n\n咱们来看下顶级接口FilterChainManager \n\n```java\npackage com.itheima.shiro.core.impl;\n\nimport org.apache.shiro.config.Ini;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.Nameable;\nimport org.apache.shiro.util.StringUtils;\nimport org.apache.shiro.web.config.IniFilterChainResolverFactory;\nimport org.apache.shiro.web.filter.AccessControlFilter;\nimport org.apache.shiro.web.filter.authc.AuthenticationFilter;\nimport org.apache.shiro.web.filter.authz.AuthorizationFilter;\nimport org.apache.shiro.web.filter.mgt.DefaultFilterChainManager;\nimport org.apache.shiro.web.filter.mgt.NamedFilterList;\nimport org.apache.shiro.web.filter.mgt.SimpleNamedFilterList;\n\nimport javax.annotation.PostConstruct;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @Description：自定义默认过滤器管理者\n */\npublic class CustomDefaultFilterChainManager extends DefaultFilterChainManager {\n\n    //登录地址\n    private String loginUrl;\n\n    //登录成功后默认跳转地址\n    private String successUrl;\n\n    //未授权跳转地址\n    private String unauthorizedUrl;\n\n    public CustomDefaultFilterChainManager() {\n        //构建过滤器\n        setFilters(new LinkedHashMap<String, Filter>());\n        //构建过滤器链\n        setFilterChains(new LinkedHashMap<String, NamedFilterList>());\n        //构建默认过滤器\n        addDefaultFilters(true);\n    }\n\n\n\n    /**\n     * @Description 注册我们自定义的过滤器，相当于ShiroFilterFactoryBean的filters属性\n     * @param customFilters 过滤器\n     * @return\n     */\n    public void setCustomFilters(Map<String, Filter> customFilters) {\n        for(Map.Entry<String, Filter> entry : customFilters.entrySet()) {\n            addFilter(entry.getKey(), entry.getValue(), false);\n        }\n    }\n\n\n    /**\n     * @Description Spring容器启动时调用\n     */\n    @PostConstruct\n    public void init() {\n        //配置默认过滤器\n        Map<String, Filter> filters = getFilters();\n\n        //为过滤器链配置全局URL处理属性\n        for (Filter filter : filters.values()) {\n            applyGlobalPropertiesIfNecessary(filter);\n        }\n    }\n\n    /**\n     * @Description 此时交于spring容器出事化，这里忽略\n     */\n    @Override\n    protected void initFilter(Filter filter) {\n    }\n\n    private void applyGlobalPropertiesIfNecessary(Filter filter) {\n        applyLoginUrlIfNecessary(filter);\n        applySuccessUrlIfNecessary(filter);\n        applyUnauthorizedUrlIfNecessary(filter);\n    }\n\n    private void applyLoginUrlIfNecessary(Filter filter) {\n        String loginUrl = getLoginUrl();\n        if (StringUtils.hasText(loginUrl) && (filter instanceof AccessControlFilter)) {\n            AccessControlFilter acFilter = (AccessControlFilter) filter;\n            //only apply the login url if they haven\'t explicitly configured one already:\n            String existingLoginUrl = acFilter.getLoginUrl();\n            if (AccessControlFilter.DEFAULT_LOGIN_URL.equals(existingLoginUrl)) {\n                acFilter.setLoginUrl(loginUrl);\n            }\n        }\n    }\n\n    private void applySuccessUrlIfNecessary(Filter filter) {\n        String successUrl = getSuccessUrl();\n        if (StringUtils.hasText(successUrl) && (filter instanceof AuthenticationFilter)) {\n            AuthenticationFilter authcFilter = (AuthenticationFilter) filter;\n            //only apply the successUrl if they haven\'t explicitly configured one already:\n            String existingSuccessUrl = authcFilter.getSuccessUrl();\n            if (AuthenticationFilter.DEFAULT_SUCCESS_URL.equals(existingSuccessUrl)) {\n                authcFilter.setSuccessUrl(successUrl);\n            }\n        }\n    }\n\n    private void applyUnauthorizedUrlIfNecessary(Filter filter) {\n        String unauthorizedUrl = getUnauthorizedUrl();\n        if (StringUtils.hasText(unauthorizedUrl) && (filter instanceof AuthorizationFilter)) {\n            AuthorizationFilter authzFilter = (AuthorizationFilter) filter;\n            //only apply the unauthorizedUrl if they haven\'t explicitly configured one already:\n            String existingUnauthorizedUrl = authzFilter.getUnauthorizedUrl();\n            if (existingUnauthorizedUrl == null) {\n                authzFilter.setUnauthorizedUrl(unauthorizedUrl);\n            }\n        }\n    }\n\n\n\n    public String getLoginUrl() {\n        return loginUrl;\n    }\n\n    public void setLoginUrl(String loginUrl) {\n        this.loginUrl = loginUrl;\n    }\n\n    public String getSuccessUrl() {\n        return successUrl;\n    }\n\n    public void setSuccessUrl(String successUrl) {\n        this.successUrl = successUrl;\n    }\n\n    public String getUnauthorizedUrl() {\n        return unauthorizedUrl;\n    }\n\n    public void setUnauthorizedUrl(String unauthorizedUrl) {\n        this.unauthorizedUrl = unauthorizedUrl;\n    }\n\n}\n\n```\n\nCustomDefaultFilterChainManager：主要是把原来对象的创建交于spring容器，同时指定过滤器，然后构建过滤器链\n\n```java\npackage com.itheima.shiro.core.impl;\n\nimport org.apache.shiro.config.Ini;\nimport org.apache.shiro.util.CollectionUtils;\nimport org.apache.shiro.util.Nameable;\nimport org.apache.shiro.util.StringUtils;\nimport org.apache.shiro.web.config.IniFilterChainResolverFactory;\nimport org.apache.shiro.web.filter.AccessControlFilter;\nimport org.apache.shiro.web.filter.authc.AuthenticationFilter;\nimport org.apache.shiro.web.filter.authz.AuthorizationFilter;\nimport org.apache.shiro.web.filter.mgt.DefaultFilterChainManager;\nimport org.apache.shiro.web.filter.mgt.NamedFilterList;\nimport org.apache.shiro.web.filter.mgt.SimpleNamedFilterList;\n\nimport javax.annotation.PostConstruct;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\n\n/**\n * @Description：自定义默认过滤器管理者\n */\npublic class CustomDefaultFilterChainManager extends DefaultFilterChainManager {\n\n    //登录地址\n    private String loginUrl;\n\n    //登录成功后默认跳转地址\n    private String successUrl;\n\n    //未授权跳转地址\n    private String unauthorizedUrl;\n\n    public CustomDefaultFilterChainManager() {\n        //构建过滤器\n        setFilters(new LinkedHashMap<String, Filter>());\n        //构建过滤器链\n        setFilterChains(new LinkedHashMap<String, NamedFilterList>());\n        //构建默认过滤器\n        addDefaultFilters(true);\n    }\n\n\n\n    /**\n     * @Description 注册我们自定义的过滤器，相当于ShiroFilterFactoryBean的filters属性\n     * @param customFilters 过滤器\n     * @return\n     */\n    public void setCustomFilters(Map<String, Filter> customFilters) {\n        for(Map.Entry<String, Filter> entry : customFilters.entrySet()) {\n            addFilter(entry.getKey(), entry.getValue(), false);\n        }\n    }\n\n\n    /**\n     * @Description Spring容器启动时调用\n     */\n    @PostConstruct\n    public void init() {\n        //配置默认过滤器\n        Map<String, Filter> filters = getFilters();\n        if (!CollectionUtils.isEmpty(filters)) {\n            //注册过滤器\n            for (Map.Entry<String, Filter> entry : filters.entrySet()) {\n                //过滤器名称\n                String name = entry.getKey();\n                //过滤器\n                Filter filter = entry.getValue();\n                if (filter instanceof Nameable) {\n                    ((Nameable) filter).setName(name);\n                }\n                //配置3个URL\n                applyGlobalPropertiesIfNecessary(filter);\n            }\n        }\n    }\n\n    /**\n     * @Description 此时交于spring容器出事化，这里忽略\n     */\n    @Override\n    protected void initFilter(Filter filter) {\n    }\n\n    private void applyGlobalPropertiesIfNecessary(Filter filter) {\n        applyLoginUrlIfNecessary(filter);\n        applySuccessUrlIfNecessary(filter);\n        applyUnauthorizedUrlIfNecessary(filter);\n    }\n\n    private void applyLoginUrlIfNecessary(Filter filter) {\n        String loginUrl = getLoginUrl();\n        if (StringUtils.hasText(loginUrl) && (filter instanceof AccessControlFilter)) {\n            AccessControlFilter acFilter = (AccessControlFilter) filter;\n            //only apply the login url if they haven\'t explicitly configured one already:\n            String existingLoginUrl = acFilter.getLoginUrl();\n            if (AccessControlFilter.DEFAULT_LOGIN_URL.equals(existingLoginUrl)) {\n                acFilter.setLoginUrl(loginUrl);\n            }\n        }\n    }\n\n    private void applySuccessUrlIfNecessary(Filter filter) {\n        String successUrl = getSuccessUrl();\n        if (StringUtils.hasText(successUrl) && (filter instanceof AuthenticationFilter)) {\n            AuthenticationFilter authcFilter = (AuthenticationFilter) filter;\n            //only apply the successUrl if they haven\'t explicitly configured one already:\n            String existingSuccessUrl = authcFilter.getSuccessUrl();\n            if (AuthenticationFilter.DEFAULT_SUCCESS_URL.equals(existingSuccessUrl)) {\n                authcFilter.setSuccessUrl(successUrl);\n            }\n        }\n    }\n\n    private void applyUnauthorizedUrlIfNecessary(Filter filter) {\n        String unauthorizedUrl = getUnauthorizedUrl();\n        if (StringUtils.hasText(unauthorizedUrl) && (filter instanceof AuthorizationFilter)) {\n            AuthorizationFilter authzFilter = (AuthorizationFilter) filter;\n            //only apply the unauthorizedUrl if they haven\'t explicitly configured one already:\n            String existingUnauthorizedUrl = authzFilter.getUnauthorizedUrl();\n            if (existingUnauthorizedUrl == null) {\n                authzFilter.setUnauthorizedUrl(unauthorizedUrl);\n            }\n        }\n    }\n\n\n\n    public String getLoginUrl() {\n        return loginUrl;\n    }\n\n    public void setLoginUrl(String loginUrl) {\n        this.loginUrl = loginUrl;\n    }\n\n    public String getSuccessUrl() {\n        return successUrl;\n    }\n\n    public void setSuccessUrl(String successUrl) {\n        this.successUrl = successUrl;\n    }\n\n    public String getUnauthorizedUrl() {\n        return unauthorizedUrl;\n    }\n\n    public void setUnauthorizedUrl(String unauthorizedUrl) {\n        this.unauthorizedUrl = unauthorizedUrl;\n    }\n\n}\n\n```\n\n###### 【2.4.2】CustomPathMatchingFilterChainResolver\n\n![1582687131628](image\\1582687131628.png)\n\n\n\n\n\n```java\n\npackage org.apache.shiro.web.filter.mgt;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\n\n\npublic interface FilterChainResolver {\n\n	//根据请求获得对应的过滤器链\n    FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain);\n\n}\n\n```\n\nCustomPathMatchingFilterChainResolver\n\n这里主要核心内容是：指定使用过滤器链管理器为自己定的过滤器管理器\n\n```java\npackage com.itheima.shiro.core.impl;\n\nimport org.apache.shiro.web.filter.mgt.FilterChainManager;\nimport org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport javax.servlet.FilterChain;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport java.util.ArrayList;\nimport java.util.List;\n\n\npublic class CustomPathMatchingFilterChainResolver extends PathMatchingFilterChainResolver {\n\n    private CustomDefaultFilterChainManager customDefaultFilterChainManager;\n\n    public void setCustomDefaultFilterChainManager(CustomDefaultFilterChainManager customDefaultFilterChainManager) {\n        this.customDefaultFilterChainManager = customDefaultFilterChainManager;\n    }\n\n    public CustomDefaultFilterChainManager getCustomDefaultFilterChainManager() {\n        return customDefaultFilterChainManager;\n    }\n\n    @Override\n    public FilterChain getChain(ServletRequest request, ServletResponse response, FilterChain originalChain) {\n        //指定使用过滤器链管理器为自己定的过滤器管理器\n        FilterChainManager filterChainManager = getCustomDefaultFilterChainManager();\n        if (!filterChainManager.hasChains()) {\n            return null;\n        }\n\n        String requestURI = getPathWithinApplication(request);\n\n        List<String> chainNames = new ArrayList<String>();\n        //the \'chain names\' in this implementation are actually path patterns defined by the user.  We just use them\n        //as the chain name for the FilterChainManager\'s requirements\n        for (String pathPattern : filterChainManager.getChainNames()) {\n\n            // If the path does match, then pass on to the subclass implementation for specific checks:\n            if (pathMatches(pathPattern, requestURI)) {\n                return filterChainManager.proxy(originalChain, pathPattern);\n            }\n        }\n        return null;\n    }\n}\n\n```\n\n###### 【2.4.3】CustomShiroFilterFactoryBean\n\n![1582688545621](image\\1582688545621.png)\n\n\n\n\n\n```java\nprotected AbstractShiroFilter createInstance() throws Exception {\n\n        log.debug(\"Creating Shiro Filter instance.\");\n\n        SecurityManager securityManager = getSecurityManager();\n        if (securityManager == null) {\n            String msg = \"SecurityManager property must be set.\";\n            throw new BeanInitializationException(msg);\n        }\n\n        if (!(securityManager instanceof WebSecurityManager)) {\n            String msg = \"The security manager does not implement the WebSecurityManager interface.\";\n            throw new BeanInitializationException(msg);\n        }\n\n        FilterChainManager manager = createFilterChainManager();\n\n        //Expose the constructed FilterChainManager by first wrapping it in a\n        // FilterChainResolver implementation. The AbstractShiroFilter implementations\n        // do not know about FilterChainManagers - only resolvers:\n        PathMatchingFilterChainResolver chainResolver = new PathMatchingFilterChainResolver();\n        chainResolver.setFilterChainManager(manager);\n\n        //Now create a concrete ShiroFilter instance and apply the acquired SecurityManager and built\n        //FilterChainResolver.  It doesn\'t matter that the instance is an anonymous inner class\n        //here - we\'re just using it because it is a concrete AbstractShiroFilter instance that accepts\n        //injection of the SecurityManager and FilterChainResolver:\n        return new SpringShiroFilter((WebSecurityManager) securityManager, chainResolver);\n    }\n```\n\nShiroFilterFactoryBean源码我们发现PathMatchingFilterChainResolver未暴露set方法，我们改写一下\n\n```java\npackage com.itheima.shiro.core.impl;\n\nimport org.apache.shiro.mgt.SecurityManager;\nimport org.apache.shiro.spring.web.ShiroFilterFactoryBean;\nimport org.apache.shiro.web.filter.mgt.FilterChainManager;\nimport org.apache.shiro.web.filter.mgt.FilterChainResolver;\nimport org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver;\nimport org.apache.shiro.web.mgt.WebSecurityManager;\nimport org.apache.shiro.web.servlet.AbstractShiroFilter;\nimport org.springframework.beans.factory.BeanInitializationException;\n\n/**\n * @Description：\n */\npublic class CustomShiroFilterFactoryBean extends ShiroFilterFactoryBean {\n\n    PathMatchingFilterChainResolver chainResolver ;\n\n    public void setChainResolver(PathMatchingFilterChainResolver chainResolver) {\n        this.chainResolver = chainResolver;\n    }\n\n    @Override\n    protected AbstractShiroFilter createInstance() throws Exception {\n\n\n        SecurityManager securityManager = getSecurityManager();\n        if (securityManager == null) {\n            String msg = \"SecurityManager property must be set.\";\n            throw new BeanInitializationException(msg);\n        }\n\n        if (!(securityManager instanceof WebSecurityManager)) {\n            String msg = \"The security manager does not implement the WebSecurityManager interface.\";\n            throw new BeanInitializationException(msg);\n        }\n\n        FilterChainManager manager = createFilterChainManager();\n\n\n        chainResolver.setFilterChainManager(manager);\n\n        //Now create a concrete ShiroFilter instance and apply the acquired SecurityManager and built\n        //FilterChainResolver.  It doesn\'t matter that the instance is an anonymous inner class\n        //here - we\'re just using it because it is a concrete AbstractShiroFilter instance that accepts\n        //injection of the SecurityManager and FilterChainResolver:\n        return new SpringShiroFilter((WebSecurityManager) securityManager, chainResolver);\n    }\n\n    private static final class SpringShiroFilter extends AbstractShiroFilter {\n\n        protected SpringShiroFilter(WebSecurityManager webSecurityManager, FilterChainResolver resolver) {\n            super();\n            if (webSecurityManager == null) {\n                throw new IllegalArgumentException(\"WebSecurityManager property cannot be null.\");\n            }\n            setSecurityManager(webSecurityManager);\n            if (resolver != null) {\n                setFilterChainResolver(resolver);\n            }\n        }\n    }\n}\n\n```\n\n###### 【2.4.4】ShiroConfig改造\n\n```java\npackage com.itheima.shiro.config;\n\n\nimport com.itheima.shiro.constant.SuperConstant;\nimport com.itheima.shiro.core.ShiroDbRealm;\nimport com.itheima.shiro.core.filter.*;\nimport com.itheima.shiro.core.impl.*;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.shiro.authc.credential.HashedCredentialsMatcher;\nimport org.apache.shiro.session.mgt.eis.SessionDAO;\nimport org.apache.shiro.spring.LifecycleBeanPostProcessor;\nimport org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor;\nimport org.apache.shiro.web.mgt.DefaultWebSecurityManager;\nimport org.apache.shiro.web.servlet.SimpleCookie;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.context.properties.EnableConfigurationProperties;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.ComponentScan;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.DependsOn;\n\nimport javax.servlet.Filter;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * @Description 权限配置类\n */\n@Configuration\n@ComponentScan(basePackages = {\"com.itheima.shiro.core\"})\n@EnableConfigurationProperties({ShiroRedisProperties.class})\n@Log4j2\npublic class ShiroConfig {\n\n    @Autowired\n    private ShiroRedisProperties shiroRedisProperties;\n\n    @Autowired\n    JwtTokenManager jwtTokenManager;\n\n    /**\n     * @Description redission客户端\n     */\n    @Bean(\"redissonClientForShiro\")\n    public RedissonClient redissonClient() {\n        log.info(\"=====初始化redissonClientForShiro开始======\");\n        String[] nodeList = shiroRedisProperties.getNodes().split(\",\");\n        Config config = new Config();\n        if (nodeList.length == 1) {\n            config.useSingleServer().setAddress(nodeList[0])\n                    .setConnectTimeout(shiroRedisProperties.getConnectTimeout())\n                    .setConnectionMinimumIdleSize(shiroRedisProperties.getConnectionMinimumidleSize())\n                    .setConnectionPoolSize(shiroRedisProperties.getConnectPoolSize()).setTimeout(shiroRedisProperties.getTimeout());\n        } else {\n            config.useClusterServers().addNodeAddress(nodeList)\n                    .setConnectTimeout(shiroRedisProperties.getConnectTimeout())\n                    .setMasterConnectionMinimumIdleSize(shiroRedisProperties.getConnectionMinimumidleSize())\n                    .setMasterConnectionPoolSize(shiroRedisProperties.getConnectPoolSize()).setTimeout(shiroRedisProperties.getTimeout());\n        }\n        RedissonClient redissonClient =  Redisson.create(config);\n        log.info(\"=====初始化redissonClientForShiro完成======\");\n        return redissonClient;\n    }\n\n    /**\n     * @Description 创建cookie对象\n     */\n    @Bean(name=\"sessionIdCookie\")\n    public SimpleCookie simpleCookie(){\n        SimpleCookie simpleCookie = new SimpleCookie();\n        simpleCookie.setName(\"ShiroSession\");\n        return simpleCookie;\n    }\n\n    /**\n     * @Description 缓存管理器\n     * @param\n     * @return\n     */\n    @Bean(name=\"shiroCacheManager\")\n    public ShiroCacheManager shiroCacheManager(){\n        return new ShiroCacheManager(shiroRedisProperties.getGlobalSessionTimeout());\n    }\n\n    /**\n     * @Description 权限管理器\n     * @param\n     * @return\n     */\n    @Bean(name=\"securityManager\")\n    public DefaultWebSecurityManager defaultWebSecurityManager(){\n        DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n        securityManager.setRealm(shiroDbRealm());\n        securityManager.setSessionManager(shiroSessionManager());\n        securityManager.setCacheManager(shiroCacheManager());\n        return securityManager;\n    }\n\n    /**\n     * @Description 密码比较器\n     */\n    @Bean\n    public HashedCredentialsMatcher hashedCredentialsMatcher (){\n        RetryLimitCredentialsMatcher matcher = new RetryLimitCredentialsMatcher(SuperConstant.HASH_ALGORITHM);\n        matcher.setHashIterations(SuperConstant.HASH_INTERATIONS);\n        return matcher;\n    }\n    /**\n     * @Description 自定义RealmImpl\n     */\n    @Bean(name=\"shiroDbRealm\")\n    public ShiroDbRealm shiroDbRealm(){\n        ShiroDbRealm shiroDbRealm =new ShiroDbRealmImpl();\n        shiroDbRealm.setCredentialsMatcher(hashedCredentialsMatcher());\n        return shiroDbRealm;\n    }\n\n\n    /**\n     * @Description 自定义session会话存储的实现类 ，使用Redis来存储共享session，达到分布式部署目的\n     */\n    @Bean(\"redisSessionDao\")\n    public SessionDAO redisSessionDao(){\n        RedisSessionDao sessionDAO =   new RedisSessionDao();\n        sessionDAO.setGlobalSessionTimeout(shiroRedisProperties.getGlobalSessionTimeout());\n        return sessionDAO;\n    }\n\n    /**\n     * @Description 会话管理器\n     */\n    @Bean(name=\"sessionManager\")\n    public ShiroSessionManager shiroSessionManager(){\n        ShiroSessionManager sessionManager = new ShiroSessionManager();\n        sessionManager.setSessionDAO(redisSessionDao());\n        sessionManager.setSessionValidationSchedulerEnabled(false);\n        sessionManager.setSessionIdCookieEnabled(true);\n        sessionManager.setSessionIdCookie(simpleCookie());\n        sessionManager.setGlobalSessionTimeout(shiroRedisProperties.getGlobalSessionTimeout());\n        return sessionManager;\n    }\n\n    /**\n     * @Description 保证实现了Shiro内部lifecycle函数的bean执行\n     */\n    @Bean(name = \"lifecycleBeanPostProcessor\")\n    public static LifecycleBeanPostProcessor getLifecycleBeanPostProcessor() {\n        return new LifecycleBeanPostProcessor();\n    }\n\n    /**\n     * @Description AOP式方法级权限检查\n     */\n    @Bean\n    @DependsOn(\"lifecycleBeanPostProcessor\")\n    public DefaultAdvisorAutoProxyCreator getDefaultAdvisorAutoProxyCreator() {\n        DefaultAdvisorAutoProxyCreator defaultAdvisorAutoProxyCreator = new DefaultAdvisorAutoProxyCreator();\n        defaultAdvisorAutoProxyCreator.setProxyTargetClass(true);\n        return defaultAdvisorAutoProxyCreator;\n    }\n\n    /**\n     * @Description 配合DefaultAdvisorAutoProxyCreator事项注解权限校验\n     */\n    @Bean\n    public AuthorizationAttributeSourceAdvisor getAuthorizationAttributeSourceAdvisor() {\n        AuthorizationAttributeSourceAdvisor aasa = new AuthorizationAttributeSourceAdvisor();\n        aasa.setSecurityManager(defaultWebSecurityManager());\n        return new AuthorizationAttributeSourceAdvisor();\n    }\n\n    /**\n     * @Description 自定义拦截器定义\n     */\n    private Map<String, Filter> filters() {\n        Map<String, Filter> map = new HashMap<String, Filter>();\n        map.put(\"role-or\", new RolesOrAuthorizationFilter());\n        map.put(\"kicked-out\", new KickedOutAuthorizationFilter(redissonClient(), redisSessionDao(), shiroSessionManager()));\n        map.put(\"jwt-authc\", new JwtAuthcFilter(jwtTokenManager));\n        map.put(\"jwt-perms\", new JwtPermsFilter());\n        map.put(\"jwt-roles\", new JwtRolesFilter());\n        return map;\n    }\n\n    /**\n     * @Description Shiro过滤器\n     */\n    @Bean(\"shiroFilter\")\n    public CustomShiroFilterFactoryBean shiroFilterFactoryBean(){\n        CustomShiroFilterFactoryBean shiroFilter = new CustomShiroFilterFactoryBean();\n        shiroFilter.setSecurityManager(defaultWebSecurityManager());\n        shiroFilter.setChainResolver(filterChainResolver());\n        return shiroFilter;\n    }\n\n    @Bean\n    public CustomDefaultFilterChainManager defaultFilterChainManager(){\n        CustomDefaultFilterChainManager filterChainManager = new CustomDefaultFilterChainManager();\n        filterChainManager.setLoginUrl(\"/login\");\n        filterChainManager.setUnauthorizedUrl(\"/login\");\n        filterChainManager.setCustomFilters(filters());\n        return filterChainManager;\n    }\n\n    @Bean\n    CustomPathMatchingFilterChainResolver filterChainResolver(){\n        CustomPathMatchingFilterChainResolver pathMatchingFilterChainResolver = new CustomPathMatchingFilterChainResolver();\n        pathMatchingFilterChainResolver.setCustomDefaultFilterChainManager(defaultFilterChainManager());\n        return pathMatchingFilterChainResolver;\n    }\n\n}\n\n```\n\n\n\n### 5、shiro-client客户端\n\nshiro-client作为jar的依赖，满足以下需求：\n\n1、非侵入式：使用者只需要对jar依赖和做少量的配置，就可以达到统一鉴权的目标\n\n2、可扩展性：用户除使用提供的过滤器外，可以轻松安自己的业务区定义过滤器\n\n3、集中式管理：依赖jar之后，shiro-mgt后台可以同时管控多个平台的权限的认证、鉴权、及动态配置过滤器链\n\n#### 【1】模块依赖关系\n\n![1582688991837](image\\1582688991837.png)\n\n#### 【2】原理分析\n\nspringboot-shiro-framework-client项目向上继承了springboot-shiro-framework-core项目，springboot-shiro-framework-core是主要实现认证、鉴权、过滤器定义、会话统一、realm缓存的核心项目。\n\nspringboot-shiro-framework-client项目以jar的方式被需要做权限控制的gateway项目所依赖，再由gateway通过对springboot-shiro-producer的dubbo消费，以达到统一认证、鉴权\n\nspringboot-shiro-framework-client模块实现了springboot-shiro-framework-core接口的3个类：\n\n```properties\nUserBridgeServiceImpl:提供用户基本资源操作的业务实现\nFilterChainBridgeServiceImpl:提供过滤器链接口的查询\nResourceBridgeServiceImpl:提供资源查询\n```\n\nUserBridgeServiceImpl\n\n```java\npackage com.itheima.shiro.client;\n\nimport com.itheima.shiro.constant.CacheConstant;\nimport com.itheima.shiro.core.SimpleCacheManager;\nimport com.itheima.shiro.core.base.ShiroUser;\nimport com.itheima.shiro.core.base.SimpleMapCache;\nimport com.itheima.shiro.core.base.SimpleToken;\nimport com.itheima.shiro.core.bridge.UserBridgeService;\nimport com.itheima.shiro.face.UserAdapterFace;\nimport com.itheima.shiro.utils.BeanConv;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport com.itheima.shiro.utils.ShiroUserUtil;\nimport com.itheima.shiro.vo.ResourceVo;\nimport com.itheima.shiro.vo.RoleVo;\nimport com.itheima.shiro.vo.UserVo;\nimport lombok.extern.slf4j.Slf4j;\nimport org.apache.dubbo.config.annotation.Reference;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authc.UnknownAccountException;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.util.ByteSource;\nimport org.redisson.api.RBucket;\nimport org.redisson.api.RedissonClient;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.TimeUnit;\n\n\n/**\n * @Description 权限桥接器\n */\n@Slf4j\n@Component(\"userBridgeService\")\npublic class UserBridgeServiceImpl implements UserBridgeService {\n\n    @Reference(version = \"1.0.0\")\n    private UserAdapterFace userAdapterFace;\n\n    @Autowired\n    private SimpleCacheManager simpleCacheManager;\n\n    @javax.annotation.Resource(name = \"redissonClientForShiro\")\n    private RedissonClient redissonClient;\n\n    public AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken,String realmName) {\n        SimpleToken token = (SimpleToken)authcToken;\n        UserVo user  = this.findUserByLoginName(token.getUsername());\n        if(EmptyUtil.isNullOrEmpty(user)){\n            throw new UnknownAccountException(\"账号不存在\");\n        }\n        ShiroUser shiroUser = BeanConv.toBean(user, ShiroUser.class);\n        String sessionId = ShiroUserUtil.getShiroSessionId();\n        String cacheKeyResourcesIds = CacheConstant.RESOURCES_KEY_IDS+sessionId;\n        shiroUser.setResourceIds(this.findResourcesIdsList(cacheKeyResourcesIds,user.getId()));\n        String salt = user.getSalt();\n        String password = user.getPassWord();\n        return new SimpleAuthenticationInfo(shiroUser, password, ByteSource.Util.bytes(salt), realmName);\n    }\n\n    @Override\n    public SimpleAuthorizationInfo getAuthorizationInfo(ShiroUser shiroUser) {\n        UserVo user = BeanConv.toBean(shiroUser, UserVo.class);\n        SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n        String sessionId = ShiroUserUtil.getShiroSessionId();\n        //查询用户拥有的角色\n        String cacheKeyRole = CacheConstant.ROLE_KEY + sessionId;\n        info.addRoles(this.findRoleList(cacheKeyRole, user.getId()));\n\n        //查询用户拥有的资源\n        String cacheKeyResources = CacheConstant.RESOURCES_KEY + sessionId;\n        info.addStringPermissions(this.findResourcesList(cacheKeyResources, user.getId()));\n        return info;\n    }\n\n\n    @Override\n    public List<String> findRoleList(String cacheKeyRole, String userId) {\n        List<RoleVo> roles = new ArrayList<RoleVo>();\n        if (simpleCacheManager.getCache(cacheKeyRole) != null) {\n            roles = (List<RoleVo>) simpleCacheManager.getCache(cacheKeyRole).get(cacheKeyRole);\n        } else {\n            roles = userAdapterFace.findRoleByUserId(userId);\n            if (roles.size() > 0) {\n                //用户角色存放到map\n                Map<Object, Object> mapRole = new HashMap<Object, Object>();\n                mapRole.put(cacheKeyRole, roles);\n                //新建SimpleMapCache实例并放入缓存管理器\n                SimpleMapCache cacheRole = new SimpleMapCache(cacheKeyRole, mapRole);\n                simpleCacheManager.createCache(cacheKeyRole, cacheRole);\n            }\n        }\n        List<String> rolesLabel = new ArrayList<String>();\n        for (RoleVo role : roles) {\n            rolesLabel.add(role.getLabel());\n        }\n        return rolesLabel;\n    }\n\n\n    @Override\n    public List<String> findResourcesList(String cacheKeyResources,String userId) {\n        List<ResourceVo> resourcesList = new ArrayList<ResourceVo>();\n        if (simpleCacheManager.getCache(cacheKeyResources) != null) {\n            resourcesList = (List<ResourceVo>) simpleCacheManager.getCache(cacheKeyResources).get(cacheKeyResources);\n        } else {\n            resourcesList = userAdapterFace.findResourceByUserId(userId);\n            if (resourcesList.size() > 0) {\n                //用户资源存放到map\n                Map<Object, Object> mapResource = new HashMap<Object, Object>();\n                mapResource.put(cacheKeyResources, resourcesList);\n                //新建SimpleMapCache实例并放入缓存管理器\n                SimpleMapCache cacheResource = new SimpleMapCache(cacheKeyResources, mapResource);\n                simpleCacheManager.createCache(cacheKeyResources, cacheResource);\n            }\n        }\n        List<String> resourcesLabel = new ArrayList<String>();\n        for (ResourceVo resources : resourcesList) {\n            resourcesLabel.add(resources.getLabel());\n        }\n        return resourcesLabel;\n    }\n\n\n    @Override\n    public UserVo findUserByLoginName(String loginName) {\n        String key = CacheConstant.FIND_USER_BY_LOGINNAME+loginName;\n        RBucket<UserVo> rBucket = redissonClient.getBucket(key);\n        UserVo user = rBucket.get();\n        if (!EmptyUtil.isNullOrEmpty(user)) {\n            return user;\n        }else {\n            user = userAdapterFace.findUserByLoginName(loginName);\n            if (!EmptyUtil.isNullOrEmpty(user)) {\n                rBucket.set(user, 300, TimeUnit.SECONDS);\n                return user;\n            }\n        }\n        rBucket.set(new UserVo(), 3, TimeUnit.SECONDS);\n        return null;\n    }\n\n    @Override\n    public List<String> findResourcesIdsList(String cacheKeyResources,String userId) {\n        List<ResourceVo> resourcesList = new ArrayList<ResourceVo>();\n        if (simpleCacheManager.getCache(cacheKeyResources) != null) {\n            resourcesList = (List<ResourceVo>) simpleCacheManager.getCache(cacheKeyResources).get(cacheKeyResources);\n        } else {\n            resourcesList = userAdapterFace.findResourceByUserId(userId);\n            if (resourcesList.size() > 0) {\n                //用户资源存放到map\n                Map<Object, Object> mapResource = new HashMap<Object, Object>();\n                mapResource.put(cacheKeyResources, resourcesList);\n                //新建SimpleMapCache实例并放入缓存管理器\n                SimpleMapCache cacheResource = new SimpleMapCache(cacheKeyResources, mapResource);\n                simpleCacheManager.createCache(cacheKeyResources, cacheResource);\n            }\n        }\n        List<String> resourcesLabel = new ArrayList<String>();\n        for (ResourceVo resources : resourcesList) {\n            resourcesLabel.add(resources.getId());\n        }\n        return resourcesLabel;\n    }\n\n    @Override\n    public void loadUserAuthorityToCache(ShiroUser user) {\n        String sessionId = user.getSessionId();\n        List<RoleVo> roles = userAdapterFace.findRoleByUserId(user.getId());\n        //创建角色cachaeKey\n        String cacheKeyRole = CacheConstant.ROLE_KEY + sessionId;\n        //用户角色存放到map\n        Map<Object, Object> mapRole = new HashMap<Object, Object>();\n        mapRole.put(cacheKeyRole, roles);\n        //新建SimpleMapCache实例并放入缓存管理器\n        SimpleMapCache cacheRole = new SimpleMapCache(cacheKeyRole, mapRole);\n        simpleCacheManager.createCache(cacheKeyRole, cacheRole);\n\n        List<ResourceVo> resourcesList = userAdapterFace.findResourceByUserId(user.getId());\n        if (resourcesList.size() > 0) {\n            //创建资源cachaeKey\n            String cacheKeyResources = CacheConstant.RESOURCES_KEY + sessionId;\n            //用户资源存放到map\n            Map<Object, Object> mapResource = new HashMap<Object, Object>();\n            mapResource.put(cacheKeyResources, resourcesList);\n            //新建SimpleMapCache实例并放入缓存管理器\n            SimpleMapCache cacheResource = new SimpleMapCache(cacheKeyResources, mapResource);\n            simpleCacheManager.createCache(cacheKeyResources, cacheResource);\n        }\n    }\n}\n\n```\n\nFilterChainBridgeServiceImpl\n\n```java\npackage com.itheima.shiro.client;\n\nimport com.itheima.shiro.core.bridge.FilterChainBridgeService;\nimport com.itheima.shiro.face.FilterChainFace;\nimport com.itheima.shiro.vo.FilterChainVo;\nimport org.apache.dubbo.config.annotation.Reference;\nimport org.springframework.stereotype.Component;\n\nimport java.util.List;\n\n/**\n * @Description：过滤器链查询\n */\n@Component(\"filterChainBridgeService\")\npublic class FilterChainBridgeServiceImpl implements FilterChainBridgeService {\n\n    @Reference(version = \"1.0.0\")\n    private FilterChainFace filterChainFace;\n\n\n    @Override\n    public List<FilterChainVo> findFilterChainList() {\n\n        return filterChainFace.findFilterChainList();\n    }\n}\n\n```\n\nResourceBridgeServiceImpl\n\n```java\npackage com.itheima.shiro.client;\n\nimport com.itheima.shiro.core.bridge.ResourceBridgeService;\nimport com.itheima.shiro.face.ResourceAdapterFace;\nimport com.itheima.shiro.vo.ResourceVo;\nimport org.apache.dubbo.config.annotation.Reference;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport java.util.List;\n\n/**\n * @Description：查询资源\n */\n@Component(\"resourceBridgeService\")\npublic class ResourceBridgeServiceImpl implements ResourceBridgeService {\n\n    @Value(\"${itheima.resource.systemcode}\")\n    private String systemCode;\n\n    @Reference(version = \"1.0.0\")\n    ResourceAdapterFace resourceAdapterFace;\n\n    @Override\n    public List<ResourceVo> findValidResourceVoAll(String systemCode) {\n        return resourceAdapterFace.findValidResourceVoAll(systemCode);\n    }\n}\n\n```\n\n从中我们可以看到3个类调用了springboot-shiro-handler中提供的dubbo鉴权服务化内容\n\n### 6、shiro-gateway网关\n\n#### 【1】原理分析\n\n![1582880165581](image/1582880165581.png)\n\n​	1、依赖springboot-shiro-framework-client实现认证、鉴权、过滤器定义、会话统一、realm缓存等功能\n\n​	2、springboot-shiro-mgt管理后台持久化网关资源\n\n​	3、springboot-shiro-handler实现网关资源查询服务化\n\n​	4、gateway-service依据持久化的网关资源，动态创建消费端服务\n\n#### 【2】代码实现\n\n##### 【2.1】网关资源持久化\n\n这里在原有资源的基础上，增加的网关资源的管理：\n\n​		1、定义网关systemcode，用以区分不同网关系统\n\n​		2、定义访问的路径\n\n​		3、定义资源的唯一标识，作为权限控制的标识\n\n​		4、定义业务端dubbo服务端接口、目标方法、传入阐述、轮训算法、超时时间、重试次数等参数，这些内容会在gateway-service项目中解析\n\n![1582704703769](image/1582704703769.png)\n\n\n\n##### 【2.2】网关资源服务化\n\n```properties\nResourceAdapterFace:网关资源服务接口\nResourceAdapterFaceImpl:网关资源服务接口实现\n\nResourceBridgeService:网关资源桥接器接口\nResourceBridgeServiceImpl:网关资源桥接器接口实现\n```\n\nResourceAdapterFace\n\n```java\npackage com.itheima.shiro.face;\n\nimport com.itheima.shiro.vo.ResourceVo;\n\nimport java.util.List;\n\n/**\n * @Description：网关资源服务接口\n */\npublic interface ResourceAdapterFace {\n\n    /**\n     * @Description 获得当前系统是由有效的dubbo的资源\n     */\n    List<ResourceVo> findValidResourceVoAll(String systemCode);\n}\n\n```\n\nResourceAdapterFaceImpl\n\n```java\npackage com.itheima.shiro.faceImpl;\n\nimport com.itheima.shiro.face.ResourceAdapterFace;\nimport com.itheima.shiro.pojo.Resource;\nimport com.itheima.shiro.service.ResourceService;\nimport com.itheima.shiro.utils.BeanConv;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport com.itheima.shiro.vo.ResourceVo;\nimport org.apache.dubbo.config.annotation.Service;\nimport org.springframework.beans.factory.annotation.Autowired;\n\nimport java.util.List;\n\n/**\n * @Description：网关资源服务接口实现\n */\n@Service(version = \"1.0.0\", retries = 3,timeout = 5000)\npublic class ResourceAdapterFaceImpl implements ResourceAdapterFace {\n\n    @Autowired\n    ResourceService resourceService;\n\n    @Override\n    public List<ResourceVo> findValidResourceVoAll(String systemCode) {\n        List<Resource> resourceList =  resourceService.findValidResourceVoAll(systemCode);\n        if (!EmptyUtil.isNullOrEmpty(resourceList)){\n            return BeanConv.toBeanList(resourceList, ResourceVo.class);\n        }\n        return  null;\n    }\n}\n\n```\n\nResourceBridgeService\n\n```java\npackage com.itheima.shiro.core.bridge;\n\nimport com.itheima.shiro.vo.ResourceVo;\n\nimport java.util.List;\n\n/**\n * @Description：网关资源桥接器接口\n */\npublic interface ResourceBridgeService {\n\n    /**\n     * @Description 查询当前系统所有有效的DUBBO类型的服务\n     * @param systemCode 系统编号：与mgt添加系统编号相同\n     * @return\n     */\n    public List<ResourceVo> findValidResourceVoAll(String systemCode);\n}\n\n```\n\nResourceBridgeServiceImpl\n\n```java\npackage com.itheima.shiro.client;\n\nimport com.itheima.shiro.core.bridge.ResourceBridgeService;\nimport com.itheima.shiro.face.ResourceAdapterFace;\nimport com.itheima.shiro.vo.ResourceVo;\nimport org.apache.dubbo.config.annotation.Reference;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\nimport java.util.List;\n\n/**\n * @Description：网关资源桥接器接口实现\n */\n@Component(\"resourceBridgeService\")\npublic class ResourceBridgeServiceImpl implements ResourceBridgeService {\n\n    @Value(\"${itheima.resource.systemcode}\")\n    private String systemCode;\n\n    @Reference(version = \"1.0.0\")\n    ResourceAdapterFace resourceAdapterFace;\n\n    @Override\n    public List<ResourceVo> findValidResourceVoAll(String systemCode) {\n        return resourceAdapterFace.findValidResourceVoAll(systemCode);\n    }\n}\n\n```\n\n\n\n##### 【2.3】动态消费端\n\n![1582882166870](image/1582882166870.png)\n\n```properties\nCacheWare:缓存仓库\n\nCacheWareService:缓存仓库服务接口\nCacheWareServiceImpl:缓存仓库服务接口实现\n\nCacheWareSyncService:缓存仓库同步服务接口\nCacheWareSyncServiceImpl:缓存仓库同步服务接口实现\n\nLoginAction:登录相应接口\nGateWayController:相应层的统一入口\n```\n\n\n\n###### 【2.3.1】CacheWareService\n\n其主要负责：\n\n1、缓存的清除\n\n2、向map容器中创建缓存\n\n3、获得缓存仓库执行对象\n\n```java\npackage com.itheima.shiro.cache;\n\nimport com.google.common.collect.Multimap;\nimport com.itheima.shiro.pojo.CacheWare;\n\n/**\n * @Description：缓存仓库服务\n */\npublic interface CacheWareService {\n\n    /**\n     * @Description 清除缓存\n     */\n    void clearCacheWare();\n\n    /**\n     * @Description 向map容器中创建缓存\n     * @param CacheWareMap\n     */\n    void createCacheWare(Multimap<String, CacheWare> CacheWareMap);\n\n    /**\n     * @Description 获得缓存仓库执行对象\n     * @param serviceName 服务名\n     * @param methodName  方法名\n     * @return {@link CacheWare}\n     *\n     */\n    CacheWare queryCacheWare(String serviceName, String methodName);\n\n\n}\n\n\n```\n\nCacheWareServiceImpl\n\n```java\npackage com.itheima.shiro.cache.impl;\n\nimport com.google.common.collect.ArrayListMultimap;\nimport com.google.common.collect.Multimap;\nimport com.itheima.shiro.cache.CacheWareService;\nimport com.itheima.shiro.pojo.CacheWare;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport org.springframework.stereotype.Service;\n\nimport java.util.Collection;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * @Description：\n */\n@Service(\"cacheWareService\")\npublic class CacheWareServiceImpl implements CacheWareService {\n\n    private Multimap<String, CacheWare> cacheWareMaps = ArrayListMultimap.create();\n\n    /**\n     * 数据锁\n     */\n    private static ReentrantLock reentrantLock = new ReentrantLock();\n\n\n    @Override\n    public void clearCacheWare() {\n        try {\n            reentrantLock.lock();\n            cacheWareMaps.clear();\n        } finally {\n            reentrantLock.unlock();\n        }\n    }\n\n\n    @Override\n    public void createCacheWare(Multimap<String, CacheWare> CacheWareMap) {\n        try {\n            reentrantLock.lock();\n            this.cacheWareMaps = CacheWareMap;\n        } finally {\n            reentrantLock.unlock();\n        }\n    }\n\n    @Override\n    public CacheWare queryCacheWare(String serviceName, String methodName) {\n        if (EmptyUtil.isNullOrEmpty(serviceName) || EmptyUtil.isNullOrEmpty(serviceName)) {\n            return null;\n        }\n        StringBuffer serviceNameStringBuffer = new StringBuffer(serviceName);\n        StringBuffer methodNameStringBuffer = new StringBuffer(methodName);\n        String key = serviceNameStringBuffer.append(\":\").append(methodName).toString();\n        Collection<CacheWare> cacheWares = cacheWareMaps.get(key);\n        return EmptyUtil.isNullOrEmpty(cacheWares) ? null : cacheWares.iterator().next();\n    }\n\n}\n\n\n```\n\n###### 【2.3.2】CacheWareSyncService\n\n其主要职责：\n\n1、启动时、调用CacheWareService的创建缓存方法初始化缓存仓库\n\n2、同步缓存仓库\n\n3、网关资源转化缓存仓库可执行对象\n\n4、从dubbo中，初始化代理对象\n\n注意：为了在多个网关系统下，接口转换的无干扰，读取的只是本网关所对应的资源\n\n```java\npackage com.itheima.shiro.cache;\n\nimport com.itheima.shiro.pojo.CacheWare;\nimport com.itheima.shiro.vo.ResourceVo;\n\n/**\n * @Description：缓存仓库同步刷新\n */\npublic interface CacheWareSyncService {\n\n    /**\n     * @Description 初始化缓存仓库\n     */\n    void initCacheWare();\n\n    /**\n     * @Description 同步缓存仓库\n     */\n    void refreshCacheWare();\n\n    /**\n     * @Description 资源转换缓存仓库对象\n     */\n    CacheWare resourceConvCacheWare(ResourceVo resource);\n\n    /**\n     * @Description 初始化代理对象\n     * @param interfaceClass 接口\n     * @param loadbalance 算法\n     * @param version 版本\n     * @param timeout 超时时间\n     * @param retries 重试次数\n     */\n    Object initProxy(Class<?> interfaceClass,\n                     String loadbalance,\n                     String version,\n                     Integer timeout,\n                     Integer retries);\n\n    /**\n     * @Description 回收资源\n     */\n    void destoryCacheWare();\n}\n\n\n```\n\nCacheWareSyncServiceImpl\n\n```java\npackage com.itheima.shiro.cache.impl;\n\nimport com.google.common.collect.ArrayListMultimap;\nimport com.google.common.collect.Multimap;\nimport com.itheima.shiro.cache.CacheWareService;\nimport com.itheima.shiro.cache.CacheWareSyncService;\nimport com.itheima.shiro.core.bridge.ResourceBridgeService;\nimport com.itheima.shiro.face.ResourceAdapterFace;\nimport com.itheima.shiro.pojo.CacheWare;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport com.itheima.shiro.vo.ResourceVo;\nimport lombok.extern.log4j.Log4j2;\nimport org.apache.dubbo.config.ApplicationConfig;\nimport org.apache.dubbo.config.ReferenceConfig;\nimport org.apache.dubbo.config.RegistryConfig;\nimport org.apache.dubbo.config.annotation.Reference;\nimport org.apache.dubbo.config.utils.ReferenceConfigCache;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Service;\nimport org.springframework.util.CollectionUtils;\n\nimport javax.annotation.PostConstruct;\nimport javax.annotation.PreDestroy;\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * @Description：\n */\n@Service(\"cacheWareSyncService\")\n@Log4j2\npublic class CacheWareSyncServiceImpl implements CacheWareSyncService {\n\n    @Value(\"${itheima.resource.systemcode}\")\n    private String systemCode;\n\n    @Autowired\n    ResourceBridgeService resourceBridgeService;\n\n    @Autowired\n    CacheWareService cacheWareService;\n\n    @Autowired\n    private ApplicationConfig applicationConfig;\n\n    @Autowired\n    private RegistryConfig registryConfig;\n\n    private ScheduledExecutorService executor = Executors.newScheduledThreadPool(1);\n\n\n    @Override\n    @PostConstruct\n    public void initCacheWare() {\n        executor.scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n                try {\n                    refreshCacheWare();\n                } catch (Exception e) {\n                    log.error(e.getMessage(), e);\n                }\n            }\n        }, 0, 2, TimeUnit.MINUTES);\n    }\n\n    @Override\n    public void refreshCacheWare()  {\n        List<ResourceVo> resources = resourceBridgeService.findValidResourceVoAll(systemCode);\n        //如果当前系统没有资源，则清空\n        if (CollectionUtils.isEmpty(resources)) {\n            log.warn(\"No apis can be used.\");\n            cacheWareService.clearCacheWare();\n            return;\n        }\n        //构建执行集合\n        Multimap<String, CacheWare> cacheWareMaps = ArrayListMultimap.create();\n        for (ResourceVo resource : resources) {\n            if (EmptyUtil.isNullOrEmpty(resource.getServiceName())\n            ||EmptyUtil.isNullOrEmpty(resource.getMethodName())){\n                log.warn(\"{} not found serviceName or methodName\",resources.toString());\n                continue;\n            }\n            CacheWare cacheWare = resourceConvCacheWare(resource);\n            if (!EmptyUtil.isNullOrEmpty(cacheWare)){\n                cacheWareMaps.put(cacheWare.getServiceName()+\":\"+cacheWare.getMethodName(), cacheWare);\n            }\n        }\n        cacheWareService.createCacheWare(cacheWareMaps);\n    }\n\n    @Override\n    public CacheWare resourceConvCacheWare(ResourceVo resource)  {\n        //获得类型\n        Class<?> serviceClass = null;\n        try {\n            serviceClass = Class.forName(resource.getServiceName());\n        } catch (ClassNotFoundException e) {\n            log.error(\"容器中未发现：{}接口类\",resource.getServiceName());\n            return null;\n        }\n        String serviceName = resource.getServiceName().substring(resource.getServiceName().lastIndexOf(\".\")+1).toLowerCase();\n        Method[] methods = serviceClass.getDeclaredMethods();\n        Method methodTarget = null;\n        //获得方法\n        for (Method method : methods) {\n            if (method.getName().equals(resource.getMethodName())) {\n                methodTarget = method;\n                break;\n            }\n        }\n        // 未在接口类中找到方法\n        if (methodTarget == null) {\n            log.warn(\"{} not found in {}\", resource.getMethodName(), resource.getServiceName());\n            return null;\n        }\n        //获得方法上的参数\n        Class<?>[] methodParamsClasss = methodTarget.getParameterTypes();\n        Class<?> methodParamClasssTarget = null;\n        for (Class<?> methodParamsClass : methodParamsClasss) {\n            if (methodParamsClass.getName().equals(resource.getMethodParam())) {\n                methodParamClasssTarget = methodParamsClass;\n                break;\n            }\n        }\n        //初始化代理类\n        Object proxy = initProxy(serviceClass, resource.getLoadbalance(), resource.getDubboVersion(), resource.getTimeout(), resource.getRetries());\n        if (proxy == null) {\n            log.warn(\"{} not found in proxy\", resource.getServiceName());\n            return null;\n        }\n       	//构建CacheWare对象\n        CacheWare cacheWare = CacheWare.builder()\n                .serviceName(serviceName)\n                .methodName(resource.getMethodName())\n                .method(methodTarget)\n                .methodParamsClass(methodParamClasssTarget)\n                .proxy(proxy)\n                .build();\n        return cacheWare;\n    }\n\n    @Override\n    public Object initProxy(Class<?> interfaceClass,\n                            String loadbalance,\n                            String version,\n                            Integer timeout,\n                            Integer retries) {\n        ReferenceConfig<Object> reference = new ReferenceConfig<Object>();\n        reference.setApplication(applicationConfig);\n        reference.setRegistry(registryConfig);\n        reference.setLoadbalance(EmptyUtil.isNullOrEmpty(loadbalance)?\"random\":loadbalance);\n        reference.setInterface(interfaceClass);\n        reference.setVersion(version);\n        reference.setTimeout(EmptyUtil.isNullOrEmpty(timeout)?20000:timeout);\n        reference.setCheck(false);\n        reference.setRetries(EmptyUtil.isNullOrEmpty(retries)?0:retries);\n        ReferenceConfigCache cache = ReferenceConfigCache.getCache();\n        return cache.get(reference);\n    }\n\n    @Override\n    @PreDestroy\n    public void destoryCacheWare() {\n        executor.shutdownNow();\n    }\n}\n\n\n```\n\n##### 【2.4】网关资源解析\n\n其主要负责：\n\n1、传入参数处理\n\n2、获得可执行缓存仓库\n\n3、执行远程服务\n\n4、处理返回结果\n\n```java\npackage com.itheima.shiro.web;\n\nimport com.alibaba.fastjson.JSON;\nimport com.alibaba.fastjson.JSONObject;\nimport com.itheima.shiro.base.BaseRequest;\nimport com.itheima.shiro.cache.CacheWareService;\nimport com.itheima.shiro.constant.GateWayConstant;\nimport com.itheima.shiro.pojo.CacheWare;\nimport com.itheima.shiro.response.MultiResponse;\nimport com.itheima.shiro.response.PageResponse;\nimport com.itheima.shiro.response.SingleResponse;\nimport com.itheima.shiro.utils.EmptyUtil;\nimport com.itheima.shiro.view.JsonResult;\nimport lombok.extern.log4j.Log4j2;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.websocket.server.PathParam;\nimport java.lang.reflect.Method;\n\n/**\n * @Description：网关统一入口\n */\n@Controller\n@Log4j2\npublic class GateWayController {\n\n    @Autowired\n    CacheWareService cacheWareService;\n\n\n    @RequestMapping(value = \"{serviceName}/{methodName}\", method = RequestMethod.POST)\n    @ResponseBody\n    public JsonResult postGateWay(@PathVariable(\"serviceName\") String serviceName,\n                                  @PathVariable(\"methodName\") String methodName,\n                                  @RequestBody BaseRequest baseRequest) throws Exception {\n        Object datas = baseRequest.getDatas();\n        JsonResult jsonResult = null;\n        if (EmptyUtil.isNullOrEmpty(serviceName)||EmptyUtil.isNullOrEmpty(methodName)){\n            jsonResult = JsonResult.builder()\n                    .result(GateWayConstant.FAIL)\n                    .msg(\"参数缺失\")\n                    .code(GateWayConstant.PARAMETERS_MISSING)\n                    .build();\n            return jsonResult;\n        }\n        //1、传入参数处理\n        JSONObject datasJson = null;\n        if (!EmptyUtil.isNullOrEmpty(datas)){\n            datasJson = JSONObject.parseObject(JSONObject.toJSONString(datas));\n        }\n        //2、获得可执行缓存仓库可执行对象\n        CacheWare cacheWare = cacheWareService.queryCacheWare(serviceName, methodName);\n        if (EmptyUtil.isNullOrEmpty(serviceName)||EmptyUtil.isNullOrEmpty(methodName)){\n            jsonResult = JsonResult.builder()\n                    .result(GateWayConstant.FAIL)\n                    .msg(\"请求链接异常\")\n                    .code(GateWayConstant.URL_MISSING)\n                    .build();\n            return jsonResult;\n        }\n        //3、执行远程服务\n        Object proxy = cacheWare.getProxy();\n        Method method = cacheWare.getMethod();\n        Class<?> methodParamsClass = cacheWare.getMethodParamsClass();\n        Object result;\n        if (EmptyUtil.isNullOrEmpty(methodParamsClass)){\n            result = method.invoke(proxy);\n        }else {\n            Object arguments = JSONObject.toJavaObject(datasJson, methodParamsClass);\n            result = method.invoke(proxy,arguments);\n        }\n        //4、处理返回结果\n        return convResult(result);\n    }\n\n    /**\n     * @Description 处理请求结果\n     */\n    private JsonResult convResult(Object result) {\n        JsonResult jsonResult = JsonResult.builder()\n                .result(GateWayConstant.SUCCEED)\n                .msg(\"相应正常\")\n                .code(GateWayConstant.SUCCEED_CODE)\n                .build();\n        if (EmptyUtil.isNullOrEmpty(result)) {\n            jsonResult = JsonResult.builder()\n                    .result(GateWayConstant.FAIL)\n                    .msg(\"返回结果为空\")\n                    .code(GateWayConstant.RESULT_ISNULLOREMPTY)\n                    .build();\n            return jsonResult;\n        }\n        if (result instanceof SingleResponse) {\n            BeanUtils.copyProperties(result, jsonResult);\n            @SuppressWarnings(\"rawtypes\")\n            SingleResponse singleResponse = (SingleResponse) result;\n            jsonResult.setDatas(singleResponse.getValue());\n        } else if (result instanceof MultiResponse) {\n            BeanUtils.copyProperties(result, jsonResult);\n            @SuppressWarnings(\"rawtypes\")\n            MultiResponse multiResponse = (MultiResponse) result;\n            jsonResult.setDatas(multiResponse.getValues());\n        } else if (result instanceof PageResponse) {\n            BeanUtils.copyProperties(result, jsonResult);\n            PageResponse pageResponse = (PageResponse)result;\n            jsonResult.setDatas( pageResponse.getValues());\n        } else {\n            jsonResult = JsonResult.builder()\n                    .result(GateWayConstant.FAIL)\n                    .msg(\"返回结果格式不正确\")\n                    .code(GateWayConstant.RESULT_MISSING)\n                    .build();\n            return jsonResult;\n        }\n        return jsonResult;\n    }\n}\n\n```\n\n### 7、shiro-mgt管理平台\n\n#### 【1】模块依赖关系\n\n![1582881763304](image/1582881763304.png)\n\n#### 【2】原理分析\n\n​		通过上面的模块依赖关系，我们可以看出，shiro-mgt管理平台也是依赖springboot-shiro-framework-client项目实现权限的校验，而他本身主要是负责对角色、资源、用户、过滤器链的CRUD，来实现各个网关平台的权限控制。\n\n资源：\n\n![1582704703769](image/1582704703769.png)\n\n1、定义了网关systemcode，用以区分不同网关、系统\n\n2、定义了访问的路径\n\n3、定义了资源的唯一标识，作为过滤器过滤的标记\n\n4、定义dubbo服务端接口的解析、同时为每个服务定义：轮训算法、超时时间、重试次数等参数，这些参数会在shiro-gateway中解析\n\n角色：\n\n![1582704738045](image/1582704738045.png)\n\n1、定义角色的唯一标识，作为过滤器过滤的标记\n\n2、为角色定义多个资源\n\n用户：\n\n![1582704772681](image/1582704772681.png)\n\n1、用户基本信息\n\n2、为用户定义多个角色\n\n过滤器链：\n\n![1582704833744](image/1582704833744.png)\n\n1、为所有系统定义统一的过滤器链路管理（可以扩展：按资源类型那样为每个网关系统定义过滤器链）\n\n2、保证过滤器器链的有序性\n\n\n\n\n\n', '2021-10-17 17:23:18', 1, 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/macos.6z1mshl4twk0.svg', 0, '2021-10-17 17:23:18', NULL, NULL, NULL, 1, 1, 0, NULL, 0, NULL);
INSERT INTO `m_blog` VALUES (31, 1, 'JavaScript之DOM', 'JavaScript之DOM', '文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。DOM 表示由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。脱胎于网景和微软早期的动态 HTML（DHTML，Dynamic HTML），DOM 现在是真正跨平台、语言无关的表示和操作网页的方式。\n\n参考资料：\n\n+ https://github.com/babbittry/Front-end-notes/edit/master/Web%20APIs-notes/Web%20APIs.md\n\n\nAPI，应用程序编程接口，就是一个工具，以便于能轻松实现想要完成的功能\n\nWeb API，是浏览器提供的一套操作浏览器功能和页面元素的 API（DOM 和 BOM）\n\n通过 DOM 接口可以改变网页的内容、结构和样式\n\nDOM 树\n\n+ 文档（document）：一个页面就是一个文档 \n+ 元素（element）：页面中的所有标签都是元素\n+ 节点（node）：网页中的所有内容都是节点（标签、属性、文本、注释等）\n\n> DOM 把以上内容都看作是对象\n\n## 获取元素\n\n获取页面中的元素可以使用以下几种方式:\n+ 根据 ID 获取\n+ 根据标签名获取\n+ 通过 HTML5 新增的方法获取\n+ 特殊元素获取\n\n### 根据 ID 获取元素\n\n使用 [`getElementById()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementById) 方法可以获取带有 ID 的元素对象。\n\n```html\n<p id=\"para\">Some text here</p>\n<button onclick=\"changeColor(\'blue\');\">blue</button>\n<button onclick=\"changeColor(\'red\');\">red</button>\n```\n\n```javascript\nfunction changeColor(newColor) {\n    var elem = document.getElementById(\'para\');\n    console.log(elem); // <p id=\"para\" style=\"color: blue;\">Some text here</p>\n    console.log(typeof elem); // object\n    console.dir(elem); // p#para\n    elem.style.color = newColor;\n}\n```\n\n<div class=\"demo demo-getElementById\">\n<script>\n    function changeColor(newColor) {\n        var elem = document.getElementById(\'para\');\n        console.log(elem); // <p id=\"para\" style=\"color: blue;\">Some text here</p>\n        console.log(typeof elem); // object\n        console.dir(elem); // p#para\n        elem.style.color = newColor;\n    }\n</script>\n    <p id=\"para\">Some text here</p>\n    <button class=\"custom-btn btn-1\" onclick=\"changeColor(\'blue\');\">blue</button>\n    <button class=\"custom-btn btn-1\" onclick=\"changeColor(\'red\');\">red</button>\n\n</div>\n\n\n\n注意：\n+ 因为文档页面从上往下加载，所以先有标签，然后才能 `getElementById()`\n+ 参数是字符串，所以需要加引号\n+ 返回的是一个 element 对象\n\n`console.dir()` 可以打印返回的元素对象，更好的查看里面的属性和方法\n\n### 根据标签获取元素\n\n`getElementsByTagName()`\n\n+ 参数是字符串，所以需要加引号\n+ 得到的是对象的集合，可以用遍历来获取所有对象\n+ 得到的是动态的\n\n例子: 获取 ol 里面的 li\n\n```html\n<ol>\n    <li>123一二三四五</li>\n    <li>123上山打老虎</li>\n    <li>123老虎有几只</li>\n    <li>123快来数一数</li>\n    <li>123一二三四五</li>\n</ol>\n<script>\n    var ol = document.getElementsByTagName(\'ol\');\n    //伪数组不能做父元素\n    var list = ol[0].getElementsByTagName(\'li\');\n    console.log(list);\n    console.dir(list);\n</script>\n```\n\n<div class=\"demo demo-getElementsByTagName\">\n\n<div id=\"div1\" >\n<p>div1 text</p>\n<p>div1 text</p>\n<p>div1 text</p>\n<p>div1 text</p>\n</div>\n<div id=\"div2\" >\n<p>div2 text</p>\n<p>div2 text</p>\n</div>\n\n\n<div>\n<button class=\"custom-btn btn-1\" onclick=\"div1ParaElems();\">\nshow div1 p element</button>\n</div>\n<div>\n<button class=\"custom-btn btn-1\" onclick=\"div2ParaElems();\">\nshow div2 p element</button>\n</div>\n</div>\n\n<script>\nfunction div1ParaElems() {\n    var div1 = document.getElementById(\"div1\");\n    var div1Paras = div1.getElementsByTagName(\"p\");\n    var num = div1Paras.length;\n    alert(\"There are \" + num + \" paragraph in #div1\");\n}\n\nfunction div2ParaElems() {\n    var div2 = document.getElementById(\"div2\");\n    var div2Paras = div2.getElementsByTagName(\"p\");\n    var num = div2Paras.length;\n    alert(\"There are \" + num + \" paragraph in #div2\");\n}\n</script>\n\n### 根据类名获取元素\n\n[`getElementsByClassName()`](https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementsByClassName) 返回一个包含了所有指定类名的子元素的类数组对象。当在 document 对象上调用时，会搜索整个 DOM 文档，包含根节点。\n\n<div class=\"demo\" id=\"parent-id\">\n    <p>hello world 1</p>\n    <p class=\"test\">hello world 2</p>\n    <p>hello world 3</p>\n    <p>hello world 4</p>\n</div>\n\n<script>\n    var parentDOM = document.getElementById(\"parent-id\");\n    var test = parentDOM.getElementsByClassName(\"test\"); // 匹配类名的元素集合，不是元素本身\n    console.log(test); //HTMLCollection[1]\n    var testTarget = parentDOM.getElementsByClassName(\"test\")[0]; // 我们想要取到的第一个元素\n    console.log(testTarget); //<p class=\"test\">hello world 2</p>\n</script>\n\n### querySelector()\n\nHTML5新增的\n\n返回指定选择器的**第一个对象**\n\n```html\n<div class=\"box\">\n<ul>\n<li>15212</li>\n<li>1641238</li>\n</ul>\n</div>\n<div class=\"box\">\n<ul>\n<li>151232</li>\n<li>1612348</li>\n</ul>\n</div>\n<script>\n//注意这里括号里面必须有“.”，因为需要指定选择的选择器\nvar boxs = document.querySelector(\'.box\');\nconsole.log(boxs);\n</script>\n```\n\n### querySelectorAll()\n\n返回指定选择器的所有对象集合\n用法和querySelector()一样\n\n### document.body\n\n获取 body 元素\n\n### document.documentElement\n\n获取 html 元素\n\n## 事件基础\n\nJavaScript 使我们有能力创建动态页面，而事件是可以被JavaScript侦测到的行为。\n网页中的每个元素都可以产生某些触发JavaScript的事件。\n\n### 事件由三部分组成：\n\n+ 事件源   事件被触发的对象 比如按钮\n+ 事件类型   如何触发 比如鼠标点击、鼠标经过、键盘按下、滚动滚轮\n+ 事件处理程序   通过函数赋值的方式完成\n\n\n```html\n<button id=\"btn\">按钮</button>\n<script>\n    var btn = document.getElementById(\'btn\');\n    btn.onclick = function () {\n        alert(\'触发事件\');\n    }\n</script>\n```\n\n\n事件都有：\n\n\n| 鼠标事件 | 触发条件 |\n| ----- | ----- |\n| onclick | 鼠标点击左键触发 |\n| onmouseover | 鼠标经过触发 |\n| onmouseout | 鼠标离开触发 |\n| onfocus | 获得鼠标焦点触发 |\n| onblur | 失去鼠标焦点触发 |\n| onmousemove | 鼠标移动触发 |\n| onmouseup | 鼠标弹起触发 |\n| onmousedown | 鼠标按下触发 |\n\n## 操作元素\n\nJavaScript可以改变网页内容、结构和样式，我们可以利用DOM操作元素来改变元素里面的内容、属性等。\n\n### element.innerText\n\n+ 从起始位置到终止位置的内容，但它去除Html标签，同时空格和换行也会去掉\n+ innerText不识别HTML标签\n+ 可读写的，可以获取元素里面的内容\n\n### element.innerHTML\n\n+ 从起始位置到终止位置的全部内容，包括Html标签，同时保留空格和换行\n+ 能识别HTML标签\n+ 可读写的，可以获取元素里面的内容\n\n### 修改表单属性\n\ndisabled 	让某个表单被禁用，不能被点击，\n用法：\n```javascript\nbtn.onclick = function () {\n    btn.disabled = true;\n    //或者写成下面这种\n    this.disabled = true;\n    //this指向的是时间函数的调用者\n}\n```\n\n**案例**：仿京东显示密码，点击按钮将密码框显示为文本框，并可以查看密码明文\n\n算法：利用一个flag变量，如果是1就切换为文本框，如果是0就切换为密码框\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n    <style>\n    * {\n        margin: 0;\n        padding: 0;\n    }\n    form {\n        position: relative;\n        width: 1000px;\n        height: 500px;\n        border: 1px solid red;\n        margin: 100px auto 0;\n    }\n    input {\n        display: block;\n        width: 800px;\n        height: 50px;\n        line-height: 30px;\n        color: #3c3c3c;\n        margin: 50px auto 50px;\n        padding-left: 20px;\n        box-sizing: border-box;\n        border: 1px solid red;\n    }\n    label img {\n        top: 164px;\n        right: 120px;\n        position: absolute;\n        width: 24px;\n    }\n    </style>\n</head>\n<body>\n    <form action=\"#\">\n        <input type=\"text\" id=\"userName\" placeholder=\"请输入你的用户名\">\n        <label for=\"\">\n            <img src=\"images/闭眼.png\" alt=\"\">\n        </label>\n        <input type=\"password\" id=\"password\" placeholder=\"请输入你的密码\">\n    </form>\n    <script>\n    var eye = document.querySelector(\'img\');\n    var password = document.getElementById(\'password\');\n    var flag = 0;\n    eye.onclick = function () {\n        if (flag === 0) {\n            password.type = \'text\';\n            eye.src = \'images/睁眼.png\';\n            flag = 1;\n        } else {\n            password.type = \'password\';\n            eye.src = \'images/闭眼.png\';\n            flag = 0;\n        }\n \n    }\n    </script>\n</body>\n</html>\n```\n\n### 修改样式属性\n\n#### element.style\n\n行内样式操作，修改元素样式，如果样式比较少或者功能简单的情况下使用\n注意：\n+ 里面的属性是驼峰命名法\n+ JS修改的是行内样式，权重比CSS的高\n+ \n#### element.className\n\n类名样式操作，适合样式比较多的情况下使用\n修改了元素的类名\n\n**注意：**这个方法直接修改了类名，也就是说会覆盖原来的类名，原来的就不生效了\n如果想要保留原先的类名，这样做：\n\n```\n//假设first 是原来的类名，change是想加入的\nthis.className = \'first change\';\n```\n\n#### 表单事件\n\n获得焦点 onfocus\n失去焦点 onblur\n\n案例：京东搜索框，默认是“手机”两个字，当用户点击搜索框的时候，“手机”两个字消失，当输入文本之后，保持文本内容不变\n\n分析：\n+ 如果获得焦点，判断里面是否是默认文字，如果是默认文字，就清空表单内容\n+ 如果失去焦点，判断表单是否为空，如果为空，则表单内容改为默认文字\n+ 获得焦点的时候，把文本框里的文字变黑\n+ 失去焦点的时候，文本框文字变浅\n\n```html\n<input type=\"text\" value=\"手机\">\n<script>\nvar input = document.querySelector(\'input\');\ninput.onfocus = function () {\n    if (this.value === \'手机\') {\n    	input.value = \'\';\n    }\n    this.style.color = \'#3c3c3c\'; \n}\ninput.onblur = function () {\n    if (this.value === \'\') {\n    	input.value = \'手机\';\n    }\n    this.style.color = \'#999\';\n}\n</script>\n```\n\n案例：密码提示框，选中的时候提示密码的长度和标准，失去焦点的时候，检查密码是否合乎规范\n\n分析：\n+ 如果获得焦点，提示密码的长度和标准\n+ 如果失去焦点，检查密码是否合乎规范，如果不符合规范，就提示\n+ 因为改变的样式比较多，所以用className来修改样式\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <title>Document</title>\n    <style>\n    div {\n        width: 600px;\n        margin: 100px auto;\n    }\n    .message {\n        display: inline-block;\n        font-size: 12px;\n        color: #999;\n        background: url(images/message.png) no-repeat left center;\n        background-size: 16px;\n        padding-left: 20px;\n    }\n    .error {\n        display: inline-block;\n        font-size: 12px;\n        color: red;\n        background: url(images/error.png) no-repeat left center;\n        background-size: 16px;\n        padding-left: 20px;\n    }\n    .right {\n        display: inline-block;\n        font-size: 12px;\n        color: green;\n        background: url(images/right.png) no-repeat left center;\n        background-size: 16px;\n        padding-left: 20px;\n    }\n    </style>\n</head>\n<body>\n    <div class=\"register\">\n        <input type=\"password\" class=\"pwd\">\n        <p class=\"message\">请输入6~16位密码</p>\n    </div>\n    <script>\n    var pwd = document.querySelector(\'.pwd\');\n    var message = document.querySelector(\'.message\');\n    pwd.onblur = function() {\n        if (pwd.value.length > 16 || pwd.value.length < 6) {\n            \n            message.className = \'error\';\n            message.innerHTML = \'您输入的位数不对，要求6~16位\';\n        } else {\n            message.className = \'right\';\n            message.innerHTML = \'对辽~\';\n        }\n    }\n    </script>\n</body>\n</html>\n```\n\n### 操作元素小总结\n\n```mermaid\ngraph LR\nA[操作元素]  -->B[操作元素内容]\nB  -->F[innerText]\nB  -->G[innerHTML]\nA[操作元素]  -->C[操作常见元素属性]\nC -->H[src href title alt等 ]\nA[操作元素]  -->D[操作表单元素属性]\nD -->I[ type value disabled等]\nA[操作元素]  -->E[操作元素样式属性]\nE -->J[element.style]\nE -->K[element.className]\n```\n\n### 排他思想\n\n两层循环，先排除其他人，然后再设置自己的样式\n\n```html\n    <button>按钮1</button>\n    <button>按钮2</button>\n    <button>按钮3</button>\n    <button>按钮4</button>\n    <button>按钮5</button>\n    <script>\n    var btns = document.querySelectorAll(\'button\');\n    for (var i = 0; i < btns.length; i++) {\n        btns[i].onclick = function () {\n            //  1. 先把所有颜色的背景颜色都清空\n            for (var j = 0; j < btns.length; j++) {\n                btns[j].style.backgroundColor = \'\';\n            }\n            //  2. 再把想要的背景颜色改成pink\n            this.style.backgroundColor = \'pink\';\n        }\n    }\n    </script>\n```\n\n案例：百度换肤效果\n\n分析：\n+ 利用循环给一组元素注册点击事件\n+ 当鼠标经过一张图片，当前的页面背景换成经过的图片，鼠标移开之后，换回默认的\n+ 当点击了图片，当前的页面背景换成点击的图片\n+ 核心算法：把当前图片的src路径取过来，给body作为背景\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n\n        body {\n            background: url(images/bg1.jpg) no-repeat center top;\n        }\n\n        li {\n            list-style: none;\n        }\n\n        .baidu {\n            overflow: hidden;\n            margin: 100px auto;\n            background-color: #fff;\n            width: 410px;\n            padding-top: 3px;\n        }\n\n        .baidu li {\n            float: left;\n            margin: 0 1px;\n            cursor: pointer;\n        }\n\n        .baidu img {\n            width: 100px;\n        }\n    </style>\n\n</head>\n\n<body>\n\n    <ul class=\"baidu\">\n        <li><img src=\"images/bg1.jpg\" alt=\"\"></li>\n        <li><img src=\"images/bg2.jpg\" alt=\"\"></li>\n        <li><img src=\"images/bg3.jpg\" alt=\"\"></li>\n        <li><img src=\"images/bg4.jpg\" alt=\"\"></li>\n    </ul>\n    <script>\n        //获取元素\n        var images = document.querySelector(\'.baidu\').querySelectorAll(\'img\');\n        for (var i = 0; i < images.length; i++) {\n            //temp 存储原来的背景\n            var temp;\n            images[i].onclick = function () {\n                document.body.style.backgroundImage = \'url(\' + this.src + \')\';\n                temp = \'url(\' + this.src + \')\';\n            }\n            images[i].onmouseover = function () {\n                temp = document.body.style.backgroundImage;\n                document.body.style.backgroundImage = \'url(\' + this.src + \')\';\n            }\n            images[i].onmouseout = function () {\n                document.body.style.backgroundImage = temp;\n            }\n        }\n    </script>\n</body>\n\n</html>\n```\n\n案例： 表单全选取消全选\n\n分析：\n+ 点击上面全选复选框，下面所有的复选框都选中（全选）\n+ 再次点击全选复选框，下面所有的复选框都不中选（取消全选）\n+ 如果下面复选框全部选中，上面全选按钮就自动选中\n+ 如果下面复选框有一个没有选中，上面全选按钮就不选中\n+ 所有复选框一开始默认都没选中状态\n+ 下面复选框需要全部选中，上面全选才能选中做法：给下面所有复选框绑定点击事件，每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的上面全选就不选中。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n    <style>\n        table {\n            width: 800px;\n            height: 500px;\n            margin: 0 auto;\n            border: 1px solid #999;\n            text-align: center;\n        }\n        table tbody tr {\n            background-color: rgb(163, 163, 163);\n        }\n        thead {\n            background-color: skyblue;\n        }\n    </style>\n</head>\n<body>\n    <table>\n        <thead>\n            <tr>\n                <th><input type=\"checkbox\" name=\"\" id=\"checkAll\" ></th>\n                <th>商品</th>\n                <th>价格</th>\n            </tr>\n        </thead>\n        <tbody>\n            <tr>\n                <td><input type=\"checkbox\" name=\"\" id=\"\"></td>\n                <td>iPhone Xs Max</td>\n                <td>10000</td>\n            </tr>\n            <tr>\n                <td><input type=\"checkbox\" name=\"\" id=\"\"></td>\n                <td>iPad Pro</td>\n                <td>5000</td>\n            </tr>\n            <tr>\n                <td><input type=\"checkbox\" name=\"\" id=\"\"></td>\n                <td>iWatch</td>\n                <td>3000</td>\n            </tr>\n            <tr>\n                <td><input type=\"checkbox\" name=\"\" id=\"\"></td>\n                <td>AirPods</td>\n                <td>1000</td>         \n            </tr>\n        </tbody>\n    </table>\n    <script>\n        var checkAll = document.querySelector(\'#checkAll\');\n        var trs = document.querySelector(\'tbody\').querySelectorAll(\'tr\');\n        var tbCheck = document.querySelector(\'tbody\').getElementsByTagName(\'input\');\n        for (var i = 0; i < trs.length; i++) {\n            trs[i].onmouseover = function () {\n                this.style.backgroundColor = \'rgb(200, 200, 200)\';\n            }\n            trs[i].onmouseout = function () {\n                this.style.backgroundColor = \'\';\n            }\n        }\n        checkAll.onclick = function () {\n            for (var j = 0; j < tbCheck.length; j++) {\n                tbCheck[j].checked = checkAll.checked;\n            }\n        }\n        //下面的全部选中，上面的就选中\n        for (var i = 0; i < tbCheck.length; i++) {\n            tbCheck[i].onclick = function () {\n                // flag 控制全选按钮是否被选中\n                var flag = true;\n                for (var j = 0; j < tbCheck.length; j++) {\n                    if (!(tbCheck[j].checked)) {\n                        flag = false;\n                        break;      // 退出for循环，提高运行效率\n                    }\n                }\n                checkAll.checked = flag;\n            }\n        }\n    </script>\n</body>\n</html>\n```\n\n### 操作元素\n\n#### 获取属性值\n\n+ element.属性 	获取内置属性值（元素自带的属性）\n+ element.getAttribute(\'属性\')	主要获取自定义的属性（标准），我们定义的属性\n\n#### 设置属性值\n\n+ element.属性 = \'值\'；\n+ element.setAttribute(\'属性\', \'值\')	主要更改自定义的属性\n\n#### 移除属性值\n\n+ element.removeAttribute(\'属性\')	主要移除自定义的属性（标准）\n\n#### TAB案例 （重点）\n\n分析：\n+ 一个大盒子，里面上下两个小盒子\n+ 上面的模块，点击某一个之后，这个的背景色是红色，其余的是灰色（排他思想）\n+ 点击某一个之后，显示这个模块对应的内容，其他的隐藏，这个要写到点击事件里面\n+ 下面的显示内容和上面的小 li 一一对应\n+ 核心思路：\n  + 给上面的tab_list 添加自定义属性，属性号从0开始\n  + 当点击上面的模块，下面的队形的显示模块开始显示，其他的隐藏\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        ul {\n            list-style: none;\n        }\n        .tab {\n            width: 800px;\n            height: 500px;\n            margin: 200px auto;\n        }\n        .tab_list {\n            height: 50px;\n            background-color: rgb(162, 162, 162);\n            border-bottom: 2px solid #c81623;\n        }\n        .tab_list ul li {\n            float: left;\n            display: inline-block;\n            width: 150px;\n            height: 50px;\n            line-height: 50px;\n            text-align: center;\n            cursor: pointer;\n        }\n        .tab_list .current {\n            background-color: #c81623;\n            color: #fff;\n        }\n        .item {\n            display: none;\n        }\n    </style>\n</head>\n<body>\n    <div class=\"tab\">\n        <div class=\"tab_list\">\n            <ul>\n                <li class=\"current\">商品介绍</li>\n                <li>规格与包装</li>\n                <li>售后保障</li>\n                <li>商品评价(1.1万+)</li>\n                <li>手机社区</li>\n            </ul>\n        </div>\n        <div class=\"tab_con\">\n            <div class=\"item\" style=\"display: block\">\n                商品介绍模块内容\n            </div>\n            <div class=\"item\">\n                规格与包装模块内容\n            </div>\n            <div class=\"item\">\n                售后保障模块内容\n            </div>\n            <div class=\"item\">\n                商品评价模块内容\n            </div>\n            <div class=\"item\">\n                手机社区模块内容\n            </div>\n        </div>\n    </div>\n    <script>\n    var tab_list = document.querySelector(\'.tab_list\');\n    var lis = tab_list.querySelectorAll(\'li\');\n    var items = document.querySelectorAll(\'.item\');\n    for (var i = 0; i < lis.length; i++) {\n        //给5个li设置索引号\n        lis[i].setAttribute(\'index\', i);\n        lis[i].onclick = function () {\n            //干掉其他人\n            for (var j = 0; j < lis.length; j++) {\n                lis[j].className = \'\';\n            }\n            this.className = \'current\';\n            var index = this.getAttribute(\'index\');\n            for (var k = 0; k < items.length; k++) {\n                items[k].style.display = \'none\';\n            }\n            items[index].style.display = \'block\';\n        }\n\n\n    }\n    </script>\n</body>\n</html>\n```\n\n### H5自定义属性\n\n自定义属性目的：为了保存并使用数据，有些数据保存到页面中，为不是数据库中\n\n\n\n#### 设置H5自定义属性\n\n但是有些自定义属性容易引以歧义，不容易判断是内置属性还是自定义属性，所以H5给我们新增了自定义属性\nH5规定自定义属性以 “data-”  开头\n\n#### 获取H5自定义属性\n\n+ 兼容性：element.getAttribute(\'属性\')\n+ H5新增：element.dataset.index 或者 element.dataset[ \'index\' ]\n\n注意：\n```html\n<div data-list-name=\"andy\"></div>\n<script>\nvar div = document.querySelector(\'div\');\nconsole.log(div.getAttribute(\'data-list-name\'));\n//上下三种方法都可以，但是如果用下面这两种方法的话，要用驼峰命名法\nconsole.log(div.dataset.listName);\nconsole.log(div.dataset[\'listName\']);\n</script>\n```\n\n## 节点操作\n\n利用DOM提供的方法获取元素  （逻辑性不强，繁琐）\n+ document.getElementById()\n+ document.getElementByTagName()\n+ document.querySelector  等等\n\n利用	（简单、符合逻辑）\n+ 利用父子兄的节点关系获取元素\n+ 逻辑性强，但是兼容性差\n\n### 节点\n\n![DOM树](media\\DOM树.png)\n\n页面中所有的内容（标签、属性、文本、注释等）都是节点。节点用node表示。\n\nHTML DOM树中的所有节点均可通过JavaScript 进行访问，所有HTML节点均可被修改，也可以创建或删除。\n\n一般的，节点至少由nodeType（节点类型）、 nodeName（节点名称）、 nodeValue（节点值）这三个基本属性。\n\n+ 元素节点 nodeType 为1\n+ 属性节点 nodeType 为2\n+ 文本节点 nodeType 为3 （文本节点包括文字、空格、换行等等）\n\n在实际开发中，节点操作主要操作的是元素节点。\n\n### 节点层级\n\n最常见的是**父子兄层级关系**。\n\n#### 父级节点\n\nnode.parentNode\n\n注意：得到的离元素最近的父级节点（亲爸爸），如果找不到就返回null\n\n#### 子级节点\n\nparentNode.childNodes     (标准)\n\n返回包含指定节点的子节点的集合，该集合为即时更新的集合\n包含的子节点包含元素节点、文本节点等等\n\n所以用 nodeType 判断，用for循环遍历\n\nparentNode.children     (非标准)\n\n得到所有的子元素节点，虽然是非标准的，但是得到了浏览器的支持，所以以后大量使用这个\n\nparentNode.firstChild\n\n返回第一个子节点，找不到返回null,不管是文本节点还是元素节点都能找到\n\nparentNode.firstElementChild\n\n返回第一个子元素节点，找不到返回null,只返回元素节点（IE9以上才支持）\n\nparentNode.lastChild\n\n返回最后一个子节点，找不到返回null,不管是文本节点还是元素节点都能找到\n\nparentNode.lastElementChild\n\n返回最后一个子元素节点，找不到返回null,只返回元素节点（IE9以上才支持）\n\n实际开发中的办法：\n\nparentNode.children[i]\n\n#### 案例\n\n案例：新浪下拉菜单\n\n分析：nav导航栏中有ul和li，li下面又有ul和li，第二层ul和li在鼠标移上去的时候才显示\n\n+ 导航栏里面的li都要有鼠标经过的效果，所以需要循环注册\n+ 核心原理：当鼠标经过li 的时候，孩子的ul 和li 显示，当鼠标离开，则隐藏\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>新浪网</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        ul {\n            list-style: none;\n        }\n        a {\n            text-decoration: none; \n        }\n        .nav {\n            width: 800px;\n            margin: 200px auto;\n            position: relative;\n        }\n        .nav>li {\n            width: 80px;\n            height: 100%;\n            line-height: 41px;\n            color: #333;\n            float: left;\n            position: relative;\n            text-align: center;\n        }\n        .nav>li>a:hover {\n            background-color: #eee;\n        }\n\n        .nav li ul {\n            display: none;\n            position: absolute;\n            top: 41px;\n            left: 0;\n            width: 100%;\n            border-left: 1px solid #fecc5b;\n            border-right: 1px solid #fecc5b;\n            box-sizing: border-box;\n        }\n        .nav li ul li {\n            border-bottom: 1px solid #fecc5b;\n/*             width: 50px;\n            text-align: center; */\n            \n        }\n        .nav ul li a:hover {\n            background-color: #FFF5DA;\n        } \n    </style>\n</head>\n<body>\n    <ul class=\"nav\">\n        <li>\n            <a href=\"#\">微博</a>\n            <ul>\n                <li>\n                    <a href=\"#\">私信</a>\n                </li>\n                <li>\n                    <a href=\"#\">评论</a>\n                </li>\n                <li>\n                    <a href=\"#\">@我</a>\n                </li>\n            </ul>\n        </li>\n        <li>\n            <a href=\"#\">微博</a>\n            <ul>\n                <li>\n                    <a href=\"#\">私信</a>\n                </li>\n                <li>\n                    <a href=\"#\">评论</a>\n                </li>\n                <li>\n                    <a href=\"#\">@我</a>\n                </li>\n            </ul>\n        </li>\n        <li>\n            <a href=\"#\">微博</a>\n            <ul>\n                <li>\n                    <a href=\"#\">私信</a>\n                </li>\n                <li>\n                    <a href=\"#\">评论</a>\n                </li>\n                <li>\n                    <a href=\"#\">@我</a>\n                </li>\n            </ul>\n        </li>\n\n    </ul>\n    <script>\n    //获取元素\n    var nav = document.querySelector(\'.nav\');\n    var lis = nav.children;\n    //循环注册事件\n    for (var i = 0; i < lis.length; i++) {\n        lis[i].onmouseover = function () {\n            this.children[1].style.display = \'block\';\n        }\n        lis[i].onmouseout = function () {\n            this.children[1].style.display = \'none\';\n        }\n    }\n    </script>\n</body>\n</html>\n```\n\n#### 兄弟节点\n\nnode.nextSibling 得到下一个兄弟节点，包括元素节点和文本节点\nnode.previousSibling  得到上一个兄弟节点，包括元素节点和文本节点\n\n//下面两个方法只有IE9以上才能兼容\nnode.nextElementSibling 得到下一个兄弟元素节点，只有元素节点\nnode.previousElementSibling  得到上一个兄弟元素节点，只有元素节点\n\n#### 创建节点\n\ndocument.createElement(\'tagName\')\n\n这个方法创建由tagName指定的 HTML 元素，因为这些元素原先不存在，是根据我们的需求动态生成的，所以也称为**动态创建元素节点**。\n\nnode.appendChild(child);\n\n它是追加元素，是在指定父节点的子节点的末尾添加。\n\nnode.insertBefore(child, 指定元素);\n\n\n#### 留言板案例\n\n分析：\n+ 页面组成：一个文本域，一个提交按钮，一个留言板\n+ 当点击提交按钮的时候，先判断文本域内容是不是空，如果是空，就警告\n+ 如果不是空，就新建一个li，然后把文本域的内容赋值给li，然后在ul里面的前面添加li\n\n####  删除节点\n\nnode.removeChild(child);\n\n从DOM中删除一个子节点，返回删除的节点\n\n#### 删除留言案例\n\n案例分析：\n\n+ 在留言板案例的基础上添加功能\n+ 当把文本域的内容幅值给 li 的时候，多添加一个删除的链接，\n+ 循环把所有的链接获取过来，当我们点击一个链接的时候，删除当前链接所在的 li\n+ 阻止链接跳转需要添加javascript:void(0);或者 javascript:;\n\n```javascript\n<script>\n        //获取元素\n        var btn = document.querySelector(\'button\');\n        var text = document.querySelector(\'textarea\');\n        var ul = document.querySelector(\'ul\');\n        //注册事件\n        btn.onclick = function () {\n            if (text.value == \'\') {\n                alert(\'您没有输入任何内容\');\n                return false;\n            } else {\n                var li = document.createElement(\'li\');\n                //将文本域的内容赋值给li，同时后面添加一个删除留言的a链接\n                li.innerHTML = text.value + \"<a href=\'javascript:;\'>删除</a>\";\n                ul.insertBefore(li, ul.children[0]);\n                var as = document.querySelectorAll(\'a\'); \n                for (var i = 0; i < as.length; i++) {\n                    as[i].onclick = function () {\n                        //删除的是a当前所在的li\n                        ul.removeChild(this.parentNode);\n                    }\n                }               \n            }\n        }\n    </script>\n```\n\n#### 复制节点（克隆节点）\n\nnode.cloneNode()\n这个方法返回一个节点的副本\n\n注意：\n+ 如果括号里面的参数为空，那么只是浅拷贝，即只复制节点本身，不克隆里面的子节点\n+ 如果括号里面的参数为true，那么是深拷贝，复制标签并且复制里面的内容\n\n#### 三种动态创建元素区别\n\n+ document.write()\n  + 文档流执行完毕之后，他会导致页面全部重绘\n+ document.innerHTML()\n  + 将内容写入某个DOM节点，不会导致页面全部重绘\n  + 拼接字符串的效率低\n  + 创建多个元素效率更高，（不要拼接字符串，采取数组形式拼接），结构稍显复杂\n+ document.createElement()\n  + 创建多个元素效率稍低一点点，但是结构更清晰\n\n**总结**：不同浏览器下，innerHTML比createElement效率高\n\n## DOM重点核心\n\n文档对象模型\n\n### 增\n+ appendChild\n+ insertBefore\n\n### 删\n+ removeChild\n\n### 改\n修改DOM元素的属性，DOM元素的内容、属性、表单的值等\n+ 修改元素属性：src、href、title等\n+ 修改普通元素内容：innerHTML、innerText\n+ 修改表单元素：value、type、disable等\n+ 修改元素样式：style、className\n\n### 查\n\n+ DOM提供的API方法：getElementById、getElementByTagName古老用法不太推荐\n+ H5提供的新方法：querySelecter、querySelectorAll提倡使用\n+ 利用节点操作获取元素：父（parentNode）、子（children）、兄（previousElementSibling、nextElementSibling）提倡使用\n\n### 属性操作\n\n+ setAttribute ： 设置DOM的属性\n+ getAttribute ： 得到DOM的属性\n+ removeAttribute ： 移除属性\n\n### 事件操作\n\n| 鼠标事件 | 触发条件 |\n| ------ | ------ |\n| onclick | 鼠标点击左键触发 |\n| onmouseover | 鼠标经过触发 |\n| onmouseout | 鼠标离开触发 |\n| onfocus | 获得鼠标焦点触发 |\n| onblur | 失去鼠标焦点触发 |\n| onmousemove | 鼠标移动触发 |\n| onmouseup | 鼠标弹起触发 |\n| onmousedown | 鼠标按下触发 |\n\n## 事件高级\n\n### 注册事件\n\n给元素添加事件，称为注册时间或者绑定事件。\n\n注册事件有两种方式：传统方式和方法监听注册方式\n\n### 传统注册方式\n\n+ 利用on开头的事件onclick\n+ <button onclick=\"alert(\'hi\')\"></button>\n+ btn.onclick = function () {}\n+ 特点：注册事件的**唯一性**\n+ 同一个元素同一个事件著能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数\n\n### 监听注册方式\n\n+ W3C标准推荐方式\n+ addEventListener() 它是一个方法\n+ IE9之前的IE浏览器不支持此方法，可使用attachEvent()代替\n+ 特点: 同一个元素同一个事件可以注册多个监听器\n\n### addEventListener() 方法\n\n```javascript\neventTarget.addEventListener(type, listener[, useCapture])\n```\n\neventTarget.addEventListener(type, listener[, useCapture]) 方法将指定的监听器注册到eventTarget 上，当该对象触发指定的事件时，就会执行事件处理函数。\n\n该方法接收三个参数：\n\n+ type : 事件类型字符串，比如click、mouseover，**注意这里不要带on**，是字符串，带引号\n+ listener ： 事件处理函数，事件发生时，会调用该监听函数\n+ useCapture : 可选函数，是一个布尔值，默认是false 。学完DOM事件流之后，再进一步学习\n\n### attachEvent\n**该特性非标准，请尽量不要在生产环境中使用它**\n\n```\neventTarget.attackEvent(eventNameWithon, callback)\n```\n\neventTarget.attackEvent方法将指定的监听器注册到eventTarget 上，当该对象触发指定的事件时，指定的回调函数将会被执行。\n\n该方法接收两个参数：\n\n+ ventNameWithon ： 事件类型字符串，比如onclick，onmouseover， 这里要带on\n+ callback : 事件处理函数，当目标触发事件时回调函数将被调用\n\n### 注册事件的兼容性解决方案\n\n```html\n    <button>点击我</button>\n    <script>\n        var btn = document.querySelector(\'button\');\n        function alertWarn () {\n            alert (\'warning\');\n        }\n        function addEventListener(element, eventName, fn) {\n            //判断浏览器是否支持addEventListener方法\n            if (element.addEventListener) {\n                element.addEventListener (eventName, fn);   //第三个参数，默认是false\n            } else if (element.attachEvent) {\n                element.attachEvent (\'on\' + eventName, fn);\n            } else {\n                //相当于element.onclick = fn;\n                element[\'on\' + eventName] = fn;\n            }\n        }\n        addEventListener(btn, \'click\', alertWarn);\n    </script>\n```\n## 删除事件\n\n### 删除事件的方式\n\n+ 传统注册方式\n```\neventTarget.onclick = null;\n```\n+ 方法监听注册方式\n```\ndivs[1].addEventListener(\'click\', alertWarn);\nfunction alertWarn () {\n    alert(\'warning\');\n    divs[1].removeEventListener(\'click\', alertWarn);\n}\n```\n+ attach 方式\n```\ndivs[2].attachEvent(\'onclick\', alertWarn1);\nfunction alertWarn1 () {\n    alert(\'warning\');\n    divs[1].detachEvent(\'click\', alertWarn1);\n}\n```\n+ 兼容性方案\n参考上面的注册事件的兼容性方式。\n\n## DOM事件流\n\n事件流描述的是从页面中接收事件的顺序。\n\n事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流。\n\n包括三个阶段：\n1. 事件捕获阶段\n2. 处于目标阶段\n3. 事件冒泡阶段\n\n\n注意:\n+ JS代码只能执行捕获或者冒泡其中的一个阶段\n+ onclick 和 attachEvent 只能得到冒泡阶段\n+ addEventListener (type, listener[, useCapture]) 第三个参数如果是true，表示在事件捕获阶段调用事件处理程序；如果是false（不写默认就是false），表示在事件冒泡阶段电泳事件处理程序。\n+ 在实际开发中，我们很少使用事件捕获，我们更关注事件冒泡\n+ 有些事件是没有冒泡的，比如onblur、onfocus、onmouseover、onmouseleave\n+ 虽然事件冒泡有时候会带来麻烦，但是有时候又会巧妙的做某些事情，我们后面讲解\n\n## 事件对象\n\n+ event 就是一个事件对象，写道我们的侦听函数的小括号里面，当形参来看\n+ 事件对象只有有了事件才会存在，他是系统给我们自动创建的，不需要我们传递参数\n+ 事件对象是我们的事件的一系列相关数据的集合，比如鼠标点击里面就包含了鼠标的相关信息\n+ 这个事件对象我们可以自己命名，比如 event、evt 、e 等\n+ 事件对象也有兼容性问题。 IE 6、7、8通过 window.event 实现\n\n兼容性写法：\n```\nevent = event || windoe.event;\n```\n\n### 事件对象常见的额属性和方法\n\n| 事件对象属性方法    | 说明                                                         |\n| ------------------- | ------------------------------------------------------------ |\n| e.target            | 返回触发事件的对象  标准                                     |\n| e.scrElement        | 返回触发事件的对象  非标准 IE 6  7 8 使用                    |\n| e.type              | 返回事件的类型，比如click、mouseover等，不带 on              |\n| e.cancelBubble      | 该属性阻止冒泡，非标准，IE 6 7 8 使用                        |\n| e.returnValue       | 该属性阻止默认事件（默认行为）非标准 ，IE 6 7 8 使用，比如不让链接跳转 |\n| e.preventDefaule()  | 该方法阻止默认事件（默认行为）标准 ，比如不让链接跳转        |\n| e.stopPropagation() | 阻止冒泡，标准                                               |\n\n\n\n### e.target 和 this 的区别\n\nthis 返回的是绑定事件的对象（元素）\n\ne.target 返回的是点击的那个对象，就是谁触发了这个事件\n\n```\nvar ul = document.querySelector(\'ul\');\nul.addEventListener(\'click\', function (e) {\n    console.log(this);\n    console.log(e.target);\n})\n\n// <ul>...</ul>\n// <li>123</li>\n```\n\n### 阻止对象默认行为\n\n三种方法：\n+ e.preventDefaule();\n是一个方法，适合普通浏览器\n+ e.returnValue;\n+ 是一个属性，适用于 IE 6 7 8\n+ return false;\n没有兼容性问题，但是需要注意后面的语句就不执行了，直接跳出\n\n### 阻止冒泡\n\n+ event.stopPropagation();    // 一般浏览器停止冒泡\n+ event.cancelBubble;         // IE 6 7 8 的停止冒泡\n\n```javascript\nvar father = document.querySelector(\'.father\');\nvar son = document.querySelector(\'.son\');\nfather.addEventListener(\'click\', alertName, false);\nson.addEventListener(\'click\', alertName, false);\ndocument.addEventListener(\'click\',function () {\n    alert(\'document\');\n}, false);\nfunction alertName (event) {\n    alert(this.getAttribute(\"class\"));\n    event.stopPropagation();    // 停止冒泡\n    event.cancelBubble;         // IE 6 7 8 的停止冒泡\n}\n```\n\n## 事件委托（代理、委派）\n\n### 事件委托的原理\n\n事件委托的原理：不给每个子节点单独设置事件监听器，而是设置在其父节点上，然后利用冒泡原理设置每个子节点。\n\n**例如：**给 ul 注册点击事件，然后利用事件对象的 target 来找到当前点击的 li ，然后事件冒泡到 ul 上， ul 有注册事件，就会触发事件监听器。\n\n### 事件委托的作用\n\n只操作了一次 DOM ，提高了程序的性能。\n\n## 常用的鼠标事件\n\n| 鼠标事件 | 触发条件 |\n| ------ | ------ |\n| onclick | 鼠标点击左键触发 |\n| onmouseover | 鼠标经过触发 |\n| onmouseout | 鼠标离开触发 |\n| onfocus | 获得鼠标焦点触发 |\n| onblur | 失去鼠标焦点触发 |\n| onmousemove | 鼠标移动触发 |\n| onmouseup | 鼠标弹起触发 |\n| onmousedown | 鼠标按下触发 |\n\n```javascript\ndocument.addEventListener(\'click\', function (e) {\n    console.log(e);\n});\n```\n\n| 鼠标事件对象 | 说明 |\n| ------ | ------ |\n| e.clientX | 返回鼠标相对于浏览器窗口可视区域的X坐标 |\n| e.clientY | 返回鼠标相对于浏览器窗口可视区域的Y坐标 |\n| e.pageX | 返回鼠标相对于文档页面的X坐标 IE9+ 支持 |\n| e.pageY | 返回鼠标相对于文档页面的Y坐标 IE9+ 支持 |\n| e.screenX | 返回鼠标相对于电脑屏幕的X坐标 |\n| e.screenY | 返回鼠标相对于电脑屏幕的Y坐标 |\n\n### 案例:\n\n跟随鼠标的小鸟:\n\n#### 案例分析\n\n+ 鼠标不断的移动,使用鼠标移动事件: mousemove\n+ 在页面中移动,所以给 document 注册事件\n+ 图片要移动距离,而且不占位置,我们使用绝对定位即可\n+ 核心原理,每次鼠标移动,我们都会获得最新的鼠标坐标,把这个 X 和 Y 的坐标做为图片的 top 和 left 值就可以移动图片\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <title>跟随鼠标的小鸟</title>\n    <style>\n        img {\n            position: absolute;\n        }\n    </style>\n</head>\n\n<body>\n    <img src=\"images/bird.gif\" alt=\"\">\n    <script>\n        var image = document.querySelector(\'img\');\n        document.addEventListener(\'mousemove\', function (e) {\n            // 只要鼠标移动，就会触发这个事件\n            var x = e.pageX;\n            var y = e.pageY;\n            // top 和 left 一定要加 px\n            image.style.left = x + 20 + \'px\';\n            image.style.top = y + 20 + \'px\';\n        });\n    </script>\n</body>\n</html>\n```\n\n## 常用键盘事件\n\n### 常用键盘事件\n\n| 键盘事件 | 触发条件 |\n| ------ | ------ |\n| onkeyup | 某个键盘按键被松开时触发（松开的时候触发） |\n| onkeydown | 某个键盘按键被按下时触发（按下之后一直触发） |\n| onkeypress | 某个键盘按键被按下时触发（按下之后一直触发），但是它不能识别功能键，比如 ctrl、shift 等 |\n\n当按下的时候，keydown 执行在 keypress 之前。\n\n## 键盘事件对象\n\n| 键盘事件对象属性 | 说明 |\n| ------ | ------ |\n| keyCode | 返回该键的 ASCII 值 |\n\n**注意：**\n\n+ keyup 和 keydown 事件不区分字母大小写， a 和 A 得到的都是65\n+ keypress 区分大小写，a 得到的是97，A 得到的是 65\n\n### 案例1:\n\n京东按下 s 键定位到搜索框:\n\n检测用户是否按下了 s 键盘，如果按下 s 键，就把光标定位到搜索框里面。\n\n#### 案例分析\n\n+ 利用键盘事件对象里面的 keyCode 判断用户是否按下的是 s 键\n+ 搜索框获得焦点的方法: 利用 js 里面的 focus() 方法\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>京东搜索框</title>\n</head>\n<body>\n    <input type=\"text\" name=\"\" id=\"\">\n    <script>\n        var input = document.querySelector(\'input\');\n        document.addEventListener(\'keyup\', function (e) {\n            if (e.keyCode == 83) {\n                input.focus();\n            }\n        });\n    </script>\n</body>\n</html>\n```\n\n### 案例2:\n\n快递单号查询:\n\n查询快递单号的时候，上面一个更大的盒子显示同样的内容（这里的字号更大）。\n\n![快递单号查询](media\\express.png)\n\n#### 案例分析\n\n+ 表单检测用户输入：给表单添加键盘事件\n+ 同时把快递单号里面的值（value）获取过来赋值给 con 盒子（innerText）作为内容\n+ 当失去焦点的时候，就隐藏这个 con 盒子。\n+ 当获得焦点的时候，如果快递单号里面不为空，就显示 con 盒子。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <title>Document</title>\n    <style>\n    .search {\n        position: relative;\n        width: 178px;\n        margin: 100px;\n    }\n    .con {\n        display: none;;\n        position: absolute;\n        top: -40px;\n        width: 171px;\n        border: 1px solid rgba(0, 0, 0, 0.2);\n        padding: 5px 0;\n        font-size: 18px;\n        line-height: 20px;\n        color: #333;\n    }\n    .con::before {\n        content: \'\';\n        width: 0;\n        height: 0;\n        position: absolute;\n        top: 28px;\n        left: 18px;\n        border: 8px solid #000;\n        border-style: solid dashed dashed;\n        border-color: #fff transparent transparent;\n    }\n    </style>\n</head>\n\n<body>\n    <div class=\"search\">\n        <div class=\"con\">123</div>\n        <input type=\"text\" placeholder=\"请输入您的快递单号\">\n    </div>\n    <script>\n    var input = document.querySelector(\'input\');\n    var con = document.querySelector(\'.con\');\n    input.addEventListener(\'keyup\', function(e) {\n        if (this.value == \'\') {\n            con.style.display = \'none\';\n        } else {\n            con.style.display = \'block\';\n            con.innerText = this.value;\n        }\n    });\n    // 当失去焦点的时候，就隐藏这个 con 盒子。\n    input.addEventListener(\'blur\', function() {\n        con.style.display = \'none\';\n    });\n    // 当获得焦点的时候，如果内容不为空，就显示这个 con 盒子。\n    input.addEventListener(\'focus\', function() {\n        if (this.value !== \'\') {\n            con.style.display = \'block\';\n        }\n    });\n    </script>\n</body>\n</html>\n```\n\n**注意：**\n\nkeydown 和 keypress 触发的时候，文字还没有落入文本框中。\n\nkeyup 触发的时候，文字已经输入到文本框中。\n\n', '2021-12-06 06:21:36', 1, 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-e@master/macos.6z1mshl4twk0.svg', 3, '2021-10-19 19:07:54', NULL, NULL, NULL, 1, 1, 0, NULL, 0, '<p>文档对象模型（DOM，Document Object Model）是 HTML 和 XML 文档的编程接口。DOM 表示由多层节点构成的文档，通过它开发者可以添加、删除和修改页面的各个部分。脱胎于网景和微软早期的动态 HTML（DHTML，Dynamic HTML），DOM 现在是真正跨平台、语言无关的表示和操作网页的方式。</p>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://github.com/babbittry/Front-end-notes/edit/master/Web%20APIs-notes/Web%20APIs.md\">https://github.com/babbittry/Front-end-notes/edit/master/Web%20APIs-notes/Web%20APIs.md</a></li>\n</ul>\n<p>API，应用程序编程接口，就是一个工具，以便于能轻松实现想要完成的功能</p>\n<p>Web API，是浏览器提供的一套操作浏览器功能和页面元素的 API（DOM 和 BOM）</p>\n<p>通过 DOM 接口可以改变网页的内容、结构和样式</p>\n<p>DOM 树</p>\n<ul>\n<li>文档（document）：一个页面就是一个文档 </li>\n<li>元素（element）：页面中的所有标签都是元素</li>\n<li>节点（node）：网页中的所有内容都是节点（标签、属性、文本、注释等）</li>\n</ul>\n<blockquote>\n<p>DOM 把以上内容都看作是对象</p>\n</blockquote>\n<h2 id=\"获取元素\">获取元素</h2>\n<p>获取页面中的元素可以使用以下几种方式:</p>\n<ul>\n<li>根据 ID 获取</li>\n<li>根据标签名获取</li>\n<li>通过 HTML5 新增的方法获取</li>\n<li>特殊元素获取</li>\n</ul>\n<h3 id=\"根据-id-获取元素\">根据 ID 获取元素</h3>\n<p>使用 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementById\"><code>getElementById()</code></a> 方法可以获取带有 ID 的元素对象。</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;para&quot;</span>&gt;</span>Some text here<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onclick</span>=<span class=\"hljs-string\">&quot;changeColor(&#x27;blue&#x27;);&quot;</span>&gt;</span>blue<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">onclick</span>=<span class=\"hljs-string\">&quot;changeColor(&#x27;red&#x27;);&quot;</span>&gt;</span>red<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n</code></pre>\n<pre><code class=\"hljs language-javascript\">function changeColor(newColor) {\n    <span class=\"hljs-built_in\">var</span> <span class=\"hljs-built_in\">elem</span> = document.getElementById(&#x27;para&#x27;);\n    console.<span class=\"hljs-built_in\">log</span>(<span class=\"hljs-built_in\">elem</span>); // &lt;p id=<span class=\"hljs-string\">&quot;para&quot;</span> <span class=\"hljs-built_in\">style</span>=<span class=\"hljs-string\">&quot;color: blue;&quot;</span>&gt;Some text here&lt;/p&gt;\n    console.<span class=\"hljs-built_in\">log</span>(typeof <span class=\"hljs-built_in\">elem</span>); // object\n    console.dir(<span class=\"hljs-built_in\">elem</span>); // p#para\n    <span class=\"hljs-built_in\">elem</span>.<span class=\"hljs-built_in\">style</span>.<span class=\"hljs-built_in\">color</span> = newColor;\n}\n</code></pre>\n<div class=\"demo demo-getElementById\">\n<script>\n    function changeColor(newColor) {\n        var elem = document.getElementById(\'para\');\n        console.log(elem); // <p id=\"para\" style=\"color: blue;\">Some text here</p>\n        console.log(typeof elem); // object\n        console.dir(elem); // p#para\n        elem.style.color = newColor;\n    }\n</script>\n    <p id=\"para\">Some text here</p>\n    <button class=\"custom-btn btn-1\" onclick=\"changeColor(\'blue\');\">blue</button>\n    <button class=\"custom-btn btn-1\" onclick=\"changeColor(\'red\');\">red</button>\n\n</div>\n\n\n\n<p>注意：</p>\n<ul>\n<li>因为文档页面从上往下加载，所以先有标签，然后才能 <code>getElementById()</code></li>\n<li>参数是字符串，所以需要加引号</li>\n<li>返回的是一个 element 对象</li>\n</ul>\n<p><code>console.dir()</code> 可以打印返回的元素对象，更好的查看里面的属性和方法</p>\n<h3 id=\"根据标签获取元素\">根据标签获取元素</h3>\n<p><code>getElementsByTagName()</code></p>\n<ul>\n<li>参数是字符串，所以需要加引号</li>\n<li>得到的是对象的集合，可以用遍历来获取所有对象</li>\n<li>得到的是动态的</li>\n</ul>\n<p>例子: 获取 ol 里面的 li</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ol</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>123一二三四五<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>123上山打老虎<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>123老虎有几只<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>123快来数一数<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>123一二三四五<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ol</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n    <span class=\"hljs-keyword\">var</span> ol = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementsByTagName</span>(<span class=\"hljs-string\">&#x27;ol&#x27;</span>);\n    <span class=\"hljs-comment\">//伪数组不能做父元素</span>\n    <span class=\"hljs-keyword\">var</span> list = ol[<span class=\"hljs-number\">0</span>].<span class=\"hljs-title function_\">getElementsByTagName</span>(<span class=\"hljs-string\">&#x27;li&#x27;</span>);\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(list);\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">dir</span>(list);\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<div class=\"demo demo-getElementsByTagName\">\n\n<div id=\"div1\" >\n<p>div1 text</p>\n<p>div1 text</p>\n<p>div1 text</p>\n<p>div1 text</p>\n</div>\n<div id=\"div2\" >\n<p>div2 text</p>\n<p>div2 text</p>\n</div>\n\n\n<div>\n<button class=\"custom-btn btn-1\" onclick=\"div1ParaElems();\">\nshow div1 p element</button>\n</div>\n<div>\n<button class=\"custom-btn btn-1\" onclick=\"div2ParaElems();\">\nshow div2 p element</button>\n</div>\n</div>\n\n<script>\nfunction div1ParaElems() {\n    var div1 = document.getElementById(\"div1\");\n    var div1Paras = div1.getElementsByTagName(\"p\");\n    var num = div1Paras.length;\n    alert(\"There are \" + num + \" paragraph in #div1\");\n}\n\nfunction div2ParaElems() {\n    var div2 = document.getElementById(\"div2\");\n    var div2Paras = div2.getElementsByTagName(\"p\");\n    var num = div2Paras.length;\n    alert(\"There are \" + num + \" paragraph in #div2\");\n}\n</script>\n\n<h3 id=\"根据类名获取元素\">根据类名获取元素</h3>\n<p><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/getElementsByClassName\"><code>getElementsByClassName()</code></a> 返回一个包含了所有指定类名的子元素的类数组对象。当在 document 对象上调用时，会搜索整个 DOM 文档，包含根节点。</p>\n<div class=\"demo\" id=\"parent-id\">\n    <p>hello world 1</p>\n    <p class=\"test\">hello world 2</p>\n    <p>hello world 3</p>\n    <p>hello world 4</p>\n</div>\n\n<script>\n    var parentDOM = document.getElementById(\"parent-id\");\n    var test = parentDOM.getElementsByClassName(\"test\"); // 匹配类名的元素集合，不是元素本身\n    console.log(test); //HTMLCollection[1]\n    var testTarget = parentDOM.getElementsByClassName(\"test\")[0]; // 我们想要取到的第一个元素\n    console.log(testTarget); //<p class=\"test\">hello world 2</p>\n</script>\n\n<h3 id=\"queryselector\">querySelector()</h3>\n<p>HTML5新增的</p>\n<p>返回指定选择器的<strong>第一个对象</strong></p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;box&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>15212<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>1641238<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;box&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>151232<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>1612348<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n<span class=\"hljs-comment\">//注意这里括号里面必须有“.”，因为需要指定选择的选择器</span>\n<span class=\"hljs-keyword\">var</span> boxs = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;.box&#x27;</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(boxs);\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<h3 id=\"queryselectorall\">querySelectorAll()</h3>\n<p>返回指定选择器的所有对象集合<br>用法和querySelector()一样</p>\n<h3 id=\"documentbody\">document.body</h3>\n<p>获取 body 元素</p>\n<h3 id=\"documentdocumentelement\">document.documentElement</h3>\n<p>获取 html 元素</p>\n<h2 id=\"事件基础\">事件基础</h2>\n<p>JavaScript 使我们有能力创建动态页面，而事件是可以被JavaScript侦测到的行为。<br>网页中的每个元素都可以产生某些触发JavaScript的事件。</p>\n<h3 id=\"事件由三部分组成：\">事件由三部分组成：</h3>\n<ul>\n<li>事件源   事件被触发的对象 比如按钮</li>\n<li>事件类型   如何触发 比如鼠标点击、鼠标经过、键盘按下、滚动滚轮</li>\n<li>事件处理程序   通过函数赋值的方式完成</li>\n</ul>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;btn&quot;</span>&gt;</span>按钮<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n    <span class=\"hljs-keyword\">var</span> btn = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;btn&#x27;</span>);\n    btn.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&#x27;触发事件&#x27;</span>);\n    }\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>事件都有：</p>\n<table>\n<thead>\n<tr>\n<th>鼠标事件</th>\n<th>触发条件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>onclick</td>\n<td>鼠标点击左键触发</td>\n</tr>\n<tr>\n<td>onmouseover</td>\n<td>鼠标经过触发</td>\n</tr>\n<tr>\n<td>onmouseout</td>\n<td>鼠标离开触发</td>\n</tr>\n<tr>\n<td>onfocus</td>\n<td>获得鼠标焦点触发</td>\n</tr>\n<tr>\n<td>onblur</td>\n<td>失去鼠标焦点触发</td>\n</tr>\n<tr>\n<td>onmousemove</td>\n<td>鼠标移动触发</td>\n</tr>\n<tr>\n<td>onmouseup</td>\n<td>鼠标弹起触发</td>\n</tr>\n<tr>\n<td>onmousedown</td>\n<td>鼠标按下触发</td>\n</tr>\n</tbody></table>\n<h2 id=\"操作元素\">操作元素</h2>\n<p>JavaScript可以改变网页内容、结构和样式，我们可以利用DOM操作元素来改变元素里面的内容、属性等。</p>\n<h3 id=\"elementinnertext\">element.innerText</h3>\n<ul>\n<li>从起始位置到终止位置的内容，但它去除Html标签，同时空格和换行也会去掉</li>\n<li>innerText不识别HTML标签</li>\n<li>可读写的，可以获取元素里面的内容</li>\n</ul>\n<h3 id=\"elementinnerhtml\">element.innerHTML</h3>\n<ul>\n<li>从起始位置到终止位置的全部内容，包括Html标签，同时保留空格和换行</li>\n<li>能识别HTML标签</li>\n<li>可读写的，可以获取元素里面的内容</li>\n</ul>\n<h3 id=\"修改表单属性\">修改表单属性</h3>\n<p>disabled     让某个表单被禁用，不能被点击，<br>用法：</p>\n<pre><code class=\"hljs language-javascript\">btn.onclick = <span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> {\n    btn.disabled = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-comment\">//或者写成下面这种</span>\n    <span class=\"hljs-keyword\">this</span>.disabled = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-comment\">//this指向的是时间函数的调用者</span>\n}\n</code></pre>\n<p><strong>案例</strong>：仿京东显示密码，点击按钮将密码框显示为文本框，并可以查看密码明文</p>\n<p>算法：利用一个flag变量，如果是1就切换为文本框，如果是0就切换为密码框</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\">\n    * {\n        <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;\n    }\n    <span class=\"hljs-selector-tag\">form</span> {\n        <span class=\"hljs-attribute\">position</span>: relative;\n        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">1000px</span>;\n        <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">500px</span>;\n        <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid red;\n        <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">100px</span> auto <span class=\"hljs-number\">0</span>;\n    }\n    <span class=\"hljs-selector-tag\">input</span> {\n        <span class=\"hljs-attribute\">display</span>: block;\n        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">800px</span>;\n        <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">50px</span>;\n        <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">30px</span>;\n        <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#3c3c3c</span>;\n        <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">50px</span> auto <span class=\"hljs-number\">50px</span>;\n        <span class=\"hljs-attribute\">padding-left</span>: <span class=\"hljs-number\">20px</span>;\n        <span class=\"hljs-attribute\">box-sizing</span>: border-box;\n        <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid red;\n    }\n    <span class=\"hljs-selector-tag\">label</span> <span class=\"hljs-selector-tag\">img</span> {\n        <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">164px</span>;\n        <span class=\"hljs-attribute\">right</span>: <span class=\"hljs-number\">120px</span>;\n        <span class=\"hljs-attribute\">position</span>: absolute;\n        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">24px</span>;\n    }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;userName&quot;</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">&quot;请输入你的用户名&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">label</span> <span class=\"hljs-attr\">for</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;images/闭眼.png&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">label</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;password&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;password&quot;</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">&quot;请输入你的密码&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n    <span class=\"hljs-keyword\">var</span> eye = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;img&#x27;</span>);\n    <span class=\"hljs-keyword\">var</span> password = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">getElementById</span>(<span class=\"hljs-string\">&#x27;password&#x27;</span>);\n    <span class=\"hljs-keyword\">var</span> flag = <span class=\"hljs-number\">0</span>;\n    eye.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">if</span> (flag === <span class=\"hljs-number\">0</span>) {\n            password.<span class=\"hljs-property\">type</span> = <span class=\"hljs-string\">&#x27;text&#x27;</span>;\n            eye.<span class=\"hljs-property\">src</span> = <span class=\"hljs-string\">&#x27;images/睁眼.png&#x27;</span>;\n            flag = <span class=\"hljs-number\">1</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n            password.<span class=\"hljs-property\">type</span> = <span class=\"hljs-string\">&#x27;password&#x27;</span>;\n            eye.<span class=\"hljs-property\">src</span> = <span class=\"hljs-string\">&#x27;images/闭眼.png&#x27;</span>;\n            flag = <span class=\"hljs-number\">0</span>;\n        }\n \n    }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<h3 id=\"修改样式属性\">修改样式属性</h3>\n<h4 id=\"elementstyle\">element.style</h4>\n<p>行内样式操作，修改元素样式，如果样式比较少或者功能简单的情况下使用<br>注意：</p>\n<ul>\n<li>里面的属性是驼峰命名法</li>\n<li>JS修改的是行内样式，权重比CSS的高</li>\n<li><h4 id=\"elementclassname\">element.className</h4>\n</li>\n</ul>\n<p>类名样式操作，适合样式比较多的情况下使用<br>修改了元素的类名</p>\n<p><strong>注意：</strong>这个方法直接修改了类名，也就是说会覆盖原来的类名，原来的就不生效了<br>如果想要保留原先的类名，这样做：</p>\n<pre><code>//假设<span class=\"hljs-built_in\">first</span> 是原来的类名，<span class=\"hljs-built_in\">change</span>是想加入的\nthis.className = &#x27;<span class=\"hljs-built_in\">first</span> <span class=\"hljs-built_in\">change</span>&#x27;;\n</code></pre>\n<h4 id=\"表单事件\">表单事件</h4>\n<p>获得焦点 onfocus<br>失去焦点 onblur</p>\n<p>案例：京东搜索框，默认是“手机”两个字，当用户点击搜索框的时候，“手机”两个字消失，当输入文本之后，保持文本内容不变</p>\n<p>分析：</p>\n<ul>\n<li>如果获得焦点，判断里面是否是默认文字，如果是默认文字，就清空表单内容</li>\n<li>如果失去焦点，判断表单是否为空，如果为空，则表单内容改为默认文字</li>\n<li>获得焦点的时候，把文本框里的文字变黑</li>\n<li>失去焦点的时候，文本框文字变浅</li>\n</ul>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;手机&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n<span class=\"hljs-keyword\">var</span> input = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;input&#x27;</span>);\ninput.<span class=\"hljs-property\">onfocus</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> === <span class=\"hljs-string\">&#x27;手机&#x27;</span>) {\n        input.<span class=\"hljs-property\">value</span> = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n    }\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">color</span> = <span class=\"hljs-string\">&#x27;#3c3c3c&#x27;</span>; \n}\ninput.<span class=\"hljs-property\">onblur</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> === <span class=\"hljs-string\">&#x27;&#x27;</span>) {\n        input.<span class=\"hljs-property\">value</span> = <span class=\"hljs-string\">&#x27;手机&#x27;</span>;\n    }\n    <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">color</span> = <span class=\"hljs-string\">&#x27;#999&#x27;</span>;\n}\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>案例：密码提示框，选中的时候提示密码的长度和标准，失去焦点的时候，检查密码是否合乎规范</p>\n<p>分析：</p>\n<ul>\n<li>如果获得焦点，提示密码的长度和标准</li>\n<li>如果失去焦点，检查密码是否合乎规范，如果不符合规范，就提示</li>\n<li>因为改变的样式比较多，所以用className来修改样式</li>\n</ul>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\">\n    <span class=\"hljs-selector-tag\">div</span> {\n        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">600px</span>;\n        <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">100px</span> auto;\n    }\n    <span class=\"hljs-selector-class\">.message</span> {\n        <span class=\"hljs-attribute\">display</span>: inline-block;\n        <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">12px</span>;\n        <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#999</span>;\n        <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">images/message.png</span>) no-repeat left center;\n        <span class=\"hljs-attribute\">background-size</span>: <span class=\"hljs-number\">16px</span>;\n        <span class=\"hljs-attribute\">padding-left</span>: <span class=\"hljs-number\">20px</span>;\n    }\n    <span class=\"hljs-selector-class\">.error</span> {\n        <span class=\"hljs-attribute\">display</span>: inline-block;\n        <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">12px</span>;\n        <span class=\"hljs-attribute\">color</span>: red;\n        <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">images/error.png</span>) no-repeat left center;\n        <span class=\"hljs-attribute\">background-size</span>: <span class=\"hljs-number\">16px</span>;\n        <span class=\"hljs-attribute\">padding-left</span>: <span class=\"hljs-number\">20px</span>;\n    }\n    <span class=\"hljs-selector-class\">.right</span> {\n        <span class=\"hljs-attribute\">display</span>: inline-block;\n        <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">12px</span>;\n        <span class=\"hljs-attribute\">color</span>: green;\n        <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">images/right.png</span>) no-repeat left center;\n        <span class=\"hljs-attribute\">background-size</span>: <span class=\"hljs-number\">16px</span>;\n        <span class=\"hljs-attribute\">padding-left</span>: <span class=\"hljs-number\">20px</span>;\n    }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;register&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;password&quot;</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;pwd&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;message&quot;</span>&gt;</span>请输入6~16位密码<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n    <span class=\"hljs-keyword\">var</span> pwd = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;.pwd&#x27;</span>);\n    <span class=\"hljs-keyword\">var</span> message = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;.message&#x27;</span>);\n    pwd.<span class=\"hljs-property\">onblur</span> = <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">if</span> (pwd.<span class=\"hljs-property\">value</span>.<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">16</span> || pwd.<span class=\"hljs-property\">value</span>.<span class=\"hljs-property\">length</span> &lt; <span class=\"hljs-number\">6</span>) {\n            \n            message.<span class=\"hljs-property\">className</span> = <span class=\"hljs-string\">&#x27;error&#x27;</span>;\n            message.<span class=\"hljs-property\">innerHTML</span> = <span class=\"hljs-string\">&#x27;您输入的位数不对，要求6~16位&#x27;</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n            message.<span class=\"hljs-property\">className</span> = <span class=\"hljs-string\">&#x27;right&#x27;</span>;\n            message.<span class=\"hljs-property\">innerHTML</span> = <span class=\"hljs-string\">&#x27;对辽~&#x27;</span>;\n        }\n    }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<h3 id=\"操作元素小总结\">操作元素小总结</h3>\n<pre><code class=\"hljs language-mermaid\">graph LR\n<span class=\"hljs-selector-tag\">A</span><span class=\"hljs-selector-attr\">[操作元素]</span>  --&gt;<span class=\"hljs-selector-tag\">B</span><span class=\"hljs-selector-attr\">[操作元素内容]</span>\n<span class=\"hljs-selector-tag\">B</span>  --&gt;F<span class=\"hljs-selector-attr\">[innerText]</span>\n<span class=\"hljs-selector-tag\">B</span>  --&gt;G<span class=\"hljs-selector-attr\">[innerHTML]</span>\n<span class=\"hljs-selector-tag\">A</span><span class=\"hljs-selector-attr\">[操作元素]</span>  --&gt;C<span class=\"hljs-selector-attr\">[操作常见元素属性]</span>\nC --&gt;H<span class=\"hljs-selector-attr\">[src href title alt等 ]</span>\n<span class=\"hljs-selector-tag\">A</span><span class=\"hljs-selector-attr\">[操作元素]</span>  --&gt;D<span class=\"hljs-selector-attr\">[操作表单元素属性]</span>\nD --&gt;<span class=\"hljs-selector-tag\">I</span><span class=\"hljs-selector-attr\">[ type value disabled等]</span>\n<span class=\"hljs-selector-tag\">A</span><span class=\"hljs-selector-attr\">[操作元素]</span>  --&gt;E<span class=\"hljs-selector-attr\">[操作元素样式属性]</span>\nE --&gt;J<span class=\"hljs-selector-attr\">[element.style]</span>\nE --&gt;K<span class=\"hljs-selector-attr\">[element.className]</span>\n</code></pre>\n<h3 id=\"排他思想\">排他思想</h3>\n<p>两层循环，先排除其他人，然后再设置自己的样式</p>\n<pre><code class=\"hljs language-html\">    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>按钮1<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>按钮2<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>按钮3<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>按钮4<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>按钮5<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n    <span class=\"hljs-keyword\">var</span> btns = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;button&#x27;</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; btns.<span class=\"hljs-property\">length</span>; i++) {\n        btns[i].<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n            <span class=\"hljs-comment\">//  1. 先把所有颜色的背景颜色都清空</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; btns.<span class=\"hljs-property\">length</span>; j++) {\n                btns[j].<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">backgroundColor</span> = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n            }\n            <span class=\"hljs-comment\">//  2. 再把想要的背景颜色改成pink</span>\n            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">backgroundColor</span> = <span class=\"hljs-string\">&#x27;pink&#x27;</span>;\n        }\n    }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<p>案例：百度换肤效果</p>\n<p>分析：</p>\n<ul>\n<li>利用循环给一组元素注册点击事件</li>\n<li>当鼠标经过一张图片，当前的页面背景换成经过的图片，鼠标移开之后，换回默认的</li>\n<li>当点击了图片，当前的页面背景换成点击的图片</li>\n<li>核心算法：把当前图片的src路径取过来，给body作为背景</li>\n</ul>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;ie=edge&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\">\n        * {\n            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;\n            <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;\n        }\n\n        <span class=\"hljs-selector-tag\">body</span> {\n            <span class=\"hljs-attribute\">background</span>: <span class=\"hljs-built_in\">url</span>(<span class=\"hljs-string\">images/bg1.jpg</span>) no-repeat center top;\n        }\n\n        <span class=\"hljs-selector-tag\">li</span> {\n            <span class=\"hljs-attribute\">list-style</span>: none;\n        }\n\n        <span class=\"hljs-selector-class\">.baidu</span> {\n            <span class=\"hljs-attribute\">overflow</span>: hidden;\n            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">100px</span> auto;\n            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#fff</span>;\n            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">410px</span>;\n            <span class=\"hljs-attribute\">padding-top</span>: <span class=\"hljs-number\">3px</span>;\n        }\n\n        <span class=\"hljs-selector-class\">.baidu</span> <span class=\"hljs-selector-tag\">li</span> {\n            <span class=\"hljs-attribute\">float</span>: left;\n            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span> <span class=\"hljs-number\">1px</span>;\n            <span class=\"hljs-attribute\">cursor</span>: pointer;\n        }\n\n        <span class=\"hljs-selector-class\">.baidu</span> <span class=\"hljs-selector-tag\">img</span> {\n            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100px</span>;\n        }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;baidu&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;images/bg1.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;images/bg2.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;images/bg3.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;images/bg4.jpg&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n        <span class=\"hljs-comment\">//获取元素</span>\n        <span class=\"hljs-keyword\">var</span> images = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;.baidu&#x27;</span>).<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;img&#x27;</span>);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; images.<span class=\"hljs-property\">length</span>; i++) {\n            <span class=\"hljs-comment\">//temp 存储原来的背景</span>\n            <span class=\"hljs-keyword\">var</span> temp;\n            images[i].<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n                <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">backgroundImage</span> = <span class=\"hljs-string\">&#x27;url(&#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">src</span> + <span class=\"hljs-string\">&#x27;)&#x27;</span>;\n                temp = <span class=\"hljs-string\">&#x27;url(&#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">src</span> + <span class=\"hljs-string\">&#x27;)&#x27;</span>;\n            }\n            images[i].<span class=\"hljs-property\">onmouseover</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n                temp = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">backgroundImage</span>;\n                <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">backgroundImage</span> = <span class=\"hljs-string\">&#x27;url(&#x27;</span> + <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">src</span> + <span class=\"hljs-string\">&#x27;)&#x27;</span>;\n            }\n            images[i].<span class=\"hljs-property\">onmouseout</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n                <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-property\">body</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">backgroundImage</span> = temp;\n            }\n        }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p>案例： 表单全选取消全选</p>\n<p>分析：</p>\n<ul>\n<li>点击上面全选复选框，下面所有的复选框都选中（全选）</li>\n<li>再次点击全选复选框，下面所有的复选框都不中选（取消全选）</li>\n<li>如果下面复选框全部选中，上面全选按钮就自动选中</li>\n<li>如果下面复选框有一个没有选中，上面全选按钮就不选中</li>\n<li>所有复选框一开始默认都没选中状态</li>\n<li>下面复选框需要全部选中，上面全选才能选中做法：给下面所有复选框绑定点击事件，每次点击，都要循环查看下面所有的复选框是否有没选中的，如果有一个没选中的上面全选就不选中。</li>\n</ul>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;ie=edge&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\">\n        <span class=\"hljs-selector-tag\">table</span> {\n            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">800px</span>;\n            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">500px</span>;\n            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span> auto;\n            <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#999</span>;\n            <span class=\"hljs-attribute\">text-align</span>: center;\n        }\n        <span class=\"hljs-selector-tag\">table</span> <span class=\"hljs-selector-tag\">tbody</span> <span class=\"hljs-selector-tag\">tr</span> {\n            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-built_in\">rgb</span>(<span class=\"hljs-number\">163</span>, <span class=\"hljs-number\">163</span>, <span class=\"hljs-number\">163</span>);\n        }\n        <span class=\"hljs-selector-tag\">thead</span> {\n            <span class=\"hljs-attribute\">background-color</span>: skyblue;\n        }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">table</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">thead</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;checkAll&quot;</span> &gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>商品<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">th</span>&gt;</span>价格<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">th</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">thead</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tbody</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>iPhone Xs Max<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>10000<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>iPad Pro<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>5000<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>iWatch<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>3000<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">tr</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;checkbox&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>AirPods<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">td</span>&gt;</span>1000<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">td</span>&gt;</span>         \n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tr</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">tbody</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">table</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n        <span class=\"hljs-keyword\">var</span> checkAll = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;#checkAll&#x27;</span>);\n        <span class=\"hljs-keyword\">var</span> trs = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;tbody&#x27;</span>).<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;tr&#x27;</span>);\n        <span class=\"hljs-keyword\">var</span> tbCheck = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;tbody&#x27;</span>).<span class=\"hljs-title function_\">getElementsByTagName</span>(<span class=\"hljs-string\">&#x27;input&#x27;</span>);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; trs.<span class=\"hljs-property\">length</span>; i++) {\n            trs[i].<span class=\"hljs-property\">onmouseover</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n                <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">backgroundColor</span> = <span class=\"hljs-string\">&#x27;rgb(200, 200, 200)&#x27;</span>;\n            }\n            trs[i].<span class=\"hljs-property\">onmouseout</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n                <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">backgroundColor</span> = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n            }\n        }\n        checkAll.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; tbCheck.<span class=\"hljs-property\">length</span>; j++) {\n                tbCheck[j].<span class=\"hljs-property\">checked</span> = checkAll.<span class=\"hljs-property\">checked</span>;\n            }\n        }\n        <span class=\"hljs-comment\">//下面的全部选中，上面的就选中</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; tbCheck.<span class=\"hljs-property\">length</span>; i++) {\n            tbCheck[i].<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n                <span class=\"hljs-comment\">// flag 控制全选按钮是否被选中</span>\n                <span class=\"hljs-keyword\">var</span> flag = <span class=\"hljs-literal\">true</span>;\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; tbCheck.<span class=\"hljs-property\">length</span>; j++) {\n                    <span class=\"hljs-keyword\">if</span> (!(tbCheck[j].<span class=\"hljs-property\">checked</span>)) {\n                        flag = <span class=\"hljs-literal\">false</span>;\n                        <span class=\"hljs-keyword\">break</span>;      <span class=\"hljs-comment\">// 退出for循环，提高运行效率</span>\n                    }\n                }\n                checkAll.<span class=\"hljs-property\">checked</span> = flag;\n            }\n        }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<h3 id=\"操作元素-1\">操作元素</h3>\n<h4 id=\"获取属性值\">获取属性值</h4>\n<ul>\n<li>element.属性     获取内置属性值（元素自带的属性）</li>\n<li>element.getAttribute(‘属性’)    主要获取自定义的属性（标准），我们定义的属性</li>\n</ul>\n<h4 id=\"设置属性值\">设置属性值</h4>\n<ul>\n<li>element.属性 = ‘值’；</li>\n<li>element.setAttribute(‘属性’, ‘值’)    主要更改自定义的属性</li>\n</ul>\n<h4 id=\"移除属性值\">移除属性值</h4>\n<ul>\n<li>element.removeAttribute(‘属性’)    主要移除自定义的属性（标准）</li>\n</ul>\n<h4 id=\"tab案例-（重点）\">TAB案例 （重点）</h4>\n<p>分析：</p>\n<ul>\n<li>一个大盒子，里面上下两个小盒子</li>\n<li>上面的模块，点击某一个之后，这个的背景色是红色，其余的是灰色（排他思想）</li>\n<li>点击某一个之后，显示这个模块对应的内容，其他的隐藏，这个要写到点击事件里面</li>\n<li>下面的显示内容和上面的小 li 一一对应</li>\n<li>核心思路：<ul>\n<li>给上面的tab_list 添加自定义属性，属性号从0开始</li>\n<li>当点击上面的模块，下面的队形的显示模块开始显示，其他的隐藏</li>\n</ul>\n</li>\n</ul>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;ie=edge&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\">\n        * {\n            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;\n            <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;\n        }\n        <span class=\"hljs-selector-tag\">ul</span> {\n            <span class=\"hljs-attribute\">list-style</span>: none;\n        }\n        <span class=\"hljs-selector-class\">.tab</span> {\n            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">800px</span>;\n            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">500px</span>;\n            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">200px</span> auto;\n        }\n        <span class=\"hljs-selector-class\">.tab_list</span> {\n            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">50px</span>;\n            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-built_in\">rgb</span>(<span class=\"hljs-number\">162</span>, <span class=\"hljs-number\">162</span>, <span class=\"hljs-number\">162</span>);\n            <span class=\"hljs-attribute\">border-bottom</span>: <span class=\"hljs-number\">2px</span> solid <span class=\"hljs-number\">#c81623</span>;\n        }\n        <span class=\"hljs-selector-class\">.tab_list</span> <span class=\"hljs-selector-tag\">ul</span> <span class=\"hljs-selector-tag\">li</span> {\n            <span class=\"hljs-attribute\">float</span>: left;\n            <span class=\"hljs-attribute\">display</span>: inline-block;\n            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">150px</span>;\n            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">50px</span>;\n            <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">50px</span>;\n            <span class=\"hljs-attribute\">text-align</span>: center;\n            <span class=\"hljs-attribute\">cursor</span>: pointer;\n        }\n        <span class=\"hljs-selector-class\">.tab_list</span> <span class=\"hljs-selector-class\">.current</span> {\n            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#c81623</span>;\n            <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#fff</span>;\n        }\n        <span class=\"hljs-selector-class\">.item</span> {\n            <span class=\"hljs-attribute\">display</span>: none;\n        }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;tab&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;tab_list&quot;</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;current&quot;</span>&gt;</span>商品介绍<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>规格与包装<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>售后保障<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>商品评价(1.1万+)<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>手机社区<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;tab_con&quot;</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span> <span class=\"hljs-attr\">style</span>=<span class=\"hljs-string\">&quot;display: block&quot;</span>&gt;</span>\n                商品介绍模块内容\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>\n                规格与包装模块内容\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>\n                售后保障模块内容\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>\n                商品评价模块内容\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;item&quot;</span>&gt;</span>\n                手机社区模块内容\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n    <span class=\"hljs-keyword\">var</span> tab_list = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;.tab_list&#x27;</span>);\n    <span class=\"hljs-keyword\">var</span> lis = tab_list.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;li&#x27;</span>);\n    <span class=\"hljs-keyword\">var</span> items = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;.item&#x27;</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; lis.<span class=\"hljs-property\">length</span>; i++) {\n        <span class=\"hljs-comment\">//给5个li设置索引号</span>\n        lis[i].<span class=\"hljs-title function_\">setAttribute</span>(<span class=\"hljs-string\">&#x27;index&#x27;</span>, i);\n        lis[i].<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n            <span class=\"hljs-comment\">//干掉其他人</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; lis.<span class=\"hljs-property\">length</span>; j++) {\n                lis[j].<span class=\"hljs-property\">className</span> = <span class=\"hljs-string\">&#x27;&#x27;</span>;\n            }\n            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">className</span> = <span class=\"hljs-string\">&#x27;current&#x27;</span>;\n            <span class=\"hljs-keyword\">var</span> index = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-title function_\">getAttribute</span>(<span class=\"hljs-string\">&#x27;index&#x27;</span>);\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> k = <span class=\"hljs-number\">0</span>; k &lt; items.<span class=\"hljs-property\">length</span>; k++) {\n                items[k].<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">display</span> = <span class=\"hljs-string\">&#x27;none&#x27;</span>;\n            }\n            items[index].<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">display</span> = <span class=\"hljs-string\">&#x27;block&#x27;</span>;\n        }\n\n\n    }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<h3 id=\"h5自定义属性\">H5自定义属性</h3>\n<p>自定义属性目的：为了保存并使用数据，有些数据保存到页面中，为不是数据库中</p>\n<h4 id=\"设置h5自定义属性\">设置H5自定义属性</h4>\n<p>但是有些自定义属性容易引以歧义，不容易判断是内置属性还是自定义属性，所以H5给我们新增了自定义属性<br>H5规定自定义属性以 “data-”  开头</p>\n<h4 id=\"获取h5自定义属性\">获取H5自定义属性</h4>\n<ul>\n<li>兼容性：element.getAttribute(‘属性’)</li>\n<li>H5新增：element.dataset.index 或者 element.dataset[ ‘index’ ]</li>\n</ul>\n<p>注意：</p>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">data-list-name</span>=<span class=\"hljs-string\">&quot;andy&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n<span class=\"hljs-keyword\">var</span> div = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;div&#x27;</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(div.<span class=\"hljs-title function_\">getAttribute</span>(<span class=\"hljs-string\">&#x27;data-list-name&#x27;</span>));\n<span class=\"hljs-comment\">//上下三种方法都可以，但是如果用下面这两种方法的话，要用驼峰命名法</span>\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(div.<span class=\"hljs-property\">dataset</span>.<span class=\"hljs-property\">listName</span>);\n<span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(div.<span class=\"hljs-property\">dataset</span>[<span class=\"hljs-string\">&#x27;listName&#x27;</span>]);\n</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<h2 id=\"节点操作\">节点操作</h2>\n<p>利用DOM提供的方法获取元素  （逻辑性不强，繁琐）</p>\n<ul>\n<li>document.getElementById()</li>\n<li>document.getElementByTagName()</li>\n<li>document.querySelector  等等</li>\n</ul>\n<p>利用    （简单、符合逻辑）</p>\n<ul>\n<li>利用父子兄的节点关系获取元素</li>\n<li>逻辑性强，但是兼容性差</li>\n</ul>\n<h3 id=\"节点\">节点</h3>\n<p><img src=\"media%5CDOM%E6%A0%91.png\" alt=\"DOM树\"></p>\n<p>页面中所有的内容（标签、属性、文本、注释等）都是节点。节点用node表示。</p>\n<p>HTML DOM树中的所有节点均可通过JavaScript 进行访问，所有HTML节点均可被修改，也可以创建或删除。</p>\n<p>一般的，节点至少由nodeType（节点类型）、 nodeName（节点名称）、 nodeValue（节点值）这三个基本属性。</p>\n<ul>\n<li>元素节点 nodeType 为1</li>\n<li>属性节点 nodeType 为2</li>\n<li>文本节点 nodeType 为3 （文本节点包括文字、空格、换行等等）</li>\n</ul>\n<p>在实际开发中，节点操作主要操作的是元素节点。</p>\n<h3 id=\"节点层级\">节点层级</h3>\n<p>最常见的是<strong>父子兄层级关系</strong>。</p>\n<h4 id=\"父级节点\">父级节点</h4>\n<p>node.parentNode</p>\n<p>注意：得到的离元素最近的父级节点（亲爸爸），如果找不到就返回null</p>\n<h4 id=\"子级节点\">子级节点</h4>\n<p>parentNode.childNodes     (标准)</p>\n<p>返回包含指定节点的子节点的集合，该集合为即时更新的集合<br>包含的子节点包含元素节点、文本节点等等</p>\n<p>所以用 nodeType 判断，用for循环遍历</p>\n<p>parentNode.children     (非标准)</p>\n<p>得到所有的子元素节点，虽然是非标准的，但是得到了浏览器的支持，所以以后大量使用这个</p>\n<p>parentNode.firstChild</p>\n<p>返回第一个子节点，找不到返回null,不管是文本节点还是元素节点都能找到</p>\n<p>parentNode.firstElementChild</p>\n<p>返回第一个子元素节点，找不到返回null,只返回元素节点（IE9以上才支持）</p>\n<p>parentNode.lastChild</p>\n<p>返回最后一个子节点，找不到返回null,不管是文本节点还是元素节点都能找到</p>\n<p>parentNode.lastElementChild</p>\n<p>返回最后一个子元素节点，找不到返回null,只返回元素节点（IE9以上才支持）</p>\n<p>实际开发中的办法：</p>\n<p>parentNode.children[i]</p>\n<h4 id=\"案例\">案例</h4>\n<p>案例：新浪下拉菜单</p>\n<p>分析：nav导航栏中有ul和li，li下面又有ul和li，第二层ul和li在鼠标移上去的时候才显示</p>\n<ul>\n<li>导航栏里面的li都要有鼠标经过的效果，所以需要循环注册</li>\n<li>核心原理：当鼠标经过li 的时候，孩子的ul 和li 显示，当鼠标离开，则隐藏</li>\n</ul>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">charset</span>=<span class=\"hljs-string\">&quot;UTF-8&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;viewport&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;X-UA-Compatible&quot;</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;ie=edge&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>新浪网<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\">\n        * {\n            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">0</span>;\n            <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">0</span>;\n        }\n        <span class=\"hljs-selector-tag\">ul</span> {\n            <span class=\"hljs-attribute\">list-style</span>: none;\n        }\n        <span class=\"hljs-selector-tag\">a</span> {\n            <span class=\"hljs-attribute\">text-decoration</span>: none; \n        }\n        <span class=\"hljs-selector-class\">.nav</span> {\n            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">800px</span>;\n            <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">200px</span> auto;\n            <span class=\"hljs-attribute\">position</span>: relative;\n        }\n        <span class=\"hljs-selector-class\">.nav</span>&gt;<span class=\"hljs-selector-tag\">li</span> {\n            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">80px</span>;\n            <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">100%</span>;\n            <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">41px</span>;\n            <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#333</span>;\n            <span class=\"hljs-attribute\">float</span>: left;\n            <span class=\"hljs-attribute\">position</span>: relative;\n            <span class=\"hljs-attribute\">text-align</span>: center;\n        }\n        <span class=\"hljs-selector-class\">.nav</span>&gt;<span class=\"hljs-selector-tag\">li</span>&gt;<span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:hover</span> {\n            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#eee</span>;\n        }\n\n        <span class=\"hljs-selector-class\">.nav</span> <span class=\"hljs-selector-tag\">li</span> <span class=\"hljs-selector-tag\">ul</span> {\n            <span class=\"hljs-attribute\">display</span>: none;\n            <span class=\"hljs-attribute\">position</span>: absolute;\n            <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">41px</span>;\n            <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">0</span>;\n            <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">100%</span>;\n            <span class=\"hljs-attribute\">border-left</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#fecc5b</span>;\n            <span class=\"hljs-attribute\">border-right</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#fecc5b</span>;\n            <span class=\"hljs-attribute\">box-sizing</span>: border-box;\n        }\n        <span class=\"hljs-selector-class\">.nav</span> <span class=\"hljs-selector-tag\">li</span> <span class=\"hljs-selector-tag\">ul</span> <span class=\"hljs-selector-tag\">li</span> {\n            <span class=\"hljs-attribute\">border-bottom</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-number\">#fecc5b</span>;\n<span class=\"hljs-comment\">/*             width: 50px;\n            text-align: center; */</span>\n            \n        }\n        <span class=\"hljs-selector-class\">.nav</span> <span class=\"hljs-selector-tag\">ul</span> <span class=\"hljs-selector-tag\">li</span> <span class=\"hljs-selector-tag\">a</span><span class=\"hljs-selector-pseudo\">:hover</span> {\n            <span class=\"hljs-attribute\">background-color</span>: <span class=\"hljs-number\">#FFF5DA</span>;\n        } \n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;nav&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>微博<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>私信<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>评论<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>@我<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>微博<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>私信<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>评论<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>@我<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>微博<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">ul</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>私信<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>评论<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">li</span>&gt;</span>\n                    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;#&quot;</span>&gt;</span>@我<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>\n                <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n            <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">li</span>&gt;</span>\n\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">ul</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n    <span class=\"hljs-comment\">//获取元素</span>\n    <span class=\"hljs-keyword\">var</span> nav = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;.nav&#x27;</span>);\n    <span class=\"hljs-keyword\">var</span> lis = nav.<span class=\"hljs-property\">children</span>;\n    <span class=\"hljs-comment\">//循环注册事件</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; lis.<span class=\"hljs-property\">length</span>; i++) {\n        lis[i].<span class=\"hljs-property\">onmouseover</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">children</span>[<span class=\"hljs-number\">1</span>].<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">display</span> = <span class=\"hljs-string\">&#x27;block&#x27;</span>;\n        }\n        lis[i].<span class=\"hljs-property\">onmouseout</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n            <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">children</span>[<span class=\"hljs-number\">1</span>].<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">display</span> = <span class=\"hljs-string\">&#x27;none&#x27;</span>;\n        }\n    }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<h4 id=\"兄弟节点\">兄弟节点</h4>\n<p>node.nextSibling 得到下一个兄弟节点，包括元素节点和文本节点<br>node.previousSibling  得到上一个兄弟节点，包括元素节点和文本节点</p>\n<p>//下面两个方法只有IE9以上才能兼容<br>node.nextElementSibling 得到下一个兄弟元素节点，只有元素节点<br>node.previousElementSibling  得到上一个兄弟元素节点，只有元素节点</p>\n<h4 id=\"创建节点\">创建节点</h4>\n<p>document.createElement(‘tagName’)</p>\n<p>这个方法创建由tagName指定的 HTML 元素，因为这些元素原先不存在，是根据我们的需求动态生成的，所以也称为<strong>动态创建元素节点</strong>。</p>\n<p>node.appendChild(child);</p>\n<p>它是追加元素，是在指定父节点的子节点的末尾添加。</p>\n<p>node.insertBefore(child, 指定元素);</p>\n<h4 id=\"留言板案例\">留言板案例</h4>\n<p>分析：</p>\n<ul>\n<li>页面组成：一个文本域，一个提交按钮，一个留言板</li>\n<li>当点击提交按钮的时候，先判断文本域内容是不是空，如果是空，就警告</li>\n<li>如果不是空，就新建一个li，然后把文本域的内容赋值给li，然后在ul里面的前面添加li</li>\n</ul>\n<h4 id=\"删除节点\">删除节点</h4>\n<p>node.removeChild(child);</p>\n<p>从DOM中删除一个子节点，返回删除的节点</p>\n<h4 id=\"删除留言案例\">删除留言案例</h4>\n<p>案例分析：</p>\n<ul>\n<li>在留言板案例的基础上添加功能</li>\n<li>当把文本域的内容幅值给 li 的时候，多添加一个删除的链接，</li>\n<li>循环把所有的链接获取过来，当我们点击一个链接的时候，删除当前链接所在的 li</li>\n<li>阻止链接跳转需要添加javascript:void(0);或者 javascript:;</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n        <span class=\"hljs-comment\">//获取元素</span>\n        <span class=\"hljs-keyword\">var</span> btn = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;button&#x27;</span>);\n        <span class=\"hljs-keyword\">var</span> text = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;textarea&#x27;</span>);\n        <span class=\"hljs-keyword\">var</span> ul = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;ul&#x27;</span>);\n        <span class=\"hljs-comment\">//注册事件</span>\n        btn.<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n            <span class=\"hljs-keyword\">if</span> (text.<span class=\"hljs-property\">value</span> == <span class=\"hljs-string\">&#x27;&#x27;</span>) {\n                <span class=\"hljs-title function_\">alert</span>(<span class=\"hljs-string\">&#x27;您没有输入任何内容&#x27;</span>);\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-keyword\">var</span> li = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">createElement</span>(<span class=\"hljs-string\">&#x27;li&#x27;</span>);\n                <span class=\"hljs-comment\">//将文本域的内容赋值给li，同时后面添加一个删除留言的a链接</span>\n                li.<span class=\"hljs-property\">innerHTML</span> = text.<span class=\"hljs-property\">value</span> + <span class=\"hljs-string\">&quot;&lt;a href=&#x27;javascript:;&#x27;&gt;删除&lt;/a&gt;&quot;</span>;\n                ul.<span class=\"hljs-title function_\">insertBefore</span>(li, ul.<span class=\"hljs-property\">children</span>[<span class=\"hljs-number\">0</span>]);\n                <span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">as</span> = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelectorAll</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>); \n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-keyword\">as</span>.<span class=\"hljs-property\">length</span>; i++) {\n                    <span class=\"hljs-keyword\">as</span>[i].<span class=\"hljs-property\">onclick</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n                        <span class=\"hljs-comment\">//删除的是a当前所在的li</span>\n                        ul.<span class=\"hljs-title function_\">removeChild</span>(<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">parentNode</span>);\n                    }\n                }               \n            }\n        }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n</code></pre>\n<h4 id=\"复制节点（克隆节点）\">复制节点（克隆节点）</h4>\n<p>node.cloneNode()<br>这个方法返回一个节点的副本</p>\n<p>注意：</p>\n<ul>\n<li>如果括号里面的参数为空，那么只是浅拷贝，即只复制节点本身，不克隆里面的子节点</li>\n<li>如果括号里面的参数为true，那么是深拷贝，复制标签并且复制里面的内容</li>\n</ul>\n<h4 id=\"三种动态创建元素区别\">三种动态创建元素区别</h4>\n<ul>\n<li>document.write()<ul>\n<li>文档流执行完毕之后，他会导致页面全部重绘</li>\n</ul>\n</li>\n<li>document.innerHTML()<ul>\n<li>将内容写入某个DOM节点，不会导致页面全部重绘</li>\n<li>拼接字符串的效率低</li>\n<li>创建多个元素效率更高，（不要拼接字符串，采取数组形式拼接），结构稍显复杂</li>\n</ul>\n</li>\n<li>document.createElement()<ul>\n<li>创建多个元素效率稍低一点点，但是结构更清晰</li>\n</ul>\n</li>\n</ul>\n<p><strong>总结</strong>：不同浏览器下，innerHTML比createElement效率高</p>\n<h2 id=\"dom重点核心\">DOM重点核心</h2>\n<p>文档对象模型</p>\n<h3 id=\"增\">增</h3>\n<ul>\n<li>appendChild</li>\n<li>insertBefore</li>\n</ul>\n<h3 id=\"删\">删</h3>\n<ul>\n<li>removeChild</li>\n</ul>\n<h3 id=\"改\">改</h3>\n<p>修改DOM元素的属性，DOM元素的内容、属性、表单的值等</p>\n<ul>\n<li>修改元素属性：src、href、title等</li>\n<li>修改普通元素内容：innerHTML、innerText</li>\n<li>修改表单元素：value、type、disable等</li>\n<li>修改元素样式：style、className</li>\n</ul>\n<h3 id=\"查\">查</h3>\n<ul>\n<li>DOM提供的API方法：getElementById、getElementByTagName古老用法不太推荐</li>\n<li>H5提供的新方法：querySelecter、querySelectorAll提倡使用</li>\n<li>利用节点操作获取元素：父（parentNode）、子（children）、兄（previousElementSibling、nextElementSibling）提倡使用</li>\n</ul>\n<h3 id=\"属性操作\">属性操作</h3>\n<ul>\n<li>setAttribute ： 设置DOM的属性</li>\n<li>getAttribute ： 得到DOM的属性</li>\n<li>removeAttribute ： 移除属性</li>\n</ul>\n<h3 id=\"事件操作\">事件操作</h3>\n<table>\n<thead>\n<tr>\n<th>鼠标事件</th>\n<th>触发条件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>onclick</td>\n<td>鼠标点击左键触发</td>\n</tr>\n<tr>\n<td>onmouseover</td>\n<td>鼠标经过触发</td>\n</tr>\n<tr>\n<td>onmouseout</td>\n<td>鼠标离开触发</td>\n</tr>\n<tr>\n<td>onfocus</td>\n<td>获得鼠标焦点触发</td>\n</tr>\n<tr>\n<td>onblur</td>\n<td>失去鼠标焦点触发</td>\n</tr>\n<tr>\n<td>onmousemove</td>\n<td>鼠标移动触发</td>\n</tr>\n<tr>\n<td>onmouseup</td>\n<td>鼠标弹起触发</td>\n</tr>\n<tr>\n<td>onmousedown</td>\n<td>鼠标按下触发</td>\n</tr>\n</tbody></table>\n<h2 id=\"事件高级\">事件高级</h2>\n<h3 id=\"注册事件\">注册事件</h3>\n<p>给元素添加事件，称为注册时间或者绑定事件。</p>\n<p>注册事件有两种方式：传统方式和方法监听注册方式</p>\n<h3 id=\"传统注册方式\">传统注册方式</h3>\n<ul>\n<li>利用on开头的事件onclick</li>\n<li><button onclick=\"alert(\'hi\')\"></button></li>\n<li>btn.onclick = function () {}</li>\n<li>特点：注册事件的<strong>唯一性</strong></li>\n<li>同一个元素同一个事件著能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数</li>\n</ul>\n<h3 id=\"监听注册方式\">监听注册方式</h3>\n<ul>\n<li>W3C标准推荐方式</li>\n<li>addEventListener() 它是一个方法</li>\n<li>IE9之前的IE浏览器不支持此方法，可使用attachEvent()代替</li>\n<li>特点: 同一个元素同一个事件可以注册多个监听器</li>\n</ul>\n<h3 id=\"addeventlistener-方法\">addEventListener() 方法</h3>\n<pre><code class=\"hljs language-javascript\">eventTarget.add<span class=\"hljs-constructor\">EventListener(<span class=\"hljs-params\">type</span>, <span class=\"hljs-params\">listener</span>[, <span class=\"hljs-params\">useCapture</span>])</span>\n</code></pre>\n<p>eventTarget.addEventListener(type, listener[, useCapture]) 方法将指定的监听器注册到eventTarget 上，当该对象触发指定的事件时，就会执行事件处理函数。</p>\n<p>该方法接收三个参数：</p>\n<ul>\n<li>type : 事件类型字符串，比如click、mouseover，<strong>注意这里不要带on</strong>，是字符串，带引号</li>\n<li>listener ： 事件处理函数，事件发生时，会调用该监听函数</li>\n<li>useCapture : 可选函数，是一个布尔值，默认是false 。学完DOM事件流之后，再进一步学习</li>\n</ul>\n<h3 id=\"attachevent\">attachEvent</h3>\n<p><strong>该特性非标准，请尽量不要在生产环境中使用它</strong></p>\n<pre><code>eventTarget.attack<span class=\"hljs-constructor\">Event(<span class=\"hljs-params\">eventNameWithon</span>, <span class=\"hljs-params\">callback</span>)</span>\n</code></pre>\n<p>eventTarget.attackEvent方法将指定的监听器注册到eventTarget 上，当该对象触发指定的事件时，指定的回调函数将会被执行。</p>\n<p>该方法接收两个参数：</p>\n<ul>\n<li>ventNameWithon ： 事件类型字符串，比如onclick，onmouseover， 这里要带on</li>\n<li>callback : 事件处理函数，当目标触发事件时回调函数将被调用</li>\n</ul>\n<h3 id=\"注册事件的兼容性解决方案\">注册事件的兼容性解决方案</h3>\n<pre><code class=\"hljs language-html\">    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">button</span>&gt;</span>点击我<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">button</span>&gt;</span></span>\n    <span class=\"language-xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n        <span class=\"hljs-keyword\">var</span> btn = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;button&#x27;</span>);\n        <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">alertWarn</span> () </span></span><span class=\"language-xquery\">{\n            alert (<span class=\"hljs-string\">&#x27;warning&#x27;</span>);\n        }</span><span class=\"language-xml\"><span class=\"language-javascript\">\n        <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-params\">element, eventName, fn</span>) </span></span><span class=\"language-xquery\">{\n            //判断浏览器是否支持addEventListener方法\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-type\">element</span>.addEventListener) {\n                <span class=\"hljs-type\">element</span>.addEventListener (eventName, fn);   //第三个参数，默认<span class=\"hljs-built_in\">是false</span>\n            }</span><span class=\"language-xml\"><span class=\"language-javascript\"> <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (element.<span class=\"hljs-property\">attachEvent</span>) </span></span><span class=\"language-xquery\">{\n                <span class=\"hljs-type\">element</span>.attachEvent (<span class=\"hljs-string\">&#x27;on&#x27;</span> + eventName, fn);\n            }</span><span class=\"language-xml\"><span class=\"language-javascript\"> <span class=\"hljs-keyword\">else</span> </span></span><span class=\"language-xquery\">{\n                //相当于<span class=\"hljs-type\">element</span>.onclick = fn;\n                <span class=\"hljs-keyword\">element</span>[&#x27;on&#x27; + eventName] = fn;\n            }</span><span class=\"language-xml\"><span class=\"language-javascript\">\n        }\n        <span class=\"hljs-title function_\">addEventListener</span>(btn, <span class=\"hljs-string\">&#x27;click&#x27;</span>, alertWarn);\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span></span>\n</code></pre>\n<h2 id=\"删除事件\">删除事件</h2>\n<h3 id=\"删除事件的方式\">删除事件的方式</h3>\n<ul>\n<li>传统注册方式<pre><code><span class=\"hljs-attr\">eventTarget.onclick</span> = null<span class=\"hljs-comment\">;</span>\n</code></pre>\n</li>\n<li>方法监听注册方式<pre><code>divs<span class=\"hljs-literal\">[<span class=\"hljs-number\">1</span>]</span>.add<span class=\"hljs-constructor\">EventListener(&#x27;<span class=\"hljs-params\">click</span>&#x27;, <span class=\"hljs-params\">alertWarn</span>)</span>;\n<span class=\"hljs-keyword\">function</span> alertWarn <span class=\"hljs-literal\">()</span> {\n  alert(&#x27;warning&#x27;);\n  divs<span class=\"hljs-literal\">[<span class=\"hljs-number\">1</span>]</span>.remove<span class=\"hljs-constructor\">EventListener(&#x27;<span class=\"hljs-params\">click</span>&#x27;, <span class=\"hljs-params\">alertWarn</span>)</span>;\n}\n</code></pre>\n</li>\n<li>attach 方式<pre><code>divs<span class=\"hljs-literal\">[<span class=\"hljs-number\">2</span>]</span>.attach<span class=\"hljs-constructor\">Event(&#x27;<span class=\"hljs-params\">onclick</span>&#x27;, <span class=\"hljs-params\">alertWarn1</span>)</span>;\n<span class=\"hljs-keyword\">function</span> alertWarn1 <span class=\"hljs-literal\">()</span> {\n  alert(&#x27;warning&#x27;);\n  divs<span class=\"hljs-literal\">[<span class=\"hljs-number\">1</span>]</span>.detach<span class=\"hljs-constructor\">Event(&#x27;<span class=\"hljs-params\">click</span>&#x27;, <span class=\"hljs-params\">alertWarn1</span>)</span>;\n}\n</code></pre>\n</li>\n<li>兼容性方案<br>参考上面的注册事件的兼容性方式。</li>\n</ul>\n<h2 id=\"dom事件流\">DOM事件流</h2>\n<p>事件流描述的是从页面中接收事件的顺序。</p>\n<p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流。</p>\n<p>包括三个阶段：</p>\n<ol>\n<li>事件捕获阶段</li>\n<li>处于目标阶段</li>\n<li>事件冒泡阶段</li>\n</ol>\n<p>注意:</p>\n<ul>\n<li>JS代码只能执行捕获或者冒泡其中的一个阶段</li>\n<li>onclick 和 attachEvent 只能得到冒泡阶段</li>\n<li>addEventListener (type, listener[, useCapture]) 第三个参数如果是true，表示在事件捕获阶段调用事件处理程序；如果是false（不写默认就是false），表示在事件冒泡阶段电泳事件处理程序。</li>\n<li>在实际开发中，我们很少使用事件捕获，我们更关注事件冒泡</li>\n<li>有些事件是没有冒泡的，比如onblur、onfocus、onmouseover、onmouseleave</li>\n<li>虽然事件冒泡有时候会带来麻烦，但是有时候又会巧妙的做某些事情，我们后面讲解</li>\n</ul>\n<h2 id=\"事件对象\">事件对象</h2>\n<ul>\n<li>event 就是一个事件对象，写道我们的侦听函数的小括号里面，当形参来看</li>\n<li>事件对象只有有了事件才会存在，他是系统给我们自动创建的，不需要我们传递参数</li>\n<li>事件对象是我们的事件的一系列相关数据的集合，比如鼠标点击里面就包含了鼠标的相关信息</li>\n<li>这个事件对象我们可以自己命名，比如 event、evt 、e 等</li>\n<li>事件对象也有兼容性问题。 IE 6、7、8通过 window.event 实现</li>\n</ul>\n<p>兼容性写法：</p>\n<pre><code><span class=\"hljs-keyword\">event</span> = <span class=\"hljs-keyword\">event</span> || windoe.<span class=\"hljs-keyword\">event</span>;\n</code></pre>\n<h3 id=\"事件对象常见的额属性和方法\">事件对象常见的额属性和方法</h3>\n<table>\n<thead>\n<tr>\n<th>事件对象属性方法</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>e.target</td>\n<td>返回触发事件的对象  标准</td>\n</tr>\n<tr>\n<td>e.scrElement</td>\n<td>返回触发事件的对象  非标准 IE 6  7 8 使用</td>\n</tr>\n<tr>\n<td>e.type</td>\n<td>返回事件的类型，比如click、mouseover等，不带 on</td>\n</tr>\n<tr>\n<td>e.cancelBubble</td>\n<td>该属性阻止冒泡，非标准，IE 6 7 8 使用</td>\n</tr>\n<tr>\n<td>e.returnValue</td>\n<td>该属性阻止默认事件（默认行为）非标准 ，IE 6 7 8 使用，比如不让链接跳转</td>\n</tr>\n<tr>\n<td>e.preventDefaule()</td>\n<td>该方法阻止默认事件（默认行为）标准 ，比如不让链接跳转</td>\n</tr>\n<tr>\n<td>e.stopPropagation()</td>\n<td>阻止冒泡，标准</td>\n</tr>\n</tbody></table>\n<h3 id=\"etarget-和-this-的区别\">e.target 和 this 的区别</h3>\n<p>this 返回的是绑定事件的对象（元素）</p>\n<p>e.target 返回的是点击的那个对象，就是谁触发了这个事件</p>\n<pre><code><span class=\"hljs-keyword\">var</span> ul = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;ul&#x27;</span>);\nul.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(<span class=\"hljs-variable language_\">this</span>);\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e.<span class=\"hljs-property\">target</span>);\n})\n\n<span class=\"hljs-comment\">// &lt;ul&gt;...&lt;/ul&gt;</span>\n<span class=\"hljs-comment\">// &lt;li&gt;123&lt;/li&gt;</span>\n</code></pre>\n<h3 id=\"阻止对象默认行为\">阻止对象默认行为</h3>\n<p>三种方法：</p>\n<ul>\n<li>e.preventDefaule();<br>是一个方法，适合普通浏览器</li>\n<li>e.returnValue;</li>\n<li>是一个属性，适用于 IE 6 7 8</li>\n<li>return false;<br>没有兼容性问题，但是需要注意后面的语句就不执行了，直接跳出</li>\n</ul>\n<h3 id=\"阻止冒泡\">阻止冒泡</h3>\n<ul>\n<li>event.stopPropagation();    // 一般浏览器停止冒泡</li>\n<li>event.cancelBubble;         // IE 6 7 8 的停止冒泡</li>\n</ul>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-keyword\">var</span> father = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;.father&#x27;</span>);\n<span class=\"hljs-keyword\">var</span> son = <span class=\"hljs-built_in\">document</span>.querySelector(<span class=\"hljs-string\">&#x27;.son&#x27;</span>);\nfather.addEventListener(<span class=\"hljs-string\">&#x27;click&#x27;</span>, alertName, <span class=\"hljs-literal\">false</span>);\nson.addEventListener(<span class=\"hljs-string\">&#x27;click&#x27;</span>, alertName, <span class=\"hljs-literal\">false</span>);\n<span class=\"hljs-built_in\">document</span>.addEventListener(<span class=\"hljs-string\">&#x27;click&#x27;</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) </span>{\n    alert(<span class=\"hljs-string\">&#x27;document&#x27;</span>);\n}, <span class=\"hljs-literal\">false</span>);\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">alertName</span> (<span class=\"hljs-params\">event</span>) </span>{\n    alert(<span class=\"hljs-keyword\">this</span>.getAttribute(<span class=\"hljs-string\">&quot;class&quot;</span>));\n    event.stopPropagation();    <span class=\"hljs-comment\">// 停止冒泡</span>\n    event.cancelBubble;         <span class=\"hljs-comment\">// IE 6 7 8 的停止冒泡</span>\n}\n</code></pre>\n<h2 id=\"事件委托（代理、委派）\">事件委托（代理、委派）</h2>\n<h3 id=\"事件委托的原理\">事件委托的原理</h3>\n<p>事件委托的原理：不给每个子节点单独设置事件监听器，而是设置在其父节点上，然后利用冒泡原理设置每个子节点。</p>\n<p><strong>例如：</strong>给 ul 注册点击事件，然后利用事件对象的 target 来找到当前点击的 li ，然后事件冒泡到 ul 上， ul 有注册事件，就会触发事件监听器。</p>\n<h3 id=\"事件委托的作用\">事件委托的作用</h3>\n<p>只操作了一次 DOM ，提高了程序的性能。</p>\n<h2 id=\"常用的鼠标事件\">常用的鼠标事件</h2>\n<table>\n<thead>\n<tr>\n<th>鼠标事件</th>\n<th>触发条件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>onclick</td>\n<td>鼠标点击左键触发</td>\n</tr>\n<tr>\n<td>onmouseover</td>\n<td>鼠标经过触发</td>\n</tr>\n<tr>\n<td>onmouseout</td>\n<td>鼠标离开触发</td>\n</tr>\n<tr>\n<td>onfocus</td>\n<td>获得鼠标焦点触发</td>\n</tr>\n<tr>\n<td>onblur</td>\n<td>失去鼠标焦点触发</td>\n</tr>\n<tr>\n<td>onmousemove</td>\n<td>鼠标移动触发</td>\n</tr>\n<tr>\n<td>onmouseup</td>\n<td>鼠标弹起触发</td>\n</tr>\n<tr>\n<td>onmousedown</td>\n<td>鼠标按下触发</td>\n</tr>\n</tbody></table>\n<pre><code class=\"hljs language-javascript\"><span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;click&#x27;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) {\n    <span class=\"hljs-variable language_\">console</span>.<span class=\"hljs-title function_\">log</span>(e);\n});\n</code></pre>\n<table>\n<thead>\n<tr>\n<th>鼠标事件对象</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>e.clientX</td>\n<td>返回鼠标相对于浏览器窗口可视区域的X坐标</td>\n</tr>\n<tr>\n<td>e.clientY</td>\n<td>返回鼠标相对于浏览器窗口可视区域的Y坐标</td>\n</tr>\n<tr>\n<td>e.pageX</td>\n<td>返回鼠标相对于文档页面的X坐标 IE9+ 支持</td>\n</tr>\n<tr>\n<td>e.pageY</td>\n<td>返回鼠标相对于文档页面的Y坐标 IE9+ 支持</td>\n</tr>\n<tr>\n<td>e.screenX</td>\n<td>返回鼠标相对于电脑屏幕的X坐标</td>\n</tr>\n<tr>\n<td>e.screenY</td>\n<td>返回鼠标相对于电脑屏幕的Y坐标</td>\n</tr>\n</tbody></table>\n<h3 id=\"案例-1\">案例:</h3>\n<p>跟随鼠标的小鸟:</p>\n<h4 id=\"案例分析\">案例分析</h4>\n<ul>\n<li>鼠标不断的移动,使用鼠标移动事件: mousemove</li>\n<li>在页面中移动,所以给 document 注册事件</li>\n<li>图片要移动距离,而且不占位置,我们使用绝对定位即可</li>\n<li>核心原理,每次鼠标移动,我们都会获得最新的鼠标坐标,把这个 X 和 Y 的坐标做为图片的 top 和 left 值就可以移动图片</li>\n</ul>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>跟随鼠标的小鸟<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\">\n        <span class=\"hljs-selector-tag\">img</span> {\n            <span class=\"hljs-attribute\">position</span>: absolute;\n        }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">img</span> <span class=\"hljs-attr\">src</span>=<span class=\"hljs-string\">&quot;images/bird.gif&quot;</span> <span class=\"hljs-attr\">alt</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n        <span class=\"hljs-keyword\">var</span> image = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;img&#x27;</span>);\n        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;mousemove&#x27;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) {\n            <span class=\"hljs-comment\">// 只要鼠标移动，就会触发这个事件</span>\n            <span class=\"hljs-keyword\">var</span> x = e.<span class=\"hljs-property\">pageX</span>;\n            <span class=\"hljs-keyword\">var</span> y = e.<span class=\"hljs-property\">pageY</span>;\n            <span class=\"hljs-comment\">// top 和 left 一定要加 px</span>\n            image.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">left</span> = x + <span class=\"hljs-number\">20</span> + <span class=\"hljs-string\">&#x27;px&#x27;</span>;\n            image.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">top</span> = y + <span class=\"hljs-number\">20</span> + <span class=\"hljs-string\">&#x27;px&#x27;</span>;\n        });\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<h2 id=\"常用键盘事件\">常用键盘事件</h2>\n<h3 id=\"常用键盘事件-1\">常用键盘事件</h3>\n<table>\n<thead>\n<tr>\n<th>键盘事件</th>\n<th>触发条件</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>onkeyup</td>\n<td>某个键盘按键被松开时触发（松开的时候触发）</td>\n</tr>\n<tr>\n<td>onkeydown</td>\n<td>某个键盘按键被按下时触发（按下之后一直触发）</td>\n</tr>\n<tr>\n<td>onkeypress</td>\n<td>某个键盘按键被按下时触发（按下之后一直触发），但是它不能识别功能键，比如 ctrl、shift 等</td>\n</tr>\n</tbody></table>\n<p>当按下的时候，keydown 执行在 keypress 之前。</p>\n<h2 id=\"键盘事件对象\">键盘事件对象</h2>\n<table>\n<thead>\n<tr>\n<th>键盘事件对象属性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>keyCode</td>\n<td>返回该键的 ASCII 值</td>\n</tr>\n</tbody></table>\n<p><strong>注意：</strong></p>\n<ul>\n<li>keyup 和 keydown 事件不区分字母大小写， a 和 A 得到的都是65</li>\n<li>keypress 区分大小写，a 得到的是97，A 得到的是 65</li>\n</ul>\n<h3 id=\"案例1\">案例1:</h3>\n<p>京东按下 s 键定位到搜索框:</p>\n<p>检测用户是否按下了 s 键盘，如果按下 s 键，就把光标定位到搜索框里面。</p>\n<h4 id=\"案例分析-1\">案例分析</h4>\n<ul>\n<li>利用键盘事件对象里面的 keyCode 判断用户是否按下的是 s 键</li>\n<li>搜索框获得焦点的方法: 利用 js 里面的 focus() 方法</li>\n</ul>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>京东搜索框<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;&quot;</span> <span class=\"hljs-attr\">id</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n        <span class=\"hljs-keyword\">var</span> input = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;input&#x27;</span>);\n        <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;keyup&#x27;</span>, <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">e</span>) {\n            <span class=\"hljs-keyword\">if</span> (e.<span class=\"hljs-property\">keyCode</span> == <span class=\"hljs-number\">83</span>) {\n                input.<span class=\"hljs-title function_\">focus</span>();\n            }\n        });\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<h3 id=\"案例2\">案例2:</h3>\n<p>快递单号查询:</p>\n<p>查询快递单号的时候，上面一个更大的盒子显示同样的内容（这里的字号更大）。</p>\n<p><img src=\"media%5Cexpress.png\" alt=\"快递单号查询\"></p>\n<h4 id=\"案例分析-2\">案例分析</h4>\n<ul>\n<li>表单检测用户输入：给表单添加键盘事件</li>\n<li>同时把快递单号里面的值（value）获取过来赋值给 con 盒子（innerText）作为内容</li>\n<li>当失去焦点的时候，就隐藏这个 con 盒子。</li>\n<li>当获得焦点的时候，如果快递单号里面不为空，就显示 con 盒子。</li>\n</ul>\n<pre><code class=\"hljs language-html\"><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">html</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span> <span class=\"hljs-attr\">lang</span>=<span class=\"hljs-string\">&quot;en&quot;</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>Document<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">style</span>&gt;</span><span class=\"language-css\">\n    <span class=\"hljs-selector-class\">.search</span> {\n        <span class=\"hljs-attribute\">position</span>: relative;\n        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">178px</span>;\n        <span class=\"hljs-attribute\">margin</span>: <span class=\"hljs-number\">100px</span>;\n    }\n    <span class=\"hljs-selector-class\">.con</span> {\n        <span class=\"hljs-attribute\">display</span>: none;;\n        <span class=\"hljs-attribute\">position</span>: absolute;\n        <span class=\"hljs-attribute\">top</span>: -<span class=\"hljs-number\">40px</span>;\n        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">171px</span>;\n        <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">1px</span> solid <span class=\"hljs-built_in\">rgba</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0.2</span>);\n        <span class=\"hljs-attribute\">padding</span>: <span class=\"hljs-number\">5px</span> <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-attribute\">font-size</span>: <span class=\"hljs-number\">18px</span>;\n        <span class=\"hljs-attribute\">line-height</span>: <span class=\"hljs-number\">20px</span>;\n        <span class=\"hljs-attribute\">color</span>: <span class=\"hljs-number\">#333</span>;\n    }\n    <span class=\"hljs-selector-class\">.con</span><span class=\"hljs-selector-pseudo\">::before</span> {\n        <span class=\"hljs-attribute\">content</span>: <span class=\"hljs-string\">&#x27;&#x27;</span>;\n        <span class=\"hljs-attribute\">width</span>: <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-attribute\">height</span>: <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-attribute\">position</span>: absolute;\n        <span class=\"hljs-attribute\">top</span>: <span class=\"hljs-number\">28px</span>;\n        <span class=\"hljs-attribute\">left</span>: <span class=\"hljs-number\">18px</span>;\n        <span class=\"hljs-attribute\">border</span>: <span class=\"hljs-number\">8px</span> solid <span class=\"hljs-number\">#000</span>;\n        <span class=\"hljs-attribute\">border-style</span>: solid dashed dashed;\n        <span class=\"hljs-attribute\">border-color</span>: <span class=\"hljs-number\">#fff</span> transparent transparent;\n    }\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">style</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span>\n\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;search&quot;</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">div</span> <span class=\"hljs-attr\">class</span>=<span class=\"hljs-string\">&quot;con&quot;</span>&gt;</span>123<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">&quot;text&quot;</span> <span class=\"hljs-attr\">placeholder</span>=<span class=\"hljs-string\">&quot;请输入您的快递单号&quot;</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">div</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">script</span>&gt;</span><span class=\"language-javascript\">\n    <span class=\"hljs-keyword\">var</span> input = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;input&#x27;</span>);\n    <span class=\"hljs-keyword\">var</span> con = <span class=\"hljs-variable language_\">document</span>.<span class=\"hljs-title function_\">querySelector</span>(<span class=\"hljs-string\">&#x27;.con&#x27;</span>);\n    input.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;keyup&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\">e</span>) {\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> == <span class=\"hljs-string\">&#x27;&#x27;</span>) {\n            con.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">display</span> = <span class=\"hljs-string\">&#x27;none&#x27;</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n            con.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">display</span> = <span class=\"hljs-string\">&#x27;block&#x27;</span>;\n            con.<span class=\"hljs-property\">innerText</span> = <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span>;\n        }\n    });\n    <span class=\"hljs-comment\">// 当失去焦点的时候，就隐藏这个 con 盒子。</span>\n    input.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;blur&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n        con.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">display</span> = <span class=\"hljs-string\">&#x27;none&#x27;</span>;\n    });\n    <span class=\"hljs-comment\">// 当获得焦点的时候，如果内容不为空，就显示这个 con 盒子。</span>\n    input.<span class=\"hljs-title function_\">addEventListener</span>(<span class=\"hljs-string\">&#x27;focus&#x27;</span>, <span class=\"hljs-keyword\">function</span>(<span class=\"hljs-params\"></span>) {\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">value</span> !== <span class=\"hljs-string\">&#x27;&#x27;</span>) {\n            con.<span class=\"hljs-property\">style</span>.<span class=\"hljs-property\">display</span> = <span class=\"hljs-string\">&#x27;block&#x27;</span>;\n        }\n    });\n    </span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">script</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span>\n</code></pre>\n<p><strong>注意：</strong></p>\n<p>keydown 和 keypress 触发的时候，文字还没有落入文本框中。</p>\n<p>keyup 触发的时候，文字已经输入到文本框中。</p>\n');

-- ----------------------------
-- Table structure for m_blog_sort
-- ----------------------------
DROP TABLE IF EXISTS `m_blog_sort`;
CREATE TABLE `m_blog_sort`  (
  `id` bigint NOT NULL AUTO_INCREMENT COMMENT '唯一uid',
  `sort_name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '分类内容',
  `content` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '分类简介',
  `create_time` datetime NOT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `status` tinyint UNSIGNED NOT NULL DEFAULT 1 COMMENT '状态',
  `sort` int NULL DEFAULT 0 COMMENT '排序字段，越大越靠前',
  `click_count` int NULL DEFAULT 0 COMMENT '点击数',
  `user_id` bigint NULL DEFAULT NULL,
  `deleted` tinyint(1) NULL DEFAULT 0,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 2 CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '博客分类表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of m_blog_sort
-- ----------------------------
INSERT INTO `m_blog_sort` VALUES (1, 'Java', 'Java', '2021-09-23 21:36:50', '2021-09-23 21:36:50', 1, 0, 0, 1, 0);
INSERT INTO `m_blog_sort` VALUES (2, 'Docker', 'Docker', '2021-09-23 21:37:01', '2021-09-23 21:37:01', 1, 0, 0, 1, 0);

-- ----------------------------
-- Table structure for m_blog_tag
-- ----------------------------
DROP TABLE IF EXISTS `m_blog_tag`;
CREATE TABLE `m_blog_tag`  (
  `uid` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '唯一uid',
  `content` varchar(1000) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '标签内容',
  `status` tinyint UNSIGNED NOT NULL DEFAULT 1 COMMENT '状态：1[启用]，2[删除]',
  `click_count` int NULL DEFAULT 0 COMMENT '标签简介',
  `create_time` datetime NOT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` datetime NOT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  `sort` int NULL DEFAULT 0 COMMENT '排序字段，越大越靠前',
  PRIMARY KEY (`uid`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci COMMENT = '标签表' ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of m_blog_tag
-- ----------------------------

-- ----------------------------
-- Table structure for m_link_nav
-- ----------------------------
DROP TABLE IF EXISTS `m_link_nav`;
CREATE TABLE `m_link_nav`  (
  `link_id` bigint NOT NULL AUTO_INCREMENT COMMENT '唯一ID',
  `link_title` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '链接标题',
  `link_description` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '链接描述',
  `link_cover` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-icon-a@master/e.7vsezrurgjk.svg' COMMENT '链接封面图片地址',
  `link_like` int NULL DEFAULT 0 COMMENT '链接点赞数',
  `link_status` tinyint NOT NULL DEFAULT 0 COMMENT '链接状态 (0:正常,1:异常)',
  `is_publish` tinyint NULL DEFAULT 1 COMMENT '是否发布 (0:否,1:是)',
  `is_open_comment` tinyint NULL DEFAULT 1 COMMENT '是否开启评论 (0:否,1:是)',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `update_time` datetime NULL DEFAULT NULL COMMENT '更新时间',
  `deleted` tinyint NULL DEFAULT 0 COMMENT '是否删除 (0:否,1:是)',
  `link_sort` bigint NULL DEFAULT NULL COMMENT '链接分类',
  `link` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '链接地址',
  `link_uuid` bigint NULL DEFAULT NULL COMMENT '链接唯一ID',
  `link_uid` bigint NULL DEFAULT NULL COMMENT '创建链接的用户',
  PRIMARY KEY (`link_id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 47 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of m_link_nav
-- ----------------------------
INSERT INTO `m_link_nav` VALUES (1, 'string', 'string', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 10, 1, 0, 0, '2021-10-09 17:08:50', '2021-10-09 17:24:25', 1, NULL, 'https://www.baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (2, 'string', 'string', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', NULL, 1, 1, 0, '2021-10-09 17:20:22', '2021-10-09 17:20:22', 0, NULL, 'https://www.baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (3, 'string', 'string', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', NULL, 0, 0, 0, '2021-10-09 17:21:48', '2021-10-09 17:21:48', 0, NULL, 'https://www.baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (4, 'stri3333ng', '3333', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', NULL, 0, 1, 0, '2021-10-09 18:13:20', '2021-10-09 18:13:20', 1, NULL, 'https://www.baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (5, 'test', 'test', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', NULL, 0, 1, 0, '2021-10-09 18:25:18', '2021-10-09 18:25:18', 1, NULL, 'https://www.baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (6, 'string', 'string', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-icon-a@master/e.7vsezrurgjk.svg', 0, 0, 1, 0, '2021-10-09 18:26:37', '2021-10-09 18:29:27', 1, NULL, 'https://www.baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (7, 'test', 'test123', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 0, 0, '2021-10-09 18:27:42', '2021-10-09 18:27:42', 0, NULL, 'https://www.baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (9, '353425234564234543534325', '354434255234523454353454455434354454545453434534534565376575687687686758568568568568', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-icon-a@master/e.7vsezrurgjk.svg', 0, 0, 1, 0, '2021-10-09 21:03:37', '2021-10-14 14:19:40', 0, NULL, 'https://baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (10, 'strin434g', 'str34ing', 's34324tring', 0, 0, 1, 0, '2021-10-11 13:44:05', '2021-10-11 13:44:05', 1, NULL, 'strin34g', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (11, 'strin434g', 'str34ing', 's34324tring', 0, 0, 1, 0, '2021-10-11 13:47:12', '2021-10-11 13:47:12', 1, NULL, 'strin34g', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (12, 'strin434g', 'str34ing', 's34324tring', 0, 0, 1, 0, '2021-10-11 13:53:37', '2021-10-11 13:53:37', 1, NULL, 'strin34g', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (13, '23424', 'ssss', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 0, 0, '2021-10-11 13:55:38', '2021-10-11 15:05:09', 0, NULL, 'https://www.baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (14, '342', '', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 0, '2021-10-11 14:10:28', '2021-10-11 15:05:24', 0, NULL, 'https://www.baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (15, '默认标题', '', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 14:11:04', '2021-10-11 14:11:04', 0, NULL, 'https://halo123.top', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (16, '默认标题', '', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 14:12:13', '2021-10-11 14:12:13', 1, NULL, 'https://halo123.top', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (17, '默认标题', '', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 14:12:22', '2021-10-11 14:12:22', 1, NULL, 'https://halo123.top', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (18, '默认标题', '', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 14:12:57', '2021-10-11 14:12:57', 1, NULL, 'https://www.baid.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (19, '默认标题', '', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 14:13:27', '2021-10-11 14:13:27', 1, NULL, 'https://www.baid.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (20, '默认标题', '', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 14:17:22', '2021-10-11 14:17:22', 1, NULL, 'https://baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (21, '默认标题', '', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 14:18:14', '2021-10-11 14:18:14', 1, NULL, 'https://baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (22, '默认标题', '', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 14:18:45', '2021-10-11 14:18:45', 1, NULL, 'https://baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (23, '3424', '', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 14:20:03', '2021-10-11 14:20:03', 1, NULL, 'https://baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (24, '默认标题tertert', '', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 14:21:25', '2021-10-11 14:21:25', 1, NULL, 'https://baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (25, '默认标题tertert', '', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 14:21:34', '2021-10-11 14:21:34', 1, NULL, 'https://baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (26, '默认标题', 'ssss', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 15:02:25', '2021-10-11 15:02:25', 0, NULL, 'https://www.baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (27, '默认标题', 'ssss', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 15:02:41', '2021-10-11 15:42:49', 0, NULL, 'https://www.baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (28, '默认标题', 'ssss', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 0, '2021-10-11 15:03:21', '2021-10-11 15:42:55', 0, NULL, 'https://www.baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (29, '353425234564234543534325', '354434255234523454353454455434354454545453434534534565376575687687686758568568568568', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-icon-a@master/e.7vsezrurgjk.svg', 0, 0, 1, 1, '2021-10-11 15:16:08', '2021-10-11 15:16:08', 0, NULL, 'https://www.baidu.com', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (30, '353425234564234543534325', '354434255234523454353454455434354454545453434534534565376575687687686758568568568568', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-icon-a@master/e.7vsezrurgjk.svg', 0, 0, 1, 1, '2021-10-11 15:29:19', '2021-10-11 15:29:19', 0, NULL, 'https://halo123.top', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (31, 'r', '354434255234523454353454455434354454545453434534534565376575687687686758568568568568', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-icon-a@master/e.7vsezrurgjk.svg', 0, 0, 0, 0, '2021-10-11 15:29:35', '2021-10-11 15:29:35', 0, NULL, 'https://halo123.top', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (32, '353425234564234543534325', '354434255234523454353454455434354454545453434534534565376575687687686758568568568568', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-icon-a@master/e.7vsezrurgjk.svg', 0, 0, 1, 0, '2021-10-11 15:29:41', '2021-10-11 15:29:41', 0, NULL, 'https://halo123.top', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (33, '5', '354434255234523454353454455434354454545453434534534565376575687687686758568568568568', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-icon-a@master/e.7vsezrurgjk.svg', 0, 0, 1, 0, '2021-10-11 15:29:47', '2021-10-11 15:29:47', 0, NULL, 'https://halo123.top', NULL, NULL);
INSERT INTO `m_link_nav` VALUES (34, '博客', '我的博客', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 15:49:47', '2021-10-11 15:49:47', 0, NULL, 'https://halo123.top', 54, NULL);
INSERT INTO `m_link_nav` VALUES (35, '默认标题', '23123', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 16:30:55', '2021-10-11 16:30:55', 0, NULL, 'https://baidu.com', 1447479811965587456, NULL);
INSERT INTO `m_link_nav` VALUES (36, '默认标题', '23123', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 16:38:29', '2021-10-11 16:38:29', 0, NULL, 'https://baidu.com', 1447481716452233216, NULL);
INSERT INTO `m_link_nav` VALUES (37, 'test', 'test', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 20:47:49', '2021-10-11 20:47:49', 0, NULL, 'https://www.baidu.com', 1447544462665453568, NULL);
INSERT INTO `m_link_nav` VALUES (38, '默认标题', '', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 21:09:35', '2021-10-11 21:09:35', 0, NULL, 'https://baidu.com', 1447549940762021888, NULL);
INSERT INTO `m_link_nav` VALUES (39, '默认标题', '', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 21:09:52', '2021-10-11 21:09:52', 0, NULL, 'https://baidu.com', 1447550014598549504, NULL);
INSERT INTO `m_link_nav` VALUES (40, '登录添加', '登录添加', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 21:15:50', '2021-10-11 21:15:50', 0, NULL, 'https://baidu.com', 1447551515718979584, 1);
INSERT INTO `m_link_nav` VALUES (41, '未登录添加', '未登录添加', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 21:18:32', '2021-10-11 21:18:32', 0, NULL, 'https://baidu.com', 1447552195544354816, 0);
INSERT INTO `m_link_nav` VALUES (42, '未登录添加324', '未登录添加5432', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 21:18:53', '2021-10-11 21:18:53', 0, NULL, 'https://baidu.com', 1447552281091379200, 0);
INSERT INTO `m_link_nav` VALUES (43, 'eeee', '', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-11 22:44:26', '2021-10-11 22:44:26', 0, NULL, 'https://baidu.com', 1447573813578567680, 1);
INSERT INTO `m_link_nav` VALUES (44, '默认标题', '23', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-12 11:00:29', '2021-10-12 11:00:29', 0, NULL, 'https://baidu.com', 1447759045707567104, 1);
INSERT INTO `m_link_nav` VALUES (45, '默认标题', '223', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-14 14:21:24', '2021-10-14 14:22:15', 0, NULL, 'http://blog.halo123.top:4000', 1448534383492468736, 1);
INSERT INTO `m_link_nav` VALUES (46, 'tttttt', 'ttttttt', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-a@master/img/网站.svg', 0, 0, 1, 1, '2021-10-14 16:28:47', '2021-10-14 16:28:47', 0, NULL, 'https://tttttt.com', 1448566438964105216, 1);

-- ----------------------------
-- Table structure for m_link_user
-- ----------------------------
DROP TABLE IF EXISTS `m_link_user`;
CREATE TABLE `m_link_user`  (
  `id` bigint NOT NULL COMMENT '表ID',
  `link_uuid` bigint NOT NULL COMMENT '链接ID',
  `uid` bigint NULL DEFAULT NULL COMMENT '用户ID',
  `create_time` datetime NULL DEFAULT NULL COMMENT '创建时间',
  `deleted` tinyint NULL DEFAULT NULL COMMENT '是否删除(0:否,1:是)',
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of m_link_user
-- ----------------------------
INSERT INTO `m_link_user` VALUES (2, 423, 3, '2021-10-11 16:48:33', NULL);
INSERT INTO `m_link_user` VALUES (54, 54, 1, '2021-10-11 16:51:35', NULL);
INSERT INTO `m_link_user` VALUES (1447481717003649025, 1447481716452233216, 1, '2021-10-11 16:38:29', NULL);
INSERT INTO `m_link_user` VALUES (1447544463216889857, 1447544462665453568, 1, '2021-10-11 20:47:49', NULL);
INSERT INTO `m_link_user` VALUES (1447549940759810049, 1447549940762021888, 1, '2021-10-11 21:09:35', NULL);
INSERT INTO `m_link_user` VALUES (1447550014575366145, 1447550014598549504, 1, '2021-10-11 21:09:52', NULL);
INSERT INTO `m_link_user` VALUES (1447551516224327681, 1447551515718979584, 1, '2021-10-11 21:15:50', NULL);
INSERT INTO `m_link_user` VALUES (1447552196158803969, 1447552195544354816, 0, '2021-10-11 21:18:32', NULL);
INSERT INTO `m_link_user` VALUES (1447552281064099842, 1447552281091379200, 0, '2021-10-11 21:18:53', NULL);
INSERT INTO `m_link_user` VALUES (1447573814058749954, 1447573813578567680, 1, '2021-10-11 22:44:26', NULL);
INSERT INTO `m_link_user` VALUES (1447759045736824833, 1447759045707567104, 1, '2021-10-12 11:00:29', NULL);
INSERT INTO `m_link_user` VALUES (1448534383993577473, 1448534383492468736, 1, '2021-10-14 14:21:24', NULL);
INSERT INTO `m_link_user` VALUES (1448566439582666753, 1448566438964105216, 1, '2021-10-14 16:28:47', NULL);

-- ----------------------------
-- Table structure for m_user
-- ----------------------------
DROP TABLE IF EXISTS `m_user`;
CREATE TABLE `m_user`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `username` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-f@master/image.4skloqie47w0.png',
  `email` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `status` int NOT NULL DEFAULT 0,
  `created` datetime NULL DEFAULT NULL,
  `last_login` datetime NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE,
  INDEX `UK_USERNAME`(`username`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 14 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of m_user
-- ----------------------------
INSERT INTO `m_user` VALUES (1, 'HALO', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-f@master/image.4skloqie47w0.png', '1379978893@qq.com', '96e79218965eb72c92a549dd5a330112', 0, '2021-09-18 15:38:39', NULL);
INSERT INTO `m_user` VALUES (3, 'hhhh545', 'https://cube.elemecdn.com/3/7c/3ea6beec64369c2642b92c6726f1epng.png', '4545454@qq.com', '96e79218965eb72c92a549dd5a330112', 0, '2021-09-26 12:08:53', NULL);
INSERT INTO `m_user` VALUES (4, 'hhhh3424', 'https://cube.elemecdn.com/3/7c/3ea6beec64369c2642b92c6726f1epng.png', '34233@qq.com', '96e79218965eb72c92a549dd5a330112', 0, '2021-09-26 21:43:32', NULL);
INSERT INTO `m_user` VALUES (9, 'hhhh', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-f@master/image.4skloqie47w0.png', '13799788936@qq.com', '96e79218965eb72c92a549dd5a330112', 0, '2021-10-09 15:08:09', NULL);

-- ----------------------------
-- Table structure for sys_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_menu`;
CREATE TABLE `sys_menu`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `parent_id` bigint NULL DEFAULT NULL COMMENT '父菜单ID，一级菜单为0',
  `name` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `path` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '菜单URL',
  `perms` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '授权(多个用逗号分隔，如：user:list,user:create)',
  `component` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `type` int NOT NULL COMMENT '类型     0：目录   1：菜单   2：按钮',
  `icon` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '菜单图标',
  `orderNum` int NULL DEFAULT NULL COMMENT '排序',
  `created` datetime NOT NULL,
  `updated` datetime NULL DEFAULT NULL,
  `status` int NOT NULL,
  `deleted` int NULL DEFAULT 0,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `name`(`name`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 19 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_menu
-- ----------------------------
INSERT INTO `sys_menu` VALUES (1, 0, '系统管理', '', 'sys:manage', '', 0, 'el-icon-s-operation', 1, '2021-01-15 18:58:18', '2021-01-15 18:58:20', 1, 0);
INSERT INTO `sys_menu` VALUES (2, 1, '用户管理', '/sys/users', 'sys:user:list', 'sys/User', 1, 'el-icon-s-custom', 1, '2021-01-15 19:03:45', '2021-01-15 19:03:48', 1, 0);
INSERT INTO `sys_menu` VALUES (3, 1, '角色管理', '/sys/roles', 'sys:role:list', 'sys/Role', 1, 'el-icon-rank', 2, '2021-01-15 19:03:45', '2021-01-15 19:03:48', 1, 0);
INSERT INTO `sys_menu` VALUES (4, 1, '菜单管理', '/sys/menus', 'sys:menu:list', 'sys/Menu', 1, 'el-icon-menu', 3, '2021-01-15 19:03:45', '2021-01-15 19:03:48', 1, 0);
INSERT INTO `sys_menu` VALUES (5, 0, '系统工具', '', 'sys:tools', NULL, 0, 'el-icon-s-tools', 2, '2021-01-15 19:06:11', NULL, 1, 0);
INSERT INTO `sys_menu` VALUES (6, 5, '数字字典', '/sys/dicts', 'sys:dict:list', 'sys/Dict', 1, 'el-icon-s-order', 1, '2021-01-15 19:07:18', '2021-01-18 16:32:13', 1, 0);
INSERT INTO `sys_menu` VALUES (7, 3, '添加角色', '', 'sys:role:save', '', 2, '', 1, '2021-01-15 23:02:25', '2021-01-17 21:53:14', 0, 0);
INSERT INTO `sys_menu` VALUES (9, 2, '添加用户', NULL, 'sys:user:save', NULL, 2, NULL, 1, '2021-01-17 21:48:32', NULL, 1, 0);
INSERT INTO `sys_menu` VALUES (10, 2, '修改用户', NULL, 'sys:user:update', NULL, 2, NULL, 2, '2021-01-17 21:49:03', '2021-01-17 21:53:04', 1, 0);
INSERT INTO `sys_menu` VALUES (11, 2, '删除用户', NULL, 'sys:user:delete', NULL, 2, NULL, 3, '2021-01-17 21:49:21', NULL, 1, 0);
INSERT INTO `sys_menu` VALUES (12, 2, '分配角色', NULL, 'sys:user:role', NULL, 2, NULL, 4, '2021-01-17 21:49:58', NULL, 1, 0);
INSERT INTO `sys_menu` VALUES (13, 2, '重置密码', NULL, 'sys:user:repass', NULL, 2, NULL, 5, '2021-01-17 21:50:36', NULL, 1, 0);
INSERT INTO `sys_menu` VALUES (14, 3, '修改角色', NULL, 'sys:role:update', NULL, 2, NULL, 2, '2021-01-17 21:51:14', NULL, 1, 0);
INSERT INTO `sys_menu` VALUES (15, 3, '删除角色', NULL, 'sys:role:delete', NULL, 2, NULL, 3, '2021-01-17 21:51:39', NULL, 1, 0);
INSERT INTO `sys_menu` VALUES (16, 3, '分配权限', NULL, 'sys:role:perm', NULL, 2, NULL, 5, '2021-01-17 21:52:02', NULL, 1, 0);
INSERT INTO `sys_menu` VALUES (17, 4, '添加菜单', NULL, 'sys:menu:save', NULL, 2, NULL, 1, '2021-01-17 21:53:53', '2021-01-17 21:55:28', 1, 0);
INSERT INTO `sys_menu` VALUES (18, 4, '修改菜单', NULL, 'sys:menu:update', NULL, 2, NULL, 2, '2021-01-17 21:56:12', NULL, 1, 0);
INSERT INTO `sys_menu` VALUES (19, 4, '删除菜单', NULL, 'sys:menu:delete', NULL, 2, NULL, 3, '2021-01-17 21:56:36', NULL, 1, 0);

-- ----------------------------
-- Table structure for sys_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_role`;
CREATE TABLE `sys_role`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `name` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `code` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,
  `remark` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL COMMENT '备注',
  `created` datetime NULL DEFAULT NULL,
  `updated` datetime NULL DEFAULT NULL,
  `status` int NOT NULL,
  `deleted` int NULL DEFAULT 0,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `name`(`name`) USING BTREE,
  UNIQUE INDEX `code`(`code`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 6 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_role
-- ----------------------------
INSERT INTO `sys_role` VALUES (3, '普通用户', 'normal', '只有基本查看功能', '2021-01-04 10:09:14', '2021-01-30 08:19:52', 1, 0);
INSERT INTO `sys_role` VALUES (6, '超级管理员', 'admin', '系统默认最高权限，不可以编辑和任意修改', '2021-01-16 13:29:03', '2021-01-17 15:50:45', 1, 0);

-- ----------------------------
-- Table structure for sys_role_menu
-- ----------------------------
DROP TABLE IF EXISTS `sys_role_menu`;
CREATE TABLE `sys_role_menu`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `role_id` bigint NOT NULL,
  `menu_id` bigint NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 101 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_role_menu
-- ----------------------------
INSERT INTO `sys_role_menu` VALUES (60, 6, 1);
INSERT INTO `sys_role_menu` VALUES (61, 6, 2);
INSERT INTO `sys_role_menu` VALUES (62, 6, 9);
INSERT INTO `sys_role_menu` VALUES (63, 6, 10);
INSERT INTO `sys_role_menu` VALUES (64, 6, 11);
INSERT INTO `sys_role_menu` VALUES (65, 6, 12);
INSERT INTO `sys_role_menu` VALUES (66, 6, 13);
INSERT INTO `sys_role_menu` VALUES (67, 6, 3);
INSERT INTO `sys_role_menu` VALUES (68, 6, 7);
INSERT INTO `sys_role_menu` VALUES (69, 6, 14);
INSERT INTO `sys_role_menu` VALUES (70, 6, 15);
INSERT INTO `sys_role_menu` VALUES (71, 6, 16);
INSERT INTO `sys_role_menu` VALUES (72, 6, 4);
INSERT INTO `sys_role_menu` VALUES (73, 6, 17);
INSERT INTO `sys_role_menu` VALUES (74, 6, 18);
INSERT INTO `sys_role_menu` VALUES (75, 6, 19);
INSERT INTO `sys_role_menu` VALUES (76, 6, 5);
INSERT INTO `sys_role_menu` VALUES (77, 6, 6);
INSERT INTO `sys_role_menu` VALUES (96, 3, 1);
INSERT INTO `sys_role_menu` VALUES (97, 3, 2);
INSERT INTO `sys_role_menu` VALUES (98, 3, 3);
INSERT INTO `sys_role_menu` VALUES (99, 3, 4);
INSERT INTO `sys_role_menu` VALUES (100, 3, 5);
INSERT INTO `sys_role_menu` VALUES (101, 3, 6);

-- ----------------------------
-- Table structure for sys_user
-- ----------------------------
DROP TABLE IF EXISTS `sys_user`;
CREATE TABLE `sys_user`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `username` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `password` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `avatar` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `email` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `city` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,
  `created` datetime NULL DEFAULT NULL,
  `updated` datetime NULL DEFAULT NULL,
  `last_login` datetime NULL DEFAULT NULL,
  `status` int NOT NULL,
  `deleted` int NULL DEFAULT 0,
  PRIMARY KEY (`id`) USING BTREE,
  UNIQUE INDEX `UK_USERNAME`(`username`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 4 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_user
-- ----------------------------
INSERT INTO `sys_user` VALUES (1, 'admin', '$2a$10$R7zegeWzOXPw871CmNuJ6upC0v8D373GuLuTw8jn6NET4BkPRZfgK', 'https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/5a9f48118166308daba8b6da7e466aab.jpg', '123@qq.com', '广州', '2021-01-12 22:13:53', '2021-01-16 16:57:32', '2020-12-30 08:38:37', 1, 0);
INSERT INTO `sys_user` VALUES (2, 'test', '$2a$10$0ilP4ZD1kLugYwLCs4pmb.ZT9cFqzOZTNaMiHxrBnVIQUGUwEvBIO', 'https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/5a9f48118166308daba8b6da7e466aab.jpg', 'test@qq.com', NULL, '2021-01-30 08:20:22', '2021-01-30 08:55:57', NULL, 1, 0);
INSERT INTO `sys_user` VALUES (3, 'halo', '$2a$10$UdPFsndCVEKRltfjDbBVguBd2EK/SnNSqzrg9jGJddjirzLzSswJ.', 'https://image-1300566513.cos.ap-guangzhou.myqcloud.com/upload/images/5a9f48118166308daba8b6da7e466aab.jpg', 'halo@qq.com', NULL, '2021-10-20 19:55:43', '2021-10-20 19:55:56', NULL, 1, 0);
INSERT INTO `sys_user` VALUES (4, 'halo123', '$2a$10$HYaC8BxIdk4M4.hDH.uMRu5akGD5dMGl383acRvTw5eWYJO2dljsW', 'https://cdn.jsdelivr.net/gh/halo-blog/cdn-blog-img-f@master/image.4skloqie47w0.png', '885240677@qq.com', NULL, '2021-10-22 23:49:50', NULL, NULL, 0, 0);

-- ----------------------------
-- Table structure for sys_user_role
-- ----------------------------
DROP TABLE IF EXISTS `sys_user_role`;
CREATE TABLE `sys_user_role`  (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `user_id` bigint NOT NULL,
  `role_id` bigint NOT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 15 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = DYNAMIC;

-- ----------------------------
-- Records of sys_user_role
-- ----------------------------
INSERT INTO `sys_user_role` VALUES (4, 1, 6);
INSERT INTO `sys_user_role` VALUES (7, 1, 3);
INSERT INTO `sys_user_role` VALUES (13, 2, 3);
INSERT INTO `sys_user_role` VALUES (14, 3, 6);
INSERT INTO `sys_user_role` VALUES (15, 4, 6);

SET FOREIGN_KEY_CHECKS = 1;
